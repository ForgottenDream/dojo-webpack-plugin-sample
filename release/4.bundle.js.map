{"version":3,"sources":["webpack:///4.bundle.js","webpack:///../dojox/charting/Chart2D.js","webpack:///../dojox/charting/plot2d/StackedAreas.js","webpack:///../dojox/charting/plot2d/Stacked.js","webpack:///../dojox/charting/plot2d/Default.js","webpack:///../dojox/charting/plot2d/common.js","webpack:///../dojox/gfx.js","webpack:///../dojox/gfx/_base.js","webpack:///../dojox/gfx/canvas.js","webpack:///../dojox/gfx/shape.js","webpack:///../dojox/gfx/matrix.js","webpack:///../dojox/gfx/path.js","webpack:///../dojox/gfx/arc.js","webpack:///../dojox/gfx/decompose.js","webpack:///../dojox/gfx/bezierutils.js","webpack:///../dojox/lang/functional.js","webpack:///../dojox/lang/functional/lambda.js","webpack:///../dojox/main.js","webpack:///../dojox/lang/functional/array.js","webpack:///../dojox/lang/functional/object.js","webpack:///../dojox/charting/scaler/common.js","webpack:///../dojox/charting/plot2d/CartesianBase.js","webpack:///../dojox/charting/plot2d/Base.js","webpack:///../dojox/charting/Element.js","webpack:///../dojox/charting/axis2d/common.js","webpack:///../dojox/charting/scaler/primitive.js","webpack:///../dojox/gfx/fx.js","webpack:///../dojox/lang/utils.js","webpack:///../dojox/charting/plot2d/_PlotEvents.js","webpack:///../dojox/lang/functional/reversed.js","webpack:///../dojox/charting/plot2d/commonStacked.js","webpack:///../dojox/charting/Chart.js","webpack:///../dojox/charting/SimpleTheme.js","webpack:///../dojox/gfx/gradutils.js","webpack:///../dojox/charting/Series.js","webpack:///../dojox/charting/bidi/Chart.js","webpack:///../dojox/gfx/_gfxBidiSupport.js","webpack:///../dojo/_base/html.js","webpack:///../dojox/gfx/utils.js","webpack:///../dojox/string/BidiEngine.js","webpack:///../dojox/charting/bidi/_bidiutils.js","webpack:///../dojox/lang/functional/fold.js","webpack:///../dojox/charting/axis2d/Default.js","webpack:///../dojox/charting/axis2d/Invisible.js","webpack:///../dojox/charting/axis2d/Base.js","webpack:///../dojox/charting/scaler/linear.js","webpack:///../dojox/charting/bidi/axis2d/Default.js","webpack:///../dojox/charting/plot2d/Lines.js","webpack:///../dojox/charting/plot2d/Areas.js","webpack:///../dojox/charting/plot2d/Markers.js","webpack:///../dojox/charting/plot2d/MarkersOnly.js","webpack:///../dojox/charting/plot2d/Scatter.js","webpack:///../dojox/charting/plot2d/StackedLines.js","webpack:///../dojox/charting/plot2d/Columns.js","webpack:///../dojox/charting/plot2d/StackedColumns.js","webpack:///../dojox/charting/plot2d/ClusteredColumns.js","webpack:///../dojox/charting/plot2d/Bars.js","webpack:///../dojox/charting/plot2d/StackedBars.js","webpack:///../dojox/charting/plot2d/ClusteredBars.js","webpack:///../dojox/charting/plot2d/Grid.js","webpack:///../dojox/charting/plot2d/Pie.js","webpack:///../dojox/charting/plot2d/Bubble.js","webpack:///../dojox/charting/plot2d/Candlesticks.js","webpack:///../dojox/charting/plot2d/OHLC.js","webpack:///../dojox/charting/plot2d/Spider.js","webpack:///../dojo/fx.js","webpack:///../dojo/fx/easing.js","webpack:///../dojox/charting/themes/Wetland.js","webpack:///../dojox/charting/themes/common.js"],"names":["webpackJsonp","Array","concat","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","kernel","lang","dojox","Chart","deprecated","setObject","apply","undefined","declare","Stacked","constructor","this","opt","lines","areas","Default","commonStacked","getSeriesStats","stats","collectStats","series","hitch","buildSegments","i","indexed","run","min","Math","max","floor","_hScaler","bounds","from","data","length","ceil","to","rseg","segments","isNullValue","j","value","getIndexValue","getValue","x","y","interpolate","push","index","arr","has","CartesianBase","_PlotEvents","dc","df","dfr","du","fx","purgeGroup","lambda","DEFAULT_ANIMATION_LENGTH","defaultParams","markers","tension","animate","enableCache","optionalParams","stroke","outline","shadow","fill","filter","styleFunc","font","fontColor","marker","markerStroke","markerOutline","markerShadow","markerFill","markerFont","markerFontColor","zeroLine","chart","kwArgs","clone","mixin","updateWithObject","updateWithPattern","createPath","creator","params","path","_pathFreePool","pop","setShape","add","_pathUsePool","hasOwnProperty","render","dim","offsets","zoom","isDataDirty","performZoom","resetEvents","dirty","isDirty","s","forEach","_eventSeries","cleanGroup","getGroup","setTransform","forEachRev","item","t","theme","events","lpoly","next","ht","scaler","getTransformerFromModel","vt","_vScaler","eventSeries","name","group","hidden","dyn","symbol","some","rsegments","seg","rsegment","map","v","l","height","b","lpath","curve","_plotFill","apoly","isNaN","apath","setFill","getFill","createPolyline","makeStroke","width","frontMarkers","outlineMarkers","shadowMarkers","spoly","c","dx","dy","setStroke","getStroke","color","shape","setFilter","markerBox","markerTheme","tMixin","addMixin","post","labels","getBoundingBox","o","element","cx","cy","_connectEvents","labelBoxW","labelBoxH","createLabel","skip","_reconnectEvents","_checkOrientation","plotGroup","animateTransform","delegate","duration","transform","start","end","play","Color","g","sc","common","getObject","doIfLoaded","makeParameters","defaultStroke","augmentColor","target","a","augmentStroke","augmentFill","defaultStats","vmin","Number","POSITIVE_INFINITY","vmax","NEGATIVE_INFINITY","hmin","hmax","collectSimpleStats","old_vmin","old_vmax","val","ymin","ymax","old_hmin","old_hmax","xmin","xmax","calculateBarSize","availableSize","clusterSize","gap","size","minBarSize","maxBarSize","collectStackedStats","foldl","array","slice","p","p0","p3","bz1x","bz1y","bz2x","bz2y","p1","p2","f","p1p2","sqrt","p0p2","p1p3","p0p2f","p1p3f","join","getLabel","number","fixed","precision","numberLib","format","places","toFixed","toString","gfxBase","renderer","switchTo","win","dom","domConstruct","domGeom","_base","_hasClass","node","classStr","cls","getAttribute","indexOf","_addClass","setAttribute","_removeClass","replace","RegExp","_getFontMeasurements","oldStyle","heights","1em","1ex","100%","12pt","16px","xx-small","x-small","small","medium","large","x-large","xx-large","doc","documentElement","style","fontSize","div","create","position","left","top","borderWidth","margin","padding","lineHeight","overflow","body","round","offsetHeight","removeChild","fontMeasurements","_getCachedFontMeasurements","recalculate","measuringNode","empty","_getTextBox","text","className","m","box","al","arguments","visibility","innerHTML","getBoundingClientRect","bcr","w","right","h","bottom","getMarginBox","_computeTextLocation","textShape","fixHeight","loc","align","_computeTextBoundingBox","_isRendered","getShape","getFont","defaultFont","getTextWidth","normalizedLength","parent","getParent","uniqueId","_getUniqueId","id","_scopeName","byId","touchActionProp","_fixMsTouchAction","surface","rawNode","defaultPath","type","defaultPolyline","points","defaultRect","r","defaultEllipse","rx","ry","defaultCircle","defaultLine","x1","y1","x2","y2","defaultImage","src","defaultText","decoration","rotated","kerning","defaultTextPath","cap","defaultLinearGradient","colors","offset","defaultRadialGradient","defaultPattern","variant","weight","family","getDefault","typeCtorCache","Function","prototype","normalizeColor","normalizeParameters","existed","update","defaults","result","formatNumber","addSpace","point","makeFontString","splitFontString","str","split","substring","charAt","cm_in_pt","mm_in_pt","px_in_pt","pt2px","len","px2pt","parseFloat","pathVmlRegExp","pathSvgRegExp","equalSources","ns","Surface","gs","pathLib","ga","decompose","bezierUtils","drawDashedArc","ctx","dash","sa","ea","ccw","prevResidue","residue","angle","beginPath","arc","splitToDashedBezier","dashArray","newPoints","tAtLength","rl","computeLength","curves","splitBezierAtT","toDashedCurveTo","pts","last","quadratic","ctx2d","api","canvasDash","moveTo","toDashedLineTo","dal","tlength","distance","prevx","prevy","abs","lineTo","canvas","pattrnbuffer","mp","multiplyPoint","pi","PI","twoPI","halfPI","extend","global","CanvasRenderingContext2D","createElement","getContext","hasNativeDash","setLineDash","hasFillText","fillText","dasharray","solid","shortdash","shortdot","shortdashdot","shortdashdotdot","dot","longdash","dashdot","longdashdot","longdashdotdot","Shape","_render","save","_renderTransform","_renderClip","_renderShape","_renderFill","_renderStroke","restore","canvasClip","clip","canvasTransform","translate","rotate","angle2","scale","sx","sy","angle1","fs","fillStyle","iw","canvasFillImage","ih","copyctx","clearRect","drawImage","canvasFill","createPattern","strokeStyle","lineWidth","lineCap","lineJoin","miterLimit","_renderDashedStroke","getEventSource","on","connect","disconnect","setClip","inherited","clipType","makeClip","_makeDirty","geometry","canvasEllipse","makeEllipse","Ellipse","call","Rect","canvasPath","makeClipPath","canvasPolyline","Polyline","geo","gfx","Path","_setPath","d","modifyMethod","method","extra","old","matrix","createLinearGradient","createRadialGradient","step","addColorStop","document","img","Image","downloadImage","st","da","toLowerCase","_needsDash","Group","Container","_init","children","destroy","clear","xl","xr","yt","yb","xl2","xr2","yt2","yb2","closePath","bezierCircle","u","curvePI4","c1","c2","e","rotateg","M","normalize","_dashedPoints","bezierCurveTo","Circle","startAngle","Line","bbox","_normalizePoints","canvasImage","Text","_setFont","fontStyle","canvasFont","measureText","ta","textAlign","strokeText","pathRenderers","L","H","V","C","S","Q","q","T","A","Z","z","lastControl","_dashedPath","segmented","_confirmSegmented","_dashResidue","_updateWithSegment","segment","action","args","_moveToA","doDash","_moveToR","_lineToA","_lineToR","_hLineToA","_hLineToR","_vLineToA","_vLineToR","_curveToA","_curveToR","_smoothCurveToA","valid","_smoothCurveToR","_qCurveToA","_qCurveToR","_qSmoothCurveToA","_qSmoothCurveToR","_arcTo","relative","arcs","arcAsBezier","_closePath","TextPath","_setText","pendingImageCount","makeDirty","setDimensions","getDimensions","force","clearTimeout","pendingRender","pendingImagesCount","_batch","setTimeout","url","handler","onImageLoad","onload","onerror","onabort","onImagesLoaded","createSurface","parentNode","pos","ownerDocument","appendChild","_parent","openBatch","closeBatch","remove","silently","_moveChildToFront","_moveChildToBack","Creator","createObject","shapeType","rawShape","fixTarget","event","gfxElement","matrixLib","parentMatrix","uid","register","getUID","dispose","__gfxObject__","getNode","getTransform","getTransformedBoundingBox","_getRealMatrix","gm","getClip","isArray","identity","_applyTransform","moveToFront","_moveToFront","moveToBack","_moveToBack","applyRightTransform","applyLeftTransform","applyTransform","removeShape","_setParent","_updateParentMatrix","multiply","_eventsProcessing","listener","fixCallback","object","token","fixFunction","scope","isString","oldParent","splice","bb","ct","multiplyRectangle","endX","endY","unshift","_nodes","_events","lastChild","isLoaded","onLoad","whenLoaded","context","once","closed","setFont","newFont","createShape","createRect","createCircle","createEllipse","createLine","createImage","createText","createTextPath","createGroup","rect","ellipse","circle","line","image","setText","_degToRadCache","_degToRad","degree","_radToDeg","radian","Matrix2D","arg","xx","yy","xy","yx","flipX","flipY","flipXY","cos","sin","skewX","tan","skewXg","skewY","skewYg","reflect","a2","b2","n2","project","isIdentity","obj","invert","D","_multiplyPoint","minx","miny","maxx","maxy","_sandwich","scaleAt","rotateAt","rotategAt","skewXAt","skewXgAt","skewYAt","skewYgAt","shapeLib","tbbox","absolute","setAbsoluteMode","mode","getAbsoluteMode","_getRealBBox","getLastPosition","_updateBBox","n","_validSegments","_pushSegment","_collectArgs","hLineTo","vLineTo","curveTo","smoothCurveTo","qCurveTo","qSmoothCurveTo","arcTo","match","newShape","lazyPathSegmentation","_2PI","getText","newText","unitArcAsBezier","alpha","cosa","sina","pi4","pi8","pi48","xRotg","sweep","Boolean","xRot","rx2","ry2","pa","pax2","pay2","ca","elliptic_transform","inversed","sp","ep","atan2","endAngle","theta","eq","calcFromValues","r1","m1","r2","m2","isFinite","transpose","scaleSign","eigenvalueDecomposition","l1","l2","vx1","vy1","vx2","vy2","d1","d2","value1","value2","vector1","vector2","decomposeSR","sign","decomposeRS","MT","U","VT","bu","bezierutils","error","currentLen","splitCount","splitFunc","splitQBezierAtT","_compute","pLen","chord","newbezier","newBeziers","splitCBezierAtT","t2","p1x","p1y","p2x","p2y","ax","ay","bx","by","px","py","r3","t3","c1x","c1y","c2x","c2y","mx","my","nx","ny","lcache","String","sep","exec","sects","vars","compose","rawLambda","buildLambda","clearLambdaCache","dojo","hasNext","every","keys","values","filterIn","forIn","mapIn","testedModules","moduleName","ifloaded","ifnotloaded","require","getNumericLabel","def","labelFunc","lo","hi","mid","hub","Base","primitive","alwaysFalse","baseParams","hAxis","vAxis","labelOffset","labelStyle","htmlLabels","omitLabels","axes","zoomQueue","lastWindow","vscale","hscale","xoffset","yoffset","_hAxis","_vAxis","noClip","_nativeClip","_clippedGroup","setAxis","axis","vertical","toPage","coord","ah","av","sh","getScaler","sv","th","tv","getCoords","toData","getTransformerFromPlot","label","_getLabel","lbox","renderLabel","vs","hs","vOffset","hBounds","xOffset","lower","vBounds","yOffset","rVScale","rHScale","rXOffset","rYOffset","anim","shift","initializeScalers","initialized","calculate","buildScaler","Element","ac","tooltipFunc","assignAxes","addSeries","calculateAxes","block","elem","pointerEvents","htmlElements","getRequiredColors","applyMirroring","renderingOptions","trailingSymbol","destroyHtmlElements","handle","bgnode","bgNode","namespaceURI","key","overrideShape","getTextWithLimitLength","limitWidth","truncated","delta","trucPercentage","minStr","minWidth","begin","widthIntercepted","getTextWithLimitCharCount","wcLimit","space","span","spanX","spanY","_shapeFill","_pseudoRadialFill","center","radius","clearNode","marginLeft","marginTop","marginRight","marginBottom","paddingLeft","paddingTop","paddingRight","paddingBottom","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","getBoxWidth","html","labelWidth","boxWidth","getTextDir","dir","whiteSpace","wrap","insertBefore","firstChild","htmlElementsRegistry","upper","buildTicks","major","minor","micro","Hub","InterpolNumber","InterpolUnit","units","InterpolColor","temp","InterpolValues","InterpolObject","InterpolTransform","stack","original","getColorInterpol","prop","getNumberInterpol","fxg","blendColors","ret","transfMatrix","transparent","animateStroke","easing","_defaultEasing","Animation","animateFill","animateFont","handlers","__svgContainer","__svgRoot","__svgWidth","parseInt","ov","ignore","sn","root","removeAttribute","opts","Object","coerceType","source","eval","conv","pattern","merge","otype","mtype","_shapeEvents","plotEvent","raiseEvent","originalEvent","originalPlot","plot","after","_connectSingleEvent","eventName","eventMask","seriesName","fireEvent","eventObject","filterRev","mapRev","everyRev","someRev","rearrangeValues","baseline","sets","previousSet","extractedSet","k","sum","counter","available","pvalue","dj","domStyle","SimpleTheme","Series","BidiChart","func","hSection","vSection","hReplace","vReplace","combineStats","plotArea","plots","purge","makeClean","getName","defaultMargins","margins","_customMargins","delayInMs","title","titleGap","titlePos","titleFont","titleFontColor","titleAlign","chartTitle","runs","declaredClass","tagName","getComputedStyle","coords","setTheme","addAxis","axisType","axis2d","Error","getAxis","removeAxis","addPlot","plotType","plot2d","getPlot","removePlot","idx","getPlotOrder","setPlotOrder","newOrder","names","order","newStack","movePlotToFront","movePlotToBack","getSeries","removeSeries","updateSeries","_invalidateDependentPlots","getSeriesOrder","plotName","setSeriesOrder","newSeries","moveSeriesToFront","moveSeriesToBack","resize","setMarginBox","getGeometry","ticks","setAxisWindow","setWindow","calculateGeometry","zoomIn","range","delayed","delayedRender","fullGeometry","self","_resetLeftBottom","getOffsets","tsize","_delayedRenderHandle","fullRender","_makeClean","_renderChartBackground","_renderPlotBackground","foldr","_renderTitle","forceHtmlLabels","labelType","tBox","isRtl","isRightToLeft","posX","get","plotarea","connectToPlot","verticalAxis","axisName","dependOnData","setDir","formatTruncatedLabel","dlu","dgg","shapeSpaces","shapeX","shapeY","defaultTheme","seriesThemes","defaultColors","markerThemes","defaultMarkers","noGradConv","noRadialConv","reverseFills","_current","_buildMarkerArray","grid","indicator","elementType","doPost","_markers","markerName","toUpperCase","substr","getTick","tick","tickName","inspectObjects","reverse","addMarker","setMarkers","CIRCLE","SQUARE","DIAMOND","CROSS","X","TRIANGLE","TRIANGLE_INVERTED","pageStyle","labelGap","majorTick","minorTick","microTick","orientation","labelWiring","lineStroke","lineOutline","lineShadow","lineFill","markerSymbol","findColor","stop","prev","gradutils","getColor","pt","rotation","projection","pf1","pf2","sort","setSeriesObject","gBidi","BidiEngine","domAttr","utils","validateTextDir","textDir","test","bidiEngine","isMirrored","checkContextual","postscript","truncatedLabelsRegistry","chartDir","setTextDir","newTextDir","tDir","axesKeyArr","reverseMatrix","set","truncateBidi","leftBottom","validValues","isVml","isSvg","svg","useSvgWeb","isSvgWeb","isSilverlight","isCanvas","bidi_const","LRM","LRE","PDF","RLM","RLE","formatText","sourceDir","targetDir","hasBidiChar","bidiTransform","bidiPreprocess","origText","extendMethod","before","rBefore","restoreText","origObj","groupTextDir","textDirPreprocess","attr","ctr","geom","isDescendant","setSelectable","getAttr","setAttr","hasAttr","removeAttr","getNodeProp","hasClass","contains","addClass","removeClass","toggleClass","toggle","replaceClass","_toDom","toDom","place","_destroyElement","_getPadExtents","getPadExtents","_getBorderExtents","getBorderExtents","_getPadBorderExtents","getPadBorderExtents","_getMarginExtents","getMarginExtents","_getMarginSize","getMarginSize","_getMarginBox","_getContentBox","getContentBox","setContentSize","_isBodyLtr","isBodyLtr","_docScroll","docScroll","_getIeDocumentElementOffset","getIeDocumentElementOffset","_fixIeBiDiScrollLeft","fixIeBiDiScrollLeft","marginBox","contentBox","includeScroll","mb","getProp","setProp","getStyle","setStyle","__toPixelValue","toPixelValue","jsonLib","Deferred","config","gu","serialize","isSurface","toJson","prettyPrint","deserialize","fromJson","json","toSvg","deferred","_cleanSvg","_innerXML","callback","errback","_initSvgSerializerDeferred","_initSvgSerializer","jsonForm","serializer","sDim","_gfxSvgProxy","withDoc","ts","draw","ex","fired","addCallback","_svgSerializerInitialized","display","intv","onreadystatechange","contentWindow","readyState","setInterval","scopeMap","clearInterval","uri","toUrl","innerXML","xml","XMLSerializer","serializeToString","Stateful","doBidiReorder","inFormat","outFormat","swap","bdx","prepareReorderingParameters","inOrdering","inOrientation","outOrdering","outOrientation","LTR","doReorder","RTL","invertStr","saveSwap","defInFormat","defOutFormat","defSwap","firstStrongDir","lastStrongDir","rtl","compress","str06","Ix","nIEnd","compressArray","doShape","outBuf","updateMap","tsMap","stMap","previousCursive","compressArrayIndx","isArabicAlefbet","isArabicDiacritics","isNextAlef","getLamAlefFE","LamAlefInialTableFE","LamAlefMedialTableFE","setAlefToSpace","currentChr","isNextArabic","getMedialFormCharacterFE","getFormCharacterFE","FinalForm","InitialForm","IsolatedForm","isStandAlonCharacter","fdc","chars","deshape","consumeNextSpace","strFE","increase","chNum","charCodeAt","AlefTable","FETo06Table","levels","computeLevels","swapChars","invertLevel","lvMap","impTab","impTabRtl","impTabLtr","prevState","newClass","newLevel","newState","cond","condPos","ix","types","classes","hiLevel","lastArabic","hasUbatAl","hasUbatB","hasUbatS","getCharacterType","getCharClass","ITIL","ITCOND","UBAT_B","handleUbatS","UBAT_S","UBAT_WS","getMirror","ch","uc","MasterTable","TBBASE","UnicodeTable","cArray","cLength","ArabicAlefBetIntervalsBegine","ArabicAlefBetIntervalsEnd","lev","tmp","cType","results","UBAT_L","UBAT_R","UBAT_ON","UBAT_AN","UBAT_EN","UBAT_AL","UBAT_CS","wType","nType","UBAT_ES","UBAT_ET","UBAT_NSM","rtlCandidate","UBAT_LRE","UBAT_RLE","UBAT_LRO","UBAT_RLO","UBAT_PDF","UBAT_BN","TYPES_NAMES","low","high","SwapTable","StandAlonForm","BaseForm","MedialForm","formArr","getOrientation","oc","alef06","LamAlefForm","initMaps","map1","map2","reverseMap","sourceMap","isGreater","inputFormat","outputFormat","sourceToTarget","targetToSource","formatIn","formatOut","checkParameters","BDX","orientIn","orientOut","osIn","osOut","stage1Text","_inputFormatSetter","validFormat","_outputFormatSetter","bidiChars","defoutFormat","hasBlockSep","hasSegSep","TB00","TB05","TB06","TB07","TB20","TBFB","TBFE","TBFF","R","EN","AN","ON","B","AL","WS","CS","ES","ET","NSM","LRO","RLO","BN","foldl1","first","foldr1","reduce","reduceRight","unfold","pr","Invisible","lin","acommon","BidiDefault","centerAnchorLimit","fixUpper","fixLower","natural","includeZero","majorLabels","minorTicks","minorLabels","microTicks","dropLabels","labelSizeChange","majorTickStep","minorTickStep","microTickStep","maxLabelSize","maxLabelCharCount","titleOrientation","_textFreePool","_lineFreePool","_textUsePool","_lineUsePool","_invalidMaxLabelSize","shape-rendering","_groupLabelWidth","isObject","trim","_getMaxLabelSize","_maxLabelSize","minMinorStep","_prevMinMinorStep","ob","sb","_majorStart","tb","majLabelW","minLabelW","tickLabelFunc","majLabelH","minLabelH","_oldSpan","Infinity","labelW","cosr","sinr","gap1","gap2","canMinorLabel","_skipInterval","taTitleFont","taTitleGap","taMajorTick","taMinorTick","side","textContent","_isRtl","titleOffset","axisVector","tickVector","anchorOffset","labelAlign","titleRotation","taFont","taFontColor","taTitleFontColor","taTitleOrientation","taMicroTick","taStroke","cachedLabelW","axisTitle","rel","canLabel","labelTooltip","truncatedLabel","elemType","modules","aroundRect","fontWidth","fontHeight","Tooltip","show","hide","shp","lt","getWindowScale","getWindowOffset","scalerType","tsb","getTicks","naturalBaseline","findString","linear","deltaLimit","calcTicks","lowerBound","upperBound","useMin","useMax","majorStart","minorStart","microStart","majorCount","minorCount","microCount","minorPerMajor","microPerMinor","majorPrecision","log","LN10","minorPrecision","count","prec","minorDelta","mag","pow","nextMajor","nextMinor","nextMicro","revScale","majorTicks","isChartDirectionRtl","isBaseTextDirRtl","shadows","finalTheme","_animateScatter","_rectFreePool","_rectUsePool","baselineHeight","bar","getBarProperties","serie","extractedValues","extractValues","sshape","thickness","srect","_animateColumn","specialFill","seriesIndex","extracted","voffset","vsize","Columns","baselineWidth","actualLength","_animateBar","hoffset","hsize","Bars","sortTicks","hMajorLines","hMinorLines","vMajorLines","vMinorLines","hStripes","vStripes","renderOnAxis","majorHLine","minorHLine","majorVLine","minorVLine","hFill","vFill","hAlternateFill","vAlternateFill","vScaler","_renderHRect","minorLine","_renderHLines","majorLine","hScaler","_renderVRect","_renderVLines","hLine","_animateGrid","vLine","hStripe","allTicks","alternateFill","vStripe","transStart","scaleStart","PlotEvents","FUDGE_FACTOR","radGrad","fanSize","runFilter","filteredRun","slices","labelR","labelFont","scircle","themes","cr","nfans","fansx","fansy","fanex","faney","labelAngle","labeledSlices","omit","labelHeight","_getProperLabelRadius","leftColumn","rightColumn","jointX","labelX","wiring","esi","minRidius","leftCenterSlice","rightCenterSlice","leftMinSIN","rightMinSIN","tempSIN","_calculateLabelR","firstSlice","nextLabelR","currentLabelR","frontCircles","outlineCircles","shadowCircles","getFinalTheme","_animateBubble","console","warn","open","close","doFill","inner","_animateCandlesticks","hl","op","cl","_animateOHLC","baseFx","coreFx","gfxfx","Spider","divisions","axisColor","axisWidth","spiderColor","spiderWidth","seriesWidth","seriesFillAlpha","spiderOrigin","markerSize","spiderType","animationType","backOut","axisTickFont","axisTickFontColor","axisFont","axisFontColor","datas","labelKey","oldSeriePoints","animations","vlist","axisKey","outerPoints","innerPoints","divisionPoints","divisionRadius","labelPoints","serieEntry","asize","ro","dv","ms","spt","at","lboffset","axisExtra","_getObjectLength","_buildPoints","axisGroup","axisStroke","spiderStroke","nd","_drawArrow","labelGroup","spiderGroup","textGroup","_getCoordinate","seriesShapes","sk","seriePoints","tipData","entry","sname","polygonBoundRect","_getBoundary","osps","cs","_createSeriesEntry","po","poly","brect","so","circles","co","tdata","sps","initpoints","anims","np","spl","pshape","cshape","anims1","masterAnimation","combine","point2","point3","recursive","Evented","arrayUtil","aspect","ready","isAsync","requires","_baseObj","_fire","evt","_chain","_index","_animations","_onAnimateCtx","_onEndCtx","delay","_onAnimate","_onEnd","gotoStart","status","beforeBegin","onBegin","onPlay","pause","gotoPercent","percent","andPlay","gotoEnd","chain","_combine","_connects","_finished","_pseudoAnimation","_doAction","_call","wipeIn","animateProperty","properties","scrollHeight","fini","wipeOut","slideTo","init","offsetTop","offsetLeft","easingFuncs","quadIn","quadOut","quadInOut","cubicIn","cubicOut","cubicInOut","quartIn","quartOut","quartInOut","quintIn","quintOut","quintInOut","sineIn","sineOut","sineInOut","expoIn","expoOut","expoInOut","circIn","circOut","circInOut","backIn","backInOut","elasticIn","elasticOut","elasticInOut","bounceIn","bounceOut","bounceInOut","Wetland"],"mappings":"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","file":"4.bundle.js","sourcesContent":["webpackJsonp([4],Array(161).concat([\n/* 161 */\n/*!************************************!*\\\n  !*** ../dojox/charting/Chart2D.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ 4), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! .. */ 177), __webpack_require__(/*! ./Chart */ 191),\n\t\t__webpack_require__(/*! ./axis2d/Default */ 202), __webpack_require__(/*! ./axis2d/Invisible */ 203), __webpack_require__(/*! ./plot2d/Default */ 164), __webpack_require__(/*! ./plot2d/Lines */ 207), __webpack_require__(/*! ./plot2d/Areas */ 208),\n\t\t__webpack_require__(/*! ./plot2d/Markers */ 209), __webpack_require__(/*! ./plot2d/MarkersOnly */ 210), __webpack_require__(/*! ./plot2d/Scatter */ 211), __webpack_require__(/*! ./plot2d/Stacked */ 163), __webpack_require__(/*! ./plot2d/StackedLines */ 212),\n\t\t__webpack_require__(/*! ./plot2d/StackedAreas */ 162), __webpack_require__(/*! ./plot2d/Columns */ 213), __webpack_require__(/*! ./plot2d/StackedColumns */ 214), __webpack_require__(/*! ./plot2d/ClusteredColumns */ 215),\n\t\t__webpack_require__(/*! ./plot2d/Bars */ 216), __webpack_require__(/*! ./plot2d/StackedBars */ 217), __webpack_require__(/*! ./plot2d/ClusteredBars */ 218), __webpack_require__(/*! ./plot2d/Grid */ 219), __webpack_require__(/*! ./plot2d/Pie */ 220),\n\t\t__webpack_require__(/*! ./plot2d/Bubble */ 221), __webpack_require__(/*! ./plot2d/Candlesticks */ 222), __webpack_require__(/*! ./plot2d/OHLC */ 223), __webpack_require__(/*! ./plot2d/Spider */ 224)], __WEBPACK_AMD_DEFINE_RESULT__ = function(kernel, lang, dojox, Chart){\n\t\tkernel.deprecated(\"dojox.charting.Chart2D\", \"Use dojox.charting.Chart instead and require all other components explicitly\", \"2.0\");\n\t\t// module:\n\t\t//\t\tdojox/charting/Chart2D\n\t\t// summary:\n\t\t//\t\tThis is a compatibility module which loads all charting modules that used to be automatically\n\t\t//\t\tloaded in versions prior to 1.6.  It is highly recommended for performance reasons that\n\t\t//\t\tthis module no longer be referenced by applications.  Instead, use dojox/charting/Chart.\n\t\treturn lang.setObject(\"dojox.charting.Chart2D\", Chart);\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 162 */\n/*!************************************************!*\\\n  !*** ../dojox/charting/plot2d/StackedAreas.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Stacked */ 163)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Stacked){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.StackedAreas\", Stacked, {\n\t\t\t// summary:\n\t\t\t//\t\tA convenience object to set up a stacked area plot.\n\t\t\tconstructor: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tForce our Stacked plotter to include both lines and areas.\n\t\t\t\tthis.opt.lines = true;\n\t\t\t\tthis.opt.areas = true;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\n\n/***/ },\n/* 163 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/plot2d/Stacked.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./Default */ 164), __webpack_require__(/*! ./commonStacked */ 190)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, lang, Default, commonStacked){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Stacked\", Default, {\n\t\t\t// summary:\n\t\t\t//\t\tLike the default plot, Stacked sets up lines, areas and markers\n\t\t\t//\t\tin a stacked fashion (values on the y axis added to each other)\n\t\t\t//\t\tas opposed to a direct one.\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = commonStacked.collectStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\t\t\n\t\t\tbuildSegments: function(i, indexed){\n\t\t\t\tvar run = this.series[i],\n\t\t\t\t\tmin = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0,\n\t\t\t\t\tmax = indexed?Math.min(run.data.length-1, Math.ceil(this._hScaler.bounds.to)):run.data.length-1,\n\t\t\t\t\trseg = null, segments = [], isNullValue = lang.hitch(this, \"isNullValue\");\n\t\t\t\t// split the run data into dense segments (each containing no nulls)\n\t\t\t\t// except if interpolates is false in which case ignore null between valid data\n\t\t\t\tfor(var j = min; j <= max; j++){\n\t\t\t\t\tvar value = indexed ? commonStacked.getIndexValue(this.series, i, j, isNullValue) : commonStacked.getValue(this.series, i, run.data[j] ?run.data[j].x: null, isNullValue);\n\t\t\t\t\tif(!isNullValue(value[0]) && (indexed || value[0].y != null)){\n\t\t\t\t\t\tif(!rseg){\n\t\t\t\t\t\t\trseg = [];\n\t\t\t\t\t\t\tsegments.push({index: j, rseg: rseg});\n\t\t\t\t\t\t}\n\t\t\t\t\t\trseg.push(value[0]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(!this.opt.interpolate || indexed){\n\t\t\t\t\t\t\t// we break the line only if not interpolating or if we have indexed data\n\t\t\t\t\t\t\trseg = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segments;\n\t\t\t}\n\t\t\t\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 164 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/plot2d/Default.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/has */ 5),\n\t\t\t__webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165), __webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\t\n\t\t/*=====\n\t\tdeclare(\"dojox.charting.plot2d.__DefaultCtorArgs\", dojox.charting.plot2d.__CartesianCtorArgs, {\n\t\t\t// summary:\n\t\t\t//\t\tThe arguments used for any/most plots.\n\t\n\t\t\t// lines: Boolean?\n\t\t\t//\t\tWhether or not to draw lines on this plot.  Defaults to true.\n\t\t\tlines:   true,\n\t\n\t\t\t// areas: Boolean?\n\t\t\t//\t\tWhether or not to draw areas on this plot. Defaults to false.\n\t\t\tareas:   false,\n\t\n\t\t\t// markers: Boolean?\n\t\t\t//\t\tWhether or not to draw markers at data points on this plot. Default is false.\n\t\t\tmarkers: false,\n\t\n\t\t\t// tension: Number|String?\n\t\t\t//\t\tWhether or not to apply 'tensioning' to the lines on this chart.\n\t\t\t//\t\tOptions include a number, \"X\", \"x\", or \"S\"; if a number is used, the\n\t\t\t//\t\tsimpler bezier curve calculations are used to draw the lines.  If X, x or S\n\t\t\t//\t\tis used, the more accurate smoothing algorithm is used.\n\t\t\ttension: \"\",\n\t\n\t\t\t// animate: Boolean?|Number?\n\t\t\t//\t\tWhether or not to animate the chart to place. When a Number it specifies the duration of the animation.\n\t\t\t//\t\tDefault is false.\n\t\t\tanimate: false,\n\t\n\t\t\t// stroke: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to use for any series on the plot.\n\t\t\tstroke:\t\t{},\n\t\n\t\t\t// outline: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke used to outline any series on the plot.\n\t\t\toutline:\t{},\n\t\n\t\t\t// shadow: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\n\t\t\tshadow:\t\t{},\n\t\n\t\t\t// fill: dojox.gfx.Fill?\n\t\t\t//\t\tAny fill to be used for elements on the plot (such as areas).\n\t\t\tfill:\t\t{},\n\t\n\t\t\t// filter: dojox.gfx.Filter?\n\t\t\t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\n\t\t\t//\t\tbe required for this to work.\n\t\t\tfilter:\t\t{},\n\t\n\t\t\t// styleFunc: Function?\n\t\t\t//\t\tA function that returns a styling object for the a given data item.\n\t\t\tstyleFunc:\tnull,\n\t\n\t\t\t// font: String?\n\t\t\t//\t\tA font definition to be used for labels and other text-based elements on the plot.\n\t\t\tfont:\t\t\"\",\n\t\n\t\t\t// fontColor: String|dojo.Color?\n\t\t\t//\t\tThe color to be used for any text-based elements on the plot.\n\t\t\tfontColor:\t\"\",\n\t\n\t\t\t// markerStroke: dojo.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to use for any markers on the plot.\n\t\t\tmarkerStroke:\t\t{},\n\t\n\t\t\t// markerOutline: dojo.gfx.Stroke?\n\t\t\t//\t\tAn optional outline to use for any markers on the plot.\n\t\t\tmarkerOutline:\t\t{},\n\t\n\t\t\t// markerShadow: dojo.gfx.Stroke?\n\t\t\t//\t\tAn optional shadow to use for any markers on the plot.\n\t\t\tmarkerShadow:\t\t{},\n\t\n\t\t\t// markerFill: dojo.gfx.Fill?\n\t\t\t//\t\tAn optional fill to use for any markers on the plot.\n\t\t\tmarkerFill:\t\t\t{},\n\t\n\t\t\t// markerFont: String?\n\t\t\t//\t\tAn optional font definition to use for any markers on the plot.\n\t\t\tmarkerFont:\t\t\t\"\",\n\t\n\t\t\t// markerFontColor: String|dojo.Color?\n\t\t\t//\t\tAn optional color to use for any marker text on the plot.\n\t\t\tmarkerFontColor:\t\"\",\n\t\n\t\t\t// enableCache: Boolean?\n\t\t\t//\t\tWhether the markers are cached from one rendering to another. This improves the rendering performance of\n\t\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\n\t\t\tenableCache: false,\n\t\n\t\t\t// interpolate: Boolean?\n\t\t\t//\t\tWhether when there is a null data point in the data the plot interpolates it or if the lines is split at that\n\t\t\t//\t\tpoint.\tDefault false.\n\t\t\tinterpolate: false,\n\t\n\t\t\t// zeroLine: Number?\n\t\t\t//\t\tZero line for an area fill. Should be a numeric value in user coordinates.\n\t\t\t//\t\tDefault: the lowest value on a vertical axis.\n\t\t\tzeroLine: 0\n\t\t});\n\t=====*/\n\t\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\t\tvar DEFAULT_ANIMATION_LENGTH = 1200;\t// in ms\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Default\", [CartesianBase, _PlotEvents], {\n\t\n\t\t\t// defaultParams:\n\t\t\t//\t\tThe default parameters of this plot.\n\t\t\tdefaultParams: {\n\t\t\t\tlines:   true,\t// draw lines\n\t\t\t\tareas:   false,\t// draw areas\n\t\t\t\tmarkers: false,\t// draw markers\n\t\t\t\ttension: \"\",\t// draw curved lines (tension is \"X\", \"x\", or \"S\")\n\t\t\t\tanimate: false, // animate chart to place\n\t\t\t\tenableCache: false,\n\t\t\t\tinterpolate: false\n\t\t\t},\n\t\n\t\t\t// optionalParams:\n\t\t\t//\t\tThe optional parameters of this plot.\n\t\t\toptionalParams: {\n\t\t\t\t// theme component\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfilter:     {},\n\t\t\t\tstyleFunc: null,\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\",\n\t\t\t\tmarker:             \"\",\n\t\t\t\tmarkerStroke:\t\t{},\n\t\t\t\tmarkerOutline:\t\t{},\n\t\t\t\tmarkerShadow:\t\t{},\n\t\t\t\tmarkerFill:\t\t\t{},\n\t\t\t\tmarkerFont:\t\t\t\"\",\n\t\t\t\tmarkerFontColor:\t\"\",\n\t\t\t\tzeroLine:           0\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturn a new plot.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t\t//\t\tAn optional arguments object to help define this plot.\n\t\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\t// animation properties\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t},\n\t\n\t\t\tcreatePath: function(run, creator, params){\n\t\t\t\tvar path;\n\t\t\t\tif(this.opt.enableCache && run._pathFreePool.length > 0){\n\t\t\t\t\tpath = run._pathFreePool.pop();\n\t\t\t\t\tpath.setShape(params);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(path);\n\t\t\t\t}else{\n\t\t\t\t\tpath = creator.createPath(params);\n\t\t\t\t}\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\trun._pathUsePool.push(path);\n\t\t\t\t}\n\t\t\t\treturn path;\n\t\t\t},\n\t\n\t\t\tbuildSegments: function(i, indexed){\n\t\t\t\tvar run = this.series[i],\n\t\t\t\t\tmin = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0,\n\t\t\t\t\tmax = indexed?Math.min(run.data.length, Math.ceil(this._hScaler.bounds.to)):run.data.length,\n\t\t\t\t\trseg = null, segments = [];\n\t\n\t\t\t\t// split the run data into dense segments (each containing no nulls)\n\t\t\t\t// except if interpolates is false in which case ignore null between valid data\n\t\t\t\tfor(var j = min; j < max; j++){\n\t\t\t\t\tif(!this.isNullValue(run.data[j])){\n\t\t\t\t\t\tif(!rseg){\n\t\t\t\t\t\t\trseg = [];\n\t\t\t\t\t\t\tsegments.push({index: j, rseg: rseg});\n\t\t\t\t\t\t}\n\t\t\t\t\t\trseg.push((indexed && run.data[j].hasOwnProperty(\"y\"))?run.data[j].y:run.data[j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(!this.opt.interpolate || indexed){\n\t\t\t\t\t\t\t// we break the line only if not interpolating or if we have indexed data\n\t\t\t\t\t\t\trseg = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segments;\n\t\t\t},\n\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender/draw everything on this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }\n\t\t\t\t// returns: dojox/charting/plot2d/Default\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\n\t\t\t\t// make sure all the series is not modified\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tvar s;\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\tthis.getGroup().setTransform(null);\n\t\t\t\t\ts = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\t\t\tvar t = this.chart.theme, stroke, outline, events = this.events();\n\t\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\t\trun._pathFreePool = (run._pathFreePool?run._pathFreePool:[]).concat(run._pathUsePool?run._pathUsePool:[]);\n\t\t\t\t\t\trun._pathUsePool = [];\n\t\t\t\t\t}\n\t\t\t\t\tif(!run.data.length){\n\t\t\t\t\t\trun.dirty = false;\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar theme = t.next(this.opt.areas ? \"area\" : \"line\", [this.opt, run], true),\n\t\t\t\t\t\tlpoly,\n\t\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\t\teventSeries = this._eventSeries[run.name] = new Array(run.data.length);\n\t\n\t\t\t\t\ts = run.group;\n\t\t\t\t\tif(run.hidden){\n\t\t\t\t\t\tif(this.opt.lines){\n\t\t\t\t\t\t\trun.dyn.stroke = theme.series.stroke;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (run.markers || (run.markers === undefined && this.opt.markers)) {\n\t\t\t\t\t\t\trun.dyn.markerFill = theme.marker.fill;\n\t\t\t\t\t\t\trun.dyn.markerStroke = theme.marker.stroke;\n\t\t\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.areas){\n\t\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// optim works only for index based case\n\t\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t});\n\t\n\t\t\t\t\tvar rsegments = this.buildSegments(i, indexed);\n\t\t\t\t\tfor(var seg = 0; seg < rsegments.length; seg++){\n\t\t\t\t\t\tvar rsegment = rsegments[seg];\n\t\t\t\t\t\tif(indexed){\n\t\t\t\t\t\t\tlpoly = arr.map(rsegment.rseg, function(v, i){\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tx: ht(i + rsegment.index + 1) + offsets.l,\n\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v),\n\t\t\t\t\t\t\t\t\tdata: v\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlpoly = arr.map(rsegment.rseg, function(v){\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\n\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y),\n\t\t\t\t\t\t\t\t\tdata: v\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// if we are indexed & we interpolate we need to put all the segments as a single one now\n\t\t\t\t\t\tif(indexed && this.opt.interpolate){\n\t\t\t\t\t\t\twhile(seg < rsegments.length) {\n\t\t\t\t\t\t\t\tseg++;\n\t\t\t\t\t\t\t\trsegment = rsegments[seg];\n\t\t\t\t\t\t\t\tif(rsegment){\n\t\t\t\t\t\t\t\t\tlpoly = lpoly.concat(arr.map(rsegment.rseg, function(v, i){\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tx: ht(i + rsegment.index + 1) + offsets.l,\n\t\t\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v),\n\t\t\t\t\t\t\t\t\t\t\tdata: v\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}, this));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar lpath = this.opt.tension ? dc.curve(lpoly, this.opt.tension) : \"\";\n\t\n\t\t\t\t\t\tif(this.opt.areas && lpoly.length > 1){\n\t\t\t\t\t\t\tvar fill = this._plotFill(theme.series.fill, dim, offsets), apoly = lang.clone(lpoly),\n\t\t\t\t\t\t\t\tzeroLine = dim.height - offsets.b;\n\t\t\t\t\t\t\tif(!isNaN(this.opt.zeroLine)){\n\t\t\t\t\t\t\t\tzeroLine = Math.max(offsets.t, Math.min(dim.height - offsets.b - vt(this.opt.zeroLine), zeroLine));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\t\tvar apath = \"L\" + apoly[apoly.length-1].x + \",\" + zeroLine +\n\t\t\t\t\t\t\t\t\t\" L\" + apoly[0].x + \",\" + zeroLine +\n\t\t\t\t\t\t\t\t\t\" L\" + apoly[0].x + \",\" + apoly[0].y;\n\t\t\t\t\t\t\t\trun.dyn.fill = s.createPath(lpath + \" \" + apath).setFill(fill).getFill();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tapoly.push({x: lpoly[lpoly.length - 1].x, y: zeroLine});\n\t\t\t\t\t\t\t\tapoly.push({x: lpoly[0].x, y: zeroLine});\n\t\t\t\t\t\t\t\tapoly.push(lpoly[0]);\n\t\t\t\t\t\t\t\trun.dyn.fill = s.createPolyline(apoly).setFill(fill).getFill();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.lines || this.opt.markers){\n\t\t\t\t\t\t\t// need a stroke\n\t\t\t\t\t\t\tstroke = theme.series.stroke;\n\t\t\t\t\t\t\tif(theme.series.outline){\n\t\t\t\t\t\t\t\toutline = run.dyn.outline = dc.makeStroke(theme.series.outline);\n\t\t\t\t\t\t\t\toutline.width = 2 * outline.width + (stroke && stroke.width || 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.markers){\n\t\t\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar frontMarkers = null, outlineMarkers = null, shadowMarkers = null;\n\t\t\t\t\t\tif(stroke && theme.series.shadow && lpoly.length > 1){\n\t\t\t\t\t\t\tvar shadow = theme.series.shadow,\n\t\t\t\t\t\t\t\tspoly = arr.map(lpoly, function(c){\n\t\t\t\t\t\t\t\t\treturn {x: c.x + shadow.dx, y: c.y + shadow.dy};\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif(this.opt.lines){\n\t\t\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\t\t\trun.dyn.shadow = s.createPath(dc.curve(spoly, this.opt.tension)).setStroke(shadow).getStroke();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trun.dyn.shadow = s.createPolyline(spoly).setStroke(shadow).getStroke();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.opt.markers && theme.marker.shadow){\n\t\t\t\t\t\t\t\tshadow = theme.marker.shadow;\n\t\t\t\t\t\t\t\tshadowMarkers = arr.map(spoly, function(c){\n\t\t\t\t\t\t\t\t\treturn this.createPath(run, s, \"M\" + c.x + \" \" + c.y + \" \" + theme.symbol).\n\t\t\t\t\t\t\t\t\t\tsetStroke(shadow).setFill(shadow.color);\n\t\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.lines && lpoly.length > 1){\n\t\t\t\t\t\t\tvar shape;\n\t\t\t\t\t\t\tif(outline){\n\t\t\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\t\t\trun.dyn.outline = s.createPath(lpath).setStroke(outline).getStroke();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trun.dyn.outline = s.createPolyline(lpoly).setStroke(outline).getStroke();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\t\trun.dyn.stroke = (shape = s.createPath(lpath)).setStroke(stroke).getStroke();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trun.dyn.stroke = (shape = s.createPolyline(lpoly)).setStroke(stroke).getStroke();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(shape.setFilter && theme.series.filter){\n\t\t\t\t\t\t\t\tshape.setFilter(theme.series.filter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar markerBox = null;\n\t\t\t\t\t\tif(this.opt.markers){\n\t\t\t\t\t\t\tvar markerTheme = theme;\n\t\t\t\t\t\t\tfrontMarkers = new Array(lpoly.length);\n\t\t\t\t\t\t\toutlineMarkers = new Array(lpoly.length);\n\t\t\t\t\t\t\toutline = null;\n\t\t\t\t\t\t\tif(markerTheme.marker.outline){\n\t\t\t\t\t\t\t\toutline = dc.makeStroke(markerTheme.marker.outline);\n\t\t\t\t\t\t\t\toutline.width = 2 * outline.width + (markerTheme.marker.stroke ? markerTheme.marker.stroke.width : 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tarr.forEach(lpoly, function(c, i){\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof c.data != \"number\"){\n\t\t\t\t\t\t\t\t\tvar tMixin = typeof c.data != \"number\" ? [c.data] : [];\n\t\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(c.data));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmarkerTheme = t.addMixin(theme, \"marker\", tMixin, true);\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tmarkerTheme = t.post(theme, \"marker\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar path = \"M\" + c.x + \" \" + c.y + \" \" + markerTheme.symbol;\n\t\t\t\t\t\t\t\tif(outline){\n\t\t\t\t\t\t\t\t\toutlineMarkers[i] = this.createPath(run, s, path).setStroke(outline);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfrontMarkers[i] = this.createPath(run, s, path).setStroke(markerTheme.marker.stroke).setFill(markerTheme.marker.fill);\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t\trun.dyn.markerFill = markerTheme.marker.fill;\n\t\t\t\t\t\t\trun.dyn.markerStroke = markerTheme.marker.stroke;\n\t\t\t\t\t\t\tif(!markerBox && this.opt.labels){\n\t\t\t\t\t\t\t\tmarkerBox = frontMarkers[0].getBoundingBox();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\tarr.forEach(frontMarkers, function(s, i){\n\t\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\t\telement: \"marker\",\n\t\t\t\t\t\t\t\t\t\tindex:   i + rsegment.index,\n\t\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\t\tshape:   s,\n\t\t\t\t\t\t\t\t\t\toutline: outlineMarkers[i] || null,\n\t\t\t\t\t\t\t\t\t\tshadow:  shadowMarkers && shadowMarkers[i] || null,\n\t\t\t\t\t\t\t\t\t\tcx:      lpoly[i].x,\n\t\t\t\t\t\t\t\t\t\tcy:      lpoly[i].y\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif(indexed){\n\t\t\t\t\t\t\t\t\t\to.x = i + rsegment.index + 1;\n\t\t\t\t\t\t\t\t\t\to.y = run.data[i + rsegment.index];\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\to.x = rsegment.rseg[i].x;\n\t\t\t\t\t\t\t\t\t\to.y = run.data[i + rsegment.index].y;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\t\teventSeries[i + rsegment.index] = o;\n\t\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdelete this._eventSeries[run.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.labels){\n\t\t\t\t\t\t\tvar labelBoxW = markerBox?markerBox.width:2;\n\t\t\t\t\t\t\tvar labelBoxH = markerBox?markerBox.height:2;\n\t\t\t\t\t\t\tarr.forEach(lpoly, function(c, i){\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof c.data != \"number\"){\n\t\t\t\t\t\t\t\t\tvar tMixin = typeof c.data != \"number\" ? [c.data] : [];\n\t\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(c.data));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmarkerTheme = t.addMixin(theme, \"marker\", tMixin, true);\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tmarkerTheme = t.post(theme, \"marker\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.createLabel(s, rsegment.rseg[i], { x: c.x - labelBoxW / 2, y: c.y - labelBoxH / 2,\n\t\t\t\t\t\t\t\t\twidth: labelBoxW , height: labelBoxH }, markerTheme);\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\tif(this.animate){\n\t\t\t\t\t// grow from the bottom\n\t\t\t\t\tvar plotGroup = this.getGroup();\n\t\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\t\tshape: plotGroup,\n\t\t\t\t\t\tduration: DEFAULT_ANIMATION_LENGTH,\n\t\t\t\t\t\ttransform:[\n\t\t\t\t\t\t\t{name:\"translate\", start: [0, dim.height - offsets.b], end: [0, 0]},\n\t\t\t\t\t\t\t{name:\"scale\", start: [1, 0], end:[1, 1]},\n\t\t\t\t\t\t\t{name:\"original\"}\n\t\t\t\t\t\t]\n\t\t\t\t\t}, this.animate)).play();\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Default\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 165 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/plot2d/common.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/Color */ 120), \n\t\t\t__webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! ../scaler/common */ 180)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, Color, g, df, sc){\n\t\t\n\t\tvar common = lang.getObject(\"dojox.charting.plot2d.common\", true);\n\t\t\n\t\treturn lang.mixin(common, {\t\n\t\t\tdoIfLoaded: sc.doIfLoaded,\n\t\t\tmakeStroke: function(stroke){\n\t\t\t\tif(!stroke){ return stroke; }\n\t\t\t\tif(typeof stroke == \"string\" || stroke instanceof Color){\n\t\t\t\t\tstroke = {color: stroke};\n\t\t\t\t}\n\t\t\t\treturn g.makeParameters(g.defaultStroke, stroke);\n\t\t\t},\n\t\t\taugmentColor: function(target, color){\n\t\t\t\tvar t = new Color(target),\n\t\t\t\t\tc = new Color(color);\n\t\t\t\tc.a = t.a;\n\t\t\t\treturn c;\n\t\t\t},\n\t\t\taugmentStroke: function(stroke, color){\n\t\t\t\tvar s = common.makeStroke(stroke);\n\t\t\t\tif(s){\n\t\t\t\t\ts.color = common.augmentColor(s.color, color);\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t},\n\t\t\taugmentFill: function(fill, color){\n\t\t\t\tvar fc, c = new Color(color);\n\t\t\t\tif(typeof fill == \"string\" || fill instanceof Color){\n\t\t\t\t\treturn common.augmentColor(fill, color);\n\t\t\t\t}\n\t\t\t\treturn fill;\n\t\t\t},\n\t\n\t\t\tdefaultStats: {\n\t\t\t\tvmin: Number.POSITIVE_INFINITY, vmax: Number.NEGATIVE_INFINITY,\n\t\t\t\thmin: Number.POSITIVE_INFINITY, hmax: Number.NEGATIVE_INFINITY\n\t\t\t},\n\t\n\t\t\tcollectSimpleStats: function(series, isNullValue){\n\t\t\t\tvar stats = lang.delegate(common.defaultStats);\n\t\t\t\tfor(var i = 0; i < series.length; ++i){\n\t\t\t\t\tvar run = series[i];\n\t\t\t\t\tfor(var j = 0; j < run.data.length; j++){\n\t\t\t\t\t\tif(!isNullValue(run.data[j])){\n\t\t\t\t\t\t\tif(typeof run.data[j] == \"number\"){\n\t\t\t\t\t\t\t\t// 1D case\n\t\t\t\t\t\t\t\tvar old_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\t\t\t\t\tarr.forEach(run.data, function(val, i){\n\t\t\t\t\t\t\t\t\tif(!isNullValue(val)){\n\t\t\t\t\t\t\t\t\t\tvar x = i + 1, y = val;\n\t\t\t\t\t\t\t\t\t\tif(isNaN(y)){ y = 0; }\n\t\t\t\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, y);\n\t\t\t\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\t\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// 2D case\n\t\t\t\t\t\t\t\tvar old_hmin = stats.hmin, old_hmax = stats.hmax,\n\t\t\t\t\t\t\t\t\told_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\t\t\t\t\tif(!(\"xmin\" in run) || !(\"xmax\" in run) || !(\"ymin\" in run) || !(\"ymax\" in run)){\n\t\t\t\t\t\t\t\t\tarr.forEach(run.data, function(val, i){\n\t\t\t\t\t\t\t\t\t\tif(!isNullValue(val)){\n\t\t\t\t\t\t\t\t\t\t\tvar x = \"x\" in val ? val.x : i + 1, y = val.y;\n\t\t\t\t\t\t\t\t\t\t\tif(isNaN(x)){ x = 0; }\n\t\t\t\t\t\t\t\t\t\t\tif(isNaN(y)){ y = 0; }\n\t\t\t\t\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, y);\n\t\t\t\t\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, y);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(\"xmin\" in run){ stats.hmin = Math.min(old_hmin, run.xmin); }\n\t\t\t\t\t\t\t\tif(\"xmax\" in run){ stats.hmax = Math.max(old_hmax, run.xmax); }\n\t\t\t\t\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\t\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn stats;\n\t\t\t},\n\t\n\t\t\tcalculateBarSize: function(/* Number */ availableSize, /* Object */ opt, /* Number? */ clusterSize){\n\t\t\t\tif(!clusterSize){\n\t\t\t\t\tclusterSize = 1;\n\t\t\t\t}\n\t\t\t\tvar gap = opt.gap, size = (availableSize - 2 * gap) / clusterSize;\n\t\t\t\tif(\"minBarSize\" in opt){\n\t\t\t\t\tsize = Math.max(size, opt.minBarSize);\n\t\t\t\t}\n\t\t\t\tif(\"maxBarSize\" in opt){\n\t\t\t\t\tsize = Math.min(size, opt.maxBarSize);\n\t\t\t\t}\n\t\t\t\tsize = Math.max(size, 1);\n\t\t\t\tgap = (availableSize - size * clusterSize) / 2;\n\t\t\t\treturn {size: size, gap: gap};\t// Object\n\t\t\t},\n\t\n\t\t\tcollectStackedStats: function(series){\n\t\t\t\t// collect statistics\n\t\t\t\tvar stats = lang.clone(common.defaultStats);\n\t\t\t\tif(series.length){\n\t\t\t\t\t// 1st pass: find the maximal length of runs\n\t\t\t\t\tstats.hmin = Math.min(stats.hmin, 1);\n\t\t\t\t\tstats.hmax = df.foldl(series, \"seed, run -> Math.max(seed, run.data.length)\", stats.hmax);\n\t\t\t\t\t// 2nd pass: stack values\n\t\t\t\t\tfor(var i = 0; i < stats.hmax; ++i){\n\t\t\t\t\t\tvar v = series[0].data[i];\n\t\t\t\t\t\tv = v && (typeof v == \"number\" ? v : v.y);\n\t\t\t\t\t\tif(isNaN(v)){ v = 0; }\n\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, v);\n\t\t\t\t\t\tfor(var j = 1; j < series.length; ++j){\n\t\t\t\t\t\t\tvar t = series[j].data[i];\n\t\t\t\t\t\t\tt = t && (typeof t == \"number\" ? t : t.y);\n\t\t\t\t\t\t\tif(isNaN(t)){ t = 0; }\n\t\t\t\t\t\t\tv += t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn stats;\n\t\t\t},\n\t\n\t\t\tcurve: function(/* Number[] */a, /* Number|String */tension){\n\t\t\t\t//\tFIX for #7235, submitted by Enzo Michelangeli.\n\t\t\t\t//\tEmulates the smoothing algorithms used in a famous, unnamed spreadsheet\n\t\t\t\t//\t\tprogram ;)\n\t\t\t\tvar array = a.slice(0);\n\t\t\t\tif(tension == \"x\") {\n\t\t\t\t\tarray[array.length] = array[0];   // add a last element equal to the first, closing the loop\n\t\t\t\t}\n\t\t\t\tvar p=arr.map(array, function(item, i){\n\t\t\t\t\tif(i==0){ return \"M\" + item.x + \",\" + item.y; }\n\t\t\t\t\tif(!isNaN(tension)) { // use standard Dojo smoothing in tension is numeric\n\t\t\t\t\t\tvar dx=item.x-array[i-1].x, dy=array[i-1].y;\n\t\t\t\t\t\treturn \"C\"+(item.x-(tension-1)*(dx/tension))+\",\"+dy+\" \"+(item.x-(dx/tension))+\",\"+item.y+\" \"+item.x+\",\"+item.y;\n\t\t\t\t\t} else if(tension == \"X\" || tension == \"x\" || tension == \"S\") {\n\t\t\t\t\t\t// use Excel \"line smoothing\" algorithm (http://xlrotor.com/resources/files.shtml)\n\t\t\t\t\t\tvar p0, p1 = array[i-1], p2 = array[i], p3;\n\t\t\t\t\t\tvar bz1x, bz1y, bz2x, bz2y;\n\t\t\t\t\t\tvar f = 1/6;\n\t\t\t\t\t\tif(i==1) {\n\t\t\t\t\t\t\tif(tension == \"x\") {\n\t\t\t\t\t\t\t\tp0 = array[array.length-2];\n\t\t\t\t\t\t\t} else { // \"tension == X || tension == \"S\"\n\t\t\t\t\t\t\t\tp0 = p1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf = 1/3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp0 = array[i-2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==(array.length-1)) {\n\t\t\t\t\t\t\tif(tension == \"x\") {\n\t\t\t\t\t\t\t\tp3 = array[1];\n\t\t\t\t\t\t\t} else { // \"tension == X || tension == \"S\"\n\t\t\t\t\t\t\t\tp3 = p2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf = 1/3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp3 = array[i+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar p1p2 = Math.sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));\n\t\t\t\t\t\tvar p0p2 = Math.sqrt((p2.x-p0.x)*(p2.x-p0.x)+(p2.y-p0.y)*(p2.y-p0.y));\n\t\t\t\t\t\tvar p1p3 = Math.sqrt((p3.x-p1.x)*(p3.x-p1.x)+(p3.y-p1.y)*(p3.y-p1.y));\n\t\n\t\t\t\t\t\tvar p0p2f = p0p2 * f;\n\t\t\t\t\t\tvar p1p3f = p1p3 * f;\n\t\n\t\t\t\t\t\tif(p0p2f > p1p2/2 && p1p3f > p1p2/2) {\n\t\t\t\t\t\t\tp0p2f = p1p2/2;\n\t\t\t\t\t\t\tp1p3f = p1p2/2;\n\t\t\t\t\t\t} else if(p0p2f > p1p2/2) {\n\t\t\t\t\t\t\tp0p2f = p1p2/2;\n\t\t\t\t\t\t\tp1p3f = p1p2/2 * p1p3/p0p2;\n\t\t\t\t\t\t} else if(p1p3f > p1p2/2) {\n\t\t\t\t\t\t\tp1p3f = p1p2/2;\n\t\t\t\t\t\t\tp0p2f = p1p2/2 * p0p2/p1p3;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(tension == \"S\") {\n\t\t\t\t\t\t\tif(p0 == p1) { p0p2f = 0; }\n\t\t\t\t\t\t\tif(p2 == p3) { p1p3f = 0; }\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbz1x = p1.x + p0p2f*(p2.x - p0.x)/p0p2;\n\t\t\t\t\t\tbz1y = p1.y + p0p2f*(p2.y - p0.y)/p0p2;\n\t\t\t\t\t\tbz2x = p2.x - p1p3f*(p3.x - p1.x)/p1p3;\n\t\t\t\t\t\tbz2y = p2.y - p1p3f*(p3.y - p1.y)/p1p3;\n\t\t\t\t\t}\n\t\t\t\t\treturn \"C\"+(bz1x+\",\"+bz1y+\" \"+bz2x+\",\"+bz2y+\" \"+p2.x+\",\"+p2.y);\n\t\t\t\t});\n\t\t\t\treturn p.join(\" \");\n\t\t\t},\n\t\t\t\n\t\t\tgetLabel: function(/*Number*/number, /*Boolean*/fixed, /*Number*/precision){\n\t\t\t\treturn sc.doIfLoaded(\"dojo/number\", function(numberLib){\n\t\t\t\t\treturn (fixed ? numberLib.format(number, {places : precision}) :\n\t\t\t\t\t\tnumberLib.format(number)) || \"\";\n\t\t\t\t}, function(){\n\t\t\t\t\treturn fixed ? number.toFixed(precision) : number.toString();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 166 */\n/*!***********************!*\\\n  !*** ../dojox/gfx.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./gfx/_base */ 167), __webpack_require__(/*! ./gfx/renderer */ 168)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, gfxBase, renderer){\n\t\t// module:\n\t\t//\t\tdojox/gfx\n\t\t// summary:\n\t\t//\t\tThis the root of the Dojo Graphics package\n\t\tgfxBase.switchTo(renderer);\n\t\treturn gfxBase;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 167 */\n/*!*****************************!*\\\n  !*** ../dojox/gfx/_base.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ 4), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/Color */ 120), __webpack_require__(/*! dojo/_base/sniff */ 46), __webpack_require__(/*! dojo/_base/window */ 15),\n\t\t    __webpack_require__(/*! dojo/_base/array */ 13),__webpack_require__(/*! dojo/dom */ 14), __webpack_require__(/*! dojo/dom-construct */ 39),__webpack_require__(/*! dojo/dom-geometry */ 36)], __WEBPACK_AMD_DEFINE_RESULT__ = function(kernel, lang, Color, has, win, arr, dom, domConstruct, domGeom){\n\t\t// module:\n\t\t//\t\tdojox/gfx\n\t\t// summary:\n\t\t//\t\tThis module contains common core Graphics API used by different graphics renderers.\n\t\n\t\tvar g = lang.getObject(\"dojox.gfx\", true),\n\t\t\tb = g._base = {};\n\t\t\n\t\t// candidates for dojox.style (work on VML and SVG nodes)\n\t\tg._hasClass = function(/*DomNode*/node, /*String*/classStr){\n\t\t\t// summary:\n\t\t\t//\t\tReturns whether or not the specified classes are a portion of the\n\t\t\t//\t\tclass list currently applied to the node.\n\t\t\t\n\t\t\t// return (new RegExp('(^|\\\\s+)'+classStr+'(\\\\s+|$)')).test(node.className)\t// Boolean\n\t\t\tvar cls = node.getAttribute(\"className\");\n\t\t\treturn cls && (\" \" + cls + \" \").indexOf(\" \" + classStr + \" \") >= 0;  // Boolean\n\t\t};\n\t\tg._addClass = function(/*DomNode*/node, /*String*/classStr){\n\t\t\t// summary:\n\t\t\t//\t\tAdds the specified classes to the end of the class list on the\n\t\t\t//\t\tpassed node.\n\t\t\tvar cls = node.getAttribute(\"className\") || \"\";\n\t\t\tif(!cls || (\" \" + cls + \" \").indexOf(\" \" + classStr + \" \") < 0){\n\t\t\t\tnode.setAttribute(\"className\", cls + (cls ? \" \" : \"\") + classStr);\n\t\t\t}\n\t\t};\n\t\tg._removeClass = function(/*DomNode*/node, /*String*/classStr){\n\t\t\t// summary:\n\t\t\t//\t\tRemoves classes from node.\n\t\t\tvar cls = node.getAttribute(\"className\");\n\t\t\tif(cls){\n\t\t\t\tnode.setAttribute(\n\t\t\t\t\t\"className\",\n\t\t\t\t\tcls.replace(new RegExp('(^|\\\\s+)' + classStr + '(\\\\s+|$)'), \"$1$2\")\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t\n\t\t// candidate for dojox.html.metrics (dynamic font resize handler is not implemented here)\n\t\n\t\t//\t\tderived from Morris John's emResized measurer\n\t\tb._getFontMeasurements = function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an object that has pixel equivilents of standard font\n\t\t\t//\t\tsize values.\n\t\t\tvar heights = {\n\t\t\t\t'1em': 0, '1ex': 0, '100%': 0, '12pt': 0, '16px': 0, 'xx-small': 0,\n\t\t\t\t'x-small': 0, 'small': 0, 'medium': 0, 'large': 0, 'x-large': 0,\n\t\t\t\t'xx-large': 0\n\t\t\t};\n\t\t\tvar p, oldStyle;\t\n\t\t\tif(has(\"ie\")){\n\t\t\t\t//\tWe do a font-size fix if and only if one isn't applied already.\n\t\t\t\t// NOTE: If someone set the fontSize on the HTML Element, this will kill it.\n\t\t\t\toldStyle = win.doc.documentElement.style.fontSize || \"\";\n\t\t\t\tif(!oldStyle){\n\t\t\t\t\twin.doc.documentElement.style.fontSize=\"100%\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t//\t\tset up the measuring node.\n\t\t\tvar div = domConstruct.create(\"div\", {style: {\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: \"0\",\n\t\t\t\t\ttop: \"-100px\",\n\t\t\t\t\twidth: \"30px\",\n\t\t\t\t\theight: \"1000em\",\n\t\t\t\t\tborderWidth: \"0\",\n\t\t\t\t\tmargin: \"0\",\n\t\t\t\t\tpadding: \"0\",\n\t\t\t\t\toutline: \"none\",\n\t\t\t\t\tlineHeight: \"1\",\n\t\t\t\t\toverflow: \"hidden\"\n\t\t\t\t}}, win.body());\n\t\n\t\t\t//\t\tdo the measurements.\n\t\t\tfor(p in heights){\n\t\t\t\tdiv.style.fontSize = p;\n\t\t\t\theights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;\n\t\t\t}\n\t\n\t\t\tif(has(\"ie\")){\n\t\t\t\t// Restore the font to its old style.\n\t\t\t\twin.doc.documentElement.style.fontSize = oldStyle;\n\t\t\t}\n\t\t\twin.body().removeChild(div);\n\t\t\treturn heights; //object\n\t\t};\n\t\n\t\tvar fontMeasurements = null;\n\t\n\t\tb._getCachedFontMeasurements = function(recalculate){\n\t\t\tif(recalculate || !fontMeasurements){\n\t\t\t\tfontMeasurements = b._getFontMeasurements();\n\t\t\t}\n\t\t\treturn fontMeasurements;\n\t\t};\n\t\n\t\t// candidate for dojox.html.metrics\n\t\n\t\tvar measuringNode = null, empty = {};\n\t\tb._getTextBox = function(\t/*String*/ text,\n\t\t\t\t\t\t\t\t\t/*Object*/ style,\n\t\t\t\t\t\t\t\t\t/*String?*/ className){\n\t\t\tvar m, s, al = arguments.length;\n\t\t\tvar i, box;\n\t\t\tif(!measuringNode){\n\t\t\t\tmeasuringNode = domConstruct.create(\"div\", {style: {\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: \"-10000px\",\n\t\t\t\t\tleft: \"0\",\n\t\t\t\t\tvisibility: \"hidden\"\n\t\t\t\t}}, win.body());\n\t\t\t}\n\t\t\tm = measuringNode;\n\t\t\t// reset styles\n\t\t\tm.className = \"\";\n\t\t\ts = m.style;\n\t\t\ts.borderWidth = \"0\";\n\t\t\ts.margin = \"0\";\n\t\t\ts.padding = \"0\";\n\t\t\ts.outline = \"0\";\n\t\t\t// set new style\n\t\t\tif(al > 1 && style){\n\t\t\t\tfor(i in style){\n\t\t\t\t\tif(i in empty){ continue; }\n\t\t\t\t\ts[i] = style[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// set classes\n\t\t\tif(al > 2 && className){\n\t\t\t\tm.className = className;\n\t\t\t}\n\t\t\t// take a measure\n\t\t\tm.innerHTML = text;\n\t\n\t\t\tif(m.getBoundingClientRect){\n\t\t\t\tvar bcr = m.getBoundingClientRect();\n\t\t\t\tbox = {l: bcr.left, t: bcr.top, w: bcr.width || (bcr.right - bcr.left), h: bcr.height || (bcr.bottom - bcr.top)};\n\t\t\t}else{\n\t\t\t\tbox = domGeom.getMarginBox(m);\n\t\t\t}\n\t\t\tm.innerHTML = \"\";\n\t\t\treturn box;\n\t\t};\n\t\n\t\tb._computeTextLocation = function(/*g.defaultTextShape*/textShape, /*Number*/width, /*Number*/height, /*Boolean*/fixHeight) {\n\t\t\tvar loc = {}, align = textShape.align;\n\t\t\tswitch (align) {\n\t\t\t\tcase 'end':\n\t\t\t\t\tloc.x = textShape.x - width;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'middle':\n\t\t\t\t\tloc.x = textShape.x - width / 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tloc.x = textShape.x;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar c = fixHeight ? 0.75 : 1;\n\t\t\tloc.y = textShape.y - height*c; // **rough** approximation of the ascent...\n\t\t\treturn loc;\n\t\t};\n\t\tb._computeTextBoundingBox = function(/*shape.Text*/s){\n\t\t\t// summary:\n\t\t\t//\t\tCompute the bbox of the given shape.Text instance. Note that this method returns an\n\t\t\t//\t\tapproximation of the bbox, and should be used when the underlying renderer cannot provide precise metrics.\n\t\t\tif(!g._base._isRendered(s)){\n\t\t\t\treturn {x:0, y:0, width:0, height:0};\n\t\t\t}\n\t\t\tvar loc, textShape = s.getShape(),\n\t\t\t\tfont = s.getFont() || g.defaultFont,\n\t\t\t\tw = s.getTextWidth(),\n\t\t\t\th = g.normalizedLength(font.size);\n\t\t\tloc = b._computeTextLocation(textShape, w, h, true);\n\t\t\treturn {\n\t\t\t\tx: loc.x,\n\t\t\t\ty: loc.y,\n\t\t\t\twidth: w,\n\t\t\t\theight: h\n\t\t\t};\n\t\t};\n\t\tb._isRendered = function(/*Shape*/s){\n\t\t\tvar p = s.parent;\n\t\t\twhile(p && p.getParent){\n\t\t\t\tp = p.parent;\n\t\t\t}\n\t\t\treturn p !== null;\n\t\t};\n\t\n\t\t// candidate for dojo.dom\n\t\n\t\tvar uniqueId = 0;\n\t\tb._getUniqueId = function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns a unique string for use with any DOM element\n\t\t\tvar id;\n\t\t\tdo{\n\t\t\t\tid = kernel._scopeName + \"xUnique\" + (++uniqueId);\n\t\t\t}while(dom.byId(id));\n\t\t\treturn id;\n\t\t};\n\t\n\t\t// IE10\n\t\n\t\tvar touchActionProp = has(\"pointer-events\") ? \"touchAction\" : has(\"MSPointer\") ? \"msTouchAction\" : null;\n\t\tb._fixMsTouchAction = touchActionProp ? function(/*dojox/gfx/shape.Surface*/surface){\n\t\t\tsurface.rawNode.style[touchActionProp] = \"none\";\n\t\t} : function() {};\n\t\n\t\t/*=====\n\t\tg.Stroke = {\n\t\t\t// summary:\n\t\t\t//\t\tA stroke defines stylistic properties that are used when drawing a path.\n\t\n\t\t\t// color: String\n\t\t\t//\t\tThe color of the stroke, default value 'black'.\n\t\t\tcolor: \"black\",\n\t\n\t\t\t// style: String\n\t\t\t//\t\tThe style of the stroke, one of 'solid', ... . Default value 'solid'.\n\t\t\tstyle: \"solid\",\n\t\n\t\t\t// width: Number\n\t\t\t//\t\tThe width of a stroke, default value 1.\n\t\t\twidth: 1,\n\t\n\t\t\t// cap: String\n\t\t\t//\t\tThe endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.\n\t\t\tcap: \"butt\",\n\t\n\t\t\t// join: Number\n\t\t\t//\t\tThe join style to use when combining path segments. Default value 4.\n\t\t\tjoin: 4\n\t\t};\n\t\t\n\t\tg.Fill = {\n\t\t\t// summary:\n\t\t\t//\t\tDefines how to fill a shape. Four types of fills can be used: solid, linear gradient, radial gradient and pattern.\n\t\t\t//\t\tSee dojox/gfx.LinearGradient, dojox/gfx.RadialGradient and dojox/gfx.Pattern respectively for more information about the properties supported by each type.\n\t\t\t\n\t\t\t// type: String?\n\t\t\t//\t\tThe type of fill. One of 'linear', 'radial', 'pattern' or undefined. If not specified, a solid fill is assumed.\n\t\t\ttype:\"\",\n\t\t\t\n\t\t\t// color: String|dojo/Color?\n\t\t\t//\t\tThe color of a solid fill type.\n\t\t\tcolor:null,\n\t\t\t\n\t\t};\n\t\t\n\t\tg.LinearGradient = {\n\t\t\t// summary:\n\t\t\t//\t\tAn object defining the default stylistic properties used for Linear Gradient fills.\n\t\t\t//\t\tLinear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.\n\t\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Linear Gradient, value 'linear'\n\t\t\ttype: \"linear\",\n\t\n\t\t\t// x1: Number\n\t\t\t//\t\tThe X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\t\tx1: 0,\n\t\n\t\t\t// y1: Number\n\t\t\t//\t\tThe Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\t\ty1: 0,\n\t\n\t\t\t// x2: Number\n\t\t\t//\t\tThe X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\t\tx2: 100,\n\t\n\t\t\t// y2: Number\n\t\t\t//\t\tThe Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\t\ty2: 100,\n\t\n\t\t\t// colors: Array\n\t\t\t//\t\tAn array of colors at given offsets (from the start of the line).  The start of the line is\n\t\t\t//\t\tdefined at offest 0 with the end of the line at offset 1.\n\t\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\t\tcolors: []\n\t\t};\n\t\t\n\t\tg.RadialGradient = {\n\t\t\t// summary:\n\t\t\t//\t\tSpecifies the properties for RadialGradients using in fills patterns.\n\t\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this is a RadialGradient, value 'radial'\n\t\t\ttype: \"radial\",\n\t\n\t\t\t// cx: Number\n\t\t\t//\t\tThe X coordinate of the center of the radial gradient, default value 0.\n\t\t\tcx: 0,\n\t\n\t\t\t// cy: Number\n\t\t\t//\t\tThe Y coordinate of the center of the radial gradient, default value 0.\n\t\t\tcy: 0,\n\t\n\t\t\t// r: Number\n\t\t\t//\t\tThe radius to the end of the radial gradient, default value 100.\n\t\t\tr: 100,\n\t\n\t\t\t// colors: Array\n\t\t\t//\t\tAn array of colors at given offsets (from the center of the radial gradient).\n\t\t\t//\t\tThe center is defined at offest 0 with the outer edge of the gradient at offset 1.\n\t\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\t\tcolors: []\n\t\t};\n\t\t\n\t\tg.Pattern = {\n\t\t\t// summary:\n\t\t\t//\t\tAn object specifying the default properties for a Pattern using in fill operations.\n\t\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Pattern, value 'pattern'.\n\t\t\ttype: \"pattern\",\n\t\n\t\t\t// x: Number\n\t\t\t//\t\tThe X coordinate of the position of the pattern, default value is 0.\n\t\t\tx: 0,\n\t\n\t\t\t// y: Number\n\t\t\t//\t\tThe Y coordinate of the position of the pattern, default value is 0.\n\t\t\ty: 0,\n\t\n\t\t\t// width: Number\n\t\t\t//\t\tThe width of the pattern image, default value is 0.\n\t\t\twidth: 0,\n\t\n\t\t\t// height: Number\n\t\t\t//\t\tThe height of the pattern image, default value is 0.\n\t\t\theight: 0,\n\t\n\t\t\t// src: String\n\t\t\t//\t\tA url specifying the image to use for the pattern.\n\t\t\tsrc: \"\"\n\t\t};\n\t\n\t\tg.Text = {\n\t\t\t//\tsummary:\n\t\t\t//\t\tA keyword argument object defining both the text to be rendered in a VectorText shape,\n\t\t\t//\t\tand specifying position, alignment, and fitting.\n\t\t\t//\ttext: String\n\t\t\t//\t\tThe text to be rendered.\n\t\t\t//\tx: Number?\n\t\t\t//\t\tThe left coordinate for the text's bounding box.\n\t\t\t//\ty: Number?\n\t\t\t//\t\tThe top coordinate for the text's bounding box.\n\t\t\t//\twidth: Number?\n\t\t\t//\t\tThe width of the text's bounding box.\n\t\t\t//\theight: Number?\n\t\t\t//\t\tThe height of the text's bounding box.\n\t\t\t//\talign: String?\n\t\t\t//\t\tThe alignment of the text, as defined in SVG. Can be \"start\", \"end\" or \"middle\".\n\t\t\t//\tfitting: Number?\n\t\t\t//\t\tHow the text is to be fitted to the bounding box. Can be 0 (no fitting), 1 (fitting based on\n\t\t\t//\t\tpassed width of the bounding box and the size of the font), or 2 (fit text to the bounding box,\n\t\t\t//\t\tand ignore any size parameters).\n\t\t\t//\tleading: Number?\n\t\t\t//\t\tThe leading to be used between lines in the text.\n\t\t\t//\tdecoration: String?\n\t\t\t//\t\tAny text decoration to be used.\n\t\t};\n\t\n\t\tg.Font = {\n\t\t\t// summary:\n\t\t\t//\t\tAn object specifying the properties for a Font used in text operations.\n\t\t\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Font, value 'font'.\n\t\t\ttype: \"font\",\n\t\t\n\t\t\t// style: String\n\t\t\t//\t\tThe font style, one of 'normal', 'bold', default value 'normal'.\n\t\t\tstyle: \"normal\",\n\t\t\n\t\t\t// variant: String\n\t\t\t//\t\tThe font variant, one of 'normal', ... , default value 'normal'.\n\t\t\tvariant: \"normal\",\n\t\t\n\t\t\t// weight: String\n\t\t\t//\t\tThe font weight, one of 'normal', ..., default value 'normal'.\n\t\t\tweight: \"normal\",\n\t\t\n\t\t\t// size: String\n\t\t\t//\t\tThe font size (including units), default value '10pt'.\n\t\t\tsize: \"10pt\",\n\t\t\n\t\t\t// family: String\n\t\t\t//\t\tThe font family, one of 'serif', 'sanserif', ..., default value 'serif'.\n\t\t\tfamily: \"serif\"\n\t\t};\n\t\n\t\t=====*/\n\t\n\t\tlang.mixin(g, {\n\t\t\t// summary:\n\t\t\t//\t\tdefines constants, prototypes, and utility functions for the core Graphics API\n\t\n\t\t\t// default shapes, which are used to fill in missing parameters\n\t\t\tdefaultPath: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default Path prototype object.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a Path, default value 'path'.\n\t\t\t\ttype: \"path\", \n\t\n\t\t\t\t// path: String\n\t\t\t\t//\t\tThe path commands. See W32C SVG 1.0 specification.\n\t\t\t\t//\t\tDefaults to empty string value.\n\t\t\t\tpath: \"\"\n\t\t\t},\n\t\t\tdefaultPolyline: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default PolyLine prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a PolyLine, default value 'polyline'.\n\t\t\t\ttype: \"polyline\",\n\t\n\t\t\t\t// points: Array\n\t\t\t\t//\t\tAn array of point objects [{x:0,y:0},...] defining the default polyline's line segments. Value is an empty array [].\n\t\t\t\tpoints: []\n\t\t\t},\n\t\t\tdefaultRect: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default Rect prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this default object is a type of Rect. Value is 'rect'\n\t\t\t\ttype: \"rect\",\n\t\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tThe X coordinate of the default rectangles position, value 0.\n\t\t\t\tx: 0,\n\t\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tThe Y coordinate of the default rectangle's position, value 0.\n\t\t\t\ty: 0,\n\t\n\t\t\t\t// width: Number\n\t\t\t\t//\t\tThe width of the default rectangle, value 100.\n\t\t\t\twidth: 100,\n\t\n\t\t\t\t// height: Number\n\t\t\t\t//\t\tThe height of the default rectangle, value 100.\n\t\t\t\theight: 100,\n\t\n\t\t\t\t// r: Number\n\t\t\t\t//\t\tThe corner radius for the default rectangle, value 0.\n\t\t\t\tr: 0\n\t\t\t},\n\t\t\tdefaultEllipse: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default Ellipse prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies that this object is a type of Ellipse, value is 'ellipse'\n\t\t\t\ttype: \"ellipse\",\n\t\n\t\t\t\t// cx: Number\n\t\t\t\t//\t\tThe X coordinate of the center of the ellipse, default value 0.\n\t\t\t\tcx: 0,\n\t\n\t\t\t\t// cy: Number\n\t\t\t\t//\t\tThe Y coordinate of the center of the ellipse, default value 0.\n\t\t\t\tcy: 0,\n\t\n\t\t\t\t// rx: Number\n\t\t\t\t//\t\tThe radius of the ellipse in the X direction, default value 200.\n\t\t\t\trx: 200,\n\t\n\t\t\t\t// ry: Number\n\t\t\t\t//\t\tThe radius of the ellipse in the Y direction, default value 200.\n\t\t\t\try: 100\n\t\t\t},\n\t\t\tdefaultCircle: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn object defining the default Circle prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a circle, value 'circle'\n\t\t\t\ttype: \"circle\",\n\t\n\t\t\t\t// cx: Number\n\t\t\t\t//\t\tThe X coordinate of the center of the circle, default value 0.\n\t\t\t\tcx: 0,\n\t\t\t\t// cy: Number\n\t\t\t\t//\t\tThe Y coordinate of the center of the circle, default value 0.\n\t\t\t\tcy: 0,\n\t\n\t\t\t\t// r: Number\n\t\t\t\t//\t\tThe radius, default value 100.\n\t\t\t\tr: 100\n\t\t\t},\n\t\t\tdefaultLine: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn object defining the default Line prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this is a Line, value 'line'\n\t\t\t\ttype: \"line\",\n\t\n\t\t\t\t// x1: Number\n\t\t\t\t//\t\tThe X coordinate of the start of the line, default value 0.\n\t\t\t\tx1: 0,\n\t\n\t\t\t\t// y1: Number\n\t\t\t\t//\t\tThe Y coordinate of the start of the line, default value 0.\n\t\t\t\ty1: 0,\n\t\n\t\t\t\t// x2: Number\n\t\t\t\t//\t\tThe X coordinate of the end of the line, default value 100.\n\t\t\t\tx2: 100,\n\t\n\t\t\t\t// y2: Number\n\t\t\t\t//\t\tThe Y coordinate of the end of the line, default value 100.\n\t\t\t\ty2: 100\n\t\t\t},\n\t\t\tdefaultImage: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default Image prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is an image, value 'image'.\n\t\t\t\ttype: \"image\",\n\t\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tThe X coordinate of the image's position, default value 0.\n\t\t\t\tx: 0,\n\t\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tThe Y coordinate of the image's position, default value 0.\n\t\t\t\ty: 0,\n\t\n\t\t\t\t// width: Number\n\t\t\t\t//\t\tThe width of the image, default value 0.\n\t\t\t\twidth: 0,\n\t\n\t\t\t\t// height: Number\n\t\t\t\t//\t\tThe height of the image, default value 0.\n\t\t\t\theight: 0,\n\t\n\t\t\t\t// src: String\n\t\t\t\t//\t\tThe src url of the image, defaults to empty string.\n\t\t\t\tsrc: \"\"\n\t\t\t},\n\t\t\tdefaultText: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default Text prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this is a Text shape, value 'text'.\n\t\t\t\ttype: \"text\",\n\t\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tThe X coordinate of the text position, default value 0.\n\t\t\t\tx: 0,\n\t\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tThe Y coordinate of the text position, default value 0.\n\t\t\t\ty: 0,\n\t\n\t\t\t\t// text: String\n\t\t\t\t//\t\tThe text to be displayed, default value empty string.\n\t\t\t\ttext: \"\",\n\t\n\t\t\t\t// align:\tString\n\t\t\t\t//\t\tThe horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.\n\t\t\t\talign: \"start\",\n\t\n\t\t\t\t// decoration: String\n\t\t\t\t//\t\tThe text decoration , one of 'none', ... . Default value 'none'.\n\t\t\t\tdecoration: \"none\",\n\t\n\t\t\t\t// rotated: Boolean\n\t\t\t\t//\t\tWhether the text is rotated, boolean default value false.\n\t\t\t\trotated: false,\n\t\n\t\t\t\t// kerning: Boolean\n\t\t\t\t//\t\tWhether kerning is used on the text, boolean default value true.\n\t\t\t\tkerning: true\n\t\t\t},\n\t\t\tdefaultTextPath: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDefines the default TextPath prototype.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this is a TextPath, value 'textpath'.\n\t\t\t\ttype: \"textpath\",\n\t\n\t\t\t\t// text: String\n\t\t\t\t//\t\tThe text to be displayed, default value empty string.\n\t\t\t\ttext: \"\",\n\t\n\t\t\t\t// align: String\n\t\t\t\t//\t\tThe horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.\n\t\t\t\talign: \"start\",\n\t\n\t\t\t\t// decoration: String\n\t\t\t\t//\t\tThe text decoration , one of 'none', ... . Default value 'none'.\n\t\t\t\tdecoration: \"none\",\n\t\n\t\t\t\t// rotated: Boolean\n\t\t\t\t//\t\tWhether the text is rotated, boolean default value false.\n\t\t\t\trotated: false,\n\t\n\t\t\t\t// kerning: Boolean\n\t\t\t\t//\t\tWhether kerning is used on the text, boolean default value true.\n\t\t\t\tkerning: true\n\t\t\t},\n\t\n\t\t\t// default stylistic attributes\n\t\t\tdefaultStroke: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tA stroke defines stylistic properties that are used when drawing a path.\n\t\t\t\t//\t\tThis object defines the default Stroke prototype.\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a type of Stroke, value 'stroke'.\n\t\t\t\ttype: \"stroke\",\n\t\n\t\t\t\t// color: String\n\t\t\t\t//\t\tThe color of the stroke, default value 'black'.\n\t\t\t\tcolor: \"black\",\n\t\n\t\t\t\t// style: String\n\t\t\t\t//\t\tThe style of the stroke, one of 'solid', ... . Default value 'solid'.\n\t\t\t\tstyle: \"solid\",\n\t\n\t\t\t\t// width: Number\n\t\t\t\t//\t\tThe width of a stroke, default value 1.\n\t\t\t\twidth: 1,\n\t\n\t\t\t\t// cap: String\n\t\t\t\t//\t\tThe endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.\n\t\t\t\tcap: \"butt\",\n\t\n\t\t\t\t// join: Number\n\t\t\t\t//\t\tThe join style to use when combining path segments. Default value 4.\n\t\t\t\tjoin: 4\n\t\t\t},\n\t\t\tdefaultLinearGradient: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn object defining the default stylistic properties used for Linear Gradient fills.\n\t\t\t\t//\t\tLinear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a Linear Gradient, value 'linear'\n\t\t\t\ttype: \"linear\",\n\t\n\t\t\t\t// x1: Number\n\t\t\t\t//\t\tThe X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\t\t\tx1: 0,\n\t\n\t\t\t\t// y1: Number\n\t\t\t\t//\t\tThe Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\t\t\ty1: 0,\n\t\n\t\t\t\t// x2: Number\n\t\t\t\t//\t\tThe X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\t\t\tx2: 100,\n\t\n\t\t\t\t// y2: Number\n\t\t\t\t//\t\tThe Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\t\t\ty2: 100,\n\t\n\t\t\t\t// colors: Array\n\t\t\t\t//\t\tAn array of colors at given offsets (from the start of the line).  The start of the line is\n\t\t\t\t//\t\tdefined at offest 0 with the end of the line at offset 1.\n\t\t\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\t\t\tcolors: [\n\t\t\t\t\t{ offset: 0, color: \"black\" }, { offset: 1, color: \"white\" }\n\t\t\t\t]\n\t\t\t},\n\t\t\tdefaultRadialGradient: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn object specifying the default properties for RadialGradients using in fills patterns.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this is a RadialGradient, value 'radial'\n\t\t\t\ttype: \"radial\",\n\t\n\t\t\t\t// cx: Number\n\t\t\t\t//\t\tThe X coordinate of the center of the radial gradient, default value 0.\n\t\t\t\tcx: 0,\n\t\n\t\t\t\t// cy: Number\n\t\t\t\t//\t\tThe Y coordinate of the center of the radial gradient, default value 0.\n\t\t\t\tcy: 0,\n\t\n\t\t\t\t// r: Number\n\t\t\t\t//\t\tThe radius to the end of the radial gradient, default value 100.\n\t\t\t\tr: 100,\n\t\n\t\t\t\t// colors: Array\n\t\t\t\t//\t\tAn array of colors at given offsets (from the center of the radial gradient).\n\t\t\t\t//\t\tThe center is defined at offest 0 with the outer edge of the gradient at offset 1.\n\t\t\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\t\t\tcolors: [\n\t\t\t\t\t{ offset: 0, color: \"black\" }, { offset: 1, color: \"white\" }\n\t\t\t\t]\n\t\t\t},\n\t\t\tdefaultPattern: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn object specifying the default properties for a Pattern using in fill operations.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a Pattern, value 'pattern'.\n\t\t\t\ttype: \"pattern\",\n\t\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tThe X coordinate of the position of the pattern, default value is 0.\n\t\t\t\tx: 0,\n\t\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tThe Y coordinate of the position of the pattern, default value is 0.\n\t\t\t\ty: 0,\n\t\n\t\t\t\t// width: Number\n\t\t\t\t//\t\tThe width of the pattern image, default value is 0.\n\t\t\t\twidth: 0,\n\t\n\t\t\t\t// height: Number\n\t\t\t\t//\t\tThe height of the pattern image, default value is 0.\n\t\t\t\theight: 0,\n\t\n\t\t\t\t// src: String\n\t\t\t\t//\t\tA url specifying the image to use for the pattern.\n\t\t\t\tsrc: \"\"\n\t\t\t},\n\t\t\tdefaultFont: {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn object specifying the default properties for a Font used in text operations.\n\t\n\t\t\t\t// type: String\n\t\t\t\t//\t\tSpecifies this object is a Font, value 'font'.\n\t\t\t\ttype: \"font\",\n\t\n\t\t\t\t// style: String\n\t\t\t\t//\t\tThe font style, one of 'normal', 'bold', default value 'normal'.\n\t\t\t\tstyle: \"normal\",\n\t\n\t\t\t\t// variant: String\n\t\t\t\t//\t\tThe font variant, one of 'normal', ... , default value 'normal'.\n\t\t\t\tvariant: \"normal\",\n\t\n\t\t\t\t// weight: String\n\t\t\t\t//\t\tThe font weight, one of 'normal', ..., default value 'normal'.\n\t\t\t\tweight: \"normal\",\n\t\n\t\t\t\t// size: String\n\t\t\t\t//\t\tThe font size (including units), default value '10pt'.\n\t\t\t\tsize: \"10pt\",\n\t\n\t\t\t\t// family: String\n\t\t\t\t//\t\tThe font family, one of 'serif', 'sanserif', ..., default value 'serif'.\n\t\t\t\tfamily: \"serif\"\n\t\t\t},\n\t\n\t\t\tgetDefault: (function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns a function used to access default memoized prototype objects (see them defined above).\n\t\t\t\tvar typeCtorCache = {};\n\t\t\t\t// a memoized delegate()\n\t\t\t\treturn function(/*String*/ type){\n\t\t\t\t\tvar t = typeCtorCache[type];\n\t\t\t\t\tif(t){\n\t\t\t\t\t\treturn new t();\n\t\t\t\t\t}\n\t\t\t\t\tt = typeCtorCache[type] = new Function();\n\t\t\t\t\tt.prototype = g[ \"default\" + type ];\n\t\t\t\t\treturn new t();\n\t\t\t\t}\n\t\t\t})(),\n\t\n\t\t\tnormalizeColor: function(/*dojo/Color|Array|string|Object*/ color){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts any legal color representation to normalized\n\t\t\t\t//\t\tdojo/Color object\n\t\t\t\t// color:\n\t\t\t\t//\t\tA color representation.\n\t\t\t\treturn (color instanceof Color) ? color : new Color(color); // dojo/Color\n\t\t\t},\n\t\t\tnormalizeParameters: function(existed, update){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tupdates an existing object with properties from an 'update'\n\t\t\t\t//\t\tobject\n\t\t\t\t// existed: Object\n\t\t\t\t//\t\tthe target object to be updated\n\t\t\t\t// update: Object\n\t\t\t\t//\t\tthe 'update' object, whose properties will be used to update\n\t\t\t\t//\t\tthe existed object\n\t\t\t\tvar x;\n\t\t\t\tif(update){\n\t\t\t\t\tvar empty = {};\n\t\t\t\t\tfor(x in existed){\n\t\t\t\t\t\tif(x in update && !(x in empty)){\n\t\t\t\t\t\t\texisted[x] = update[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn existed;\t// Object\n\t\t\t},\n\t\t\tmakeParameters: function(defaults, update){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcopies the original object, and all copied properties from the\n\t\t\t\t//\t\t'update' object\n\t\t\t\t// defaults: Object\n\t\t\t\t//\t\tthe object to be cloned before updating\n\t\t\t\t// update: Object\n\t\t\t\t//\t\tthe object, which properties are to be cloned during updating\n\t\t\t\t// returns: Object\n\t\t\t\t//      new object with new and default properties\n\t\t\t\tvar i = null;\n\t\t\t\tif(!update){\n\t\t\t\t\t// return dojo.clone(defaults);\n\t\t\t\t\treturn lang.delegate(defaults);\n\t\t\t\t}\n\t\t\t\tvar result = {};\n\t\t\t\tfor(i in defaults){\n\t\t\t\t\tif(!(i in result)){\n\t\t\t\t\t\tresult[i] = lang.clone((i in update) ? update[i] : defaults[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result; // Object\n\t\t\t},\n\t\t\tformatNumber: function(x, addSpace){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts a number to a string using a fixed notation\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tnumber to be converted\n\t\t\t\t// addSpace: Boolean\n\t\t\t\t//\t\twhether to add a space before a positive number\n\t\t\t\t// returns: String\n\t\t\t\t//      the formatted value\n\t\t\t\tvar val = x.toString();\n\t\t\t\tif(val.indexOf(\"e\") >= 0){\n\t\t\t\t\tval = x.toFixed(4);\n\t\t\t\t}else{\n\t\t\t\t\tvar point = val.indexOf(\".\");\n\t\t\t\t\tif(point >= 0 && val.length - point > 5){\n\t\t\t\t\t\tval = x.toFixed(4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x < 0){\n\t\t\t\t\treturn val; // String\n\t\t\t\t}\n\t\t\t\treturn addSpace ? \" \" + val : val; // String\n\t\t\t},\n\t\t\t// font operations\n\t\t\tmakeFontString: function(font){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts a font object to a CSS font string\n\t\t\t\t// font: Object\n\t\t\t\t//\t\tfont object (see dojox/gfx.defaultFont)\n\t\t\t\treturn font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \" \" + font.family; // Object\n\t\t\t},\n\t\t\tsplitFontString: function(str){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts a CSS font string to a font object\n\t\t\t\t// description:\n\t\t\t\t//\t\tConverts a CSS font string to a gfx font object. The CSS font\n\t\t\t\t//\t\tstring components should follow the W3C specified order\n\t\t\t\t//\t\t(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):\n\t\t\t\t//\t\tstyle, variant, weight, size, optional line height (will be\n\t\t\t\t//\t\tignored), and family. Note that the Font.size attribute is limited to numeric CSS length.\n\t\t\t\t// str: String\n\t\t\t\t//\t\ta CSS font string.\n\t\t\t\t// returns: Object\n\t\t\t\t//      object in dojox/gfx.defaultFont format\n\t\t\t\tvar font = g.getDefault(\"Font\");\n\t\t\t\tvar t = str.split(/\\s+/);\n\t\t\t\tdo{\n\t\t\t\t\tif(t.length < 5){ break; }\n\t\t\t\t\tfont.style   = t[0];\n\t\t\t\t\tfont.variant = t[1];\n\t\t\t\t\tfont.weight  = t[2];\n\t\t\t\t\tvar i = t[3].indexOf(\"/\");\n\t\t\t\t\tfont.size = i < 0 ? t[3] : t[3].substring(0, i);\n\t\t\t\t\tvar j = 4;\n\t\t\t\t\tif(i < 0){\n\t\t\t\t\t\tif(t[4] == \"/\"){\n\t\t\t\t\t\t\tj = 6;\n\t\t\t\t\t\t}else if(t[4].charAt(0) == \"/\"){\n\t\t\t\t\t\t\tj = 5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j < t.length){\n\t\t\t\t\t\tfont.family = t.slice(j).join(\" \");\n\t\t\t\t\t}\n\t\t\t\t}while(false);\n\t\t\t\treturn font;\t// Object\n\t\t\t},\n\t\t\t// length operations\n\t\n\t\t\t// cm_in_pt: Number\n\t\t\t//\t\tpoints per centimeter (constant)\n\t\t\tcm_in_pt: 72 / 2.54,\n\t\n\t\t\t// mm_in_pt: Number\n\t\t\t//\t\tpoints per millimeter (constant)\n\t\t\tmm_in_pt: 7.2 / 2.54,\n\t\n\t\t\tpx_in_pt: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the current number of pixels per point.\n\t\t\t\treturn g._base._getCachedFontMeasurements()[\"12pt\"] / 12;\t// Number\n\t\t\t},\n\t\n\t\t\tpt2px: function(len){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts points to pixels\n\t\t\t\t// len: Number\n\t\t\t\t//\t\ta value in points\n\t\t\t\treturn len * g.px_in_pt();\t// Number\n\t\t\t},\n\t\n\t\t\tpx2pt: function(len){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts pixels to points\n\t\t\t\t// len: Number\n\t\t\t\t//\t\ta value in pixels\n\t\t\t\treturn len / g.px_in_pt();\t// Number\n\t\t\t},\n\t\n\t\t\tnormalizedLength: function(len) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts any length value to pixels\n\t\t\t\t// len: String\n\t\t\t\t//\t\ta length, e.g., '12pc'\n\t\t\t\t// returns: Number\n\t\t\t\t//      pixels\n\t\t\t\tif(len.length === 0){ return 0; }\n\t\t\t\tif(len.length > 2){\n\t\t\t\t\tvar px_in_pt = g.px_in_pt();\n\t\t\t\t\tvar val = parseFloat(len);\n\t\t\t\t\tswitch(len.slice(-2)){\n\t\t\t\t\t\tcase \"px\": return val;\n\t\t\t\t\t\tcase \"pt\": return val * px_in_pt;\n\t\t\t\t\t\tcase \"in\": return val * 72 * px_in_pt;\n\t\t\t\t\t\tcase \"pc\": return val * 12 * px_in_pt;\n\t\t\t\t\t\tcase \"mm\": return val * g.mm_in_pt * px_in_pt;\n\t\t\t\t\t\tcase \"cm\": return val * g.cm_in_pt * px_in_pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn parseFloat(len);\t// Number\n\t\t\t},\n\t\n\t\t\t// pathVmlRegExp: RegExp\n\t\t\t//\t\ta constant regular expression used to split a SVG/VML path into primitive components\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tpathVmlRegExp: /([A-Za-z]+)|(\\d+(\\.\\d+)?)|(\\.\\d+)|(-\\d+(\\.\\d+)?)|(-\\.\\d+)/g,\n\t\n\t\t\t// pathVmlRegExp: RegExp\n\t\t\t//\t\ta constant regular expression used to split a SVG/VML path into primitive components\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tpathSvgRegExp: /([A-DF-Za-df-z])|([-+]?\\d*[.]?\\d+(?:[eE][-+]?\\d+)?)/g,\n\t\n\t\t\tequalSources: function(a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcompares event sources, returns true if they are equal\n\t\t\t\t// a: Object\n\t\t\t\t//\t\tfirst event source\n\t\t\t\t// b: Object\n\t\t\t\t//\t\tevent source to compare against a\n\t\t\t\t// returns: Boolean\n\t\t\t\t//      true, if objects are truthy and the same\n\t\t\t\treturn a && b && a === b;\n\t\t\t},\n\t\n\t\t\tswitchTo: function(/*String|Object*/ renderer){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tswitch the graphics implementation to the specified renderer.\n\t\t\t\t// renderer:\n\t\t\t\t//\t\tEither the string name of a renderer (eg. 'canvas', 'svg, ...) or the renderer\n\t\t\t\t//\t\tobject to switch to.\n\t\t\t\tvar ns = typeof renderer == \"string\" ? g[renderer] : renderer;\n\t\t\t\tif(ns){\n\t\t\t\t\t// If more options are added, update the docblock at the end of shape.js!\n\t\t\t\t\tarr.forEach([\"Group\", \"Rect\", \"Ellipse\", \"Circle\", \"Line\",\n\t\t\t\t\t\t\t\"Polyline\", \"Image\", \"Text\", \"Path\", \"TextPath\",\n\t\t\t\t\t\t\t\"Surface\", \"createSurface\", \"fixTarget\"], function(name){\n\t\t\t\t\t\tg[name] = ns[name];\n\t\t\t\t\t});\n\t\t\t\t\tif(typeof renderer == \"string\"){\n\t\t\t\t\t\tg.renderer = renderer;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tarr.some([\"svg\",\"vml\",\"canvas\",\"canvasWithEvents\",\"silverlight\"], function(r){\n\t\t\t\t\t\t\treturn (g.renderer = g[r] && g[r].Surface === g.Surface ? r : null);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t/*=====\n\t\t\tg.createSurface = function(parentNode, width, height){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a surface\n\t\t\t\t// parentNode: Node\n\t\t\t\t//\t\ta parent node\n\t\t\t\t// width: String|Number\n\t\t\t\t//\t\twidth of surface, e.g., \"100px\" or 100\n\t\t\t\t// height: String|Number\n\t\t\t\t//\t\theight of surface, e.g., \"100px\" or 100\n\t\t\t\t// returns: dojox/gfx.Surface\n\t\t\t\t//     newly created surface\n\t\t\t};\n\t\t\tg.fixTarget = function(){\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t};\n\t\t=====*/\n\t\t\n\t\treturn g; // defaults object api\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 168 */\n/*!******************************!*\\\n  !*** ../dojox/gfx/canvas.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/window */ 15), __webpack_require__(/*! dojo/dom-geometry */ 36),\n\t\t\t__webpack_require__(/*! dojo/dom */ 14), __webpack_require__(/*! ./shape */ 169), __webpack_require__(/*! ./path */ 171), __webpack_require__(/*! ./arc */ 172), __webpack_require__(/*! ./matrix */ 170), __webpack_require__(/*! ./decompose */ 173), __webpack_require__(/*! ./bezierutils */ 174)], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang, arr, declare, win, domGeom, dom, gs, pathLib, ga, m, decompose, bezierUtils ){\n\t\tvar canvas = g.canvas = {\n\t\t\t// summary:\n\t\t\t//\t\tThis the graphics rendering bridge for W3C Canvas compliant browsers.\n\t\t\t//\t\tSince Canvas is an immediate mode graphics api, with no object graph or\n\t\t\t//\t\teventing capabilities, use of this module alone will only add in drawing support.\n\t\t\t//\t\tThe additional module, canvasWithEvents extends this module with additional support\n\t\t\t//\t\tfor handling events on Canvas.  By default, the support for events is now included\n\t\t\t//\t\thowever, if only drawing capabilities are needed, canvas event module can be disabled\n\t\t\t//\t\tusing the dojoConfig option, canvasEvents:true|false.\n\t\t\t//\t\tThe id of the Canvas renderer is 'canvas'.  This id can be used when switch Dojo's\n\t\t\t//\t\tgraphics context between renderer implementations.  See dojox/gfx/_base.switchRenderer\n\t\t\t//\t\tAPI.\n\t\t};\n\t\tvar pattrnbuffer = null,\n\t\t\tmp = m.multiplyPoint,\n\t\t\tpi = Math.PI,\n\t\t\ttwoPI = 2 * pi,\n\t\t\thalfPI = pi /2,\n\t\t\textend = lang.extend;\n\t\n\t\tif(win.global.CanvasRenderingContext2D){\n\t\t\tvar ctx2d = win.doc.createElement(\"canvas\").getContext(\"2d\");\n\t\t\tvar hasNativeDash = typeof ctx2d.setLineDash == \"function\";\n\t\t\tvar hasFillText = typeof ctx2d.fillText == \"function\";\n\t\t}\n\t\n\t\tvar dasharray = {\n\t\t\tsolid:\t\t\t\t\"none\",\n\t\t\tshortdash:\t\t\t[4, 1],\n\t\t\tshortdot:\t\t\t[1, 1],\n\t\t\tshortdashdot:\t\t[4, 1, 1, 1],\n\t\t\tshortdashdotdot:\t[4, 1, 1, 1, 1, 1],\n\t\t\tdot:\t\t\t\t[1, 3],\n\t\t\tdash:\t\t\t\t[4, 3],\n\t\t\tlongdash:\t\t\t[8, 3],\n\t\t\tdashdot:\t\t\t[4, 3, 1, 3],\n\t\t\tlongdashdot:\t\t[8, 3, 1, 3],\n\t\t\tlongdashdotdot:\t\t[8, 3, 1, 3, 1, 3]\n\t\t};\n\t\n\t\tfunction drawDashedArc(/*CanvasRenderingContext2D*/ctx, /*Number[]*/dash,  /*int*/cx,  /*int*/cy,  /*int*/r, /*Number*/sa, /*Number*/ea, /*Boolean*/ccw, /*Boolean?*/apply, prevResidue){\n\t\t\tvar residue, angle, l = dash.length, i= 0;\n\t\t\t// if there's a previous dash residue from the previous arc, start with it.\n\t\t\tif(prevResidue){\n\t\t\t\tangle = prevResidue.l/r;\n\t\t\t\ti = prevResidue.i;\n\t\t\t}else{\n\t\t\t\tangle = dash[0]/r;\n\t\t\t}\n\t\t\twhile(sa < ea){\n\t\t\t\t// if the dash segment length is longer than what remains to stroke, keep it for next arc. (aka residue)\n\t\t\t\tif(sa+angle > ea){\n\t\t\t\t\tresidue = {l: (sa+angle-ea)*r, i: i};\n\t\t\t\t\tangle = ea-sa;\n\t\t\t\t}\n\t\t\t\tif(!(i%2)){\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(cx, cy, r, sa, sa+angle, ccw);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t}\n\t\t\t\tsa += angle;\n\t\t\t\t++i;\n\t\t\t\tangle = dash[i%l]/r;\n\t\t\t}\n\t\t\treturn residue;\n\t\t}\n\t\n\t\tfunction splitToDashedBezier(/*Number[]*/points, /*Number[]*/dashArray, /*Number[]*/newPoints, /*Object*/prevResidue){\n\t\t\tvar residue = 0, t = 0, dash, i = 0;\n\t\t\tif(prevResidue){\n\t\t\t\tdash = prevResidue.l;\n\t\t\t\ti = prevResidue.i;\n\t\t\t}else{\n\t\t\t\tdash = dashArray[0];\n\t\t\t}\n\t\t\twhile(t<1){\n\t\t\t\t// get the 't' corresponding to the given dash value.\n\t\t\t\tt = bezierUtils.tAtLength(points, dash);\n\t\t\t\tif(t==1){\n\t\t\t\t\tvar rl = bezierUtils.computeLength(points);\n\t\t\t\t\tresidue = {l: dash-rl, i: i};\n\t\t\t\t}\n\t\t\t\t// split bezier at t: left part is the \"dash\" curve, right part is the remaining bezier points\n\t\t\t\tvar curves = bezierUtils.splitBezierAtT(points, t);\n\t\t\t\tif(!(i%2)){\n\t\t\t\t\t// only keep the \"dash\" curve\n\t\t\t\t\tnewPoints.push(curves[0]);\n\t\t\t\t}\n\t\t\t\tpoints = curves[1];\n\t\t\t\t++i;\n\t\t\t\tdash = dashArray[i%dashArray.length];\n\t\t\t}\n\t\t\treturn residue;\n\t\t}\n\t\n\t\tfunction toDashedCurveTo(/*Array||CanvasRenderingContext2D*/ctx, /*shape.Path*/shape, /*Number[]*/points, /*Object*/prevResidue){\n\t\t\t// summary:\n\t\t\t//\t\tBuilds a set of bezier (cubic || quadratic)curveTo' canvas instructions that represents a dashed stroke of the specified bezier geometry.\n\t\n\t\t\tvar pts = [shape.last.x, shape.last.y].concat(points),\n\t\t\t\tquadratic = points.length === 4, ctx2d = !(ctx instanceof Array),\n\t\t\t\tapi = quadratic ? \"quadraticCurveTo\" : \"bezierCurveTo\",\n\t\t\t\tcurves = [];\n\t\t\tvar residue = splitToDashedBezier(pts, shape.canvasDash, curves, prevResidue);\n\t\t\tfor(var c=0; c<curves.length;++c){\n\t\t\t\tvar curve = curves[c];\n\t\t\t\tif(ctx2d){\n\t\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\t\t\tctx[api].apply(ctx, curve.slice(2));\n\t\t\t\t}else{\n\t\t\t\t\tctx.push(\"moveTo\", [curve[0], curve[1]]);\n\t\t\t\t\tctx.push(api, curve.slice(2));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn residue;\n\t\t}\n\t\n\t\tfunction toDashedLineTo(/*Array||CanvasRenderingContext2D*/ctx, /*shape.Shape*/shape, /*int*/x1, /*int*/y1, /*int*/x2, /*int*/y2, /*Object*/prevResidue){\n\t\t\t// summary:\n\t\t\t//\t\tBuilds a set of moveTo/lineTo' canvas instructions that represents a dashed stroke of the specified line geometry.\n\t\n\t\t\tvar residue = 0, r = 0, dal = 0, tlength = bezierUtils.distance(x1, y1, x2, y2), i = 0, dash = shape.canvasDash,\n\t\t\t\tprevx = x1, prevy = y1, x, y, ctx2d = !(ctx instanceof Array);\n\t\t\tif(prevResidue){\n\t\t\t\tdal=prevResidue.l;\n\t\t\t\ti = prevResidue.i;\n\t\t\t}else{\n\t\t\t\tdal += dash[0];\n\t\t\t}\n\t\t\twhile(Math.abs(1-r)>0.01){\n\t\t\t\tif(dal>tlength){\n\t\t\t\t\tresidue = {l:dal-tlength,i:i};\n\t\t\t\t\tdal=tlength;\n\t\t\t\t}\n\t\t\t\tr = dal/tlength;\n\t\t\t\tx = x1 + (x2-x1)*r;\n\t\t\t\ty = y1 + (y2-y1)*r;\n\t\t\t\tif(!(i++%2)){\n\t\t\t\t\tif(ctx2d){\n\t\t\t\t\t\tctx.moveTo(prevx, prevy);\n\t\t\t\t\t\tctx.lineTo(x, y);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tctx.push(\"moveTo\", [prevx, prevy]);\n\t\t\t\t\t\tctx.push(\"lineTo\", [x, y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevx = x;\n\t\t\t\tprevy = y;\n\t\t\t\tdal += dash[i%dash.length];\n\t\t\t}\n\t\t\treturn residue;\n\t\t}\n\t\n\t\tcanvas.Shape = declare(\"dojox.gfx.canvas.Shape\", gs.Shape, {\n\t\t\t_render: function(/* Object */ ctx){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trender the shape\n\t\t\t\tctx.save();\n\t\t\t\tthis._renderTransform(ctx);\n\t\t\t\tthis._renderClip(ctx);\n\t\t\t\tthis._renderShape(ctx);\n\t\t\t\tthis._renderFill(ctx, true);\n\t\t\t\tthis._renderStroke(ctx, true);\n\t\t\t\tctx.restore();\n\t\t\t},\n\t\t\t_renderClip: function(ctx){\n\t\t\t\tif (this.canvasClip){\n\t\t\t\t\tthis.canvasClip.render(ctx);\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderTransform: function(/* Object */ ctx){\n\t\t\t\tif(\"canvasTransform\" in this){\n\t\t\t\t\tvar t = this.canvasTransform;\n\t\t\t\t\tctx.translate(t.dx, t.dy);\n\t\t\t\t\tctx.rotate(t.angle2);\n\t\t\t\t\tctx.scale(t.sx, t.sy);\n\t\t\t\t\tctx.rotate(t.angle1);\n\t\t\t\t\t// The future implementation when vendors catch up with the spec:\n\t\t\t\t\t// var t = this.matrix;\n\t\t\t\t\t// ctx.transform(t.xx, t.yx, t.xy, t.yy, t.dx, t.dy);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\t// nothing\n\t\t\t},\n\t\t\t_renderFill: function(/* Object */ ctx, /* Boolean */ apply){\n\t\t\t\tif(\"canvasFill\" in this){\n\t\t\t\t\tvar fs = this.fillStyle;\n\t\t\t\t\tif(\"canvasFillImage\" in this){\n\t\t\t\t\t\tvar w = fs.width, h = fs.height,\n\t\t\t\t\t\t\tiw = this.canvasFillImage.width, ih = this.canvasFillImage.height,\n\t\t\t\t\t\t\t// let's match the svg default behavior wrt. aspect ratio: xMidYMid meet\n\t\t\t\t\t\t\tsx = w == iw ? 1 : w / iw,\n\t\t\t\t\t\t\tsy = h == ih ? 1 : h / ih,\n\t\t\t\t\t\t\ts = Math.min(sx,sy), //meet->math.min , slice->math.max\n\t\t\t\t\t\t\tdx = (w - s * iw)/2,\n\t\t\t\t\t\t\tdy = (h - s * ih)/2;\n\t\t\t\t\t\t// the buffer used to scaled the image\n\t\t\t\t\t\tpattrnbuffer.width = w; pattrnbuffer.height = h;\n\t\t\t\t\t\tvar copyctx = pattrnbuffer.getContext(\"2d\");\n\t\t\t\t\t\tcopyctx.clearRect(0, 0, w, h);\n\t\t\t\t\t\tcopyctx.drawImage(this.canvasFillImage, 0, 0, iw, ih, dx, dy, s*iw, s*ih);\n\t\t\t\t\t\tthis.canvasFill = ctx.createPattern(pattrnbuffer, \"repeat\");\n\t\t\t\t\t\tdelete this.canvasFillImage;\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillStyle = this.canvasFill;\n\t\t\t\t\tif(apply){\n\t\t\t\t\t\t// offset the pattern\n\t\t\t\t\t\tif (fs.type===\"pattern\" && (fs.x !== 0 || fs.y !== 0)) {\n\t\t\t\t\t\t\tctx.translate(fs.x,fs.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tctx.fillStyle = \"rgba(0,0,0,0.0)\";\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderStroke: function(/* Object */ ctx, /* Boolean */ apply){\n\t\t\t\tvar s = this.strokeStyle;\n\t\t\t\tif(s){\n\t\t\t\t\tctx.strokeStyle = s.color.toString();\n\t\t\t\t\tctx.lineWidth = s.width;\n\t\t\t\t\tctx.lineCap = s.cap;\n\t\t\t\t\tif(typeof s.join == \"number\"){\n\t\t\t\t\t\tctx.lineJoin = \"miter\";\n\t\t\t\t\t\tctx.miterLimit = s.join;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tctx.lineJoin = s.join;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.canvasDash){\n\t\t\t\t\t\tif(hasNativeDash){\n\t\t\t\t\t\t\tctx.setLineDash(this.canvasDash);\n\t\t\t\t\t\t\tif(apply){ ctx.stroke(); }\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthis._renderDashedStroke(ctx, apply);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(apply){ ctx.stroke(); }\n\t\t\t\t\t}\n\t\t\t\t}else if(!apply){\n\t\t\t\t\tctx.strokeStyle = \"rgba(0,0,0,0.0)\";\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderDashedStroke: function(ctx, apply){},\n\t\n\t\t\t// events are not implemented\n\t\t\tgetEventSource: function(){ return null; },\n\t\t\ton:\t\t\t\tfunction(){},\n\t\t\tconnect:\t\tfunction(){},\n\t\t\tdisconnect:\t\tfunction(){},\n\t\n\t\t\tcanvasClip:null,\n\t\t\tsetClip: function(/*Object*/clip){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tvar clipType = clip ? \"width\" in clip ? \"rect\" :\n\t\t\t\t\t\t\t\t\"cx\" in clip ? \"ellipse\" :\n\t\t\t\t\t\t\t\t\"points\" in clip ? \"polyline\" : \"d\" in clip ? \"path\" : null : null;\n\t\t\t\tif(clip && !clipType){\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tthis.canvasClip = clip ? makeClip(clipType, clip) : null;\n\t\t\t\tif(this.parent){this.parent._makeDirty();}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t});\n\t\n\t\tvar makeClip = function(clipType, geometry){\n\t\t\tswitch(clipType){\n\t\t\t\tcase \"ellipse\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcanvasEllipse: makeEllipse({shape:geometry}),\n\t\t\t\t\t\trender: function(ctx){return canvas.Ellipse.prototype._renderShape.call(this, ctx);}\n\t\t\t\t\t};\n\t\t\t\tcase \"rect\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tshape: lang.delegate(geometry,{r:0}),\n\t\t\t\t\t\trender: function(ctx){return canvas.Rect.prototype._renderShape.call(this, ctx);}\n\t\t\t\t\t};\n\t\t\t\tcase \"path\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcanvasPath: makeClipPath(geometry),\n\t\t\t\t\t\trender: function(ctx){this.canvasPath._renderShape(ctx);}\n\t\t\t\t\t};\n\t\t\t\tcase \"polyline\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcanvasPolyline: geometry.points,\n\t\t\t\t\t\trender: function(ctx){return canvas.Polyline.prototype._renderShape.call(this, ctx);}\n\t\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\tvar makeClipPath = function(geo){\n\t\t\tvar p = new dojox.gfx.canvas.Path();\n\t\t\tp.canvasPath = [];\n\t\t\tp._setPath(geo.d);\n\t\t\treturn p;\n\t\t};\n\t\n\t\tvar modifyMethod = function(shape, method, extra){\n\t\t\tvar old = shape.prototype[method];\n\t\t\tshape.prototype[method] = extra ?\n\t\t\t\tfunction(){\n\t\t\t\t\tif(this.parent){this.parent._makeDirty();}\n\t\t\t\t\told.apply(this, arguments);\n\t\t\t\t\textra.call(this);\n\t\t\t\t\treturn this;\n\t\t\t\t} :\n\t\t\t\tfunction(){\n\t\t\t\t\tif(this.parent){this.parent._makeDirty();}\n\t\t\t\t\treturn old.apply(this, arguments);\n\t\t\t\t};\n\t\t};\n\t\n\t\tmodifyMethod(canvas.Shape, \"setTransform\",\n\t\t\tfunction(){\n\t\t\t\t// prepare Canvas-specific structures\n\t\t\t\tif(this.matrix){\n\t\t\t\t\tthis.canvasTransform = g.decompose(this.matrix);\n\t\t\t\t}else{\n\t\t\t\t\tdelete this.canvasTransform;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\tmodifyMethod(canvas.Shape, \"setFill\",\n\t\t\tfunction(){\n\t\t\t\t// prepare Canvas-specific structures\n\t\t\t\tvar fs = this.fillStyle, f;\n\t\t\t\tif(fs){\n\t\t\t\t\tif(typeof(fs) == \"object\" && \"type\" in fs){\n\t\t\t\t\t\tvar ctx = this.surface.rawNode.getContext(\"2d\");\n\t\t\t\t\t\tswitch(fs.type){\n\t\t\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\t\t\tf = fs.type == \"linear\" ?\n\t\t\t\t\t\t\t\t\tctx.createLinearGradient(fs.x1, fs.y1, fs.x2, fs.y2) :\n\t\t\t\t\t\t\t\t\tctx.createRadialGradient(fs.cx, fs.cy, 0, fs.cx, fs.cy, fs.r);\n\t\t\t\t\t\t\t\tarr.forEach(fs.colors, function(step){\n\t\t\t\t\t\t\t\t\tf.addColorStop(step.offset, g.normalizeColor(step.color).toString());\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\t\t\tif (!pattrnbuffer) {\n\t\t\t\t\t\t\t\t\tpattrnbuffer = document.createElement(\"canvas\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// no need to scale the image since the canvas.createPattern uses\n\t\t\t\t\t\t\t\t// the original image data and not the scaled ones (see spec.)\n\t\t\t\t\t\t\t\t// the scaling needs to be done at rendering time in a context buffer\n\t\t\t\t\t\t\t\tvar img =new Image();\n\t\t\t\t\t\t\t\tthis.surface.downloadImage(img, fs.src);\n\t\t\t\t\t\t\t\tthis.canvasFillImage = img;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// Set fill color using CSS RGBA func style\n\t\t\t\t\t\tf = fs.toString();\n\t\t\t\t\t}\n\t\t\t\t\tthis.canvasFill = f;\n\t\t\t\t}else{\n\t\t\t\t\tdelete this.canvasFill;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\tmodifyMethod(canvas.Shape, \"setStroke\",\n\t\t\tfunction(){\n\t\t\t\tvar st = this.strokeStyle;\n\t\t\t\tif(st){\n\t\t\t\t\tvar da = this.strokeStyle.style.toLowerCase();\n\t\t\t\t\tif(da in dasharray){\n\t\t\t\t\t\tda = dasharray[da];\n\t\t\t\t\t}\n\t\t\t\t\tif(da instanceof Array){\n\t\t\t\t\t\tda = da.slice();\n\t\t\t\t\t\tthis.canvasDash = da;\n\t\t\t\t\t\tvar i;\n\t\t\t\t\t\tfor(i = 0; i < da.length; ++i){\n\t\t\t\t\t\t\tda[i] *= st.width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(st.cap != \"butt\"){\n\t\t\t\t\t\t\tfor(i = 0; i < da.length; i += 2){\n\t\t\t\t\t\t\t\tda[i] -= st.width;\n\t\t\t\t\t\t\t\tif(da[i] < 1){ da[i] = 1; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(i = 1; i < da.length; i += 2){\n\t\t\t\t\t\t\t\tda[i] += st.width;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdelete this.canvasDash;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdelete this.canvasDash;\n\t\t\t\t}\n\t\t\t\tthis._needsDash = !hasNativeDash && !!this.canvasDash;\n\t\t\t});\n\t\n\t\tmodifyMethod(canvas.Shape, \"setShape\");\n\t\n\t\tcanvas.Group = declare(\"dojox.gfx.canvas.Group\", canvas.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta group shape (Canvas), which can be used\n\t\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\n\t\t\tconstructor: function(){\n\t\t\t\tgs.Container._init.call(this);\n\t\t\t},\n\t\t\t_render: function(/* Object */ ctx){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trender the group\n\t\t\t\tctx.save();\n\t\t\t\tthis._renderTransform(ctx);\n\t\t\t\tthis._renderClip(ctx);\n\t\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\t\tthis.children[i]._render(ctx);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t},\n\t\t\tdestroy: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReleases all internal resources owned by this shape. Once this method has been called,\n\t\t\t\t//\t\tthe instance is considered disposed and should not be used anymore.\n\t\n\t\t\t\t// don't call canvas impl to avoid makeDirty'\n\t\t\t\tgs.Container.clear.call(this, true);\n\t\t\t\t// avoid this.inherited\n\t\t\t\tcanvas.Shape.prototype.destroy.apply(this, arguments);\n\t\t\t}\n\t\t});\n\t\n\t\n\t\n\t\tcanvas.Rect = declare(\"dojox.gfx.canvas.Rect\", [canvas.Shape, gs.Rect], {\n\t\t\t// summary:\n\t\t\t//\t\ta rectangle shape (Canvas)\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar s = this.shape, r = Math.min(s.r, s.height / 2, s.width / 2),\n\t\t\t\t\txl = s.x, xr = xl + s.width, yt = s.y, yb = yt + s.height,\n\t\t\t\t\txl2 = xl + r, xr2 = xr - r, yt2 = yt + r, yb2 = yb - r;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(xl2, yt);\n\t\t\t\tif(r){\n\t\t\t\t\tctx.arc(xr2, yt2, r, -halfPI, 0, false);\n\t\t\t\t\tctx.arc(xr2, yb2, r, 0, halfPI, false);\n\t\t\t\t\tctx.arc(xl2, yb2, r, halfPI, pi, false);\n\t\t\t\t\tctx.arc(xl2, yt2, r, pi, pi + halfPI, false);\n\t\t\t\t}else{\n\t\t\t\t\tctx.lineTo(xr2, yt);\n\t\t\t\t\tctx.lineTo(xr, yb2);\n\t\t\t\t\tctx.lineTo(xl2, yb);\n\t\t\t\t\tctx.lineTo(xl, yt2);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t},\n\t\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\t\tvar s = this.shape, residue, r = Math.min(s.r, s.height / 2, s.width / 2),\n\t\t\t\t\txl = s.x, xr = xl + s.width, yt = s.y, yb = yt + s.height,\n\t\t\t\t\txl2 = xl + r, xr2 = xr - r, yt2 = yt + r, yb2 = yb - r;\n\t\t\t\tif(r){\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xl2, yt, xr2, yt);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t\tresidue = drawDashedArc(ctx, this.canvasDash, xr2, yt2, r, -halfPI, 0, false, apply, residue);\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xr, yt2, xr, yb2, residue);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t\tresidue = drawDashedArc(ctx, this.canvasDash, xr2, yb2, r, 0, halfPI, false, apply, residue);\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xr2, yb, xl2, yb, residue);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t\tresidue = drawDashedArc(ctx, this.canvasDash, xl2, yb2, r, halfPI, pi, false, apply, residue);\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xl, yb2, xl, yt2,residue);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t\tdrawDashedArc(ctx, this.canvasDash, xl2, yt2, r, pi, pi + halfPI, false, apply, residue);\n\t\t\t\t}else{\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xl2, yt, xr2, yt);\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xr2, yt, xr, yb2, residue);\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, xr, yb2, xl2, yb, residue);\n\t\t\t\t\ttoDashedLineTo(ctx, this, xl2, yb, xl, yt2, residue);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\tvar bezierCircle = [];\n\t\t(function(){\n\t\t\tvar u = ga.curvePI4;\n\t\t\tbezierCircle.push(u.s, u.c1, u.c2, u.e);\n\t\t\tfor(var a = 45; a < 360; a += 45){\n\t\t\t\tvar r = m.rotateg(a);\n\t\t\t\tbezierCircle.push(mp(r, u.c1), mp(r, u.c2), mp(r, u.e));\n\t\t\t}\n\t\t})();\n\t\n\t\tvar makeEllipse = function(shape){\n\t\t\t// prepare Canvas-specific structures\n\t\t\tvar t, c1, c2, r = [], s = shape.shape,\n\t\t\t\tM = m.normalize([m.translate(s.cx, s.cy), m.scale(s.rx, s.ry)]);\n\t\t\tt = mp(M, bezierCircle[0]);\n\t\t\tr.push([t.x, t.y]);\n\t\t\tfor(var i = 1; i < bezierCircle.length; i += 3){\n\t\t\t\tc1 = mp(M, bezierCircle[i]);\n\t\t\t\tc2 = mp(M, bezierCircle[i + 1]);\n\t\t\t\tt  = mp(M, bezierCircle[i + 2]);\n\t\t\t\tr.push([c1.x, c1.y, c2.x, c2.y, t.x, t.y]);\n\t\t\t}\n\t\t\tif(shape._needsDash){\n\t\t\t\tvar points = [], p1 = r[0];\n\t\t\t\tfor(i = 1; i < r.length; ++i){\n\t\t\t\t\tvar curves = [];\n\t\t\t\t\tsplitToDashedBezier(p1.concat(r[i]), shape.canvasDash, curves);\n\t\t\t\t\tp1 = [r[i][4],r[i][5]];\n\t\t\t\t\tpoints.push(curves);\n\t\t\t\t}\n\t\t\t\tshape._dashedPoints = points;\n\t\t\t}\n\t\t\treturn r;\n\t\t};\n\t\n\t\tcanvas.Ellipse = declare(\"dojox.gfx.canvas.Ellipse\", [canvas.Shape, gs.Ellipse], {\n\t\t\t// summary:\n\t\t\t//\t\tan ellipse shape (Canvas)\n\t\t\tsetShape: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tthis.canvasEllipse = makeEllipse(this);\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetStroke: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tif(!hasNativeDash){\n\t\t\t\t\tthis.canvasEllipse = makeEllipse(this);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar r = this.canvasEllipse, i;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo.apply(ctx, r[0]);\n\t\t\t\tfor(i = 1; i < r.length; ++i){\n\t\t\t\t\tctx.bezierCurveTo.apply(ctx, r[i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t},\n\t\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\t\tvar r = this._dashedPoints;\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor(var i = 0; i < r.length; ++i){\n\t\t\t\t\tvar curves = r[i];\n\t\t\t\t\tfor(var j=0;j<curves.length;++j){\n\t\t\t\t\t\tvar curve = curves[j];\n\t\t\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\t\t\t\tctx.bezierCurveTo(curve[2],curve[3],curve[4],curve[5],curve[6],curve[7]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t}\n\t\t});\n\t\n\t\tcanvas.Circle = declare(\"dojox.gfx.canvas.Circle\", [canvas.Shape, gs.Circle], {\n\t\t\t// summary:\n\t\t\t//\t\ta circle shape (Canvas)\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar s = this.shape;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(s.cx, s.cy, s.r, 0, twoPI, 1);\n\t\t\t},\n\t\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\t\tvar s = this.shape;\n\t\t\t\tvar startAngle = 0, angle, l = this.canvasDash.length; i=0;\n\t\t\t\twhile(startAngle < twoPI){\n\t\t\t\t\tangle = this.canvasDash[i%l]/s.r;\n\t\t\t\t\tif(!(i%2)){\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.arc(s.cx, s.cy, s.r, startAngle, startAngle+angle, 0);\n\t\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\tstartAngle+=angle;\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\tcanvas.Line = declare(\"dojox.gfx.canvas.Line\", [canvas.Shape, gs.Line], {\n\t\t\t// summary:\n\t\t\t//\t\ta line shape (Canvas)\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar s = this.shape;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(s.x1, s.y1);\n\t\t\t\tctx.lineTo(s.x2, s.y2);\n\t\t\t},\n\t\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\t\tvar s = this.shape;\n\t\t\t\tctx.beginPath();\n\t\t\t\ttoDashedLineTo(ctx, this, s.x1, s.y1, s.x2, s.y2);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t}\n\t\t});\n\t\n\t\tcanvas.Polyline = declare(\"dojox.gfx.canvas.Polyline\", [canvas.Shape, gs.Polyline], {\n\t\t\t// summary:\n\t\t\t//\t\ta polyline/polygon shape (Canvas)\n\t\t\tsetShape: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tvar p = this.shape.points, f = p[0], r, c, i;\n\t\t\t\tthis.bbox = null;\n\t\t\t\t// normalize this.shape.points as array of points: [{x,y}, {x,y}, ...]\n\t\t\t\tthis._normalizePoints();\n\t\t\t\t// after _normalizePoints, if shape.points was [x1,y1,x2,y2,..], shape.points references a new array\n\t\t\t\t// and p references the original points array\n\t\t\t\t// prepare Canvas-specific structures, if needed\n\t\t\t\tif(p.length){\n\t\t\t\t\tif(typeof f == \"number\"){ // already in the canvas format [x1,y1,x2,y2,...]\n\t\t\t\t\t\tr = p;\n\t\t\t\t\t}else{ // convert into canvas-specific format\n\t\t\t\t\t\tr = [];\n\t\t\t\t\t\tfor(i=0; i < p.length; ++i){\n\t\t\t\t\t\t\tc = p[i];\n\t\t\t\t\t\t\tr.push(c.x, c.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tr = [];\n\t\t\t\t}\n\t\t\t\tthis.canvasPolyline = r;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar p = this.canvasPolyline;\n\t\t\t\tif(p.length){\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(p[0], p[1]);\n\t\t\t\t\tfor(var i = 2; i < p.length; i += 2){\n\t\t\t\t\t\tctx.lineTo(p[i], p[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\t\tvar p = this.canvasPolyline, residue = 0;\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor(var i = 0; i < p.length; i += 2){\n\t\t\t\t\tresidue = toDashedLineTo(ctx, this, p[i], p[i + 1], p[i + 2], p[i + 3], residue);\n\t\t\t\t}\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t}\n\t\t});\n\t\n\t\tcanvas.Image = declare(\"dojox.gfx.canvas.Image\", [canvas.Shape, gs.Image], {\n\t\t\t// summary:\n\t\t\t//\t\tan image shape (Canvas)\n\t\t\tsetShape: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\t// prepare Canvas-specific structures\n\t\t\t\tvar img = new Image();\n\t\t\t\tthis.surface.downloadImage(img, this.shape.src);\n\t\t\t\tthis.canvasImage = img;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar s = this.shape;\n\t\t\t\tctx.drawImage(this.canvasImage, s.x, s.y, s.width, s.height);\n\t\t\t}\n\t\t});\n\t\n\t\tcanvas.Text = declare(\"dojox.gfx.canvas.Text\", [canvas.Shape, gs.Text], {\n\t\t\t_setFont:function(){\n\t\t\t\tif(this.fontStyle){\n\t\t\t\t\tthis.canvasFont = g.makeFontString(this.fontStyle);\n\t\t\t\t}else{\n\t\t\t\t\tdelete this.canvasFont;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tgetTextWidth: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tget the text width in pixels\n\t\t\t\tvar s = this.shape, w = 0, ctx;\n\t\t\t\tif(s.text){\n\t\t\t\t\tctx = this.surface.rawNode.getContext(\"2d\");\n\t\t\t\t\tctx.save();\n\t\t\t\t\tthis._renderTransform(ctx);\n\t\t\t\t\tthis._renderFill(ctx, false);\n\t\t\t\t\tthis._renderStroke(ctx, false);\n\t\t\t\t\tif (this.canvasFont)\n\t\t\t\t\t\tctx.font = this.canvasFont;\n\t\t\t\t\tw = ctx.measureText(s.text).width;\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t\treturn w;\n\t\t\t},\n\t\n\t\t\t// override to apply first fill and stroke (\n\t\t\t// the base implementation is for path-based shape that needs to first define the path then to fill/stroke it.\n\t\t\t// Here, we need the fillstyle or strokestyle to be set before calling fillText/strokeText.\n\t\t\t_render: function(/* Object */ctx){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trender the shape\n\t\t\t\t// ctx: Object\n\t\t\t\t//\t\tthe drawing context.\n\t\t\t\tctx.save();\n\t\t\t\tthis._renderTransform(ctx);\n\t\t\t\tthis._renderFill(ctx, false);\n\t\t\t\tthis._renderStroke(ctx, false);\n\t\t\t\tthis._renderShape(ctx);\n\t\t\t\tctx.restore();\n\t\t\t},\n\t\n\t\t\t_renderShape: function(ctx){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ta text shape (Canvas)\n\t\t\t\t// ctx: Object\n\t\t\t\t//\t\tthe drawing context.\n\t\t\t\tvar ta, s = this.shape;\n\t\t\t\tif(!s.text){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// text align\n\t\t\t\tta = s.align === 'middle' ? 'center' : s.align;\n\t\t\t\tctx.textAlign = ta;\n\t\t\t\tif(this.canvasFont){\n\t\t\t\t\tctx.font = this.canvasFont;\n\t\t\t\t}\n\t\t\t\tif(this.canvasFill){\n\t\t\t\t\tctx.fillText(s.text, s.x, s.y);\n\t\t\t\t}\n\t\t\t\tif(this.strokeStyle){\n\t\t\t\t\tctx.beginPath(); // fix bug in FF3.6. Fixed in FF4b8\n\t\t\t\t\tctx.strokeText(s.text, s.x, s.y);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tmodifyMethod(canvas.Text, \"setFont\");\n\t\n\t\tif(!hasFillText){\n\t\t\tcanvas.Text.extend({\n\t\t\t\tgetTextWidth: function(){\n\t\t\t\t\treturn 0;\n\t\t\t\t},\n\t\t\t\tgetBoundingBox: function(){\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t\t_renderShape: function(){\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tvar pathRenderers = {\n\t\t\t\tM: \"_moveToA\", m: \"_moveToR\",\n\t\t\t\tL: \"_lineToA\", l: \"_lineToR\",\n\t\t\t\tH: \"_hLineToA\", h: \"_hLineToR\",\n\t\t\t\tV: \"_vLineToA\", v: \"_vLineToR\",\n\t\t\t\tC: \"_curveToA\", c: \"_curveToR\",\n\t\t\t\tS: \"_smoothCurveToA\", s: \"_smoothCurveToR\",\n\t\t\t\tQ: \"_qCurveToA\", q: \"_qCurveToR\",\n\t\t\t\tT: \"_qSmoothCurveToA\", t: \"_qSmoothCurveToR\",\n\t\t\t\tA: \"_arcTo\", a: \"_arcTo\",\n\t\t\t\tZ: \"_closePath\", z: \"_closePath\"\n\t\t\t};\n\t\n\t\n\t\tcanvas.Path = declare(\"dojox.gfx.canvas.Path\", [canvas.Shape, pathLib.Path], {\n\t\t\t// summary:\n\t\t\t//\t\ta path shape (Canvas)\n\t\t\tconstructor: function(){\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\tsetShape: function(){\n\t\t\t\tthis.canvasPath = [];\n\t\t\t\tthis._dashedPath= [];\n\t\t\t\treturn this.inherited(arguments);\n\t\t\t},\n\t\t\tsetStroke:function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tif(!hasNativeDash){\n\t\t\t\t\tthis.segmented = false;\n\t\t\t\t\tthis._confirmSegmented();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_setPath: function(){\n\t\t\t\tthis._dashResidue = null;\n\t\t\t\tthis.inherited(arguments);\n\t\t\t},\n\t\t\t_updateWithSegment: function(segment){\n\t\t\t\tvar last = lang.clone(this.last);\n\t\t\t\tthis[pathRenderers[segment.action]](this.canvasPath, segment.action, segment.args, this._needsDash ? this._dashedPath : null);\n\t\t\t\tthis.last = last;\n\t\t\t\tthis.inherited(arguments);\n\t\t\t},\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar r = this.canvasPath;\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor(var i = 0; i < r.length; i += 2){\n\t\t\t\t\tctx[r[i]].apply(ctx, r[i + 1]);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderDashedStroke: hasNativeDash ? function(){} : function(ctx, apply){\n\t\t\t\tvar r = this._dashedPath;\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor(var i = 0; i < r.length; i += 2){\n\t\t\t\t\tctx[r[i]].apply(ctx, r[i + 1]);\n\t\t\t\t}\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t},\n\t\t\t_moveToA: function(result, action, args, doDash){\n\t\t\t\tresult.push(\"moveTo\", [args[0], args[1]]);\n\t\t\t\tif(doDash) doDash.push(\"moveTo\", [args[0], args[1]]);\n\t\t\t\tfor(var i = 2; i < args.length; i += 2){\n\t\t\t\t\tresult.push(\"lineTo\", [args[i], args[i + 1]]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, args[i - 2], args[i - 1], args[i], args[i + 1], this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.last.x = args[args.length - 2];\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_moveToR: function(result, action, args, doDash){\n\t\t\t\tvar pts;\n\t\t\t\tif(\"x\" in this.last){\n\t\t\t\t\tpts = [this.last.x += args[0], this.last.y += args[1]];\n\t\t\t\t\tresult.push(\"moveTo\", pts);\n\t\t\t\t\tif(doDash) doDash.push(\"moveTo\", pts);\n\t\t\t\t}else{\n\t\t\t\t\tpts = [this.last.x = args[0], this.last.y = args[1]];\n\t\t\t\t\tresult.push(\"moveTo\", pts);\n\t\t\t\t\tif(doDash) doDash.push(\"moveTo\", pts);\n\t\t\t\t}\n\t\t\t\tfor(var i = 2; i < args.length; i += 2){\n\t\t\t\t\tresult.push(\"lineTo\", [this.last.x += args[i], this.last.y += args[i + 1]]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_lineToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, this.last.x, this.last.y, args[i], args[i + 1], this._dashResidue);\n\t\t\t\t\tresult.push(\"lineTo\", [args[i], args[i + 1]]);\n\t\t\t\t}\n\t\t\t\tthis.last.x = args[args.length - 2];\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_lineToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\t\tresult.push(\"lineTo\", [this.last.x += args[i], this.last.y += args[i + 1]]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_hLineToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\t\tresult.push(\"lineTo\", [args[i], this.last.y]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], args[i], this.last.y, this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.last.x = args[args.length - 1];\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_hLineToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\t\tresult.push(\"lineTo\", [this.last.x += args[i], this.last.y]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_vLineToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\t\tresult.push(\"lineTo\", [this.last.x, args[i]]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, args[i], this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_vLineToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\t\tresult.push(\"lineTo\", [this.last.x, this.last.y += args[i]]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_curveToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 6){\n\t\t\t\t\tresult.push(\"bezierCurveTo\", args.slice(i, i + 6));\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\t}\n\t\t\t\tthis.last.x = args[args.length - 2];\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t\tthis.lastControl.x = args[args.length - 4];\n\t\t\t\tthis.lastControl.y = args[args.length - 3];\n\t\t\t\tthis.lastControl.type = \"C\";\n\t\t\t},\n\t\t\t_curveToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 6){\n\t\t\t\t\tresult.push(\"bezierCurveTo\", [\n\t\t\t\t\t\tthis.last.x + args[i],\n\t\t\t\t\t\tthis.last.y + args[i + 1],\n\t\t\t\t\t\tthis.lastControl.x = this.last.x + args[i + 2],\n\t\t\t\t\t\tthis.lastControl.y = this.last.y + args[i + 3],\n\t\t\t\t\t\tthis.last.x + args[i + 4],\n\t\t\t\t\t\tthis.last.y + args[i + 5]\n\t\t\t\t\t]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\t\tthis.last.x += args[i + 4];\n\t\t\t\t\tthis.last.y += args[i + 5];\n\t\t\t\t}\n\t\t\t\tthis.lastControl.type = \"C\";\n\t\t\t},\n\t\t\t_smoothCurveToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\t\tvar valid = this.lastControl.type == \"C\";\n\t\t\t\t\tresult.push(\"bezierCurveTo\", [\n\t\t\t\t\t\tvalid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\t\tvalid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\t\targs[i],\n\t\t\t\t\t\targs[i + 1],\n\t\t\t\t\t\targs[i + 2],\n\t\t\t\t\t\targs[i + 3]\n\t\t\t\t\t]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\t\tthis.lastControl.x = args[i];\n\t\t\t\t\tthis.lastControl.y = args[i + 1];\n\t\t\t\t\tthis.lastControl.type = \"C\";\n\t\t\t\t}\n\t\t\t\tthis.last.x = args[args.length - 2];\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t},\n\t\t\t_smoothCurveToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\t\tvar valid = this.lastControl.type == \"C\";\n\t\t\t\t\tresult.push(\"bezierCurveTo\", [\n\t\t\t\t\t\tvalid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\t\tvalid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\t\tthis.last.x + args[i],\n\t\t\t\t\t\tthis.last.y + args[i + 1],\n\t\t\t\t\t\tthis.last.x + args[i + 2],\n\t\t\t\t\t\tthis.last.y + args[i + 3]\n\t\t\t\t\t]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\t\tthis.lastControl.x = this.last.x + args[i];\n\t\t\t\t\tthis.lastControl.y = this.last.y + args[i + 1];\n\t\t\t\t\tthis.lastControl.type = \"C\";\n\t\t\t\t\tthis.last.x += args[i + 2];\n\t\t\t\t\tthis.last.y += args[i + 3];\n\t\t\t\t}\n\t\t\t},\n\t\t\t_qCurveToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\t\tresult.push(\"quadraticCurveTo\", args.slice(i, i + 4));\n\t\t\t\t}\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\tthis.last.x = args[args.length - 2];\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t\tthis.lastControl.x = args[args.length - 4];\n\t\t\t\tthis.lastControl.y = args[args.length - 3];\n\t\t\t\tthis.lastControl.type = \"Q\";\n\t\t\t},\n\t\t\t_qCurveToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\t\tresult.push(\"quadraticCurveTo\", [\n\t\t\t\t\t\tthis.lastControl.x = this.last.x + args[i],\n\t\t\t\t\t\tthis.lastControl.y = this.last.y + args[i + 1],\n\t\t\t\t\t\tthis.last.x + args[i + 2],\n\t\t\t\t\t\tthis.last.y + args[i + 3]\n\t\t\t\t\t]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\t\tthis.last.x += args[i + 2];\n\t\t\t\t\tthis.last.y += args[i + 3];\n\t\t\t\t}\n\t\t\t\tthis.lastControl.type = \"Q\";\n\t\t\t},\n\t\t\t_qSmoothCurveToA: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\t\tvar valid = this.lastControl.type == \"Q\";\n\t\t\t\t\tresult.push(\"quadraticCurveTo\", [\n\t\t\t\t\t\tthis.lastControl.x = valid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\t\tthis.lastControl.y = valid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\t\targs[i],\n\t\t\t\t\t\targs[i + 1]\n\t\t\t\t\t]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\t\tthis.lastControl.type = \"Q\";\n\t\t\t\t}\n\t\t\t\tthis.last.x = args[args.length - 2];\n\t\t\t\tthis.last.y = args[args.length - 1];\n\t\t\t},\n\t\t\t_qSmoothCurveToR: function(result, action, args, doDash){\n\t\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\t\tvar valid = this.lastControl.type == \"Q\";\n\t\t\t\t\tresult.push(\"quadraticCurveTo\", [\n\t\t\t\t\t\tthis.lastControl.x = valid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\t\tthis.lastControl.y = valid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\t\tthis.last.x + args[i],\n\t\t\t\t\t\tthis.last.y + args[i + 1]\n\t\t\t\t\t]);\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\t\tthis.lastControl.type = \"Q\";\n\t\t\t\t\tthis.last.x += args[i];\n\t\t\t\t\tthis.last.y += args[i + 1];\n\t\t\t\t}\n\t\t\t},\n\t\t\t_arcTo: function(result, action, args, doDash){\n\t\t\t\tvar relative = action == \"a\";\n\t\t\t\tfor(var i = 0; i < args.length; i += 7){\n\t\t\t\t\tvar x1 = args[i + 5], y1 = args[i + 6];\n\t\t\t\t\tif(relative){\n\t\t\t\t\t\tx1 += this.last.x;\n\t\t\t\t\t\ty1 += this.last.y;\n\t\t\t\t\t}\n\t\t\t\t\tvar arcs = ga.arcAsBezier(\n\t\t\t\t\t\tthis.last, args[i], args[i + 1], args[i + 2],\n\t\t\t\t\t\targs[i + 3] ? 1 : 0, args[i + 4] ? 1 : 0,\n\t\t\t\t\t\tx1, y1\n\t\t\t\t\t);\n\t\t\t\t\tarr.forEach(arcs, function(p){\n\t\t\t\t\t\tresult.push(\"bezierCurveTo\", p);\n\t\t\t\t\t});\n\t\t\t\t\tif(doDash)\n\t\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, p, this._dashResidue);\n\t\t\t\t\tthis.last.x = x1;\n\t\t\t\t\tthis.last.y = y1;\n\t\t\t\t}\n\t\t\t\tthis.lastControl = {};\n\t\t\t},\n\t\t\t_closePath: function(result, action, args, doDash){\n\t\t\t\tresult.push(\"closePath\", []);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, this.last.x, this.last.y, doDash[1][0], doDash[1][1], this._dashResidue);\n\t\t\t\tthis.lastControl = {};\n\t\t\t}\n\t\t});\n\t\tarr.forEach([\"moveTo\", \"lineTo\", \"hLineTo\", \"vLineTo\", \"curveTo\",\n\t\t\t\"smoothCurveTo\", \"qCurveTo\", \"qSmoothCurveTo\", \"arcTo\", \"closePath\"],\n\t\t\tfunction(method){ modifyMethod(canvas.Path, method); }\n\t\t);\n\t\n\t\tcanvas.TextPath = declare(\"dojox.gfx.canvas.TextPath\", [canvas.Shape, pathLib.TextPath], {\n\t\t\t// summary:\n\t\t\t//\t\ta text shape (Canvas)\n\t\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t\tvar s = this.shape;\n\t\t\t\t// nothing for the moment\n\t\t\t},\n\t\t\t_setText: function(){\n\t\t\t\t// not implemented\n\t\t\t},\n\t\t\t_setFont: function(){\n\t\t\t\t// not implemented\n\t\t\t}\n\t\t});\n\t\n\t\tcanvas.Surface = declare(\"dojox.gfx.canvas.Surface\", gs.Surface, {\n\t\t\t// summary:\n\t\t\t//\t\ta surface object to be used for drawings (Canvas)\n\t\t\tconstructor: function(){\n\t\t\t\tgs.Container._init.call(this);\n\t\t\t\tthis.pendingImageCount = 0;\n\t\t\t\tthis.makeDirty();\n\t\t\t},\n\t\t\tdestroy: function(){\n\t\t\t\tgs.Container.clear.call(this, true); // avoid makeDirty() from canvas.Container.clear impl.\n\t\t\t\tthis.inherited(arguments);\n\t\t\t},\n\t\t\tsetDimensions: function(width, height){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets the width and height of the rawNode\n\t\t\t\t// width: String\n\t\t\t\t//\t\twidth of surface, e.g., \"100px\"\n\t\t\t\t// height: String\n\t\t\t\t//\t\theight of surface, e.g., \"100px\"\n\t\t\t\tthis.width  = g.normalizedLength(width);\t// in pixels\n\t\t\t\tthis.height = g.normalizedLength(height);\t// in pixels\n\t\t\t\tif(!this.rawNode) return this;\n\t\t\t\tvar dirty = false;\n\t\t\t\tif (this.rawNode.width != this.width){\n\t\t\t\t\tthis.rawNode.width = this.width;\n\t\t\t\t\tdirty = true;\n\t\t\t\t}\n\t\t\t\tif (this.rawNode.height != this.height){\n\t\t\t\t\tthis.rawNode.height = this.height;\n\t\t\t\t\tdirty = true;\n\t\t\t\t}\n\t\t\t\tif (dirty)\n\t\t\t\t\tthis.makeDirty();\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tgetDimensions: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns an object with properties \"width\" and \"height\"\n\t\t\t\treturn this.rawNode ? {width:  this.rawNode.width, height: this.rawNode.height} : null;\t// Object\n\t\t\t},\n\t\t\t_render: function(force){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trender the all shapes\n\t\t\t\tif(!this.rawNode || (!force && this.pendingImageCount)){ return; }\n\t\t\t\tvar ctx = this.rawNode.getContext(\"2d\");\n\t\t\t\tctx.clearRect(0, 0, this.rawNode.width, this.rawNode.height);\n\t\t\t\tthis.render(ctx);\n\t\t\t\tif(\"pendingRender\" in this){\n\t\t\t\t\tclearTimeout(this.pendingRender);\n\t\t\t\t\tdelete this.pendingRender;\n\t\t\t\t}\n\t\t\t},\n\t\t\trender: function(ctx){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRenders the gfx scene.\n\t\t\t\t// description:\n\t\t\t\t//\t\tthis method is called to render the gfx scene to the specified context.\n\t\t\t\t//\t\tThis method should not be invoked directly but should be used instead\n\t\t\t\t//\t\tas an extension point on which user can connect to with aspect.before/aspect.after\n\t\t\t\t//\t\tto implement pre- or post- image processing jobs on the drawing surface.\n\t\t\t\t// ctx: CanvasRenderingContext2D\n\t\t\t\t//\t\tThe surface Canvas rendering context.\n\t\t\t\tctx.save();\n\t\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\t\tthis.children[i]._render(ctx);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t},\n\t\t\tmakeDirty: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tinternal method, which is called when we may need to redraw\n\t\t\t\tif(!this.pendingImagesCount && !(\"pendingRender\" in this) && !this._batch){\n\t\t\t\t\tthis.pendingRender = setTimeout(lang.hitch(this, this._render), 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdownloadImage: function(img, url){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tinternal method, which starts an image download and renders, when it is ready\n\t\t\t\t// img: Image\n\t\t\t\t//\t\tthe image object\n\t\t\t\t// url: String\n\t\t\t\t//\t\tthe url of the image\n\t\t\t\tvar handler = lang.hitch(this, this.onImageLoad);\n\t\t\t\tif(!this.pendingImageCount++ && \"pendingRender\" in this){\n\t\t\t\t\tclearTimeout(this.pendingRender);\n\t\t\t\t\tdelete this.pendingRender;\n\t\t\t\t}\n\t\t\t\timg.onload  = handler;\n\t\t\t\timg.onerror = handler;\n\t\t\t\timg.onabort = handler;\n\t\t\t\timg.src = url;\n\t\t\t},\n\t\t\tonImageLoad: function(){\n\t\t\t\tif(!--this.pendingImageCount){\n\t\t\t\t\tthis.onImagesLoaded();\n\t\t\t\t\tthis._render();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonImagesLoaded: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAn extension point called when all pending images downloads have been completed.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThis method is invoked when all pending images downloads have been completed, just before\n\t\t\t\t//\t\tthe gfx scene is redrawn. User can connect to this method to get notified when a\n\t\t\t\t//\t\tgfx scene containing images is fully resolved.\n\t\t\t},\n\t\n\t\t\t// events are not implemented\n\t\t\tgetEventSource: function(){ return null; },\n\t\t\tconnect:\t\tfunction(){},\n\t\t\tdisconnect:\t\tfunction(){},\n\t\t\ton:\t\t\t\tfunction(){}\n\t\t});\n\t\n\t\tcanvas.createSurface = function(parentNode, width, height){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a surface (Canvas)\n\t\t\t// parentNode: Node\n\t\t\t//\t\ta parent node\n\t\t\t// width: String\n\t\t\t//\t\twidth of surface, e.g., \"100px\"\n\t\t\t// height: String\n\t\t\t//\t\theight of surface, e.g., \"100px\"\n\t\n\t\t\tif(!width && !height){\n\t\t\t\tvar pos = domGeom.position(parentNode);\n\t\t\t\twidth  = width  || pos.w;\n\t\t\t\theight = height || pos.h;\n\t\t\t}\n\t\t\tif(typeof width == \"number\"){\n\t\t\t\twidth = width + \"px\";\n\t\t\t}\n\t\t\tif(typeof height == \"number\"){\n\t\t\t\theight = height + \"px\";\n\t\t\t}\n\t\n\t\t\tvar s = new canvas.Surface(),\n\t\t\t\tp = dom.byId(parentNode),\n\t\t\t\tc = p.ownerDocument.createElement(\"canvas\");\n\t\n\t\t\tc.width  = g.normalizedLength(width);\t// in pixels\n\t\t\tc.height = g.normalizedLength(height);\t// in pixels\n\t\n\t\t\tp.appendChild(c);\n\t\t\ts.rawNode = c;\n\t\t\ts._parent = p;\n\t\t\ts.surface = s;\n\t\t\treturn s;\t// dojox/gfx.Surface\n\t\t};\n\t\n\t\t// Extenders\n\t\n\t\tvar C = gs.Container, Container = {\n\t\t\topenBatch: function() {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tstarts a new batch, subsequent new child shapes will be held in\n\t\t\t\t//\t\tthe batch instead of appending to the container directly.\n\t\t\t\t// description:\n\t\t\t\t//\t\tBecause the canvas renderer has no DOM hierarchy, the canvas implementation differs\n\t\t\t\t//\t\tsuch that it suspends the repaint requests for this container until the current batch is closed by a call to closeBatch().\n\t\t\t\t++this._batch;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tcloseBatch: function() {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsubmits the current batch.\n\t\t\t\t// description:\n\t\t\t\t//\t\tOn canvas, this method flushes the pending redraws queue.\n\t\t\t\tthis._batch = this._batch > 0 ? --this._batch : 0;\n\t\t\t\tthis._makeDirty();\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_makeDirty: function(){\n\t\t\t\tif(!this._batch){\n\t\t\t\t\tthis.surface.makeDirty();\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: function(shape){\n\t\t\t\tthis._makeDirty();\n\t\t\t\treturn C.add.apply(this, arguments);\n\t\t\t},\n\t\t\tremove: function(shape, silently){\n\t\t\t\tthis._makeDirty();\n\t\t\t\treturn C.remove.apply(this, arguments);\n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\tthis._makeDirty();\n\t\t\t\treturn C.clear.apply(this, arguments);\n\t\t\t},\n\t\t\tgetBoundingBox: C.getBoundingBox,\n\t\t\t_moveChildToFront: function(shape){\n\t\t\t\tthis._makeDirty();\n\t\t\t\treturn C._moveChildToFront.apply(this, arguments);\n\t\t\t},\n\t\t\t_moveChildToBack: function(shape){\n\t\t\t\tthis._makeDirty();\n\t\t\t\treturn C._moveChildToBack.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t\n\t\tvar Creator = {\n\t\t\t// summary:\n\t\t\t//\t\tCanvas shape creators\n\t\t\tcreateObject: function(shapeType, rawShape) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates an instance of the passed shapeType class\n\t\t\t\t// shapeType: Function\n\t\t\t\t//\t\ta class constructor to create an instance of\n\t\t\t\t// rawShape: Object\n\t\t\t\t//\t\tproperties to be passed in to the classes \"setShape\" method\n\t\t\t\t// overrideSize: Boolean\n\t\t\t\t//\t\tset the size explicitly, if true\n\t\t\t\tvar shape = new shapeType();\n\t\t\t\tshape.surface = this.surface;\n\t\t\t\tshape.setShape(rawShape);\n\t\t\t\tthis.add(shape);\n\t\t\t\treturn shape;\t// dojox/gfx/shape.Shape\n\t\t\t}\n\t\t};\n\t\n\t\textend(canvas.Group, Container);\n\t\textend(canvas.Group, gs.Creator);\n\t\textend(canvas.Group, Creator);\n\t\n\t\textend(canvas.Surface, Container);\n\t\textend(canvas.Surface, gs.Creator);\n\t\textend(canvas.Surface, Creator);\n\t\n\t\t// no event support -> nothing to fix.\n\t\tcanvas.fixTarget = function(event, gfxElement){\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\treturn true;\n\t\t};\n\t\n\t\treturn canvas;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 169 */\n/*!*****************************!*\\\n  !*** ../dojox/gfx/shape.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/kernel */ 4), __webpack_require__(/*! dojo/_base/sniff */ 46),\n\t\t__webpack_require__(/*! dojo/on */ 25), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/dom-construct */ 39), __webpack_require__(/*! dojo/_base/Color */ 120), __webpack_require__(/*! ./matrix */ 170) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang, declare, kernel, has, on, arr, domConstruct, Color, matrixLib){\n\t\n\t\tvar shape = g.shape = {\n\t\t\t// summary:\n\t\t\t//\t\tThis module contains the core graphics Shape API.\n\t\t\t//\t\tDifferent graphics renderer implementation modules (svg, canvas, vml, silverlight, etc.) extend this\n\t\t\t//\t\tbasic api to provide renderer-specific implementations for each shape.\n\t\t};\n\t\n\t\tshape.Shape = declare(\"dojox.gfx.shape.Shape\", null, {\n\t\t\t// summary:\n\t\t\t//\t\ta Shape object, which knows how to apply\n\t\t\t//\t\tgraphical attributes and transformations\n\t\t\n\t\t\tconstructor: function(){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\tunderlying graphics-renderer-specific implementation object (if applicable)\n\t\t\t\tthis.rawNode = null;\n\t\n\t\t\t\t// shape: Object\n\t\t\t\t//\t\tan abstract shape object\n\t\t\t\t//\t\t(see dojox/gfx.defaultPath,\n\t\t\t\t//\t\tdojox/gfx.defaultPolyline,\n\t\t\t\t//\t\tdojox/gfx.defaultRect,\n\t\t\t\t//\t\tdojox/gfx.defaultEllipse,\n\t\t\t\t//\t\tdojox/gfx.defaultCircle,\n\t\t\t\t//\t\tdojox/gfx.defaultLine,\n\t\t\t\t//\t\tor dojox/gfx.defaultImage)\n\t\t\t\tthis.shape = null;\n\t\t\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta transformation matrix\n\t\t\t\tthis.matrix = null;\n\t\t\n\t\t\t\t// fillStyle: dojox/gfx.Fill\n\t\t\t\t//\t\ta fill object\n\t\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\n\t\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\n\t\t\t\t//\t\tdojox/gfx.defaultPattern,\n\t\t\t\t//\t\tor dojo/Color)\n\t\t\t\tthis.fillStyle = null;\n\t\t\n\t\t\t\t// strokeStyle: dojox/gfx.Stroke\n\t\t\t\t//\t\ta stroke object\n\t\t\t\t//\t\t(see dojox/gfx.defaultStroke)\n\t\t\t\tthis.strokeStyle = null;\n\t\t\n\t\t\t\t// bbox: dojox/gfx.Rectangle\n\t\t\t\t//\t\ta bounding box of this shape\n\t\t\t\t//\t\t(see dojox/gfx.defaultRect)\n\t\t\t\tthis.bbox = null;\n\t\t\n\t\t\t\t// virtual group structure\n\t\t\n\t\t\t\t// parent: Object\n\t\t\t\t//\t\ta parent or null\n\t\t\t\t//\t\t(see dojox/gfx/shape.Surface,\n\t\t\t\t//\t\tor dojox/gfx.Group)\n\t\t\t\tthis.parent = null;\n\t\t\n\t\t\t\t// parentMatrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta transformation matrix inherited from the parent\n\t\t\t\tthis.parentMatrix = null;\n\t\n\t\t\t\tif(has(\"gfxRegistry\")){\n\t\t\t\t\tvar uid = shape.register(this);\n\t\t\t\t\tthis.getUID = function(){\n\t\t\t\t\t\treturn uid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\tdestroy: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReleases all internal resources owned by this shape. Once this method has been called,\n\t\t\t\t//\t\tthe instance is considered destroyed and should not be used anymore.\n\t\t\t\tif(has(\"gfxRegistry\")){\n\t\t\t\t\tshape.dispose(this);\n\t\t\t\t}\n\t\t\t\tif(this.rawNode && \"__gfxObject__\" in this.rawNode){\n\t\t\t\t\tthis.rawNode.__gfxObject__ = null;\n\t\t\t\t}\n\t\t\t\tthis.rawNode = null;\n\t\t\t},\n\t\t\n\t\t\t// trivial getters\n\t\t\n\t\t\tgetNode: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDifferent graphics rendering subsystems implement shapes in different ways.  This\n\t\t\t\t//\t\tmethod provides access to the underlying graphics subsystem object.  Clients calling this\n\t\t\t\t//\t\tmethod and using the return value must be careful not to try sharing or using the underlying node\n\t\t\t\t//\t\tin a general way across renderer implementation.\n\t\t\t\t//\t\tReturns the underlying graphics Node, or null if no underlying graphics node is used by this shape.\n\t\t\t\treturn this.rawNode; // Node\n\t\t\t},\n\t\t\tgetShape: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the current Shape object or null\n\t\t\t\t//\t\t(see dojox/gfx.defaultPath,\n\t\t\t\t//\t\tdojox/gfx.defaultPolyline,\n\t\t\t\t//\t\tdojox/gfx.defaultRect,\n\t\t\t\t//\t\tdojox/gfx.defaultEllipse,\n\t\t\t\t//\t\tdojox/gfx.defaultCircle,\n\t\t\t\t//\t\tdojox/gfx.defaultLine,\n\t\t\t\t//\t\tor dojox/gfx.defaultImage)\n\t\t\t\treturn this.shape; // Object\n\t\t\t},\n\t\t\tgetTransform: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns the current transformation matrix applied to this Shape or null\n\t\t\t\treturn this.matrix;\t// dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tgetFill: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns the current fill object or null\n\t\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\n\t\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\n\t\t\t\t//\t\tdojox/gfx.defaultPattern,\n\t\t\t\t//\t\tor dojo/Color)\n\t\t\t\treturn this.fillStyle;\t// Object\n\t\t\t},\n\t\t\tgetStroke: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns the current stroke object or null\n\t\t\t\t//\t\t(see dojox/gfx.defaultStroke)\n\t\t\t\treturn this.strokeStyle;\t// Object\n\t\t\t},\n\t\t\tgetParent: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns the parent Shape, Group or null if this Shape is unparented.\n\t\t\t\t//\t\t(see dojox/gfx/shape.Surface,\n\t\t\t\t//\t\tor dojox/gfx.Group)\n\t\t\t\treturn this.parent;\t// Object\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns the bounding box Rectangle for this shape or null if a BoundingBox cannot be\n\t\t\t\t//\t\tcalculated for the shape on the current renderer or for shapes with no geometric area (points).\n\t\t\t\t//\t\tA bounding box is a rectangular geometric region\n\t\t\t\t//\t\tdefining the X and Y extent of the shape.\n\t\t\t\t//\t\t(see dojox/gfx.defaultRect)\n\t\t\t\t//\t\tNote that this method returns a direct reference to the attribute of this instance. Therefore you should\n\t\t\t\t//\t\tnot modify its value directly but clone it instead.\n\t\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t\t},\n\t\t\tgetTransformedBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns an array of four points or null\n\t\t\t\t//\t\tfour points represent four corners of the untransformed bounding box\n\t\t\t\tvar b = this.getBoundingBox();\n\t\t\t\tif(!b){\n\t\t\t\t\treturn null;\t// null\n\t\t\t\t}\n\t\t\t\tvar m = this._getRealMatrix(),\n\t\t\t\t\tgm = matrixLib;\n\t\t\t\treturn [\t// Array\n\t\t\t\t\t\tgm.multiplyPoint(m, b.x, b.y),\n\t\t\t\t\t\tgm.multiplyPoint(m, b.x + b.width, b.y),\n\t\t\t\t\t\tgm.multiplyPoint(m, b.x + b.width, b.y + b.height),\n\t\t\t\t\t\tgm.multiplyPoint(m, b.x, b.y + b.height)\n\t\t\t\t\t];\n\t\t\t},\n\t\t\tgetEventSource: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns a Node, which is used as\n\t\t\t\t//\t\ta source of events for this shape\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\treturn this.rawNode;\t// Node\n\t\t\t},\n\t\t\n\t\t\t// empty settings\n\t\t\t\n\t\t\tsetClip: function(clip){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets the clipping area of this shape.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe clipping area defines the shape area that will be effectively visible. Everything that\n\t\t\t\t//\t\twould be drawn outside of the clipping area will not be rendered.\n\t\t\t\t//\t\tThe possible clipping area types are rectangle, ellipse, polyline and path, but all are not\n\t\t\t\t//\t\tsupported by all the renderers. vml only supports rectangle clipping, while the gfx silverlight renderer does not\n\t\t\t\t//\t\tsupport path clipping.\n\t\t\t\t//\t\tThe clip parameter defines the clipping area geometry, and should be an object with the following properties:\n\t\t\t\t//\n\t\t\t\t//\t\t- {x:Number, y:Number, width:Number, height:Number} for rectangular clip\n\t\t\t\t//\t\t- {cx:Number, cy:Number, rx:Number, ry:Number} for ellipse clip\n\t\t\t\t//\t\t- {points:Array} for polyline clip\n\t\t\t\t//\t\t- {d:String} for a path clip.\n\t\t\t\t//\n\t\t\t\t//\t\tThe clip geometry coordinates are expressed in the coordinate system used to draw the shape. In other\n\t\t\t\t//\t\twords, the clipping area is defined in the shape parent coordinate system and the shape transform is automatically applied.\n\t\t\t\t// example:\n\t\t\t\t//\t\tThe following example shows how to clip a gfx image with all the possible clip geometry: a rectangle,\n\t\t\t\t//\t\tan ellipse, a circle (using the ellipse geometry), a polyline and a path:\n\t\t\t\t//\n\t\t\t\t//\t|\tsurface.createImage({src:img, width:200,height:200}).setClip({x:10,y:10,width:50,height:50});\n\t\t\t\t//\t|\tsurface.createImage({src:img, x:100,y:50,width:200,height:200}).setClip({cx:200,cy:100,rx:20,ry:30});\n\t\t\t\t//\t|\tsurface.createImage({src:img, x:0,y:350,width:200,height:200}).setClip({cx:100,cy:425,rx:60,ry:60});\n\t\t\t\t//\t|\tsurface.createImage({src:img, x:300,y:0,width:200,height:200}).setClip({points:[350,0,450,50,380,130,300,110]});\n\t\t\t\t//\t|\tsurface.createImage({src:img, x:300,y:350,width:200,height:200}).setClip({d:\"M 350,350 C314,414 317,557 373,450.0000 z\"});\n\t\n\t\t\t\t// clip: Object\n\t\t\t\t//\t\tan object that defines the clipping geometry, or null to remove clip.\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\tthis.clip = clip;\n\t\t\t},\n\t\t\t\n\t\t\tgetClip: function(){\n\t\t\t\treturn this.clip;\n\t\t\t},\n\t\t\n\t\t\tsetShape: function(shape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a shape object\n\t\t\t\t//\t\t(the default implementation simply ignores it)\n\t\t\t\t// shape: Object\n\t\t\t\t//\t\ta shape object\n\t\t\t\t//\t\t(see dojox/gfx.defaultPath,\n\t\t\t\t//\t\tdojox/gfx.defaultPolyline,\n\t\t\t\t//\t\tdojox/gfx.defaultRect,\n\t\t\t\t//\t\tdojox/gfx.defaultEllipse,\n\t\t\t\t//\t\tdojox/gfx.defaultCircle,\n\t\t\t\t//\t\tdojox/gfx.defaultLine,\n\t\t\t\t//\t\tor dojox/gfx.defaultImage)\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\tthis.shape = g.makeParameters(this.shape, shape);\n\t\t\t\tthis.bbox = null;\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tsetFill: function(fill){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a fill object\n\t\t\t\t//\t\t(the default implementation simply ignores it)\n\t\t\t\t// fill: Object\n\t\t\t\t//\t\ta fill object\n\t\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\n\t\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\n\t\t\t\t//\t\tdojox/gfx.defaultPattern,\n\t\t\t\t//\t\tor dojo/_base/Color)\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\tif(!fill){\n\t\t\t\t\t// don't fill\n\t\t\t\t\tthis.fillStyle = null;\n\t\t\t\t\treturn this;\t// self\n\t\t\t\t}\n\t\t\t\tvar f = null;\n\t\t\t\tif(typeof(fill) == \"object\" && \"type\" in fill){\n\t\t\t\t\t// gradient or pattern\n\t\t\t\t\tswitch(fill.type){\n\t\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\t\tf = g.makeParameters(g.defaultLinearGradient, fill);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\t\tf = g.makeParameters(g.defaultRadialGradient, fill);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\t\tf = g.makeParameters(g.defaultPattern, fill);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// color object\n\t\t\t\t\tf = g.normalizeColor(fill);\n\t\t\t\t}\n\t\t\t\tthis.fillStyle = f;\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tsetStroke: function(stroke){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a stroke object\n\t\t\t\t//\t\t(the default implementation simply ignores it)\n\t\t\t\t// stroke: Object\n\t\t\t\t//\t\ta stroke object\n\t\t\t\t//\t\t(see dojox/gfx.defaultStroke)\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\tif(!stroke){\n\t\t\t\t\t// don't stroke\n\t\t\t\t\tthis.strokeStyle = null;\n\t\t\t\t\treturn this;\t// self\n\t\t\t\t}\n\t\t\t\t// normalize the stroke\n\t\t\t\tif(typeof stroke == \"string\" || lang.isArray(stroke) || stroke instanceof Color){\n\t\t\t\t\tstroke = {color: stroke};\n\t\t\t\t}\n\t\t\t\tvar s = this.strokeStyle = g.makeParameters(g.defaultStroke, stroke);\n\t\t\t\ts.color = g.normalizeColor(s.color);\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tsetTransform: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a transformation matrix\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\tthis.matrix = matrixLib.clone(matrix ? matrixLib.normalize(matrix) : matrixLib.identity);\n\t\t\t\treturn this._applyTransform();\t// self\n\t\t\t},\n\t\t\n\t\t\t_applyTransform: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tphysically sets a matrix\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\n\t\t\t// z-index\n\t\t\n\t\t\tmoveToFront: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmoves a shape to front of its parent's list of shapes\n\t\t\t\tvar p = this.getParent();\n\t\t\t\tif(p){\n\t\t\t\t\tp._moveChildToFront(this);\n\t\t\t\t\tthis._moveToFront();\t// execute renderer-specific action\n\t\t\t\t}\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tmoveToBack: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmoves a shape to back of its parent's list of shapes\n\t\t\t\tvar p = this.getParent();\n\t\t\t\tif(p){\n\t\t\t\t\tp._moveChildToBack(this);\n\t\t\t\t\tthis._moveToBack();\t// execute renderer-specific action\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_moveToFront: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trenderer-specific hook, see dojox/gfx/shape.Shape.moveToFront()\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t},\n\t\t\t_moveToBack: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trenderer-specific hook, see dojox/gfx/shape.Shape.moveToFront()\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t},\n\t\t\n\t\t\t// apply left & right transformation\n\t\t\n\t\t\tapplyRightTransform: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmultiplies the existing matrix with an argument on right side\n\t\t\t\t//\t\t(this.matrix * matrix)\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\n\t\t\t},\n\t\t\tapplyLeftTransform: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmultiplies the existing matrix with an argument on left side\n\t\t\t\t//\t\t(matrix * this.matrix)\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\t\treturn matrix ? this.setTransform([matrix, this.matrix]) : this;\t// self\n\t\t\t},\n\t\t\tapplyTransform: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ta shortcut for dojox/gfx/shape.Shape.applyRightTransform\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\n\t\t\t},\n\t\t\n\t\t\t// virtual group methods\n\t\t\n\t\t\tremoveShape: function(silently){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tremoves the shape from its parent's list of shapes\n\t\t\t\t// silently: Boolean\n\t\t\t\t//\t\tif true, do not redraw a picture yet\n\t\t\t\tif(this.parent){\n\t\t\t\t\tthis.parent.remove(this, silently);\n\t\t\t\t}\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\t_setParent: function(parent, matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a parent\n\t\t\t\t// parent: Object\n\t\t\t\t//\t\ta parent or null\n\t\t\t\t//\t\t(see dojox/gfx/shape.Surface,\n\t\t\t\t//\t\tor dojox/gfx.Group)\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix or a matrix-like object\n\t\t\t\tthis.parent = parent;\n\t\t\t\treturn this._updateParentMatrix(matrix);\t// self\n\t\t\t},\n\t\t\t_updateParentMatrix: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tupdates the parent matrix with new matrix\n\t\t\t\t// matrix: dojox/gfx/Matrix2D\n\t\t\t\t//\t\ta 2D matrix or a matrix-like object\n\t\t\t\tthis.parentMatrix = matrix ? matrixLib.clone(matrix) : null;\n\t\t\t\treturn this._applyTransform();\t// self\n\t\t\t},\n\t\t\t_getRealMatrix: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the cumulative ('real') transformation matrix\n\t\t\t\t//\t\tby combining the shape's matrix with its parent's matrix\n\t\t\t\tvar m = this.matrix;\n\t\t\t\tvar p = this.parent;\n\t\t\t\twhile(p){\n\t\t\t\t\tif(p.matrix){\n\t\t\t\t\t\tm = matrixLib.multiply(p.matrix, m);\n\t\t\t\t\t}\n\t\t\t\t\tp = p.parent;\n\t\t\t\t}\n\t\t\t\treturn m;\t// dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape._eventsProcessing = {\n\t\t\ton: function(type, listener){\n\t\t\t\t//\tsummary:\n\t\t\t\t//\t\tConnects an event to this shape.\n\t\n\t\t\t\treturn on(this.getEventSource(), type, shape.fixCallback(this, g.fixTarget, listener));\n\t\t\t},\n\t\n\t\t\tconnect: function(name, object, method){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconnects a handler to an event on this shape\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\t// redirect to fixCallback to normalize events and add the gfxTarget to the event. The latter\n\t\t\t\t// is done by dojox/gfx.fixTarget which is defined by each renderer\n\t\t\t\tif(name.substring(0, 2) == \"on\"){\n\t\t\t\t\tname = name.substring(2);\n\t\t\t\t}\n\t\t\t\treturn this.on(name, method ? lang.hitch(object, method) : object);\n\t\t\t},\n\t\n\t\t\tdisconnect: function(token){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconnects a handler by token from an event on this shape\n\t\t\t\t\n\t\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\n\t\t\t\treturn token.remove();\n\t\t\t}\n\t\t};\n\t\t\n\t\tshape.fixCallback = function(gfxElement, fixFunction, scope, method){\n\t\t\t// summary:\n\t\t\t//\t\tWraps the callback to allow for tests and event normalization\n\t\t\t//\t\tbefore it gets invoked. This is where 'fixTarget' is invoked.\n\t\t\t// tags:\n\t\t\t//      private\n\t\t\t// gfxElement: Object\n\t\t\t//\t\tThe GFX object that triggers the action (ex.:\n\t\t\t//\t\tdojox/gfx.Surface and dojox/gfx/shape.Shape). A new event property\n\t\t\t//\t\t'gfxTarget' is added to the event to reference this object.\n\t\t\t//\t\tfor easy manipulation of GFX objects by the event handlers.\n\t\t\t// fixFunction: Function\n\t\t\t//\t\tThe function that implements the logic to set the 'gfxTarget'\n\t\t\t//\t\tproperty to the event. It should be 'dojox/gfx.fixTarget' for\n\t\t\t//\t\tmost of the cases\n\t\t\t// scope: Object\n\t\t\t//\t\tOptional. The scope to be used when invoking 'method'. If\n\t\t\t//\t\tomitted, a global scope is used.\n\t\t\t// method: Function|String\n\t\t\t//\t\tThe original callback to be invoked.\n\t\t\tif(!method){\n\t\t\t\tmethod = scope;\n\t\t\t\tscope = null;\n\t\t\t}\n\t\t\tif(lang.isString(method)){\n\t\t\t\tscope = scope || kernel.global;\n\t\t\t\tif(!scope[method]){ throw(['dojox.gfx.shape.fixCallback: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\t\treturn function(e){  \n\t\t\t\t\treturn fixFunction(e,gfxElement) ? scope[method].apply(scope, arguments || []) : undefined; }; // Function\n\t\t\t}\n\t\t\treturn !scope \n\t\t\t\t? function(e){ \n\t\t\t\t\treturn fixFunction(e,gfxElement) ? method.apply(scope, arguments) : undefined; } \n\t\t\t\t: function(e){ \n\t\t\t\t\treturn fixFunction(e,gfxElement) ? method.apply(scope, arguments || []) : undefined; }; // Function\n\t\t};\n\t\tlang.extend(shape.Shape, shape._eventsProcessing);\n\t\t\n\t\tshape.Container = {\n\t\t\t// summary:\n\t\t\t//\t\ta container of shapes, which can be used\n\t\t\t//\t\tas a foundation for renderer-specific groups, or as a way\n\t\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\n\t\t\n\t\t\t_init: function() {\n\t\t\t\t// children: Array\n\t\t\t\t//\t\ta list of children\n\t\t\t\tthis.children = [];\n\t\t\t\tthis._batch = 0;\n\t\t\t},\n\t\t\n\t\t\t// group management\n\t\t\n\t\t\topenBatch: function() {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tstarts a new batch, subsequent new child shapes will be held in\n\t\t\t\t//\t\tthe batch instead of appending to the container directly.\n\t\t\t\t// description:\n\t\t\t\t//\t\tBecause the canvas renderer has no DOM hierarchy, the canvas implementation differs\n\t\t\t\t//\t\tsuch that it suspends the repaint requests for this container until the current batch is closed by a call to closeBatch().\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tcloseBatch: function() {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsubmits the current batch, append all pending child shapes to DOM\n\t\t\t\t// description:\n\t\t\t\t//\t\tOn canvas, this method flushes the pending redraws queue.\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tadd: function(shape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tadds a shape to the list\n\t\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t\t//\t\tthe shape to add to the list\n\t\t\t\tvar oldParent = shape.getParent();\n\t\t\t\tif(oldParent){\n\t\t\t\t\toldParent.remove(shape, true);\n\t\t\t\t}\n\t\t\t\tthis.children.push(shape);\n\t\t\t\treturn shape._setParent(this, this._getRealMatrix());\t// self\n\t\t\t},\n\t\t\tremove: function(shape, silently){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tremoves a shape from the list\n\t\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t\t//\t\tthe shape to remove\n\t\t\t\t// silently: Boolean\n\t\t\t\t//\t\tif true, do not redraw a picture yet\n\t\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\t\tif(this.children[i] == shape){\n\t\t\t\t\t\tif(silently){\n\t\t\t\t\t\t\t// skip for now\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tshape.parent = null;\n\t\t\t\t\t\t\tshape.parentMatrix = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tclear: function(/*Boolean?*/ destroy){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tremoves all shapes from a group/surface.\n\t\t\t\t// destroy: Boolean\n\t\t\t\t//\t\tIndicates whether the children should be destroyed. Optional.\n\t\t\t\tvar shape;\n\t\t\t\tfor(var i = 0; i < this.children.length;++i){\n\t\t\t\t\tshape = this.children[i];\n\t\t\t\t\tshape.parent = null;\n\t\t\t\t\tshape.parentMatrix = null;\n\t\t\t\t\tif(destroy){\n\t\t\t\t\t\tshape.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.children = [];\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns the bounding box Rectangle for this shape.\n\t\t\t\tif(this.children){\n\t\t\t\t\t// if this is a composite shape, then sum up all the children\n\t\t\t\t\tvar result = null;\n\t\t\t\t\tarr.forEach(this.children, function(shape){\n\t\t\t\t\t\tvar bb = shape.getBoundingBox();\n\t\t\t\t\t\tif(bb){\n\t\t\t\t\t\t\tvar ct = shape.getTransform();\n\t\t\t\t\t\t\tif(ct){\n\t\t\t\t\t\t\t\tbb = matrixLib.multiplyRectangle(ct, bb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(result){\n\t\t\t\t\t\t\t\t// merge two bbox \n\t\t\t\t\t\t\t\tresult.x = Math.min(result.x, bb.x);\n\t\t\t\t\t\t\t\tresult.y = Math.min(result.y, bb.y);\n\t\t\t\t\t\t\t\tresult.endX = Math.max(result.endX, bb.x + bb.width);\n\t\t\t\t\t\t\t\tresult.endY = Math.max(result.endY, bb.y + bb.height);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// first bbox \n\t\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\t\tx: bb.x,\n\t\t\t\t\t\t\t\t\ty: bb.y,\n\t\t\t\t\t\t\t\t\tendX: bb.x + bb.width,\n\t\t\t\t\t\t\t\t\tendY: bb.y + bb.height\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif(result){\n\t\t\t\t\t\tresult.width = result.endX - result.x;\n\t\t\t\t\t\tresult.height = result.endY - result.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn result; // dojox/gfx.Rectangle\n\t\t\t\t}\n\t\t\t\t// unknown/empty bounding box, subclass shall override this impl \n\t\t\t\treturn null;\n\t\t\t},\n\t\t\t// moving child nodes\n\t\t\t_moveChildToFront: function(shape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmoves a shape to front of the list of shapes\n\t\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t\t//\t\tone of the child shapes to move to the front\n\t\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\t\tif(this.children[i] == shape){\n\t\t\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\t\t\tthis.children.push(shape);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\t_moveChildToBack: function(shape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmoves a shape to back of the list of shapes\n\t\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t\t//\t\tone of the child shapes to move to the front\n\t\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\t\tif(this.children[i] == shape){\n\t\t\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\t\t\tthis.children.unshift(shape);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t// self\n\t\t\t}\n\t\t};\n\t\n\t\tshape.Surface = declare(\"dojox.gfx.shape.Surface\", null, {\n\t\t\t// summary:\n\t\t\t//\t\ta surface object to be used for drawings\n\t\t\tconstructor: function(){\n\t\t\t\t// underlying node\n\t\t\t\tthis.rawNode = null;\n\t\t\t\t// the parent node\n\t\t\t\tthis._parent = null;\n\t\t\t\t// the list of DOM nodes to be deleted in the case of destruction\n\t\t\t\tthis._nodes = [];\n\t\t\t\t// the list of events to be detached in the case of destruction\n\t\t\t\tthis._events = [];\n\t\t\t},\n\t\t\tdestroy: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tdestroy all relevant external resources and release all\n\t\t\t\t//\t\texternal references to make this object garbage-collectible\n\t\t\t\tarr.forEach(this._nodes, domConstruct.destroy);\n\t\t\t\tthis._nodes = [];\n\t\t\t\tarr.forEach(this._events, function(h){ if(h){ h.remove(); } });\n\t\t\t\tthis._events = [];\n\t\t\t\tthis.rawNode = null;\t// recycle it in _nodes, if it needs to be recycled\n\t\t\t\tif(has(\"ie\")){\n\t\t\t\t\twhile(this._parent.lastChild){\n\t\t\t\t\t\tdomConstruct.destroy(this._parent.lastChild);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis._parent.innerHTML = \"\";\n\t\t\t\t}\n\t\t\t\tthis._parent = null;\n\t\t\t},\n\t\t\tgetEventSource: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns a node, which can be used to attach event listeners\n\t\t\t\treturn this.rawNode; // Node\n\t\t\t},\n\t\t\t_getRealMatrix: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\talways returns the identity matrix\n\t\t\t\treturn null;\t// dojox/gfx/Matrix2D\n\t\t\t},\n\t\t\t/*=====\n\t\t\t setDimensions: function(width, height){\n\t\t\t\t // summary:\n\t\t\t\t //\t\tsets the width and height of the rawNode\n\t\t\t\t // width: String\n\t\t\t\t //\t\twidth of surface, e.g., \"100px\"\n\t\t\t\t // height: String\n\t\t\t\t //\t\theight of surface, e.g., \"100px\"\n\t\t\t\t return this;\t// self\n\t\t\t },\n\t\t\t getDimensions: function(){\n\t\t\t\t // summary:\n\t\t\t\t //     gets current width and height in pixels\n\t\t\t\t // returns: Object\n\t\t\t\t //     object with properties \"width\" and \"height\"\n\t\t\t },\n\t\t\t =====*/\n\t\t\tisLoaded: true,\n\t\t\tonLoad: function(/*dojox/gfx/shape.Surface*/ surface){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tlocal event, fired once when the surface is created\n\t\t\t\t//\t\tasynchronously, used only when isLoaded is false, required\n\t\t\t\t//\t\tonly for Silverlight.\n\t\t\t},\n\t\t\twhenLoaded: function(/*Object|Null*/ context, /*Function|String*/ method){\n\t\t\t\tvar f = lang.hitch(context, method);\n\t\t\t\tif(this.isLoaded){\n\t\t\t\t\tf(this);\n\t\t\t\t}else{\n\t\t\t\t\ton.once(this, \"load\", function(surface){\n\t\t\t\t\t\tf(surface);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlang.extend(shape.Surface, shape._eventsProcessing);\n\t\n\t\t/*=====\n\t\tg.Point = declare(\"dojox/gfx.Point\", null, {\n\t\t\t// summary:\n\t\t\t//\t\t2D point for drawings - {x, y}\n\t\t\t// description:\n\t\t\t//\t\tDo not use this object directly!\n\t\t\t//\t\tUse the naked object instead: {x: 1, y: 2}.\n\t\t});\n\t\n\t\tg.Rectangle = declare(\"dojox.gfx.Rectangle\", null, {\n\t\t\t// summary:\n\t\t\t//\t\trectangle - {x, y, width, height}\n\t\t\t// description:\n\t\t\t//\t\tDo not use this object directly!\n\t\t\t//\t\tUse the naked object instead: {x: 1, y: 2, width: 100, height: 200}.\n\t\t});\n\t\t =====*/\n\t\n\t\n\t\tshape.Rect = declare(\"dojox.gfx.shape.Rect\", shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic rectangle\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\tThe underlying graphics system object (typically a DOM Node)\n\t\t\t\tthis.shape = g.getDefault(\"Rect\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box (its shape in this case)\n\t\t\t\treturn this.shape;\t// dojox/gfx.Rectangle\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Ellipse = declare(\"dojox.gfx.shape.Ellipse\", shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic ellipse\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM Node\n\t\t\t\tthis.shape = g.getDefault(\"Ellipse\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box\n\t\t\t\tif(!this.bbox){\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tthis.bbox = {x: shape.cx - shape.rx, y: shape.cy - shape.ry,\n\t\t\t\t\t\twidth: 2 * shape.rx, height: 2 * shape.ry};\n\t\t\t\t}\n\t\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Circle = declare(\"dojox.gfx.shape.Circle\", shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic circle\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM Node\n\t\t\t\tthis.shape = g.getDefault(\"Circle\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box\n\t\t\t\tif(!this.bbox){\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tthis.bbox = {x: shape.cx - shape.r, y: shape.cy - shape.r,\n\t\t\t\t\t\twidth: 2 * shape.r, height: 2 * shape.r};\n\t\t\t\t}\n\t\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Line = declare(\"dojox.gfx.shape.Line\", shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic line (do not instantiate it directly)\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM Node\n\t\t\t\tthis.shape = g.getDefault(\"Line\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box\n\t\t\t\tif(!this.bbox){\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tthis.bbox = {\n\t\t\t\t\t\tx:\t\tMath.min(shape.x1, shape.x2),\n\t\t\t\t\t\ty:\t\tMath.min(shape.y1, shape.y2),\n\t\t\t\t\t\twidth:\tMath.abs(shape.x2 - shape.x1),\n\t\t\t\t\t\theight:\tMath.abs(shape.y2 - shape.y1)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Polyline = declare(\"dojox.gfx.shape.Polyline\", shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic polyline/polygon (do not instantiate it directly)\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM Node\n\t\t\t\tthis.shape = g.getDefault(\"Polyline\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tsetShape: function(points, closed){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a polyline/polygon shape object\n\t\t\t\t// points: Object|Array\n\t\t\t\t//\t\ta polyline/polygon shape object, or an array of points\n\t\t\t\t// closed: Boolean\n\t\t\t\t//\t\tclose the polyline to make a polygon\n\t\t\t\tif(points && points instanceof Array){\n\t\t\t\t\tthis.inherited(arguments, [{points: points}]);\n\t\t\t\t\tif(closed && this.shape.points.length){\n\t\t\t\t\t\tthis.shape.points.push(this.shape.points[0]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis.inherited(arguments, [points]);\n\t\t\t\t}\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\t_normalizePoints: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tnormalize points to array of {x:number, y:number}\n\t\t\t\tvar p = this.shape.points, l = p && p.length;\n\t\t\t\tif(l && typeof p[0] == \"number\"){\n\t\t\t\t\tvar points = [];\n\t\t\t\t\tfor(var i = 0; i < l; i += 2){\n\t\t\t\t\t\tpoints.push({x: p[i], y: p[i + 1]});\n\t\t\t\t\t}\n\t\t\t\t\tthis.shape.points = points;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box\n\t\t\t\tif(!this.bbox && this.shape.points.length){\n\t\t\t\t\tvar p = this.shape.points;\n\t\t\t\t\tvar l = p.length;\n\t\t\t\t\tvar t = p[0];\n\t\t\t\t\tvar bbox = {l: t.x, t: t.y, r: t.x, b: t.y};\n\t\t\t\t\tfor(var i = 1; i < l; ++i){\n\t\t\t\t\t\tt = p[i];\n\t\t\t\t\t\tif(bbox.l > t.x) bbox.l = t.x;\n\t\t\t\t\t\tif(bbox.r < t.x) bbox.r = t.x;\n\t\t\t\t\t\tif(bbox.t > t.y) bbox.t = t.y;\n\t\t\t\t\t\tif(bbox.b < t.y) bbox.b = t.y;\n\t\t\t\t\t}\n\t\t\t\t\tthis.bbox = {\n\t\t\t\t\t\tx:\t\tbbox.l,\n\t\t\t\t\t\ty:\t\tbbox.t,\n\t\t\t\t\t\twidth:\tbbox.r - bbox.l,\n\t\t\t\t\t\theight:\tbbox.b - bbox.t\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Image = declare(\"dojox.gfx.shape.Image\", shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic image (do not instantiate it directly)\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM Node\n\t\t\t\tthis.shape = g.getDefault(\"Image\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box (its shape in this case)\n\t\t\t\treturn this.shape;\t// dojox/gfx.Rectangle\n\t\t\t},\n\t\t\tsetStroke: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tignore setting a stroke style\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tsetFill: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tignore setting a fill style\n\t\t\t\treturn this;\t// self\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Text = declare(shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generic text (do not instantiate it directly)\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM Node\n\t\t\t\tthis.fontStyle = null;\n\t\t\t\tthis.shape = g.getDefault(\"Text\");\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t},\n\t\t\tgetFont: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the current font object or null\n\t\t\t\treturn this.fontStyle;\t// Object\n\t\t\t},\n\t\t\tsetFont: function(newFont){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a font for text\n\t\t\t\t// newFont: Object\n\t\t\t\t//\t\ta font object (see dojox/gfx.defaultFont) or a font string\n\t\t\t\tthis.fontStyle = typeof newFont == \"string\" ? g.splitFontString(newFont) :\n\t\t\t\t\tg.makeParameters(g.defaultFont, newFont);\n\t\t\t\tthis._setFont();\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\tvar bbox = null, s = this.getShape();\n\t\t\t\tif(s.text){\n\t\t\t\t\tbbox = g._base._computeTextBoundingBox(this);\n\t\t\t\t}\n\t\t\t\treturn bbox;\n\t\t\t}\n\t\t});\n\t\t\n\t\tshape.Creator = {\n\t\t\t// summary:\n\t\t\t//\t\tshape creators\n\t\t\tcreateShape: function(shape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a shape object based on its type; it is meant to be used\n\t\t\t\t//\t\tby group-like objects\n\t\t\t\t// shape: Object\n\t\t\t\t//\t\ta shape descriptor object\n\t\t\t\t// returns: dojox/gfx/shape.Shape | Null\n\t\t\t\t//      a fully instantiated surface-specific Shape object\n\t\t\t\tswitch(shape.type){\n\t\t\t\t\tcase g.defaultPath.type:\t\treturn this.createPath(shape);\n\t\t\t\t\tcase g.defaultRect.type:\t\treturn this.createRect(shape);\n\t\t\t\t\tcase g.defaultCircle.type:\t    return this.createCircle(shape);\n\t\t\t\t\tcase g.defaultEllipse.type:\t    return this.createEllipse(shape);\n\t\t\t\t\tcase g.defaultLine.type:\t\treturn this.createLine(shape);\n\t\t\t\t\tcase g.defaultPolyline.type:\treturn this.createPolyline(shape);\n\t\t\t\t\tcase g.defaultImage.type:\t\treturn this.createImage(shape);\n\t\t\t\t\tcase g.defaultText.type:\t\treturn this.createText(shape);\n\t\t\t\t\tcase g.defaultTextPath.type:\treturn this.createTextPath(shape);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tcreateGroup: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a group shape\n\t\t\t\treturn this.createObject(g.Group);\t// dojox/gfx/Group\n\t\t\t},\n\t\t\tcreateRect: function(rect){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a rectangle shape\n\t\t\t\t// rect: Object\n\t\t\t\t//\t\ta path object (see dojox/gfx.defaultRect)\n\t\t\t\treturn this.createObject(g.Rect, rect);\t// dojox/gfx/shape.Rect\n\t\t\t},\n\t\t\tcreateEllipse: function(ellipse){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates an ellipse shape\n\t\t\t\t// ellipse: Object\n\t\t\t\t//\t\tan ellipse object (see dojox/gfx.defaultEllipse)\n\t\t\t\treturn this.createObject(g.Ellipse, ellipse);\t// dojox/gfx/shape.Ellipse\n\t\t\t},\n\t\t\tcreateCircle: function(circle){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a circle shape\n\t\t\t\t// circle: Object\n\t\t\t\t//\t\ta circle object (see dojox/gfx.defaultCircle)\n\t\t\t\treturn this.createObject(g.Circle, circle);\t// dojox/gfx/shape.Circle\n\t\t\t},\n\t\t\tcreateLine: function(line){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a line shape\n\t\t\t\t// line: Object\n\t\t\t\t//\t\ta line object (see dojox/gfx.defaultLine)\n\t\t\t\treturn this.createObject(g.Line, line);\t// dojox/gfx/shape.Line\n\t\t\t},\n\t\t\tcreatePolyline: function(points){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a polyline/polygon shape\n\t\t\t\t// points: Object\n\t\t\t\t//\t\ta points object (see dojox/gfx.defaultPolyline)\n\t\t\t\t//\t\tor an Array of points\n\t\t\t\treturn this.createObject(g.Polyline, points);\t// dojox/gfx/shape.Polyline\n\t\t\t},\n\t\t\tcreateImage: function(image){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a image shape\n\t\t\t\t// image: Object\n\t\t\t\t//\t\tan image object (see dojox/gfx.defaultImage)\n\t\t\t\treturn this.createObject(g.Image, image);\t// dojox/gfx/shape.Image\n\t\t\t},\n\t\t\tcreateText: function(text){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a text shape\n\t\t\t\t// text: Object\n\t\t\t\t//\t\ta text object (see dojox/gfx.defaultText)\n\t\t\t\treturn this.createObject(g.Text, text);\t// dojox/gfx/shape.Text\n\t\t\t},\n\t\t\tcreatePath: function(path){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a path shape\n\t\t\t\t// path: Object\n\t\t\t\t//\t\ta path object (see dojox/gfx.defaultPath)\n\t\t\t\treturn this.createObject(g.Path, path);\t// dojox/gfx/shape.Path\n\t\t\t},\n\t\t\tcreateTextPath: function(text){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a text shape\n\t\t\t\t// text: Object\n\t\t\t\t//\t\ta textpath object (see dojox/gfx.defaultTextPath)\n\t\t\t\treturn this.createObject(g.TextPath, {}).setText(text);\t// dojox/gfx/shape.TextPath\n\t\t\t},\n\t\t\tcreateObject: function(shapeType, rawShape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates an instance of the passed shapeType class\n\t\t\t\t// shapeType: Function\n\t\t\t\t//\t\ta class constructor to create an instance of\n\t\t\t\t// rawShape: Object \n\t\t\t\t//\t\tproperties to be passed in to the classes 'setShape' method\n\t\t\n\t\t\t\t// SHOULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t\treturn null;\t// dojox/gfx/shape.Shape\n\t\t\t}\n\t\t};\n\t\t\n\t\t/*=====\n\t\t lang.extend(shape.Surface, shape.Container);\n\t\t lang.extend(shape.Surface, shape.Creator);\n\t\n\t\t g.Group = declare(shape.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta group shape, which can be used\n\t\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\n\t\t});\n\t\tlang.extend(g.Group, shape.Container);\n\t\tlang.extend(g.Group, shape.Creator);\n\t\n\t\tg.Rect     = shape.Rect;\n\t\tg.Circle   = shape.Circle;\n\t\tg.Ellipse  = shape.Ellipse;\n\t\tg.Line     = shape.Line;\n\t\tg.Polyline = shape.Polyline;\n\t\tg.Text     = shape.Text;\n\t\tg.Surface  = shape.Surface;\n\t\t=====*/\n\t\n\t\treturn shape;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 170 */\n/*!******************************!*\\\n  !*** ../dojox/gfx/matrix.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167),__webpack_require__(/*! dojo/_base/lang */ 9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang){\n\t\tvar m = g.matrix = {};\n\t\n\t\t// candidates for dojox.math:\n\t\tvar _degToRadCache = {};\n\t\tm._degToRad = function(degree){\n\t\t\treturn _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));\n\t\t};\n\t\tm._radToDeg = function(radian){ return radian / Math.PI * 180; };\n\t\n\t\tm.Matrix2D = function(arg){\n\t\t\t// summary:\n\t\t\t//\t\ta 2D matrix object\n\t\t\t// description:\n\t\t\t//\t\tNormalizes a 2D matrix-like object. If arrays is passed,\n\t\t\t//\t\tall objects of the array are normalized and multiplied sequentially.\n\t\t\t// arg: Object\n\t\t\t//\t\ta 2D matrix-like object, a number, or an array of such objects\n\t\t\tif(arg){\n\t\t\t\tif(typeof arg == \"number\"){\n\t\t\t\t\tthis.xx = this.yy = arg;\n\t\t\t\t}else if(arg instanceof Array){\n\t\t\t\t\tif(arg.length > 0){\n\t\t\t\t\t\tvar matrix = m.normalize(arg[0]);\n\t\t\t\t\t\t// combine matrices\n\t\t\t\t\t\tfor(var i = 1; i < arg.length; ++i){\n\t\t\t\t\t\t\tvar l = matrix, r = m.normalize(arg[i]);\n\t\t\t\t\t\t\tmatrix = new m.Matrix2D();\n\t\t\t\t\t\t\tmatrix.xx = l.xx * r.xx + l.xy * r.yx;\n\t\t\t\t\t\t\tmatrix.xy = l.xx * r.xy + l.xy * r.yy;\n\t\t\t\t\t\t\tmatrix.yx = l.yx * r.xx + l.yy * r.yx;\n\t\t\t\t\t\t\tmatrix.yy = l.yx * r.xy + l.yy * r.yy;\n\t\t\t\t\t\t\tmatrix.dx = l.xx * r.dx + l.xy * r.dy + l.dx;\n\t\t\t\t\t\t\tmatrix.dy = l.yx * r.dx + l.yy * r.dy + l.dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlang.mixin(this, matrix);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlang.mixin(this, arg);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t// the default (identity) matrix, which is used to fill in missing values\n\t\tlang.extend(m.Matrix2D, {xx: 1, xy: 0, yx: 0, yy: 1, dx: 0, dy: 0});\n\t\n\t\tlang.mixin(m, {\n\t\t\t// summary:\n\t\t\t//\t\tclass constants, and methods of dojox/gfx/matrix\n\t\n\t\t\t// matrix constants\n\t\n\t\t\t// identity: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\tan identity matrix constant: identity * (x, y) == (x, y)\n\t\t\tidentity: new m.Matrix2D(),\n\t\n\t\t\t// flipX: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)\n\t\t\tflipX:    new m.Matrix2D({xx: -1}),\n\t\n\t\t\t// flipY: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)\n\t\t\tflipY:    new m.Matrix2D({yy: -1}),\n\t\n\t\t\t// flipXY: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)\n\t\t\tflipXY:   new m.Matrix2D({xx: -1, yy: -1}),\n\t\n\t\t\t// matrix creators\n\t\n\t\t\ttranslate: function(a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a translation matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to translate (move) points by specified offsets.\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x coordinate value, or a point-like object, which specifies offsets for both dimensions\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y coordinate value\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 1){\n\t\t\t\t\treturn new m.Matrix2D({dx: a, dy: b}); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\t// branch\n\t\t\t\treturn new m.Matrix2D({dx: a.x, dy: a.y}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tscale: function(a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a scaling matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to scale (magnify) points by specified offsets.\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\ta scaling factor used for the x coordinate, or\n\t\t\t\t//\t\ta uniform scaling factor used for the both coordinates, or\n\t\t\t\t//\t\ta point-like object, which specifies scale factors for both dimensions\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta scaling factor used for the y coordinate\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 1){\n\t\t\t\t\treturn new m.Matrix2D({xx: a, yy: b}); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\tif(typeof a == \"number\"){\n\t\t\t\t\treturn new m.Matrix2D({xx: a, yy: a}); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn new m.Matrix2D({xx: a.x, yy: a.y}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\trotate: function(angle){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a rotating matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to rotate points\n\t\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\n\t\t\t\t// angle: Number\n\t\t\t\t//\t\tan angle of rotation in radians (>0 for CW)\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tvar c = Math.cos(angle);\n\t\t\t\tvar s = Math.sin(angle);\n\t\t\t\treturn new m.Matrix2D({xx: c, xy: -s, yx: s, yy: c}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\trotateg: function(degree){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a rotating matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to rotate points\n\t\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\n\t\t\t\t//\t\tSee dojox/gfx/matrix.rotate() for comparison.\n\t\t\t\t// degree: Number\n\t\t\t\t//\t\tan angle of rotation in degrees (>0 for CW)\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\treturn m.rotate(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewX: function(angle) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms an x skewing matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to skew points in the x dimension\n\t\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\n\t\t\t\t// angle: Number\n\t\t\t\t//\t\ta skewing angle in radians\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\treturn new m.Matrix2D({xy: Math.tan(angle)}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewXg: function(degree){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms an x skewing matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to skew points in the x dimension\n\t\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\n\t\t\t\t//\t\tSee dojox/gfx/matrix.skewX() for comparison.\n\t\t\t\t// degree: Number\n\t\t\t\t//\t\ta skewing angle in degrees\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\treturn m.skewX(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewY: function(angle){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a y skewing matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to skew points in the y dimension\n\t\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\n\t\t\t\t// angle: Number\n\t\t\t\t//\t\ta skewing angle in radians\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\treturn new m.Matrix2D({yx: Math.tan(angle)}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewYg: function(degree){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a y skewing matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to skew points in the y dimension\n\t\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\n\t\t\t\t//\t\tSee dojox/gfx/matrix.skewY() for comparison.\n\t\t\t\t// degree: Number\n\t\t\t\t//\t\ta skewing angle in degrees\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\treturn m.skewY(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\treflect: function(a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a reflection matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to reflect points around a vector,\n\t\t\t\t//\t\twhich goes through the origin.\n\t\t\t\t// a: dojox/gfx.Point|Number\n\t\t\t\t//\t\ta point-like object, which specifies a vector of reflection, or an X value\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta Y value\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length == 1){\n\t\t\t\t\tb = a.y;\n\t\t\t\t\ta = a.x;\n\t\t\t\t}\n\t\t\t\t// make a unit vector\n\t\t\t\tvar a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = 2 * a * b / n2;\n\t\t\t\treturn new m.Matrix2D({xx: 2 * a2 / n2 - 1, xy: xy, yx: xy, yy: 2 * b2 / n2 - 1}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tproject: function(a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms an orthogonal projection matrix\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe resulting matrix is used to project points orthogonally on a vector,\n\t\t\t\t//\t\twhich goes through the origin.\n\t\t\t\t// a: dojox/gfx.Point|Number\n\t\t\t\t//\t\ta point-like object, which specifies a vector of projection, or\n\t\t\t\t//\t\tan x coordinate value\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y coordinate value\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length == 1){\n\t\t\t\t\tb = a.y;\n\t\t\t\t\ta = a.x;\n\t\t\t\t}\n\t\t\t\t// make a unit vector\n\t\t\t\tvar a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = a * b / n2;\n\t\t\t\treturn new m.Matrix2D({xx: a2 / n2, xy: xy, yx: xy, yy: b2 / n2}); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\n\t\t\t// ensure matrix 2D conformance\n\t\t\tnormalize: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts an object to a matrix, if necessary\n\t\t\t\t// description:\n\t\t\t\t//\t\tConverts any 2D matrix-like object or an array of\n\t\t\t\t//\t\tsuch objects to a valid dojox/gfx/matrix.Matrix2D object.\n\t\t\t\t// matrix: Object\n\t\t\t\t//\t\tan object, which is converted to a matrix, if necessary\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\treturn (matrix instanceof m.Matrix2D) ? matrix : new m.Matrix2D(matrix); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\n\t\t\t// common operations\n\t\n\t\t\tisIdentity: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns whether the specified matrix is the identity.\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix object to be tested\n\t\t\t\t// returns: Boolean\n\t\t\t\treturn matrix.xx == 1 && matrix.xy == 0 && matrix.yx == 0 && matrix.yy == 1 && matrix.dx == 0 && matrix.dy == 0; // Boolean\n\t\t\t},\n\t\t\tclone: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a copy of a 2D matrix\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix-like object to be cloned\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tvar obj = new m.Matrix2D();\n\t\t\t\tfor(var i in matrix){\n\t\t\t\t\tif(typeof(matrix[i]) == \"number\" && typeof(obj[i]) == \"number\" && obj[i] != matrix[i]) obj[i] = matrix[i];\n\t\t\t\t}\n\t\t\t\treturn obj; // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tinvert: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tinverts a 2D matrix\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix-like object to be inverted\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tvar M = m.normalize(matrix),\n\t\t\t\t\tD = M.xx * M.yy - M.xy * M.yx;\n\t\t\t\t\tM = new m.Matrix2D({\n\t\t\t\t\t\txx: M.yy/D, xy: -M.xy/D,\n\t\t\t\t\t\tyx: -M.yx/D, yy: M.xx/D,\n\t\t\t\t\t\tdx: (M.xy * M.dy - M.yy * M.dx) / D,\n\t\t\t\t\t\tdy: (M.yx * M.dx - M.xx * M.dy) / D\n\t\t\t\t\t});\n\t\t\t\treturn M; // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\t_multiplyPoint: function(matrix, x, y){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tapplies a matrix to a point\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix object to be applied\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tan x coordinate of a point\n\t\t\t\t// y: Number\n\t\t\t\t//\t\ta y coordinate of a point\n\t\t\t\t// returns: dojox/gfx.Point\n\t\t\t\treturn {x: matrix.xx * x + matrix.xy * y + matrix.dx, y: matrix.yx * x + matrix.yy * y + matrix.dy}; // dojox/gfx.Point\n\t\t\t},\n\t\t\tmultiplyPoint: function(matrix, /* Number||Point */ a, /* Number? */ b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tapplies a matrix to a point\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix object to be applied\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x coordinate of a point, or a point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y coordinate of a point\n\t\t\t\t// returns: dojox/gfx.Point\n\t\t\t\tvar M = m.normalize(matrix);\n\t\t\t\tif(typeof a == \"number\" && typeof b == \"number\"){\n\t\t\t\t\treturn m._multiplyPoint(M, a, b); // dojox/gfx.Point\n\t\t\t\t}\n\t\t\t\treturn m._multiplyPoint(M, a.x, a.y); // dojox/gfx.Point\n\t\t\t},\n\t\t\tmultiplyRectangle: function(matrix, /*Rectangle*/ rect){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tApplies a matrix to a rectangle.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThe method applies the transformation on all corners of the\n\t\t\t\t//\t\trectangle and returns the smallest rectangle enclosing the 4 transformed\n\t\t\t\t//\t\tpoints.\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix object to be applied.\n\t\t\t\t// rect: Rectangle\n\t\t\t\t//\t\tthe rectangle to transform.\n\t\t\t\t// returns: dojox/gfx.Rectangle\n\t\t\t\tvar M = m.normalize(matrix);\n\t\t\t\trect = rect || {x:0, y:0, width:0, height:0}; \n\t\t\t\tif(m.isIdentity(M))\n\t\t\t\t\treturn {x: rect.x, y: rect.y, width: rect.width, height: rect.height}; // dojo/gfx.Rectangle\n\t\t\t\tvar p0 = m.multiplyPoint(M, rect.x, rect.y),\n\t\t\t\t\tp1 = m.multiplyPoint(M, rect.x, rect.y + rect.height),\n\t\t\t\t\tp2 = m.multiplyPoint(M, rect.x + rect.width, rect.y),\n\t\t\t\t\tp3 = m.multiplyPoint(M, rect.x + rect.width, rect.y + rect.height),\n\t\t\t\t\tminx = Math.min(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\t\tminy = Math.min(p0.y, p1.y, p2.y, p3.y),\n\t\t\t\t\tmaxx = Math.max(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\t\tmaxy = Math.max(p0.y, p1.y, p2.y, p3.y);\n\t\t\t\treturn{ // dojo/gfx.Rectangle\n\t\t\t\t\tx: minx,\n\t\t\t\t\ty: miny,\n\t\t\t\t\twidth: maxx - minx,\n\t\t\t\t\theight: maxy - miny\n\t\t\t\t};\n\t\t\t},\n\t\t\tmultiply: function(matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcombines matrices by multiplying them sequentially in the given order\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix-like object,\n\t\t\t\t//\t\tall subsequent arguments are matrix-like objects too\n\t\t\t\tvar M = m.normalize(matrix);\n\t\t\t\t// combine matrices\n\t\t\t\tfor(var i = 1; i < arguments.length; ++i){\n\t\t\t\t\tvar l = M, r = m.normalize(arguments[i]);\n\t\t\t\t\tM = new m.Matrix2D();\n\t\t\t\t\tM.xx = l.xx * r.xx + l.xy * r.yx;\n\t\t\t\t\tM.xy = l.xx * r.xy + l.xy * r.yy;\n\t\t\t\t\tM.yx = l.yx * r.xx + l.yy * r.yx;\n\t\t\t\t\tM.yy = l.yx * r.xy + l.yy * r.yy;\n\t\t\t\t\tM.dx = l.xx * r.dx + l.xy * r.dy + l.dx;\n\t\t\t\t\tM.dy = l.yx * r.dx + l.yy * r.dy + l.dy;\n\t\t\t\t}\n\t\t\t\treturn M; // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\n\t\t\t// high level operations\n\t\n\t\t\t_sandwich: function(matrix, x, y){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tapplies a matrix at a central point\n\t\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t\t//\t\ta 2D matrix-like object, which is applied at a central point\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tan x component of the central point\n\t\t\t\t// y: Number\n\t\t\t\t//\t\ta y component of the central point\n\t\t\t\treturn m.multiply(m.translate(x, y), matrix, m.translate(-x, -y)); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tscaleAt: function(a, b, c, d){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tscales a picture using a specified point as a center of scaling\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.scale().\n\t\t\t\t// a: Number\n\t\t\t\t//\t\ta scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta scaling factor used for the y coordinate\n\t\t\t\t// c: Number|Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// d: Number\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tswitch(arguments.length){\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\t// a and b are scale factor components, c and d are components of a point\n\t\t\t\t\t\treturn m._sandwich(m.scale(a, b), c, d); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tif(typeof c == \"number\"){\n\t\t\t\t\t\t\treturn m._sandwich(m.scale(a), b, c); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn m._sandwich(m.scale(a, b), c.x, c.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.scale(a), b.x, b.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\trotateAt: function(angle, a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trotates a picture using a specified point as a center of rotation\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.rotate().\n\t\t\t\t// angle: Number\n\t\t\t\t//\t\tan angle of rotation in radians (>0 for CW)\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 2){\n\t\t\t\t\treturn m._sandwich(m.rotate(angle), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.rotate(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\trotategAt: function(degree, a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trotates a picture using a specified point as a center of rotation\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.rotateg().\n\t\t\t\t// degree: Number\n\t\t\t\t//\t\tan angle of rotation in degrees (>0 for CW)\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 2){\n\t\t\t\t\treturn m._sandwich(m.rotateg(degree), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.rotateg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewXAt: function(angle, a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tskews a picture along the x axis using a specified point as a center of skewing\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.skewX().\n\t\t\t\t// angle: Number\n\t\t\t\t//\t\ta skewing angle in radians\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 2){\n\t\t\t\t\treturn m._sandwich(m.skewX(angle), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.skewX(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewXgAt: function(degree, a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tskews a picture along the x axis using a specified point as a center of skewing\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.skewXg().\n\t\t\t\t// degree: Number\n\t\t\t\t//\t\ta skewing angle in degrees\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 2){\n\t\t\t\t\treturn m._sandwich(m.skewXg(degree), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.skewXg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewYAt: function(angle, a, b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tskews a picture along the y axis using a specified point as a center of skewing\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.skewY().\n\t\t\t\t// angle: Number\n\t\t\t\t//\t\ta skewing angle in radians\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 2){\n\t\t\t\t\treturn m._sandwich(m.skewY(angle), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.skewY(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t},\n\t\t\tskewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tskews a picture along the y axis using a specified point as a center of skewing\n\t\t\t\t// description:\n\t\t\t\t//\t\tCompare with dojox/gfx/matrix.skewYg().\n\t\t\t\t// degree: Number\n\t\t\t\t//\t\ta skewing angle in degrees\n\t\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t\t// b: Number?\n\t\t\t\t//\t\ta y component of a central point\n\t\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\t\tif(arguments.length > 2){\n\t\t\t\t\treturn m._sandwich(m.skewYg(degree), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\treturn m._sandwich(m.skewYg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\n\t\t\t//TODO: rect-to-rect mapping, scale-to-fit (isotropic and anisotropic versions)\n\t\n\t\t});\n\t\t// propagate Matrix2D up\n\t\tg.Matrix2D = m.Matrix2D;\n\t\n\t\treturn m;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t\n\n\n/***/ },\n/* 171 */\n/*!****************************!*\\\n  !*** ../dojox/gfx/path.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9),__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./matrix */ 170), __webpack_require__(/*! ./shape */ 169)], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang, declare, matrix, shapeLib){\n\t\n\t\t// module:\n\t\t//\t\tdojox/gfx/path\n\t\n\t\tvar Path = declare(\"dojox.gfx.path.Path\", shapeLib.Shape, {\n\t\t\t// summary:\n\t\t\t//\t\ta generalized path shape\n\t\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ta path constructor\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM node to be used by this path object\n\t\t\t\tthis.shape = lang.clone(g.defaultPath);\n\t\t\t\tthis.segments = [];\n\t\t\t\tthis.tbbox = null;\n\t\t\t\tthis.absolute = true;\n\t\t\t\tthis.last = {};\n\t\t\t\tthis.rawNode = rawNode;\n\t\t\t\tthis.segmented = false;\n\t\t\t},\n\t\n\t\t\t// mode manipulations\n\t\t\tsetAbsoluteMode: function(mode){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets an absolute or relative mode for path points\n\t\t\t\t// mode: Boolean\n\t\t\t\t//\t\ttrue/false or \"absolute\"/\"relative\" to specify the mode\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tthis.absolute = typeof mode == \"string\" ? (mode == \"absolute\") : mode;\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tgetAbsoluteMode: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns a current value of the absolute mode\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\treturn this.absolute; // Boolean\n\t\t\t},\n\t\n\t\t\tgetBoundingBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the bounding box {x, y, width, height} or null\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\treturn (this.bbox && (\"l\" in this.bbox)) ? {x: this.bbox.l, y: this.bbox.t, width: this.bbox.r - this.bbox.l, height: this.bbox.b - this.bbox.t} : null; // dojox/gfx.Rectangle\n\t\t\t},\n\t\n\t\t\t_getRealBBox: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns an array of four points or null\n\t\t\t\t//\t\tfour points represent four corners of the untransformed bounding box\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tif(this.tbbox){\n\t\t\t\t\treturn this.tbbox;\t// Array\n\t\t\t\t}\n\t\t\t\tvar bbox = this.bbox, matrix = this._getRealMatrix();\n\t\t\t\tthis.bbox = null;\n\t\t\t\tfor(var i = 0, len = this.segments.length; i < len; ++i){\n\t\t\t\t\tthis._updateWithSegment(this.segments[i], matrix);\n\t\t\t\t}\n\t\t\t\tvar t = this.bbox;\n\t\t\t\tthis.bbox = bbox;\n\t\t\t\tthis.tbbox = t ? [\n\t\t\t\t\t{x: t.l, y: t.t},\n\t\t\t\t\t{x: t.r, y: t.t},\n\t\t\t\t\t{x: t.r, y: t.b},\n\t\t\t\t\t{x: t.l, y: t.b}\n\t\t\t\t] : null;\n\t\t\t\treturn this.tbbox;\t// Array\n\t\t\t},\n\t\n\t\t\tgetLastPosition: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the last point in the path, or null\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\treturn \"x\" in this.last ? this.last : null; // Object\n\t\t\t},\n\t\n\t\t\t_applyTransform: function(){\n\t\t\t\tthis.tbbox = null;\n\t\t\t\treturn this.inherited(arguments);\n\t\t\t},\n\t\n\t\t\t// segment interpretation\n\t\t\t_updateBBox: function(x, y, m){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tupdates the bounding box of path with new point\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tan x coordinate\n\t\t\t\t// y: Number\n\t\t\t\t//\t\ta y coordinate\n\t\n\t\t\t\tif(m){\n\t\t\t\t\tvar t = matrix.multiplyPoint(m, x, y);\n\t\t\t\t\tx = t.x;\n\t\t\t\t\ty = t.y;\n\t\t\t\t}\n\t\n\t\t\t\t// we use {l, b, r, t} representation of a bbox\n\t\t\t\tif(this.bbox && (\"l\" in this.bbox)){\n\t\t\t\t\tif(this.bbox.l > x) this.bbox.l = x;\n\t\t\t\t\tif(this.bbox.r < x) this.bbox.r = x;\n\t\t\t\t\tif(this.bbox.t > y) this.bbox.t = y;\n\t\t\t\t\tif(this.bbox.b < y) this.bbox.b = y;\n\t\t\t\t}else{\n\t\t\t\t\tthis.bbox = {l: x, b: y, r: x, t: y};\n\t\t\t\t}\n\t\t\t},\n\t\t\t_updateWithSegment: function(segment, matrix){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tupdates the bounding box of path with new segment\n\t\t\t\t// segment: Object\n\t\t\t\t//\t\ta segment\n\t\t\t\tvar n = segment.args, l = n.length, i;\n\t\t\t\t// update internal variables: bbox, absolute, last\n\t\t\t\tswitch(segment.action){\n\t\t\t\t\tcase \"M\":\n\t\t\t\t\tcase \"L\":\n\t\t\t\t\tcase \"C\":\n\t\t\t\t\tcase \"S\":\n\t\t\t\t\tcase \"Q\":\n\t\t\t\t\tcase \"T\":\n\t\t\t\t\t\tfor(i = 0; i < l; i += 2){\n\t\t\t\t\t\t\tthis._updateBBox(n[i], n[i + 1], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.last.x = n[l - 2];\n\t\t\t\t\t\tthis.last.y = n[l - 1];\n\t\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"H\":\n\t\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\t\tthis._updateBBox(n[i], this.last.y, matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.last.x = n[l - 1];\n\t\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"V\":\n\t\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x, n[i], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.last.y = n[l - 1];\n\t\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"m\":\n\t\t\t\t\t\tvar start = 0;\n\t\t\t\t\t\tif(!(\"x\" in this.last)){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x = n[0], this.last.y = n[1], matrix);\n\t\t\t\t\t\t\tstart = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(i = start; i < l; i += 2){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i], this.last.y += n[i + 1], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"l\":\n\t\t\t\t\tcase \"t\":\n\t\t\t\t\t\tfor(i = 0; i < l; i += 2){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i], this.last.y += n[i + 1], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"h\":\n\t\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i], this.last.y, matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"v\":\n\t\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x, this.last.y += n[i], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"c\":\n\t\t\t\t\t\tfor(i = 0; i < l; i += 6){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x + n[i], this.last.y + n[i + 1], matrix);\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x + n[i + 2], this.last.y + n[i + 3], matrix);\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i + 4], this.last.y += n[i + 5], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"s\":\n\t\t\t\t\tcase \"q\":\n\t\t\t\t\t\tfor(i = 0; i < l; i += 4){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x + n[i], this.last.y + n[i + 1], matrix);\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i + 2], this.last.y += n[i + 3], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"A\":\n\t\t\t\t\t\tfor(i = 0; i < l; i += 7){\n\t\t\t\t\t\t\tthis._updateBBox(n[i + 5], n[i + 6], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.last.x = n[l - 2];\n\t\t\t\t\t\tthis.last.y = n[l - 1];\n\t\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"a\":\n\t\t\t\t\t\tfor(i = 0; i < l; i += 7){\n\t\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i + 5], this.last.y += n[i + 6], matrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// add an SVG path segment\n\t\t\t\tvar path = [segment.action];\n\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\tpath.push(g.formatNumber(n[i], true));\n\t\t\t\t}\n\t\t\t\tif(typeof this.shape.path == \"string\"){\n\t\t\t\t\tthis.shape.path += path.join(\"\");\n\t\t\t\t}else{\n\t\t\t\t\tfor(i = 0, l = path.length; i < l; ++i){\n\t\t\t\t\t\tthis.shape.path.push(path[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// a dictionary, which maps segment type codes to a number of their arguments\n\t\t\t_validSegments: {m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, z: 0},\n\t\n\t\t\t_pushSegment: function(action, args){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tadds a segment\n\t\t\t\t// action: String\n\t\t\t\t//\t\tvalid SVG code for a segment's type\n\t\t\t\t// args: Array\n\t\t\t\t//\t\ta list of parameters for this segment\n\t\t\t\tthis.tbbox = null;\n\t\t\t\tvar group = this._validSegments[action.toLowerCase()], segment;\n\t\t\t\tif(typeof group == \"number\"){\n\t\t\t\t\tif(group){\n\t\t\t\t\t\tif(args.length >= group){\n\t\t\t\t\t\t\tsegment = {action: action, args: args.slice(0, args.length - args.length % group)};\n\t\t\t\t\t\t\tthis.segments.push(segment);\n\t\t\t\t\t\t\tthis._updateWithSegment(segment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsegment = {action: action, args: []};\n\t\t\t\t\t\tthis.segments.push(segment);\n\t\t\t\t\t\tthis._updateWithSegment(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_collectArgs: function(array, args){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tconverts an array of arguments to plain numeric values\n\t\t\t\t// array: Array\n\t\t\t\t//\t\tan output argument (array of numbers)\n\t\t\t\t// args: Array\n\t\t\t\t//\t\tan input argument (can be values of Boolean, Number, dojox/gfx.Point, or an embedded array of them)\n\t\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\t\tvar t = args[i];\n\t\t\t\t\tif(typeof t == \"boolean\"){\n\t\t\t\t\t\tarray.push(t ? 1 : 0);\n\t\t\t\t\t}else if(typeof t == \"number\"){\n\t\t\t\t\t\tarray.push(t);\n\t\t\t\t\t}else if(t instanceof Array){\n\t\t\t\t\t\tthis._collectArgs(array, t);\n\t\t\t\t\t}else if(\"x\" in t && \"y\" in t){\n\t\t\t\t\t\tarray.push(t.x, t.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// segments\n\t\t\tmoveTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a move segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"M\" : \"m\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tlineTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a line segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"L\" : \"l\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\thLineTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a horizontal line segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"H\" : \"h\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tvLineTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a vertical line segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"V\" : \"v\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tcurveTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a curve segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"C\" : \"c\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tsmoothCurveTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a smooth curve segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"S\" : \"s\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tqCurveTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a quadratic curve segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"Q\" : \"q\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tqSmoothCurveTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a quadratic smooth curve segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"T\" : \"t\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tarcTo: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms an elliptic arc segment\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tvar args = [];\n\t\t\t\tthis._collectArgs(args, arguments);\n\t\t\t\tthis._pushSegment(this.absolute ? \"A\" : \"a\", args);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\t\tclosePath: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcloses a path\n\t\t\t\tthis._confirmSegmented();\n\t\t\t\tthis._pushSegment(\"Z\", []);\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\n\t\t\t_confirmSegmented: function() {\n\t\t\t\tif (!this.segmented) {\n\t\t\t\t\tvar path = this.shape.path;\n\t\t\t\t\t// switch to non-updating version of path building\n\t\t\t\t\tthis.shape.path = [];\n\t\t\t\t\tthis._setPath(path);\n\t\t\t\t\t// switch back to the string path\n\t\t\t\t\tthis.shape.path = this.shape.path.join(\"\");\n\t\t\t\t\t// become segmented\n\t\t\t\t\tthis.segmented = true;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// setShape\n\t\t\t_setPath: function(path){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a path using an SVG path string\n\t\t\t\t// path: String\n\t\t\t\t//\t\tan SVG path string\n\t\t\t\tvar p = lang.isArray(path) ? path : path.match(g.pathSvgRegExp);\n\t\t\t\tthis.segments = [];\n\t\t\t\tthis.absolute = true;\n\t\t\t\tthis.bbox = {};\n\t\t\t\tthis.last = {};\n\t\t\t\tif(!p) return;\n\t\t\t\t// create segments\n\t\t\t\tvar action = \"\",\t// current action\n\t\t\t\t\targs = [],\t\t// current arguments\n\t\t\t\t\tl = p.length;\n\t\t\t\tfor(var i = 0; i < l; ++i){\n\t\t\t\t\tvar t = p[i], x = parseFloat(t);\n\t\t\t\t\tif(isNaN(x)){\n\t\t\t\t\t\tif(action){\n\t\t\t\t\t\t\tthis._pushSegment(action, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs = [];\n\t\t\t\t\t\taction = t;\n\t\t\t\t\t}else{\n\t\t\t\t\t\targs.push(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._pushSegment(action, args);\n\t\t\t},\n\t\t\tsetShape: function(newShape){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tforms a path using a shape\n\t\t\t\t// newShape: Object\n\t\t\t\t//\t\tan SVG path string or a path object (see dojox/gfx.defaultPath)\n\t\t\t\tthis.inherited(arguments, [typeof newShape == \"string\" ? {path: newShape} : newShape]);\n\t\n\t\t\t\tthis.segmented = false;\n\t\t\t\tthis.segments = [];\n\t\t\t\tif(!g.lazyPathSegmentation){\n\t\t\t\t\tthis._confirmSegmented();\n\t\t\t\t}\n\t\t\t\treturn this; // self\n\t\t\t},\n\t\n\t\t\t// useful constant for descendants\n\t\t\t_2PI: Math.PI * 2\n\t\t});\n\t\n\t\tvar TextPath = declare(\"dojox.gfx.path.TextPath\", Path, {\n\t\t\t// summary:\n\t\t\t//\t\ta generalized TextPath shape\n\t\n\t\t\tconstructor: function(rawNode){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ta TextPath shape constructor\n\t\t\t\t// rawNode: Node\n\t\t\t\t//\t\ta DOM node to be used by this TextPath object\n\t\t\t\tif(!(\"text\" in this)){\n\t\t\t\t\tthis.text = lang.clone(g.defaultTextPath);\n\t\t\t\t}\n\t\t\t\tif(!(\"fontStyle\" in this)){\n\t\t\t\t\tthis.fontStyle = lang.clone(g.defaultFont);\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetText: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the current text object or null\n\t\t\t\treturn this.text;\t// Object\n\t\t\t},\n\t\t\tsetText: function(newText){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a text to be drawn along the path\n\t\t\t\tthis.text = g.makeParameters(this.text,\n\t\t\t\t\ttypeof newText == \"string\" ? {text: newText} : newText);\n\t\t\t\tthis._setText();\n\t\t\t\treturn this;\t// self\n\t\t\t},\n\t\t\tgetFont: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns the current font object or null\n\t\t\t\treturn this.fontStyle;\t// Object\n\t\t\t},\n\t\t\tsetFont: function(newFont){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets a font for text\n\t\t\t\tthis.fontStyle = typeof newFont == \"string\" ?\n\t\t\t\t\tg.splitFontString(newFont) :\n\t\t\t\t\tg.makeParameters(g.defaultFont, newFont);\n\t\t\t\tthis._setFont();\n\t\t\t\treturn this;\t// self\n\t\t\t}\n\t\t});\n\t\n\t\t/*=====\n\t\tg.Path = Path;\n\t\tg.TextPath = TextPath;\n\t\t=====*/\n\t\n\t\treturn g.path = {\n\t\t\t// summary:\n\t\t\t//\t\tThis module contains the core graphics Path API.\n\t\t\t//\t\tPath command format follows the W3C SVG 1.0 Path api.\n\t\n\t\t\tPath: Path,\n\t\t\tTextPath: TextPath\n\t\t};\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 172 */\n/*!***************************!*\\\n  !*** ../dojox/gfx/arc.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./matrix */ 170)], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang, m){\n\t\tvar twoPI = 2 * Math.PI, pi4 = Math.PI / 4, pi8 = Math.PI / 8,\n\t\t\tpi48 = pi4 + pi8, curvePI4 = unitArcAsBezier(pi8);\n\t\n\t\tfunction unitArcAsBezier(alpha){\n\t\t\t// summary:\n\t\t\t//\t\treturn a start point, 1st and 2nd control points, and an end point of\n\t\t\t//\t\ta an arc, which is reflected on the x axis\n\t\t\t// alpha: Number\n\t\t\t//\t\tangle in radians, the arc will be 2 * angle size\n\t\t\tvar cosa  = Math.cos(alpha), sina  = Math.sin(alpha),\n\t\t\t\tp2 = {x: cosa + (4 / 3) * (1 - cosa), y: sina - (4 / 3) * cosa * (1 - cosa) / sina};\n\t\t\treturn {\t// Object\n\t\t\t\ts:  {x: cosa, y: -sina},\n\t\t\t\tc1: {x: p2.x, y: -p2.y},\n\t\t\t\tc2: p2,\n\t\t\t\te:  {x: cosa, y: sina}\n\t\t\t};\n\t\t}\n\t\n\t\tvar arc = g.arc = {\n\t\t\t// summary:\n\t\t\t//\t\tThis module contains the core graphics Arc functions.\n\t\t\t\n\t\t\tunitArcAsBezier: unitArcAsBezier,\n\t\t\t/*===== \n\t\t\tunitArcAsBezier: function(alpha) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturn a start point, 1st and 2nd control points, and an end point of\n\t\t\t\t//\t\ta an arc, which is reflected on the x axis\n\t\t\t\t// alpha: Number\n\t\t\t\t//\t\tangle in radians, the arc will be 2 * angle size\n\t\t\t},\n\t\t\t=====*/\n\t\n\t\t\t// curvePI4: Object\n\t\t\t//\t\tan object with properties of an arc around a unit circle from 0 to pi/4\n\t\t\tcurvePI4: curvePI4,\n\t\n\t\t\tarcAsBezier: function(last, rx, ry, xRotg, large, sweep, x, y){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcalculates an arc as a series of Bezier curves\n\t\t\t\t//\t\tgiven the last point and a standard set of SVG arc parameters,\n\t\t\t\t//\t\tit returns an array of arrays of parameters to form a series of\n\t\t\t\t//\t\tabsolute Bezier curves.\n\t\t\t\t// last: Object\n\t\t\t\t//\t\ta point-like object as a start of the arc\n\t\t\t\t// rx: Number\n\t\t\t\t//\t\ta horizontal radius for the virtual ellipse\n\t\t\t\t// ry: Number\n\t\t\t\t//\t\ta vertical radius for the virtual ellipse\n\t\t\t\t// xRotg: Number\n\t\t\t\t//\t\ta rotation of an x axis of the virtual ellipse in degrees\n\t\t\t\t// large: Boolean\n\t\t\t\t//\t\twhich part of the ellipse will be used (the larger arc if true)\n\t\t\t\t// sweep: Boolean\n\t\t\t\t//\t\tdirection of the arc (CW if true)\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tthe x coordinate of the end point of the arc\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tthe y coordinate of the end point of the arc\n\t\n\t\t\t\t// calculate parameters\n\t\t\t\tlarge = Boolean(large);\n\t\t\t\tsweep = Boolean(sweep);\n\t\t\t\tvar xRot = m._degToRad(xRotg),\n\t\t\t\t\trx2 = rx * rx, ry2 = ry * ry,\n\t\t\t\t\tpa = m.multiplyPoint(\n\t\t\t\t\t\tm.rotate(-xRot),\n\t\t\t\t\t\t{x: (last.x - x) / 2, y: (last.y - y) / 2}\n\t\t\t\t\t),\n\t\t\t\t\tpax2 = pa.x * pa.x, pay2 = pa.y * pa.y,\n\t\t\t\t\tc1 = Math.sqrt((rx2 * ry2 - rx2 * pay2 - ry2 * pax2) / (rx2 * pay2 + ry2 * pax2));\n\t\t\t\tif(isNaN(c1)){ c1 = 0; }\n\t\t\t\tvar\tca = {\n\t\t\t\t\t\tx:  c1 * rx * pa.y / ry,\n\t\t\t\t\t\ty: -c1 * ry * pa.x / rx\n\t\t\t\t\t};\n\t\t\t\tif(large == sweep){\n\t\t\t\t\tca = {x: -ca.x, y: -ca.y};\n\t\t\t\t}\n\t\t\t\t// the center\n\t\t\t\tvar c = m.multiplyPoint(\n\t\t\t\t\t[\n\t\t\t\t\t\tm.translate(\n\t\t\t\t\t\t\t(last.x + x) / 2,\n\t\t\t\t\t\t\t(last.y + y) / 2\n\t\t\t\t\t\t),\n\t\t\t\t\t\tm.rotate(xRot)\n\t\t\t\t\t],\n\t\t\t\t\tca\n\t\t\t\t);\n\t\t\t\t// calculate the elliptic transformation\n\t\t\t\tvar elliptic_transform = m.normalize([\n\t\t\t\t\tm.translate(c.x, c.y),\n\t\t\t\t\tm.rotate(xRot),\n\t\t\t\t\tm.scale(rx, ry)\n\t\t\t\t]);\n\t\t\t\t// start, end, and size of our arc\n\t\t\t\tvar inversed = m.invert(elliptic_transform),\n\t\t\t\t\tsp = m.multiplyPoint(inversed, last),\n\t\t\t\t\tep = m.multiplyPoint(inversed, x, y),\n\t\t\t\t\tstartAngle = Math.atan2(sp.y, sp.x),\n\t\t\t\t\tendAngle   = Math.atan2(ep.y, ep.x),\n\t\t\t\t\ttheta = startAngle - endAngle;\t// size of our arc in radians\n\t\t\t\tif(sweep){ theta = -theta; }\n\t\t\t\tif(theta < 0){\n\t\t\t\t\ttheta += twoPI;\n\t\t\t\t}else if(theta > twoPI){\n\t\t\t\t\ttheta -= twoPI;\n\t\t\t\t}\n\t\n\t\t\t\t// draw curve chunks\n\t\t\t\tvar alpha = pi8, curve = curvePI4, step  = sweep ? alpha : -alpha,\n\t\t\t\t\tresult = [];\n\t\t\t\tfor(var angle = theta; angle > 0; angle -= pi4){\n\t\t\t\t\tif(angle < pi48){\n\t\t\t\t\t\talpha = angle / 2;\n\t\t\t\t\t\tcurve = unitArcAsBezier(alpha);\n\t\t\t\t\t\tstep  = sweep ? alpha : -alpha;\n\t\t\t\t\t\tangle = 0;\t// stop the loop\n\t\t\t\t\t}\n\t\t\t\t\tvar c2, e, M = m.normalize([elliptic_transform, m.rotate(startAngle + step)]);\n\t\t\t\t\tif(sweep){\n\t\t\t\t\t\tc1 = m.multiplyPoint(M, curve.c1);\n\t\t\t\t\t\tc2 = m.multiplyPoint(M, curve.c2);\n\t\t\t\t\t\te  = m.multiplyPoint(M, curve.e );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc1 = m.multiplyPoint(M, curve.c2);\n\t\t\t\t\t\tc2 = m.multiplyPoint(M, curve.c1);\n\t\t\t\t\t\te  = m.multiplyPoint(M, curve.s );\n\t\t\t\t\t}\n\t\t\t\t\t// draw the curve\n\t\t\t\t\tresult.push([c1.x, c1.y, c2.x, c2.y, e.x, e.y]);\n\t\t\t\t\tstartAngle += 2 * step;\n\t\t\t\t}\n\t\t\t\treturn result;\t// Array\n\t\t\t}\n\t\t};\n\t\t\n\t\treturn arc;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 173 */\n/*!*********************************!*\\\n  !*** ../dojox/gfx/decompose.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./matrix */ 170)], __WEBPACK_AMD_DEFINE_RESULT__ = function (g, lang, m){\n\t\tfunction eq(/* Number */ a, /* Number */ b){\n\t\t\t// summary:\n\t\t\t//\t\tcompare two FP numbers for equality\n\t\t\treturn Math.abs(a - b) <= 1e-6 * (Math.abs(a) + Math.abs(b));\t// Boolean\n\t\t}\n\t\n\t\tfunction calcFromValues(/* Number */ r1, /* Number */ m1, /* Number */ r2, /* Number */ m2){\n\t\t\t// summary:\n\t\t\t//\t\tuses two close FP ration and their original magnitudes to approximate the result\n\t\t\tif(!isFinite(r1)){\n\t\t\t\treturn r2;\t// Number\n\t\t\t}else if(!isFinite(r2)){\n\t\t\t\treturn r1;\t// Number\n\t\t\t}\n\t\t\tm1 = Math.abs(m1); m2 = Math.abs(m2);\n\t\t\treturn (m1 * r1 + m2 * r2) / (m1 + m2);\t// Number\n\t\t}\n\t\n\t\tfunction transpose(matrix){\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object\n\t\t\tvar M = new m.Matrix2D(matrix);\n\t\t\treturn lang.mixin(M, {dx: 0, dy: 0, xy: M.yx, yx: M.xy});\t// dojox/gfx/matrix.Matrix2D\n\t\t}\n\t\n\t\tfunction scaleSign(/* dojox/gfx/matrix.Matrix2D */ matrix){\n\t\t\treturn (matrix.xx * matrix.yy < 0 || matrix.xy * matrix.yx > 0) ? -1 : 1;\t// Number\n\t\t}\n\t\n\t\tfunction eigenvalueDecomposition(matrix){\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object\n\t\t\tvar M = m.normalize(matrix),\n\t\t\t\tb = -M.xx - M.yy,\n\t\t\t\tc = M.xx * M.yy - M.xy * M.yx,\n\t\t\t\td = Math.sqrt(b * b - 4 * c),\n\t\t\t\tl1 = -(b + (b < 0 ? -d : d)) / 2,\n\t\t\t\tl2 = c / l1,\n\t\t\t\tvx1 = M.xy / (l1 - M.xx), vy1 = 1,\n\t\t\t\tvx2 = M.xy / (l2 - M.xx), vy2 = 1;\n\t\t\tif(eq(l1, l2)){\n\t\t\t\tvx1 = 1, vy1 = 0, vx2 = 0, vy2 = 1;\n\t\t\t}\n\t\t\tif(!isFinite(vx1)){\n\t\t\t\tvx1 = 1, vy1 = (l1 - M.xx) / M.xy;\n\t\t\t\tif(!isFinite(vy1)){\n\t\t\t\t\tvx1 = (l1 - M.yy) / M.yx, vy1 = 1;\n\t\t\t\t\tif(!isFinite(vx1)){\n\t\t\t\t\t\tvx1 = 1, vy1 = M.yx / (l1 - M.yy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isFinite(vx2)){\n\t\t\t\tvx2 = 1, vy2 = (l2 - M.xx) / M.xy;\n\t\t\t\tif(!isFinite(vy2)){\n\t\t\t\t\tvx2 = (l2 - M.yy) / M.yx, vy2 = 1;\n\t\t\t\t\tif(!isFinite(vx2)){\n\t\t\t\t\t\tvx2 = 1, vy2 = M.yx / (l2 - M.yy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar d1 = Math.sqrt(vx1 * vx1 + vy1 * vy1),\n\t\t\t\td2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\tif(!isFinite(vx1 /= d1)){ vx1 = 0; }\n\t\t\tif(!isFinite(vy1 /= d1)){ vy1 = 0; }\n\t\t\tif(!isFinite(vx2 /= d2)){ vx2 = 0; }\n\t\t\tif(!isFinite(vy2 /= d2)){ vy2 = 0; }\n\t\t\treturn {\t// Object\n\t\t\t\tvalue1: l1,\n\t\t\t\tvalue2: l2,\n\t\t\t\tvector1: {x: vx1, y: vy1},\n\t\t\t\tvector2: {x: vx2, y: vy2}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction decomposeSR(/* dojox/gfx/matrix.Matrix2D */ M, /* Object */ result){\n\t\t\t// summary:\n\t\t\t//\t\tdecomposes a matrix into [scale, rotate]; no checks are done.\n\t\t\tvar sign = scaleSign(M),\n\t\t\t\ta = result.angle1 = (Math.atan2(M.yx, M.yy) + Math.atan2(-sign * M.xy, sign * M.xx)) / 2,\n\t\t\t\tcos = Math.cos(a), sin = Math.sin(a);\n\t\t\tresult.sx = calcFromValues(M.xx / cos, cos, -M.xy / sin, sin);\n\t\t\tresult.sy = calcFromValues(M.yy / cos, cos,  M.yx / sin, sin);\n\t\t\treturn result;\t// Object\n\t\t}\n\t\n\t\tfunction decomposeRS(/* dojox/gfx/matrix.Matrix2D */ M, /* Object */ result){\n\t\t\t// summary:\n\t\t\t//\t\tdecomposes a matrix into [rotate, scale]; no checks are done\n\t\t\tvar sign = scaleSign(M),\n\t\t\t\ta = result.angle2 = (Math.atan2(sign * M.yx, sign * M.xx) + Math.atan2(-M.xy, M.yy)) / 2,\n\t\t\t\tcos = Math.cos(a), sin = Math.sin(a);\n\t\t\tresult.sx = calcFromValues(M.xx / cos, cos,  M.yx / sin, sin);\n\t\t\tresult.sy = calcFromValues(M.yy / cos, cos, -M.xy / sin, sin);\n\t\t\treturn result;\t// Object\n\t\t}\n\t\n\t\treturn g.decompose = function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tDecompose a 2D matrix into translation, scaling, and rotation components.\n\t\t\t// description:\n\t\t\t//\t\tThis function decompose a matrix into four logical components:\n\t\t\t//\t\ttranslation, rotation, scaling, and one more rotation using SVD.\n\t\t\t//\t\tThe components should be applied in following order:\n\t\t\t//\t| [translate, rotate(angle2), scale, rotate(angle1)]\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object\n\t\t\tvar M = m.normalize(matrix),\n\t\t\t\tresult = {dx: M.dx, dy: M.dy, sx: 1, sy: 1, angle1: 0, angle2: 0};\n\t\t\t// detect case: [scale]\n\t\t\tif(eq(M.xy, 0) && eq(M.yx, 0)){\n\t\t\t\treturn lang.mixin(result, {sx: M.xx, sy: M.yy});\t// Object\n\t\t\t}\n\t\t\t// detect case: [scale, rotate]\n\t\t\tif(eq(M.xx * M.yx, -M.xy * M.yy)){\n\t\t\t\treturn decomposeSR(M, result);\t// Object\n\t\t\t}\n\t\t\t// detect case: [rotate, scale]\n\t\t\tif(eq(M.xx * M.xy, -M.yx * M.yy)){\n\t\t\t\treturn decomposeRS(M, result);\t// Object\n\t\t\t}\n\t\t\t// do SVD\n\t\t\tvar\tMT = transpose(M),\n\t\t\t\tu  = eigenvalueDecomposition([M, MT]),\n\t\t\t\tv  = eigenvalueDecomposition([MT, M]),\n\t\t\t\tU  = new m.Matrix2D({xx: u.vector1.x, xy: u.vector2.x, yx: u.vector1.y, yy: u.vector2.y}),\n\t\t\t\tVT = new m.Matrix2D({xx: v.vector1.x, xy: v.vector1.y, yx: v.vector2.x, yy: v.vector2.y}),\n\t\t\t\tS = new m.Matrix2D([m.invert(U), M, m.invert(VT)]);\n\t\t\tdecomposeSR(VT, result);\n\t\t\tS.xx *= result.sx;\n\t\t\tS.yy *= result.sy;\n\t\t\tdecomposeRS(U, result);\n\t\t\tS.xx *= result.sx;\n\t\t\tS.yy *= result.sy;\n\t\t\treturn lang.mixin(result, {sx: S.xx, sy: S.yy});\t// Object\n\t\t};\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 174 */\n/*!***********************************!*\\\n  !*** ../dojox/gfx/bezierutils.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t\t__webpack_require__(/*! ./_base */ 167)\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function(gfx){\n\t\n\t\tvar bu = gfx.bezierutils = {},\n\t\t\terror = 0.1;\n\t\n\t\tvar tAtLength = bu.tAtLength = function(points, length){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the t corresponding to the given length for the specified bezier curve.\n\t\t\t// points: Number[]\n\t\t\t//\t\tThe bezier points. Should be [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y] for a cubic\n\t\t\t//\t\tbezier curve or [p1x, p1y, cx, cy, p2x, p2y] for a quadratic bezier curve.\n\t\t\t// length: Number\n\t\t\t//\t\tThe length.\n\t\t\tvar t = 0,\n\t\t\t\tquadratic = points.length == 6,\n\t\t\t\tcurrentLen = 0,\n\t\t\t\tsplitCount = 0,\n\t\t\t\tsplitFunc = quadratic ? splitQBezierAtT : splitBezierAtT;\n\t\t\tvar _compute = function(p, error){\n\t\t\t\t// control points polygon length\n\t\t\t\tvar pLen = 0;\n\t\t\t\tfor(var i = 0; i < p.length-2; i+=2)\n\t\t\t\t\tpLen += distance(p[i],p[i+1],p[i+2],p[i+3]);\n\t\t\t\t// chord length\n\t\t\t\tvar chord = quadratic ?\n\t\t\t\t\tdistance(points[0],points[1],points[4],points[5]) :\n\t\t\t\t\tdistance(points[0],points[1],points[6],points[7]);\n\t\t\t\t// if needs more approx. or if currentLen is greater than the target length,\n\t\t\t\t// split the curve one more time\n\t\t\t\tif(pLen - chord > error || currentLen + pLen > length + error){\n\t\t\t\t\t++splitCount;\n\t\t\t\t\tvar newbezier = splitFunc(p, .5);\n\t\t\t\t\t// check 1st subpath\n\t\t\t\t\t_compute(newbezier[0], error);\n\t\t\t\t\t// the 1st subcurve was the good one, we stop\n\t\t\t\t\tif(Math.abs(currentLen - length) <= error){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// need to continue with the 2nde subcurve\n\t\t\t\t\t_compute(newbezier[1], error);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tcurrentLen += pLen;\n\t\t\t\tt += 1.0 / (1 << splitCount);\n\t\t\t};\n\t\t\tif(length)\n\t\t\t\t_compute(points, 0.5);\n\t\t\treturn t;\n\t\t};\n\t\n\t\tvar computeLength = bu.computeLength = function(/*Array*/points){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the length of the given bezier curve.\n\t\t\t// points: Number[]\n\t\t\t//\t\tThe bezier points. Should be [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y] for a cubic\n\t\t\t//\t\tbezier curve or [p1x, p1y, cx, cy, p2x, p2y] for a quadratic bezier curve.\n\t\n\t\t\tvar quadratic = points.length == 6, pLen=0;\n\t\t\t// control points polygon length\n\t\t\tfor(var i = 0; i < points.length-2; i+=2)\n\t\t\t\tpLen += distance(points[i],points[i+1],points[i+2],points[i+3]);\n\t\t\t// chord length\n\t\t\tvar chord = quadratic ?\n\t\t\t\tdistance(points[0],points[1],points[4],points[5]) :\n\t\t\t\tdistance(points[0],points[1],points[6],points[7]);\n\t\t\t// split polygons until the polygon and the chord are \"the same\"\n\t\t\tif(pLen-chord>error){\n\t\t\t\tvar newBeziers = quadratic ? splitQBezierAtT(points,.5) : splitCBezierAtT(points,.5);\n\t\t\t\tvar length = computeLength(newBeziers[0], quadratic);\n\t\t\t\tlength += computeLength(newBeziers[1], quadratic);\n\t\t\t\treturn length;\n\t\t\t}\n\t\t\t// pLen is close enough, done.\n\t\t\treturn pLen;\n\t\t};\n\t\n\t\tvar distance = bu.distance = function(x1, y1, x2, y2){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the distance between the specified points.\n\t\t\treturn Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\t\t};\n\t\n\t\tvar splitQBezierAtT = function(points, t){\n\t\t\t// summary:\n\t\t\t//\t\tSplit a quadratic bezier curve into 2 sub-quadratic beziers at the specified t.\n\t\n\t\t\t// de Casteljau\n\t\t\tvar r = 1-t,\n\t\t\t\tr2 = r*r,\n\t\t\t\tt2 = t*t,\n\t\t\t\tp1x = points[0],\n\t\t\t\tp1y = points[1],\n\t\t\t\tcx = points[2],\n\t\t\t\tcy = points[3],\n\t\t\t\tp2x = points[4],\n\t\t\t\tp2y = points[5],\n\t\n\t\t\t\tax = r*p1x + t*cx,\n\t\t\t\tay = r*p1y + t*cy,\n\t\t\t\tbx = r*cx + t*p2x,\n\t\t\t\tby = r*cy + t*p2y,\n\t\t\t\tpx = r2*p1x + 2*r*t*cx + t2*p2x,\n\t\t\t\tpy = r2*p1y + 2*r*t*cy + t2*p2y;\n\t\n\t\t\treturn [\n\t\t\t\t[\n\t\t\t\t\tp1x, p1y,\n\t\t\t\t\tax, ay,\n\t\t\t\t\tpx, py\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\tpx, py,\n\t\t\t\t\tbx, by,\n\t\t\t\t\tp2x, p2y\n\t\t\t\t]\n\t\t\t];\n\t\t};\n\t\n\t\tvar splitCBezierAtT = function(points, t){\n\t\t\t// summary:\n\t\t\t//\t\tSplit a cubic bezier curve into 2 sub-cubic beziers at the specified t.\n\t\n\t\t\t// de Casteljau\n\t\t\tvar r = 1-t,\n\t\t\t\tr2 = r*r,\n\t\t\t\tr3 = r2*r,\n\t\t\t\tt2 = t*t,\n\t\t\t\tt3 = t2*t,\n\t\t\t\tp1x = points[0],\n\t\t\t\tp1y = points[1],\n\t\t\t\tc1x = points[2],\n\t\t\t\tc1y = points[3],\n\t\t\t\tc2x = points[4],\n\t\t\t\tc2y = points[5],\n\t\t\t\tp2x = points[6],\n\t\t\t\tp2y = points[7],\n\t\n\t\t\t\tax = r*p1x + t*c1x,\n\t\t\t\tay = r*p1y + t*c1y,\n\t\t\t\tcx = r*c2x + t*p2x,\n\t\t\t\tcy = r*c2y + t*p2y,\n\t\t\t\tmx = r2*p1x + 2*r*t*c1x + t2*c2x,\n\t\t\t\tmy = r2*p1y + 2*r*t*c1y + t2*c2y,\n\t\t\t\tnx = r2*c1x + 2*r*t*c2x + t2*p2x,\n\t\t\t\tny = r2*c1y + 2*r*t*c2y + t2*p2y,\n\t\t\t\tpx = r3*p1x + 3*r2*t*c1x + 3*r*t2*c2x+t3*p2x,\n\t\t\t\tpy = r3*p1y + 3*r2*t*c1y + 3*r*t2*c2y+t3*p2y;\n\t\n\t\t\treturn [\n\t\t\t\t[\n\t\t\t\t\tp1x, p1y,\n\t\t\t\t\tax, ay,\n\t\t\t\t\tmx, my,\n\t\t\t\t\tpx, py\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\tpx, py,\n\t\t\t\t\tnx, ny,\n\t\t\t\t\tcx, cy,\n\t\t\t\t\tp2x, p2y\n\t\t\t\t]\n\t\t\t];\n\t\t};\n\t\n\t\tvar splitBezierAtT = bu.splitBezierAtT = function(points, t){\n\t\t\treturn points.length == 6 ? splitQBezierAtT(points, t) : splitCBezierAtT(points, t);\n\t\t};\n\t\treturn bu;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 175 */\n/*!***********************************!*\\\n  !*** ../dojox/lang/functional.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./functional/lambda */ 176), __webpack_require__(/*! ./functional/array */ 178), __webpack_require__(/*! ./functional/object */ 179)], __WEBPACK_AMD_DEFINE_RESULT__ = function(df){\n\t\treturn df;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 176 */\n/*!******************************************!*\\\n  !*** ../dojox/lang/functional/lambda.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../.. */ 177), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojox, lang, arr){\n\t\tvar df = lang.getObject(\"lang.functional\", true, dojox);\n\t\n\t// This module adds high-level functions and related constructs:\n\t//\t- anonymous functions built from the string\n\t\n\t// Acknowledgements:\n\t//\t- lambda() is based on work by Oliver Steele\n\t//\t\t(http://osteele.com/sources/javascript/functional/functional.js)\n\t//\t\twhich was published under MIT License\n\t\n\t// Notes:\n\t//\t- lambda() produces functions, which after the compilation step are\n\t//\t\tas fast as regular JS functions (at least theoretically).\n\t\n\t// Lambda input values:\n\t//\t- returns functions unchanged\n\t//\t- converts strings to functions\n\t//\t- converts arrays to a functional composition\n\t\n\t\tvar lcache = {};\n\t\n\t\t// split() is augmented on IE6 to ensure the uniform behavior\n\t\tvar split = \"ab\".split(/a*/).length > 1 ? String.prototype.split :\n\t\t\t\tfunction(sep){\n\t\t\t\t\t var r = this.split.call(this, sep),\n\t\t\t\t\t\t m = sep.exec(this);\n\t\t\t\t\t if(m && m.index == 0){ r.unshift(\"\"); }\n\t\t\t\t\t return r;\n\t\t\t\t};\n\t\t\t\t\n\t\tvar lambda = function(/*String*/ s){\n\t\t\tvar args = [], sects = split.call(s, /\\s*->\\s*/m);\n\t\t\tif(sects.length > 1){\n\t\t\t\twhile(sects.length){\n\t\t\t\t\ts = sects.pop();\n\t\t\t\t\targs = sects.pop().split(/\\s*,\\s*|\\s+/m);\n\t\t\t\t\tif(sects.length){ sects.push(\"(function(\" + args.join(\", \") + \"){ return (\" + s + \"); })\"); }\n\t\t\t\t}\n\t\t\t}else if(s.match(/\\b_\\b/)){\n\t\t\t\targs = [\"_\"];\n\t\t\t}else{\n\t\t\t\tvar l = s.match(/^\\s*(?:[+*\\/%&|\\^\\.=<>]|!=)/m),\n\t\t\t\t\tr = s.match(/[+\\-*\\/%&|\\^\\.=<>!]\\s*$/m);\n\t\t\t\tif(l || r){\n\t\t\t\t\tif(l){\n\t\t\t\t\t\targs.push(\"$1\");\n\t\t\t\t\t\ts = \"$1\" + s;\n\t\t\t\t\t}\n\t\t\t\t\tif(r){\n\t\t\t\t\t\targs.push(\"$2\");\n\t\t\t\t\t\ts = s + \"$2\";\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// the point of the long regex below is to exclude all well-known\n\t\t\t\t\t// lower-case words from the list of potential arguments\n\t\t\t\t\tvar vars = s.\n\t\t\t\t\t\treplace(/(?:\\b[A-Z]|\\.[a-zA-Z_$])[a-zA-Z_$\\d]*|[a-zA-Z_$][a-zA-Z_$\\d]*:|this|true|false|null|undefined|typeof|instanceof|in|delete|new|void|arguments|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape|dojo|dijit|dojox|window|document|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"/g, \"\").\n\t\t\t\t\t\tmatch(/([a-z_$][a-z_$\\d]*)/gi) || [], t = {};\n\t\t\t\t\tarr.forEach(vars, function(v){\n\t\t\t\t\t\tif(!t.hasOwnProperty(v)){\n\t\t\t\t\t\t\targs.push(v);\n\t\t\t\t\t\t\tt[v] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {args: args, body: s};\t// Object\n\t\t};\n\t\n\t\tvar compose = function(/*Array*/ a){\n\t\t\treturn a.length ?\n\t\t\t\t\t\tfunction(){\n\t\t\t\t\t\t\tvar i = a.length - 1, x = df.lambda(a[i]).apply(this, arguments);\n\t\t\t\t\t\t\tfor(--i; i >= 0; --i){ x = df.lambda(a[i]).call(this, x); }\n\t\t\t\t\t\t\treturn x;\n\t\t\t\t\t\t}\n\t\t\t\t\t:\n\t\t\t\t\t\t// identity\n\t\t\t\t\t\tfunction(x){ return x; };\n\t\t};\n\t\n\t\tlang.mixin(df, {\n\t\t\t// lambda\n\t\t\trawLambda: function(/*String*/ s){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\n\t\t\t\t//\t\treturns an object describing the function; functions are\n\t\t\t\t//\t\tpassed through unmodified.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThis method is to normalize a functional representation (a\n\t\t\t\t//\t\ttext snippet) to an object that contains an array of\n\t\t\t\t//\t\targuments, and a body , which is used to calculate the\n\t\t\t\t//\t\treturning value.\n\t\t\t\treturn lambda(s);\t// Object\n\t\t\t},\n\t\t\tbuildLambda: function(/*String*/ s){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tbuilds a function from a snippet, returns a string, which\n\t\t\t\t//\t\trepresents the function.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThis method returns a textual representation of a function\n\t\t\t\t//\t\tbuilt from the snippet. It is meant to be evaled in the\n\t\t\t\t//\t\tproper context, so local variables can be pulled from the\n\t\t\t\t//\t\tenvironment.\n\t\t\t\tvar l = lambda(s);\n\t\t\t\treturn \"function(\" + l.args.join(\",\") + \"){return (\" + l.body + \");}\";\t// String\n\t\t\t},\n\t\t\tlambda: function(/*Function|String|Array*/ s){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\n\t\t\t\t//\t\treturns a function object; functions are passed through\n\t\t\t\t//\t\tunmodified.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThis method is used to normalize a functional\n\t\t\t\t//\t\trepresentation (a text snippet, an array, or a function) to\n\t\t\t\t//\t\ta function object.\n\t\t\t\tif(typeof s == \"function\"){ return s; }\n\t\t\t\tif(s instanceof Array){ return compose(s); }\n\t\t\t\tif(lcache.hasOwnProperty(s)){ return lcache[s]; }\n\t\t\t\tvar l = lambda(s);\n\t\t\t\treturn lcache[s] = new Function(l.args, \"return (\" + l.body + \");\");\t// Function\n\t\t\t},\n\t\t\tclearLambdaCache: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tclears internal cache of lambdas\n\t\t\t\tlcache = {};\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn df;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 177 */\n/*!************************!*\\\n  !*** ../dojox/main.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ 4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo) {\n\t\t// module:\n\t\t//\t\tdojox/main\n\t\n\t\t/*=====\n\t\treturn {\n\t\t\t// summary:\n\t\t\t//\t\tThe dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.\n\t\t\t//\t\tApps should require modules from the dojox packages directly, rather than loading this module.\n\t\t};\n\t\t=====*/\n\t\n\t\treturn dojo.dojox;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 178 */\n/*!*****************************************!*\\\n  !*** ../dojox/lang/functional/array.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ 4), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! ./lambda */ 176)], __WEBPACK_AMD_DEFINE_RESULT__ = function(kernel, lang, arr, df){\n\t\n\t// This module adds high-level functions and related constructs:\n\t//\t- array-processing functions similar to standard JS functions\n\t\n\t// Notes:\n\t//\t- this module provides JS standard methods similar to high-level functions in dojo/_base/array.js:\n\t//\t\tforEach, map, filter, every, some\n\t\n\t// Defined methods:\n\t//\t- take any valid lambda argument as the functional argument\n\t//\t- operate on dense arrays\n\t//\t- take a string as the array argument\n\t//\t- take an iterator objects as the array argument\n\t\n\t\tvar empty = {};\n\t\n\t\tlang.mixin(df, {\n\t\t\t// JS 1.6 standard array functions, which can take a lambda as a parameter.\n\t\t\t// Consider using dojo._base.array functions, if you don't need the lambda support.\n\t\t\tfilter: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a new array with all elements that pass the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar t = [], v, i, n;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tfor(i = 0, n = a.length; i < n; ++i){\n\t\t\t\t\t\tv = a[i];\n\t\t\t\t\t\tif(f.call(o, v, i, a)){ t.push(v); }\n\t\t\t\t\t}\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tfor(i = 0; a.hasNext();){\n\t\t\t\t\t\tv = a.next();\n\t\t\t\t\t\tif(f.call(o, v, i++, a)){ t.push(v); }\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tv = a[i];\n\t\t\t\t\t\t\tif(f.call(o, v, i, a)){ t.push(v); }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn t;\t// Array\n\t\t\t},\n\t\t\tforEach: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\texecutes a provided function once per array element.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar i, n;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tfor(i = 0, n = a.length; i < n; f.call(o, a[i], i, a), ++i);\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tfor(i = 0; a.hasNext(); f.call(o, a.next(), i++, a));\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tf.call(o, a[i], i, a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn o;\t// Object\n\t\t\t},\n\t\t\tmap: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a new array with the results of calling\n\t\t\t\t//\t\ta provided function on every element in this array.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar t, n, i;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tt = new Array(n = a.length);\n\t\t\t\t\tfor(i = 0; i < n; t[i] = f.call(o, a[i], i, a), ++i);\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tt = [];\n\t\t\t\t\tfor(i = 0; a.hasNext(); t.push(f.call(o, a.next(), i++, a)));\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tt = [];\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tt.push(f.call(o, a[i], i, a));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn t;\t// Array\n\t\t\t},\n\t\t\tevery: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ttests whether all elements in the array pass the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar i, n;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tfor(i = 0, n = a.length; i < n; ++i){\n\t\t\t\t\t\tif(!f.call(o, a[i], i, a)){\n\t\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tfor(i = 0; a.hasNext();){\n\t\t\t\t\t\tif(!f.call(o, a.next(), i++, a)){\n\t\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tif(!f.call(o, a[i], i, a)){\n\t\t\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\t// Boolean\n\t\t\t},\n\t\t\tsome: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ttests whether some element in the array passes the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar i, n;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tfor(i = 0, n = a.length; i < n; ++i){\n\t\t\t\t\t\tif(f.call(o, a[i], i, a)){\n\t\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tfor(i = 0; a.hasNext();){\n\t\t\t\t\t\tif(f.call(o, a.next(), i++, a)){\n\t\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tif(f.call(o, a[i], i, a)){\n\t\t\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\t// Boolean\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn df;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 179 */\n/*!******************************************!*\\\n  !*** ../dojox/lang/functional/object.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ 4), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./lambda */ 176)], __WEBPACK_AMD_DEFINE_RESULT__ = function(kernel, lang, df){\n\t\n\t// This module adds high-level functions and related constructs:\n\t//\t- object/dictionary helpers\n\t\n\t// Defined methods:\n\t//\t- take any valid lambda argument as the functional argument\n\t//\t- skip all attributes that are present in the empty object\n\t//\t\t(IE and/or 3rd-party libraries).\n\t\n\t\tvar empty = {};\n\t\n\t\tlang.mixin(df, {\n\t\t\t// object helpers\n\t\t\tkeys: function(/*Object*/ obj){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns an array of all keys in the object\n\t\t\t\tvar t = [];\n\t\t\t\tfor(var i in obj){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tt.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\tt; // Array\n\t\t\t},\n\t\t\tvalues: function(/*Object*/ obj){\n\t\t\t\t// summary:\n\t\t\t\t//\t\treturns an array of all values in the object\n\t\t\t\tvar t = [];\n\t\t\t\tfor(var i in obj){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tt.push(obj[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\tt; // Array\n\t\t\t},\n\t\t\tfilterIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates new object with all attributes that pass the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar t = {}, v, i;\n\t\t\t\tfor(i in obj){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tv = obj[i];\n\t\t\t\t\t\tif(f.call(o, v, i, obj)){ t[i] = v; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn t;\t// Object\n\t\t\t},\n\t\t\tforIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\titerates over all object attributes.\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tfor(var i in obj){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tf.call(o, obj[i], i, obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn o;\t// Object\n\t\t\t},\n\t\t\tmapIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates new object with the results of calling\n\t\t\t\t//\t\ta provided function on every attribute in this object.\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar t = {}, i;\n\t\t\t\tfor(i in obj){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tt[i] = f.call(o, obj[i], i, obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn t;\t// Object\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn df;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 180 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/scaler/common.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){\n\t\n\t\tvar eq = function(/*Number*/ a, /*Number*/ b){\n\t\t\t// summary:\n\t\t\t//\t\tcompare two FP numbers for equality\n\t\t\treturn Math.abs(a - b) <= 1e-6 * (Math.abs(a) + Math.abs(b));\t// Boolean\n\t\t};\n\t\n\t\tvar common = lang.getObject(\"dojox.charting.scaler.common\", true);\n\t\n\t\tvar testedModules = {};\n\t\n\t\treturn lang.mixin(common, {\n\t\t\tdoIfLoaded: function(moduleName, ifloaded, ifnotloaded){\n\t\t\t\tif(testedModules[moduleName] === undefined){\n\t\t\t\t\ttry{\n\t\t\t\t\t\ttestedModules[moduleName] = require(moduleName);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\ttestedModules[moduleName] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(testedModules[moduleName]){\n\t\t\t\t\treturn ifloaded(testedModules[moduleName]);\n\t\t\t\t}else{\n\t\t\t\t\treturn ifnotloaded();\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetNumericLabel: function(/*Number*/ number, /*Number*/ precision, /*Object*/ kwArgs){\n\t\t\t\tvar def = \"\";\n\t\t\t\tcommon.doIfLoaded(\"dojo/number\", function(numberLib){\n\t\t\t\t\tdef = (kwArgs.fixed ? numberLib.format(number, {places : precision < 0 ? -precision : 0}) :\n\t\t\t\t\t\tnumberLib.format(number)) || \"\";\n\t\t\t\t}, function(){\n\t\t\t\t\tdef = kwArgs.fixed ? number.toFixed(precision < 0 ? -precision : 0) : number.toString();\n\t\t\t\t});\n\t\t\t\tif(kwArgs.labelFunc){\n\t\t\t\t\tvar r = kwArgs.labelFunc(def, number, precision);\n\t\t\t\t\tif(r){ return r; }\n\t\t\t\t\t// else fall through to the regular labels search\n\t\t\t\t}\n\t\t\t\tif(kwArgs.labels){\n\t\t\t\t\t// classic binary search\n\t\t\t\t\t// TODO: working only if the array is sorted per value should be better documented or sorted automatically\n\t\t\t\t\tvar l = kwArgs.labels, lo = 0, hi = l.length;\n\t\t\t\t\twhile(lo < hi){\n\t\t\t\t\t\tvar mid = Math.floor((lo + hi) / 2), val = l[mid].value;\n\t\t\t\t\t\tif(val < number){\n\t\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\thi = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// lets take into account FP errors\n\t\t\t\t\tif(lo < l.length && eq(l[lo].value, number)){\n\t\t\t\t\t\treturn l[lo].text;\n\t\t\t\t\t}\n\t\t\t\t\t--lo;\n\t\t\t\t\tif(lo >= 0 && lo < l.length && eq(l[lo].value, number)){\n\t\t\t\t\t\treturn l[lo].text;\n\t\t\t\t\t}\n\t\t\t\t\tlo += 2;\n\t\t\t\t\tif(lo < l.length && eq(l[lo].value, number)){\n\t\t\t\t\t\treturn l[lo].text;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise we will produce a number\n\t\t\t\t}\n\t\t\t\treturn def;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 181 */\n/*!*************************************************!*\\\n  !*** ../dojox/charting/plot2d/CartesianBase.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/connect */ 42), __webpack_require__(/*! dojo/has */ 5),\n\t\t\t__webpack_require__(/*! ./Base */ 182), __webpack_require__(/*! ../scaler/primitive */ 185), __webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/gfx/fx */ 186), __webpack_require__(/*! dojox/lang/utils */ 187)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, hub, has, Base, primitive, gfx, fx, du){\n\t\t/*=====\n\t\tdeclare(\"dojox.charting.plot2d.__CartesianCtorArgs\", dojox.charting.plot2d.__PlotCtorArgs, {\n\t\t\t// hAxis: String?\n\t\t\t//\t\tThe horizontal axis name.\n\t\t\thAxis: \"x\",\n\t\n\t\t\t// vAxis: String?\n\t\t\t//\t\tThe vertical axis name\n\t\t\tvAxis: \"y\",\n\t\n\t\t\t// labels: Boolean?\n\t\t\t//\t\tFor plots that support labels, whether or not to draw labels for each data item.  Default is false.\n\t\t\tlabels:\t\t\tfalse,\n\t\n\t\t\t// fixed: Boolean?\n\t        //\t\tWhether a fixed precision must be applied to data values for display. Default is true.\n\t\t\tfixed:\t\t\ttrue,\n\t\n\t\t\t// precision: Number?\n\t        //\t\tThe precision at which to round data values for display. Default is 0.\n\t\t\tprecision:\t\t1,\n\t\n\t\t\t// labelOffset: Number?\n\t\t\t//\t\tThe amount in pixels by which to offset labels when using \"outside\" labelStyle.  Default is 10.\n\t\t\tlabelOffset:\t10,\n\t\n\t\t\t// labelStyle: String?\n\t\t\t//\t\tOptions as to where to draw labels.  This must be either \"inside\" or \"outside\". By default\n\t\t\t//      the labels are drawn \"inside\" the shape representing the data point (a column rectangle for a Columns plot\n\t\t\t//      or a marker for a Line plot for instance). When \"outside\" is used the labels are drawn above the data point shape.\n\t\t\tlabelStyle:\t\t\"inside\",\n\t\n\t\t\t// htmlLabels: Boolean?\n\t\t\t//\t\tWhether or not to use HTML to render slice labels. Default is true.\n\t\t\thtmlLabels:\t\ttrue,\n\t\n\t\t\t// omitLabels: Boolean?\n\t\t\t//\t\tWhether labels that do not fit in an item render are omitted or not.\tThis applies only when labelStyle\n\t\t\t//\t\tis \"inside\".\tDefault is false.\n\t\t\tomitLabels: true,\n\t\n\t\t\t// labelFunc: Function?\n\t\t\t//\t\tAn optional function to use to compute label text. It takes precedence over\n\t\t\t//\t\tthe default text when available.\n\t\t\t//\t|\t\tfunction labelFunc(value, fixed, precision) {}\n\t\t\t//\t\t`value` is the data value to display\n\t\t\t//\t\t`fixed` is true if fixed precision must be applied.\n\t\t\t//\t\t`precision` is the requested precision to be applied.\n\t\t\tlabelFunc: null\n\t\t});\n\t\t=====*/\n\t\n\t\tvar alwaysFalse = function(){ return false; }\n\t\n\t\treturn declare(\"dojox.charting.plot2d.CartesianBase\", Base, {\n\t\t\tbaseParams: {\n\t\t\t\thAxis: \t\t\t\"x\",\n\t\t\t\tvAxis: \t\t\t\"y\",\n\t\t\t\tlabels:\t\t\tfalse,\n\t\t\t\tlabelOffset:    10,\n\t\t\t\tfixed:\t\t\ttrue,\n\t\t\t\tprecision:\t\t1,\n\t\t\t\tlabelStyle:\t\t\"inside\",\n\t\t\t\thtmlLabels:\t\ttrue,\t\t// use HTML to draw labels\n\t\t\t\tomitLabels:\t\ttrue,\n\t\t\t\tlabelFunc:\t\tnull\n\t        },\n\t\n\t\t\t// summary:\n\t\t\t//\t\tBase class for cartesian plot types.\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate a cartesian base plot for cartesian charts.\n\t\t\t\t// chart: dojox/chart/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__CartesianCtorArgs?\n\t\t\t\t//\t\tAn optional arguments object to help define the plot.\n\t\t\t\tthis.axes = [\"hAxis\", \"vAxis\"];\n\t\t\t\tthis.zoom = null;\n\t\t\t\tthis.zoomQueue = [];\t// zooming action task queue\n\t\t\t\tthis.lastWindow = {vscale: 1, hscale: 1, xoffset: 0, yoffset: 0};\n\t\t\t\tthis.hAxis = (kwArgs && kwArgs.hAxis) || \"x\";\n\t\t\t\tthis.vAxis = (kwArgs && kwArgs.vAxis) || \"y\";\n\t\t\t\tthis.series = [];\n\t\t\t\tthis.opt = lang.clone(this.baseParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tthis._hAxis = null;\n\t\t\t\tthis._vAxis = null;\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t\t},\n\t\t\tcleanGroup: function(creator, noClip){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tif(!noClip && this.chart._nativeClip){\n\t\t\t\t\tvar offsets = this.chart.offsets, dim = this.chart.dim;\n\t\t\t\t\tvar w = Math.max(0, dim.width  - offsets.l - offsets.r),\n\t\t\t\t\t\th = Math.max(0, dim.height - offsets.t - offsets.b);\n\t\t\t\t\tthis.group.setClip({ x: offsets.l, y: offsets.t, width: w, height: h });\n\t\t\t\t\tif(!this._clippedGroup){\n\t\t\t\t\t\tthis._clippedGroup = this.group.createGroup();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpurgeGroup: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tthis._clippedGroup = null;\n\t\t\t},\n\t\t\tgetGroup: function(){\n\t\t\t\treturn this._clippedGroup || this.group;\n\t\t\t},\n\t\t\tsetAxis: function(axis){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet an axis for this plot.\n\t\t\t\t// axis: dojox/charting/axis2d/Base\n\t\t\t\t//\t\tThe axis to set.\n\t\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(axis){\n\t\t\t\t\tthis[axis.vertical ? \"_vAxis\" : \"_hAxis\"] = axis;\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t\t},\n\t\t\ttoPage: function(coord){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCompute page coordinates from plot axis data coordinates.\n\t\t\t\t// coord: Object?\n\t\t\t\t//\t\tThe coordinates in plot axis data coordinate space. For cartesian charts that is of the following form:\n\t\t\t\t//\t\t`{ hAxisName: 50, vAxisName: 200 }`\n\t\t\t\t//\t\tIf not provided return the transform method instead of the result of the transformation.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tThe resulting page pixel coordinates. That is of the following form:\n\t\t\t\t//\t\t`{ x: 50, y: 200 }`\n\t\t\t\tvar ah = this._hAxis, av = this._vAxis,\n\t\t\t\t\tsh = ah.getScaler(), sv = av.getScaler(),\n\t\t\t\t\tth = sh.scaler.getTransformerFromModel(sh),\n\t\t\t\t\ttv = sv.scaler.getTransformerFromModel(sv),\n\t\t\t\t\tc = this.chart.getCoords(),\n\t\t\t\t\to = this.chart.offsets, dim = this.chart.dim;\n\t\t\t\tvar t = function(coord){\n\t\t\t\t\tvar r = {};\n\t\t\t\t\tr.x = th(coord[ah.name]) + c.x + o.l;\n\t\t\t\t\tr.y = c.y + dim.height - o.b - tv(coord[av.name]);\n\t\t\t\t\treturn r;\n\t\t\t\t};\n\t\t\t\t// if no coord return the function so that we can capture the current transforms\n\t\t\t\t// and reuse them later on\n\t\t\t\treturn coord?t(coord):t; // Object\n\t\t\t},\n\t\t\ttoData: function(coord){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCompute plot axis data coordinates from page coordinates.\n\t\t\t\t// coord: Object\n\t\t\t\t//\t\tThe pixel coordinate in page coordinate space. That is of the following form:\n\t\t\t\t//\t\t`{ x: 50, y: 200 }`\n\t\t\t\t//\t\tIf not provided return the tranform method instead of the result of the transformation.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tThe resulting plot axis data coordinates. For cartesian charts that is of the following form:\n\t\t\t\t//\t\t`{ hAxisName: 50, vAxisName: 200 }`\n\t\t\t\tvar ah = this._hAxis, av = this._vAxis,\n\t\t\t\t\tsh = ah.getScaler(), sv = av.getScaler(),\n\t\t\t\t\tth = sh.scaler.getTransformerFromPlot(sh),\n\t\t\t\t\ttv = sv.scaler.getTransformerFromPlot(sv),\n\t\t\t\t\tc = this.chart.getCoords(),\n\t\t\t\t\to = this.chart.offsets, dim = this.chart.dim;\n\t\t\t\tvar t = function(coord){\n\t\t\t\t\tvar r = {};\n\t\t\t\t\tr[ah.name] = th(coord.x - c.x - o.l);\n\t\t\t\t\tr[av.name] = tv(c.y + dim.height - coord.y  - o.b);\n\t\t\t\t\treturn r;\n\t\t\t\t};\n\t\t\t\t// if no coord return the function so that we can capture the current transforms\n\t\t\t\t// and reuse them later on\n\t\t\t\treturn coord?t(coord):t; // Object\n\t\t\t},\n\t\t\tisDirty: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns whether or not this plot needs to be rendered.\n\t\t\t\t// returns: Boolean\n\t\t\t\t//\t\tThe state of the plot.\n\t\t\t\treturn this.dirty || this._hAxis && this._hAxis.dirty || this._vAxis && this._vAxis.dirty;\t//\tBoolean\n\t\t\t},\n\t\t\tcreateLabel: function(group, value, bbox, theme){\n\t\t\t\tif(this.opt.labels){\n\t\t\t\t\tvar x, y, label = this.opt.labelFunc?this.opt.labelFunc.apply(this, [value, this.opt.fixed, this.opt.precision]):\n\t\t\t\t\t\tthis._getLabel(isNaN(value.y)?value:value.y);\n\t\t\t\t\tif(this.opt.labelStyle == \"inside\"){\n\t\t\t\t\t\tvar lbox = gfx._base._getTextBox(label, { font: theme.series.font } );\n\t\t\t\t\t\tx = bbox.x + bbox.width / 2;\n\t\t\t\t\t\ty = bbox.y + bbox.height / 2 + lbox.h / 4;\n\t\t\t\t\t\tif(lbox.w > bbox.width || lbox.h > bbox.height){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\tx = bbox.x + bbox.width / 2;\n\t\t\t\t\t\ty = bbox.y - this.opt.labelOffset;\n\t\t\t\t\t}\n\t\t\t\t\tthis.renderLabel(group, x, y, label, theme, this.opt.labelStyle == \"inside\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tperformZoom: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate/alter any zooming windows on this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\n\t\t\t\t// get current zooming various\n\t\t\t\tvar vs = this._vAxis.scale || 1,\n\t\t\t\t\ths = this._hAxis.scale || 1,\n\t\t\t\t\tvOffset = dim.height - offsets.b,\n\t\t\t\t\thBounds = this._hScaler.bounds,\n\t\t\t\t\txOffset = (hBounds.from - hBounds.lower) * hBounds.scale,\n\t\t\t\t\tvBounds = this._vScaler.bounds,\n\t\t\t\t\tyOffset = (vBounds.from - vBounds.lower) * vBounds.scale,\n\t\t\t\t\t// get incremental zooming various\n\t\t\t\t\trVScale = vs / this.lastWindow.vscale,\n\t\t\t\t\trHScale = hs / this.lastWindow.hscale,\n\t\t\t\t\trXOffset = (this.lastWindow.xoffset - xOffset)/\n\t\t\t\t\t\t((this.lastWindow.hscale == 1)? hs : this.lastWindow.hscale),\n\t\t\t\t\trYOffset = (yOffset - this.lastWindow.yoffset)/\n\t\t\t\t\t\t((this.lastWindow.vscale == 1)? vs : this.lastWindow.vscale),\n\t\n\t\t\t\t\tshape = this.getGroup(),\n\t\t\t\t\tanim = fx.animateTransform(lang.delegate({\n\t\t\t\t\t\tshape: shape,\n\t\t\t\t\t\tduration: 1200,\n\t\t\t\t\t\ttransform:[\n\t\t\t\t\t\t\t{name:\"translate\", start:[0, 0], end: [offsets.l * (1 - rHScale), vOffset * (1 - rVScale)]},\n\t\t\t\t\t\t\t{name:\"scale\", start:[1, 1], end: [rHScale, rVScale]},\n\t\t\t\t\t\t\t{name:\"original\"},\n\t\t\t\t\t\t\t{name:\"translate\", start: [0, 0], end: [rXOffset, rYOffset]}\n\t\t\t\t\t\t]}, this.zoom));\n\t\n\t\t\t\tlang.mixin(this.lastWindow, {vscale: vs, hscale: hs, xoffset: xOffset, yoffset: yOffset});\n\t\t\t\t//add anim to zooming action queue,\n\t\t\t\t//in order to avoid several zooming action happened at the same time\n\t\t\t\tthis.zoomQueue.push(anim);\n\t\t\t\t//perform each anim one by one in zoomQueue\n\t\t\t\thub.connect(anim, \"onEnd\", this, function(){\n\t\t\t\t\tthis.zoom = null;\n\t\t\t\t\tthis.zoomQueue.shift();\n\t\t\t\t\tif(this.zoomQueue.length > 0){\n\t\t\t\t\t\tthis.zoomQueue[0].play();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(this.zoomQueue.length == 1){\n\t\t\t\t\tthis.zoomQueue[0].play();\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t\t},\n\t\t\tinitializeScalers: function(dim, stats){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tInitializes scalers using attached axes.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tSize of a plot area in pixels as {width, height}.\n\t\t\t\t// stats: Object\n\t\t\t\t//\t\tMin/max of data in both directions as {hmin, hmax, vmin, vmax}.\n\t\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this._hAxis){\n\t\t\t\t\tif(!this._hAxis.initialized()){\n\t\t\t\t\t\tthis._hAxis.calculate(stats.hmin, stats.hmax, dim.width);\n\t\t\t\t\t}\n\t\t\t\t\tthis._hScaler = this._hAxis.getScaler();\n\t\t\t\t}else{\n\t\t\t\t\tthis._hScaler = primitive.buildScaler(stats.hmin, stats.hmax, dim.width);\n\t\t\t\t}\n\t\t\t\tif(this._vAxis){\n\t\t\t\t\tif(!this._vAxis.initialized()){\n\t\t\t\t\t\tthis._vAxis.calculate(stats.vmin, stats.vmax, dim.height);\n\t\t\t\t\t}\n\t\t\t\t\tthis._vScaler = this._vAxis.getScaler();\n\t\t\t\t}else{\n\t\t\t\t\tthis._vScaler = primitive.buildScaler(stats.vmin, stats.vmax, dim.height);\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t\t},\n\t\t\tisNullValue: function(value){\n\t\t\t\tif(value === null || typeof value == \"undefined\"){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar h = this._hAxis ? this._hAxis.isNullValue : alwaysFalse,\n\t\t\t\t\tv = this._vAxis ? this._vAxis.isNullValue : alwaysFalse;\n\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\treturn h(1) || v(value);\n\t\t\t\t}\n\t\t\t\treturn h(isNaN(value.x) ? 1 : value.x) || value.y === null || v(value.y);\n\t\t\t}\t\t\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 182 */\n/*!****************************************!*\\\n  !*** ../dojox/charting/plot2d/Base.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojox/gfx */ 166),\n\t\t\t__webpack_require__(/*! ../Element */ 183), __webpack_require__(/*! ./common */ 165), __webpack_require__(/*! ../axis2d/common */ 184), __webpack_require__(/*! dojo/has */ 5)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, arr, lang, gfx, Element, common, ac, has){\n\t/*=====\n\tdojox.charting.plot2d.__PlotCtorArgs = {\n\t\t// summary:\n\t\t//\t\tThe base keyword arguments object for plot constructors.\n\t\t//\t\tNote that the parameters for this may change based on the\n\t\t//\t\tspecific plot type (see the corresponding plot type for\n\t\t//\t\tdetails).\n\t\n\t\t// tooltipFunc: Function?\n\t\t//\t\tAn optional function used to compute tooltip text for this plot. It takes precedence over\n\t\t//\t\tthe default function when available.\n\t\t//\t|\t\tfunction tooltipFunc(o) { return \"text\"; }\n\t\t//\t\t`o`is the event object that triggered the tooltip.\n\t\ttooltipFunc: null\n\t};\n\t=====*/\n\t\tvar Base = declare(\"dojox.charting.plot2d.Base\", Element, {\n\t\t\t// summary:\n\t\t\t//\t\tBase class for all plot types.\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate a base plot for charting.\n\t\t\t\t// chart: dojox/chart/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__PlotCtorArgs?\n\t\t\t\t//\t\tAn optional arguments object to help define the plot.\n\t\t\n\t\t\t\t// TODO does not work in markup\n\t\t\t\tif(kwArgs && kwArgs.tooltipFunc){\n\t\t\t\t\tthis.tooltipFunc = kwArgs.tooltipFunc;\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t\t// returns: dojox.charting.plot2d.Base\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.series = [];\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t\t},\n\t\t\tsetAxis: function(axis){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet an axis for this plot.\n\t\t\t\t// axis: dojox.charting.axis2d.Base\n\t\t\t\t//\t\tThe axis to set.\n\t\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t\t},\n\t\t\tassignAxes: function(axes){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tFrom an array of axes pick the ones that correspond to this plot and\n\t\t\t\t//\t\tassign them to the plot using setAxis method.\n\t\t\t\t// axes: Array\n\t\t\t\t//\t\tAn array of dojox/charting/axis2d/Base\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprotected\n\t\t\t\tarr.forEach(this.axes, function(axis){\n\t\t\t\t\tif(this[axis]){\n\t\t\t\t\t\tthis.setAxis(axes[this[axis]]);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t},\n\t\t\taddSeries: function(run){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAdd a data series to this plot.\n\t\t\t\t// run: dojox.charting.Series\n\t\t\t\t//\t\tThe series to be added.\n\t\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.series.push(run);\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t\t},\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\treturn common.collectSimpleStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\t},\n\t\t\tcalculateAxes: function(dim){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tStub function for running the axis calculations (deprecated).\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }\n\t\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.initializeScalers(dim, this.getSeriesStats());\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t\t},\n\t\t\tinitializeScalers: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDoes nothing.\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tisDataDirty: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns whether or not any of this plot's data series need to be rendered.\n\t\t\t\t// returns: Boolean\n\t\t\t\t//\t\tFlag indicating if any of this plot's series are invalid and need rendering.\n\t\t\t\treturn arr.some(this.series, function(item){ return item.dirty; });\t//\tBoolean\n\t\t\t},\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender the plot on the chart.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t\t},\n\t\t\trenderLabel: function(group, x, y, label, theme, block, align){\n\t\t\t\tvar elem = ac.createText[this.opt.htmlLabels && gfx.renderer != \"vml\" ? \"html\" : \"gfx\"]\n\t\t\t\t\t(this.chart, group, x, y, align?align:\"middle\", label, theme.series.font, theme.series.fontColor);\n\t\t\t\t// if the label is inside we need to avoid catching events on it this would prevent action on\n\t\t\t\t// chart elements\n\t\t\t\tif(block){\n\t\t\t\t\t// TODO this won't work in IE neither in VML nor in HTML\n\t\t\t\t\t// a solution would be to catch the event on the label and refire it to the element\n\t\t\t\t\t// possibly using elementFromPoint or having it already available\n\t\t\t\t\tif(this.opt.htmlLabels && gfx.renderer != \"vml\"){\n\t\t\t\t\t\t// we have HTML labels, let's use pointEvents on the HTML node\n\t\t\t\t\t\telem.style.pointerEvents = \"none\";\n\t\t\t\t\t}else if(elem.rawNode){\n\t\t\t\t\t\t// we have SVG labels, let's use pointerEvents on the SVG or VML node\n\t\t\t\t\t\telem.rawNode.style.pointerEvents = \"none\";\n\t\t\t\t\t}\n\t\t\t\t\t// else we have Canvas, we need do nothing, as Canvas text won't catch events\n\t\t\t\t}\n\t\t\t\tif(this.opt.htmlLabels && gfx.renderer != \"vml\"){\n\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t}\n\t\n\t\t\t\treturn elem;\n\t\t\t},\n\t\t\tgetRequiredColors: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet how many data series we have, so we know how many colors to use.\n\t\t\t\t// returns: Number\n\t\t\t\t//\t\tThe number of colors needed.\n\t\t\t\treturn this.series.length;\t//\tNumber\n\t\t\t},\n\t\t\t_getLabel: function(number){\n\t\t\t\treturn common.getLabel(number, this.opt.fixed, this.opt.precision);\n\t\t\t}\n\t\t});\n\t\tif(has(\"dojo-bidi\")){\n\t\t\tBase.extend({\n\t\t\t\t_checkOrientation: function(group, dim, offsets){\n\t\t\t\t\tthis.chart.applyMirroring(this.group, dim, offsets);\n\t\t\t\t}\t\t\n\t\t\t});\n\t\t}\n\t\treturn Base;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 183 */\n/*!************************************!*\\\n  !*** ../dojox/charting/Element.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/dom-construct */ 39),__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/gfx/shape */ 169)], __WEBPACK_AMD_DEFINE_RESULT__ = function(arr, domConstruct, declare, gfx, shape){\n\t\n\t\treturn declare(\"dojox.charting.Element\", null, {\n\t\t\t// summary:\n\t\t\t//\t\tA base class that is used to build other elements of a chart, such as\n\t\t\t//\t\ta series.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe parent chart for this element.\n\t\t\t// group: dojox/gfx/shape.Group\n\t\t\t//\t\tThe visual GFX group representing this element.\n\t\t\t// htmlElement: Array\n\t\t\t//\t\tAny DOMNodes used as a part of this element (such as HTML-based labels).\n\t\t\t// dirty: Boolean\n\t\t\t//\t\tA flag indicating whether or not this element needs to be rendered.\n\t\n\t\t\tchart: null,\n\t\t\tgroup: null,\n\t\t\thtmlElements: null,\n\t\t\tdirty: true,\n\t\t\trenderingOptions: null,\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreates a new charting element.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart that this element belongs to.\n\t\t\t\tthis.chart = chart;\n\t\t\t\tthis.group = null;\n\t\t\t\tthis.htmlElements = [];\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.trailingSymbol = \"...\";\n\t\t\t\tthis._events = [];\n\t\t\t\tif (kwArgs && kwArgs.renderingOptions) {\n\t\t\t\t\tthis.renderingOptions = kwArgs.renderingOptions;\n\t\t\t\t}\n\t\t\t},\n\t\t\tpurgeGroup: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear any elements out of our group, and destroy the group.\n\t\t\t\t// returns: dojox/charting/Element\n\t\t\t\t//\t\tA reference to this object for functional chaining.\n\t\t\t\tthis.destroyHtmlElements();\n\t\t\t\tif(this.group){\n\t\t\t\t\t// since 1.7.x we need dispose shape otherwise there is a memoryleak\n\t\t\t\t\tthis.getGroup().removeShape();\n\t\t\t\t\tvar children = this.getGroup().children;\n\t\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\t\tif(shape.dispose){\n\t\t\t\t\t\tfor(var i = 0; i < children.length;++i){\n\t\t\t\t\t\t\tshape.dispose(children[i], true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(this.getGroup().rawNode){\n\t\t\t\t\t\tdomConstruct.empty(this.getGroup().rawNode);\n\t\t\t\t\t}\n\t\t\t\t\tthis.getGroup().clear();\n\t\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\t\tif(shape.dispose){\n\t\t\t\t\t\tshape.dispose(this.getGroup(), true);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.getGroup() != this.group){\n\t\t\t\t\t\t// we do have an intermediary clipping group (see CartesianBase)\n\t\t\t\t\t\tif(this.group.rawNode){\n\t\t\t\t\t\t\tdomConstruct.empty(this.group.rawNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.group.clear();\n\t\t\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\t\t\tif(shape.dispose){\n\t\t\t\t\t\t\tshape.dispose(this.group, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.group = null;\n\t\t\t\t}\n\t\t\t\tthis.dirty = true;\n\t\t\t\tif(this._events.length){\n\t\t\t\t\tarr.forEach(this._events, function(item){\n\t\t\t\t\t\titem.shape.disconnect(item.handle);\n\t\t\t\t\t});\n\t\t\t\t\tthis._events = [];\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox.charting.Element\n\t\t\t},\n\t\t\tcleanGroup: function(creator){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClean any elements (HTML or GFX-based) out of our group, and create a new one.\n\t\t\t\t// creator: dojox/gfx/shape.Surface?\n\t\t\t\t//\t\tAn optional surface to work with.\n\t\t\t\t// returns: dojox/charting/Element\n\t\t\t\t//\t\tA reference to this object for functional chaining.\n\t\t\t\tthis.destroyHtmlElements();\n\t\t\t\tif(!creator){ creator = this.chart.surface; }\n\t\t\t\tif(this.group){\n\t\t\t\t\tvar bgnode;\n\t\t\t\t\tvar children = this.getGroup().children;\n\t\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\t\tif(shape.dispose){\n\t\t\t\t\t\tfor(var i = 0; i < children.length;++i){\n\t\t\t\t\t\t\tshape.dispose(children[i], true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(this.getGroup().rawNode){\n\t\t\t\t\t\tbgnode = this.getGroup().bgNode;\n\t\t\t\t\t\tdomConstruct.empty(this.getGroup().rawNode);\n\t\t\t\t\t}\n\t\t\t\t\tthis.getGroup().clear();\n\t\t\t\t\tif(bgnode){\n\t\t\t\t\t\tthis.getGroup().rawNode.appendChild(bgnode);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis.group = creator.createGroup();\n\t\t\t\t\t// in some cases we have a rawNode but this is not an actual DOM element (CanvasWithEvents) so check\n\t\t\t\t\t// the actual rawNode type.\n\t\t\t\t\tif (this.renderingOptions && this.group.rawNode &&\n\t\t\t\t\t\tthis.group.rawNode.namespaceURI == \"http://www.w3.org/2000/svg\") {\n\t\t\t\t\t\tfor (var key in this.renderingOptions) {\n\t\t\t\t\t\t\tthis.group.rawNode.setAttribute(key, this.renderingOptions[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox.charting.Element\n\t\t\t},\n\t\t\tgetGroup: function(){\n\t\t\t\treturn this.group;\n\t\t\t},\n\t\t\tdestroyHtmlElements: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDestroy any DOMNodes that may have been created as a part of this element.\n\t\t\t\tif(this.htmlElements.length){\n\t\t\t\t\tarr.forEach(this.htmlElements, domConstruct.destroy);\n\t\t\t\t\tthis.htmlElements = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tdestroy: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAPI addition to conform to the rest of the Dojo Toolkit's standard.\n\t\t\t\tthis.purgeGroup();\n\t\t\t},\n\t\t\toverrideShape: function(shape, params){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tExtension point for overriding the charting shape\n\t\t\t},\n\t\t\t//text utilities\n\t\t\tgetTextWidth: function(s, font){\n\t\t\t\treturn gfx._base._getTextBox(s, {font: font}).w || 0;\n\t\t\t},\n\t\t\tgetTextWithLimitLength: function(s, font, limitWidth, truncated){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the truncated string based on the limited width in px(dichotomy algorithm)\n\t\t\t\t// s: String?\n\t\t\t\t//\t\tcandidate text.\n\t\t\t\t// font: String?\n\t\t\t\t//\t\ttext's font style.\n\t\t\t\t// limitWidth: Number?\n\t\t\t\t//\t\ttext limited width in px.\n\t\t\t\t// truncated: Boolean?\n\t\t\t\t//\t\twhether the input text(s) has already been truncated.\n\t\t\t\t// returns: Object\n\t\t\t\t// |\t{\n\t\t\t\t// |\t\ttext: processed text, maybe truncated or not,\n\t\t\t\t// |\t\ttruncated: whether text has been truncated\n\t\t\t\t// |\t}\n\t\t\t\tif(!s || s.length <= 0){\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: \"\",\n\t\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(!limitWidth || limitWidth <= 0){\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: s,\n\t\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar delta = 2,\n\t\t\t\t\t//golden section for dichotomy algorithm\n\t\t\t\t\ttrucPercentage = 0.618,\n\t\t\t\t\tminStr = s.substring(0,1) + this.trailingSymbol,\n\t\t\t\t\tminWidth = this.getTextWidth(minStr, font);\n\t\t\t\tif(limitWidth <= minWidth){\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: minStr,\n\t\t\t\t\t\ttruncated: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar width = this.getTextWidth(s, font);\n\t\t\t\tif(width <= limitWidth){\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: s,\n\t\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tvar begin = 0,\n\t\t\t\t\t\tend = s.length;\n\t\t\t\t\twhile(begin < end){\n\t\t\t\t\t\tif(end - begin <= delta ){\n\t\t\t\t\t\t\twhile (this.getTextWidth(s.substring(0, begin) + this.trailingSymbol, font) > limitWidth) {\n\t\t\t\t\t\t\t\tbegin -= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: (s.substring(0,begin) + this.trailingSymbol),\n\t\t\t\t\t\t\t\ttruncated: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar index = begin + Math.round((end - begin) * trucPercentage),\n\t\t\t\t\t\t\twidthIntercepted = this.getTextWidth(s.substring(0, index), font);\n\t\t\t\t\t\tif(widthIntercepted < limitWidth){\n\t\t\t\t\t\t\tbegin = index;\n\t\t\t\t\t\t\tend = end;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbegin = begin;\n\t\t\t\t\t\t\tend = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetTextWithLimitCharCount: function(s, font, wcLimit, truncated){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the truncated string based on the limited character count(dichotomy algorithm)\n\t\t\t\t// s: String?\n\t\t\t\t//\t\tcandidate text.\n\t\t\t\t// font: String?\n\t\t\t\t//\t\ttext's font style.\n\t\t\t\t// wcLimit: Number?\n\t\t\t\t//\t\ttext limited character count.\n\t\t\t\t// truncated: Boolean?\n\t\t\t\t//\t\twhether the input text(s) has already been truncated.\n\t\t\t\t// returns: Object\n\t\t\t\t// |\t{\n\t\t\t\t// |\t\ttext: processed text, maybe truncated or not,\n\t\t\t\t// |\t\ttruncated: whether text has been truncated\n\t\t\t\t// |\t}\n\t\t\t\tif (!s || s.length <= 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: \"\",\n\t\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(!wcLimit || wcLimit <= 0 || s.length <= wcLimit){\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: s,\n\t\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttext: s.substring(0, wcLimit) + this.trailingSymbol,\n\t\t\t\t\ttruncated: true\n\t\t\t\t};\n\t\t\t},\n\t\t\t// fill utilities\n\t\t\t_plotFill: function(fill, dim, offsets){\n\t\t\t\t// process a plot-wide fill\n\t\t\t\tif(!fill || !fill.type || !fill.space){\n\t\t\t\t\treturn fill;\n\t\t\t\t}\n\t\t\t\tvar space = fill.space, span;\n\t\t\t\tswitch(fill.type){\n\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultLinearGradient, fill);\n\t\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\t\tspan = dim.height - offsets.t - offsets.b;\n\t\t\t\t\t\t\t\tfill.y1 = offsets.t + span * fill.y1 / 100;\n\t\t\t\t\t\t\t\tfill.y2 = offsets.t + span * fill.y2 / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\t\tspan = dim.width - offsets.l - offsets.r;\n\t\t\t\t\t\t\t\tfill.x1 = offsets.l + span * fill.x1 / 100;\n\t\t\t\t\t\t\t\tfill.x2 = offsets.l + span * fill.x2 / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\tif(space === \"plot\"){\n\t\t\t\t\t\t\t// this one is used exclusively for scatter charts\n\t\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultRadialGradient, fill);\n\t\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t\t// process both dimensions\n\t\t\t\t\t\t\tvar spanX = dim.width  - offsets.l - offsets.r,\n\t\t\t\t\t\t\t\tspanY = dim.height - offsets.t - offsets.b;\n\t\t\t\t\t\t\tfill.cx = offsets.l + spanX * fill.cx / 100;\n\t\t\t\t\t\t\tfill.cy = offsets.t + spanY * fill.cy / 100;\n\t\t\t\t\t\t\tfill.r  = fill.r * Math.sqrt(spanX * spanX + spanY * spanY) / 200;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultPattern, fill);\n\t\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\t\tspan = dim.height - offsets.t - offsets.b;\n\t\t\t\t\t\t\t\tfill.y = offsets.t + span * fill.y / 100;\n\t\t\t\t\t\t\t\tfill.height = span * fill.height / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\t\tspan = dim.width - offsets.l - offsets.r;\n\t\t\t\t\t\t\t\tfill.x = offsets.l + span * fill.x / 100;\n\t\t\t\t\t\t\t\tfill.width = span * fill.width / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn fill;\n\t\t\t},\n\t\t\t_shapeFill: function(fill, bbox){\n\t\t\t\t// process shape-specific fill\n\t\t\t\tif(!fill || !fill.space){\n\t\t\t\t\treturn fill;\n\t\t\t\t}\n\t\t\t\tvar space = fill.space, span;\n\t\t\t\tswitch(fill.type){\n\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultLinearGradient, fill);\n\t\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\t\tspan = bbox.width;\n\t\t\t\t\t\t\t\tfill.x1 = bbox.x + span * fill.x1 / 100;\n\t\t\t\t\t\t\t\tfill.x2 = bbox.x + span * fill.x2 / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\t\tspan = bbox.height;\n\t\t\t\t\t\t\t\tfill.y1 = bbox.y + span * fill.y1 / 100;\n\t\t\t\t\t\t\t\tfill.y2 = bbox.y + span * fill.y2 / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\tif(space === \"shape\"){\n\t\t\t\t\t\t\t// this one is used exclusively for bubble charts and pie charts\n\t\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultRadialGradient, fill);\n\t\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t\t// process both dimensions\n\t\t\t\t\t\t\tfill.cx = bbox.x + bbox.width  / 2;\n\t\t\t\t\t\t\tfill.cy = bbox.y + bbox.height / 2;\n\t\t\t\t\t\t\tfill.r  = fill.r * bbox.width  / 200;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultPattern, fill);\n\t\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\t\tspan = bbox.width;\n\t\t\t\t\t\t\t\tfill.x = bbox.x + span * fill.x / 100;\n\t\t\t\t\t\t\t\tfill.width = span * fill.width / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\t\tspan = bbox.height;\n\t\t\t\t\t\t\t\tfill.y = bbox.y + span * fill.y / 100;\n\t\t\t\t\t\t\t\tfill.height = span * fill.height / 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn fill;\n\t\t\t},\n\t\t\t_pseudoRadialFill: function(fill, center, radius, start, end){\n\t\t\t\t// process pseudo-radial fills\n\t\t\t\tif(!fill || fill.type !== \"radial\" || fill.space !== \"shape\"){\n\t\t\t\t\treturn fill;\n\t\t\t\t}\n\t\t\t\t// clone and normalize fill\n\t\t\t\tvar space = fill.space;\n\t\t\t\tfill = gfx.makeParameters(gfx.defaultRadialGradient, fill);\n\t\t\t\tfill.space = space;\n\t\t\t\tif(arguments.length < 4){\n\t\t\t\t\t// process both dimensions\n\t\t\t\t\tfill.cx = center.x;\n\t\t\t\t\tfill.cy = center.y;\n\t\t\t\t\tfill.r  = fill.r * radius / 100;\n\t\t\t\t\treturn fill;\n\t\t\t\t}\n\t\t\t\t// convert to a linear gradient\n\t\t\t\tvar angle = arguments.length < 5 ? start : (end + start) / 2;\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"linear\",\n\t\t\t\t\tx1: center.x,\n\t\t\t\t\ty1: center.y,\n\t\t\t\t\tx2: center.x + fill.r * radius * Math.cos(angle) / 100,\n\t\t\t\t\ty2: center.y + fill.r * radius * Math.sin(angle) / 100,\n\t\t\t\t\tcolors: fill.colors\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 184 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/axis2d/common.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/window */ 15), __webpack_require__(/*! dojo/dom-geometry */ 36), __webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojo/has */ 5)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, win, domGeom, g, has){\n\t\n\t\tvar common = lang.getObject(\"dojox.charting.axis2d.common\", true);\n\t\t\n\t\tvar clearNode = function(s){\n\t\t\ts.marginLeft   = \"0px\";\n\t\t\ts.marginTop    = \"0px\";\n\t\t\ts.marginRight  = \"0px\";\n\t\t\ts.marginBottom = \"0px\";\n\t\t\ts.paddingLeft   = \"0px\";\n\t\t\ts.paddingTop    = \"0px\";\n\t\t\ts.paddingRight  = \"0px\";\n\t\t\ts.paddingBottom = \"0px\";\n\t\t\ts.borderLeftWidth   = \"0px\";\n\t\t\ts.borderTopWidth    = \"0px\";\n\t\t\ts.borderRightWidth  = \"0px\";\n\t\t\ts.borderBottomWidth = \"0px\";\n\t\t};\n\t\n\t\tvar getBoxWidth = function(n){\n\t\t\t// marginBox is incredibly slow, so avoid it if we can\n\t\t\tif(n[\"getBoundingClientRect\"]){\n\t\t\t\tvar bcr = n.getBoundingClientRect();\n\t\t\t\treturn bcr.width || (bcr.right - bcr.left);\n\t\t\t}else{\n\t\t\t\treturn domGeom.getMarginBox(n).w;\n\t\t\t}\n\t\t};\n\t\n\t\treturn lang.mixin(common, {\n\t\t\t// summary:\n\t\t\t//\t\tCommon methods to be used by any axis.  This is considered \"static\".\n\t\t\tcreateText: {\n\t\t\t\tgfx: function(chart, creator, x, y, align, text, font, fontColor){\n\t\t\t\t\t// summary:\n\t\t\t\t\t//\t\tUse dojox.gfx to create any text.\n\t\t\t\t\t// chart: dojox.charting.Chart\n\t\t\t\t\t//\t\tThe chart to create the text into.\n\t\t\t\t\t// creator: dojox.gfx.Surface\n\t\t\t\t\t//\t\tThe graphics surface to use for creating the text.\n\t\t\t\t\t// x: Number\n\t\t\t\t\t//\t\tWhere to create the text along the x axis (CSS left).\n\t\t\t\t\t// y: Number\n\t\t\t\t\t//\t\tWhere to create the text along the y axis (CSS top).\n\t\t\t\t\t// align: String\n\t\t\t\t\t//\t\tHow to align the text.  Can be \"left\", \"right\", \"center\".\n\t\t\t\t\t// text: String\n\t\t\t\t\t//\t\tThe text to render.\n\t\t\t\t\t// font: String\n\t\t\t\t\t//\t\tThe font definition, a la CSS \"font\".\n\t\t\t\t\t// fontColor: String|dojo.Color\n\t\t\t\t\t//\t\tThe color of the resultant text.\n\t\t\t\t\t// returns: dojox.gfx.Text\n\t\t\t\t\t//\t\tThe resultant GFX object.\n\t\t\t\t\treturn creator.createText({\n\t\t\t\t\t\tx: x, y: y, text: text, align: align\n\t\t\t\t\t}).setFont(font).setFill(fontColor);\t//\tdojox.gfx.Text\n\t\t\t\t},\n\t\t\t\thtml: function(chart, creator, x, y, align, text, font, fontColor, labelWidth){\n\t\t\t\t\t// summary:\n\t\t\t\t\t//\t\tUse the HTML DOM to create any text.\n\t\t\t\t\t// chart: dojox.charting.Chart\n\t\t\t\t\t//\t\tThe chart to create the text into.\n\t\t\t\t\t// creator: dojox.gfx.Surface\n\t\t\t\t\t//\t\tThe graphics surface to use for creating the text.\n\t\t\t\t\t// x: Number\n\t\t\t\t\t//\t\tWhere to create the text along the x axis (CSS left).\n\t\t\t\t\t// y: Number\n\t\t\t\t\t//\t\tWhere to create the text along the y axis (CSS top).\n\t\t\t\t\t// align: String\n\t\t\t\t\t//\t\tHow to align the text.  Can be \"left\", \"right\", \"center\".\n\t\t\t\t\t// text: String\n\t\t\t\t\t//\t\tThe text to render.\n\t\t\t\t\t// font: String\n\t\t\t\t\t//\t\tThe font definition, a la CSS \"font\".\n\t\t\t\t\t// fontColor: String|dojo.Color\n\t\t\t\t\t//\t\tThe color of the resultant text.\n\t\t\t\t\t// labelWidth: Number?\n\t\t\t\t\t//\t\tThe maximum width of the resultant DOM node.\n\t\t\t\t\t// returns: DOMNode\n\t\t\t\t\t//\t\tThe resultant DOMNode (a \"div\" element).\n\t\n\t\t\t\t\t// setup the text node\n\t\t\t\t\tvar p = win.doc.createElement(\"div\"), s = p.style, boxWidth;\n\t\t\t\t\t// bidi support, if this function exists the module was loaded \n\t\t\t\t\tif(chart.getTextDir){\n\t\t\t\t\t\tp.dir = chart.getTextDir(text);\n\t\t\t\t\t}\n\t\t\t\t\tclearNode(s);\n\t\t\t\t\ts.font = font;\n\t\t\t\t\tp.innerHTML = String(text).replace(/\\s/g, \"&nbsp;\");\n\t\t\t\t\ts.color = fontColor;\n\t\t\t\t\t// measure the size\n\t\t\t\t\ts.position = \"absolute\";\n\t\t\t\t\ts.left = \"-10000px\";\n\t\t\t\t\twin.body().appendChild(p);\n\t\t\t\t\tvar size = g.normalizedLength(g.splitFontString(font).size);\n\t\n\t\t\t\t\t// do we need to calculate the label width?\n\t\t\t\t\tif(!labelWidth){\n\t\t\t\t\t\tboxWidth = getBoxWidth(p);\n\t\t\t\t\t}\n\t\t\t\t\t// when the textDir is rtl, but the UI ltr needs\n\t\t\t\t\t// to recalculate the starting point\n\t\t\t\t\tif(p.dir == \"rtl\"){\n\t\t\t\t\t\tx += labelWidth ? labelWidth : boxWidth;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// new settings for the text node\n\t\t\t\t\twin.body().removeChild(p);\n\t\n\t\t\t\t\ts.position = \"relative\";\n\t\t\t\t\tif(labelWidth){\n\t\t\t\t\t\ts.width = labelWidth + \"px\";\n\t\t\t\t\t\t// s.border = \"1px dotted grey\";\n\t\t\t\t\t\tswitch(align){\n\t\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\t\ts.textAlign = \"center\";\n\t\t\t\t\t\t\t\ts.left = (x - labelWidth / 2) + \"px\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\ts.textAlign = \"right\";\n\t\t\t\t\t\t\t\ts.left = (x - labelWidth) + \"px\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ts.left = x + \"px\";\n\t\t\t\t\t\t\t\ts.textAlign = \"left\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tswitch(align){\n\t\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\t\ts.left = Math.floor(x - boxWidth / 2) + \"px\";\n\t\t\t\t\t\t\t\t// s.left = Math.floor(x - p.offsetWidth / 2) + \"px\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\ts.left = Math.floor(x - boxWidth) + \"px\";\n\t\t\t\t\t\t\t\t// s.left = Math.floor(x - p.offsetWidth) + \"px\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t//case \"start\":\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ts.left = Math.floor(x) + \"px\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts.top = Math.floor(y - size) + \"px\";\n\t\t\t\t\ts.whiteSpace = \"nowrap\";\t// hack for WebKit\n\t\t\t\t\t// setup the wrapper node\n\t\t\t\t\tvar wrap = win.doc.createElement(\"div\"), w = wrap.style;\n\t\t\t\t\tclearNode(w);\n\t\t\t\t\tw.width = \"0px\";\n\t\t\t\t\tw.height = \"0px\";\n\t\t\t\t\t// insert nodes\n\t\t\t\t\twrap.appendChild(p);\n\t\t\t\t\tchart.node.insertBefore(wrap, chart.node.firstChild);\n\t\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\t\tchart.htmlElementsRegistry.push([wrap, x, y, align, text, font, fontColor]);\n\t\t\t\t\t}\n\t\t\t\t\treturn wrap;\t//\tDOMNode\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 185 */\n/*!*********************************************!*\\\n  !*** ../dojox/charting/scaler/primitive.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){\n\t\tvar primitive = lang.getObject(\"dojox.charting.scaler.primitive\", true);\n\t\treturn lang.mixin(primitive, {\n\t\t\tbuildScaler: function(/*Number*/ min, /*Number*/ max, /*Number*/ span, /*Object*/ kwArgs){\n\t\t\t\tif(min == max){\n\t\t\t\t\t// artificially extend bounds\n\t\t\t\t\tmin -= 0.5;\n\t\t\t\t\tmax += 0.5;\n\t\t\t\t\t// now the line will be centered\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbounds: {\n\t\t\t\t\t\tlower: min,\n\t\t\t\t\t\tupper: max,\n\t\t\t\t\t\tfrom:  min,\n\t\t\t\t\t\tto:    max,\n\t\t\t\t\t\tscale: span / (max - min),\n\t\t\t\t\t\tspan:  span\n\t\t\t\t\t},\n\t\t\t\t\tscaler: primitive\n\t\t\t\t};\n\t\t\t},\n\t\t\tbuildTicks: function(/*Object*/ scaler, /*Object*/ kwArgs){\n\t\t\t\treturn {major: [], minor: [], micro: []};\t// Object\n\t\t\t},\n\t\t\tgetTransformerFromModel: function(/*Object*/ scaler){\n\t\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\t\treturn function(x){ return (x - offset) * scale; };\t// Function\n\t\t\t},\n\t\t\tgetTransformerFromPlot: function(/*Object*/ scaler){\n\t\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\t\treturn function(x){ return x / scale + offset; };\t// Function\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 186 */\n/*!**************************!*\\\n  !*** ../dojox/gfx/fx.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! ./matrix */ 170), __webpack_require__(/*! dojo/_base/Color */ 120), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/fx */ 119), __webpack_require__(/*! dojo/_base/connect */ 42), __webpack_require__(/*! dojo/sniff */ 10)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, g, m, Color, arr, fx, Hub, has){\n\t\tvar fxg = g.fx = {};\n\t\n\t\t// Generic interpolators. Should they be moved to dojox.fx?\n\t\n\t\tfunction InterpolNumber(start, end){\n\t\t\tthis.start = start, this.end = end;\n\t\t}\n\t\tInterpolNumber.prototype.getValue = function(r){\n\t\t\treturn (this.end - this.start) * r + this.start;\n\t\t};\n\t\n\t\tfunction InterpolUnit(start, end, units){\n\t\t\tthis.start = start, this.end = end;\n\t\t\tthis.units = units;\n\t\t}\n\t\tInterpolUnit.prototype.getValue = function(r){\n\t\t\treturn (this.end - this.start) * r + this.start + this.units;\n\t\t};\n\t\n\t\tfunction InterpolColor(start, end){\n\t\t\tthis.start = start, this.end = end;\n\t\t\tthis.temp = new Color();\n\t\t}\n\t\tInterpolColor.prototype.getValue = function(r){\n\t\t\treturn Color.blendColors(this.start, this.end, r, this.temp);\n\t\t};\n\t\n\t\tfunction InterpolValues(values){\n\t\t\tthis.values = values;\n\t\t\tthis.length = values.length;\n\t\t}\n\t\tInterpolValues.prototype.getValue = function(r){\n\t\t\treturn this.values[Math.min(Math.floor(r * this.length), this.length - 1)];\n\t\t};\n\t\n\t\tfunction InterpolObject(values, def){\n\t\t\tthis.values = values;\n\t\t\tthis.def = def ? def : {};\n\t\t}\n\t\tInterpolObject.prototype.getValue = function(r){\n\t\t\tvar ret = lang.clone(this.def);\n\t\t\tfor(var i in this.values){\n\t\t\t\tret[i] = this.values[i].getValue(r);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\n\t\tfunction InterpolTransform(stack, original){\n\t\t\tthis.stack = stack;\n\t\t\tthis.original = original;\n\t\t}\n\t\tInterpolTransform.prototype.getValue = function(r){\n\t\t\tvar ret = [];\n\t\t\tarr.forEach(this.stack, function(t){\n\t\t\t\tif(t instanceof m.Matrix2D){\n\t\t\t\t\tret.push(t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(t.name == \"original\" && this.original){\n\t\t\t\t\tret.push(this.original);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t \t\t\t// Adding support for custom matrices\n\t \t\t\tif(t.name == \"matrix\"){\n\t \t\t\t\tif((t.start instanceof m.Matrix2D) && (t.end instanceof m.Matrix2D)){\n\t \t\t\t\t\tvar transfMatrix = new m.Matrix2D();\n\t \t\t\t\t\tfor(var p in t.start) {\n\t \t\t\t\t\t\ttransfMatrix[p] = (t.end[p] - t.start[p])*r + t.start[p];\n\t \t\t\t\t\t}\n\t \t\t\t\t\tret.push(transfMatrix);\n\t \t\t\t\t}\n\t \t\t\t\treturn;\n\t \t\t\t}\n\t\t\t\tif(!(t.name in m)){ return; }\n\t\t\t\tvar f = m[t.name];\n\t\t\t\tif(typeof f != \"function\"){\n\t\t\t\t\t// constant\n\t\t\t\t\tret.push(f);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar val = arr.map(t.start, function(v, i){\n\t\t\t\t\t\t\t\treturn (t.end[i] - v) * r + v;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\tmatrix = f.apply(m, val);\n\t\t\t\tif(matrix instanceof m.Matrix2D){\n\t\t\t\t\tret.push(matrix);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\treturn ret;\n\t\t};\n\t\n\t\tvar transparent = new Color(0, 0, 0, 0);\n\t\n\t\tfunction getColorInterpol(prop, obj, name, def){\n\t\t\tif(prop.values){\n\t\t\t\treturn new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tvar value, start, end;\n\t\t\tif(prop.start){\n\t\t\t\tstart = g.normalizeColor(prop.start);\n\t\t\t}else{\n\t\t\t\tstart = value = obj ? (name ? obj[name] : obj) : def;\n\t\t\t}\n\t\t\tif(prop.end){\n\t\t\t\tend = g.normalizeColor(prop.end);\n\t\t\t}else{\n\t\t\t\tif(!value){\n\t\t\t\t\tvalue = obj ? (name ? obj[name] : obj) : def;\n\t\t\t\t}\n\t\t\t\tend = value;\n\t\t\t}\n\t\t\treturn new InterpolColor(start, end);\n\t\t}\n\t\n\t\tfunction getNumberInterpol(prop, obj, name, def){\n\t\t\tif(prop.values){\n\t\t\t\treturn new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tvar value, start, end;\n\t\t\tif(prop.start){\n\t\t\t\tstart = prop.start;\n\t\t\t}else{\n\t\t\t\tstart = value = obj ? obj[name] : def;\n\t\t\t}\n\t\t\tif(prop.end){\n\t\t\t\tend = prop.end;\n\t\t\t}else{\n\t\t\t\tif(typeof value != \"number\"){\n\t\t\t\t\tvalue = obj ? obj[name] : def;\n\t\t\t\t}\n\t\t\t\tend = value;\n\t\t\t}\n\t\t\treturn new InterpolNumber(start, end);\n\t\t}\n\t\n\t\tfxg.animateStroke = function(/*Object*/ args){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an animation which will change stroke properties over time.\n\t\t\t// args:\n\t\t\t//\t\tan object defining the animation setting.\n\t\t\t// example:\n\t\t\t//\t|\tfxg.animateStroke{{\n\t\t\t//\t|\t\tshape: shape,\n\t\t\t//\t|\t\tduration: 500,\n\t\t\t//\t|\t\tcolor: {start: \"red\", end: \"green\"},\n\t\t\t//\t|\t\twidth: {end: 15},\n\t\t\t//\t|\t\tjoin:  {values: [\"miter\", \"bevel\", \"round\"]}\n\t\t\t//\t|\t}).play();\n\t\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\t\tvar anim = new fx.Animation(args), shape = args.shape, stroke;\n\t\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\t\tstroke = shape.getStroke();\n\t\t\t\tvar prop = args.color, values = {}, value, start, end;\n\t\t\t\tif(prop){\n\t\t\t\t\tvalues.color = getColorInterpol(prop, stroke, \"color\", transparent);\n\t\t\t\t}\n\t\t\t\tprop = args.style;\n\t\t\t\tif(prop && prop.values){\n\t\t\t\t\tvalues.style = new InterpolValues(prop.values);\n\t\t\t\t}\n\t\t\t\tprop = args.width;\n\t\t\t\tif(prop){\n\t\t\t\t\tvalues.width = getNumberInterpol(prop, stroke, \"width\", 1);\n\t\t\t\t}\n\t\t\t\tprop = args.cap;\n\t\t\t\tif(prop && prop.values){\n\t\t\t\t\tvalues.cap = new InterpolValues(prop.values);\n\t\t\t\t}\n\t\t\t\tprop = args.join;\n\t\t\t\tif(prop){\n\t\t\t\t\tif(prop.values){\n\t\t\t\t\t\tvalues.join = new InterpolValues(prop.values);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstart = prop.start ? prop.start : (stroke && stroke.join || 0);\n\t\t\t\t\t\tend = prop.end ? prop.end : (stroke && stroke.join || 0);\n\t\t\t\t\t\tif(typeof start == \"number\" && typeof end == \"number\"){\n\t\t\t\t\t\t\tvalues.join = new InterpolNumber(start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.curve = new InterpolObject(values, stroke);\n\t\t\t});\n\t\t\tHub.connect(anim, \"onAnimate\", shape, \"setStroke\");\n\t\t\treturn anim; // dojo.Animation\n\t\t};\n\t\n\t\tfxg.animateFill = function(/*Object*/ args){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an animation which will change fill color over time.\n\t\t\t//\t\tOnly solid fill color is supported at the moment\n\t\t\t// args:\n\t\t\t//\t\tan object defining the animation setting.\n\t\t\t// example:\n\t\t\t//\t|\tgfx.animateFill{{\n\t\t\t//\t|\t\tshape: shape,\n\t\t\t//\t|\t\tduration: 500,\n\t\t\t//\t|\t\tcolor: {start: \"red\", end: \"green\"}\n\t\t\t//\t|\t}).play();\n\t\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\t\tvar anim = new fx.Animation(args), shape = args.shape, fill;\n\t\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\t\tfill = shape.getFill();\n\t\t\t\tvar prop = args.color, values = {};\n\t\t\t\tif(prop){\n\t\t\t\t\tthis.curve = getColorInterpol(prop, fill, \"\", transparent);\n\t\t\t\t}\n\t\t\t});\n\t\t\tHub.connect(anim, \"onAnimate\", shape, \"setFill\");\n\t\t\treturn anim; // dojo.Animation\n\t\t};\n\t\n\t\tfxg.animateFont = function(/*Object*/ args){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an animation which will change font properties over time.\n\t\t\t// args:\n\t\t\t//\t\tan object defining the animation setting.\n\t\t\t// example:\n\t\t\t//\t|\tgfx.animateFont{{\n\t\t\t//\t|\t\tshape: shape,\n\t\t\t//\t|\t\tduration: 500,\n\t\t\t//\t|\t\tvariant: {values: [\"normal\", \"small-caps\"]},\n\t\t\t//\t|\t\tsize:  {end: 10, units: \"pt\"}\n\t\t\t//\t|\t}).play();\n\t\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\t\tvar anim = new fx.Animation(args), shape = args.shape, font;\n\t\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\t\tfont = shape.getFont();\n\t\t\t\tvar prop = args.style, values = {}, value, start, end;\n\t\t\t\tif(prop && prop.values){\n\t\t\t\t\tvalues.style = new InterpolValues(prop.values);\n\t\t\t\t}\n\t\t\t\tprop = args.variant;\n\t\t\t\tif(prop && prop.values){\n\t\t\t\t\tvalues.variant = new InterpolValues(prop.values);\n\t\t\t\t}\n\t\t\t\tprop = args.weight;\n\t\t\t\tif(prop && prop.values){\n\t\t\t\t\tvalues.weight = new InterpolValues(prop.values);\n\t\t\t\t}\n\t\t\t\tprop = args.family;\n\t\t\t\tif(prop && prop.values){\n\t\t\t\t\tvalues.family = new InterpolValues(prop.values);\n\t\t\t\t}\n\t\t\t\tprop = args.size;\n\t\t\t\tif(prop && prop.units){\n\t\t\t\t\tstart = parseFloat(prop.start ? prop.start : (shape.font && shape.font.size || \"0\"));\n\t\t\t\t\tend = parseFloat(prop.end ? prop.end : (shape.font && shape.font.size || \"0\"));\n\t\t\t\t\tvalues.size = new InterpolUnit(start, end, prop.units);\n\t\t\t\t}\n\t\t\t\tthis.curve = new InterpolObject(values, font);\n\t\t\t});\n\t\t\tHub.connect(anim, \"onAnimate\", shape, \"setFont\");\n\t\t\treturn anim; // dojo.Animation\n\t\t};\n\t\n\t\tfxg.animateTransform = function(/*Object*/ args){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an animation which will change transformation over time.\n\t\t\t// args:\n\t\t\t//\t\tan object defining the animation setting.\n\t\t\t// example:\n\t\t\t//\t|\tgfx.animateTransform{{\n\t\t\t//\t|\t\tshape: shape,\n\t\t\t//\t|\t\tduration: 500,\n\t\t\t//\t|\t\ttransform: [\n\t\t\t//\t|\t\t\t{name: \"translate\", start: [0, 0], end: [200, 200]},\n\t\t\t//\t|\t\t\t{name: \"original\"}\n\t\t\t//\t|\t\t]\n\t\t\t//\t|\t}).play();\n\t\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\t\tvar anim = new fx.Animation(args), shape = args.shape, original;\n\t\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\t\toriginal = shape.getTransform();\n\t\t\t\tthis.curve = new InterpolTransform(args.transform, original);\n\t\t\t});\n\t\t\tHub.connect(anim, \"onAnimate\", shape, \"setTransform\");\n\t\t\tif(g.renderer === \"svg\" && (has(\"ie\") >= 9 || has(\"ff\"))){\n\t\t\t\t// fix http://bugs.dojotoolkit.org/ticket/16879\n\t\t\t\tvar handlers = [\n\t\t\t\t\t\tHub.connect(anim, \"onBegin\", anim, function(){\n\t\t\t\t\t\t\tvar parent = shape.getParent();\n\t\t\t\t\t\t\twhile(parent && parent.getParent){\n\t\t\t\t\t\t\t\tparent = parent.getParent();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(parent){\n\t\t\t\t\t\t\t\tshape.__svgContainer = parent.rawNode.parentNode;\n\t\t\t\t\t\t\t\tshape.__svgRoot = parent.rawNode;\n\t\t\t\t\t\t\t\tif(shape.__svgRoot && shape.__svgRoot.getAttribute){\n\t\t\t\t\t\t\t\t\tshape.__svgWidth = parseInt(shape.__svgRoot.getAttribute(\"width\"), 10);\n\t\t\t\t\t\t\t\t\tif(isNaN(shape.__svgWidth)){\n\t\t\t\t\t\t\t\t\t\tdelete shape.__svgWidth;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tHub.connect(anim, \"onAnimate\", anim, function(){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\tif(shape.__svgContainer){\n\t\t\t\t\t\t\t\t\tvar ov = shape.__svgContainer.style.visibility;\n\t\t\t\t\t\t\t\t\tshape.__svgContainer.style.visibility = \"visible\";\n\t\t\t\t\t\t\t\t\tvar pokeNode = shape.__svgContainer.offsetHeight;\n\t\t\t\t\t\t\t\t\tshape.__svgContainer.style.visibility = ov;\n\t\t\t\t\t\t\t\t\tvar width = shape.__svgWidth;\n\t\t\t\t\t\t\t\t\tif(!isNaN(width)){\n\t\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\t\tshape.__svgRoot.setAttribute(\"width\", width  - 0.000005);\n\t\t\t\t\t\t\t\t\t\t\tshape.__svgRoot.setAttribute(\"width\", width);\n\t\t\t\t\t\t\t\t\t\t}catch(ignore){}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tHub.connect(anim, \"onEnd\", anim, function(){\n\t\t\t\t\t\t\tarr.forEach(handlers, Hub.disconnect);\n\t\t\t\t\t\t\tif(shape.__svgContainer){\n\t\t\t\t\t\t\t\tvar sn = shape.__svgContainer;\n\t\t\t\t\t\t\t\tif(sn.getAttribute(\"__gotVis\") == null){\n\t\t\t\t\t\t\t\t\tsn.setAttribute(\"__gotVis\", true);\n\t\t\t\t\t\t\t\t\tvar ov = shape.__svgContainer.style.visibility;\n\t\t\t\t\t\t\t\t\tvar root = shape.__svgRoot;\n\t\t\t\t\t\t\t\t\tvar width = shape.__svgWidth;\n\t\t\t\t\t\t\t\t\tsn.style.visibility = \"visible\";\n\t\t\t\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\t\tsn.style.visibility = ov;\n\t\t\t\t\t\t\t\t\t\t\tsn.removeAttribute(\"__gotVis\");\n\t\t\t\t\t\t\t\t\t\t\tsn = null;\n\t\t\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\t\t\tif(!isNaN(width)){\n\t\t\t\t\t\t\t\t\t\t\t\t\troot.setAttribute(\"width\", width - 0.000005);\n\t\t\t\t\t\t\t\t\t\t\t\t\troot.setAttribute(\"width\", width);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}catch(ignore){}\n\t\t\t\t\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t\t\t\t\t},100);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelete shape.__svgContainer;\n\t\t\t\t\t\t\tdelete shape.__svgRoot;\n\t\t\t\t\t\t\tdelete shape.__svgWidth;\n\t\t\t\t\t\t})\n\t\t\t\t\t];\n\t\t\t}\n\t\t\treturn anim; // dojo.Animation\n\t\t};\n\t\t\n\t\treturn fxg;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 187 */\n/*!******************************!*\\\n  !*** ../dojox/lang/utils.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! .. */ 177), __webpack_require__(/*! dojo/_base/lang */ 9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojox, lang){\n\t\tvar du = lang.getObject(\"lang.utils\", true, dojox);\n\t\t\n\t\tvar empty = {}, opts = Object.prototype.toString;\n\t\n\t\tvar clone = function(o){\n\t\t\tif(o){\n\t\t\t\tswitch(opts.call(o)){\n\t\t\t\t\tcase \"[object Array]\":\n\t\t\t\t\t\treturn o.slice(0);\n\t\t\t\t\tcase \"[object Object]\":\n\t\t\t\t\t\treturn lang.delegate(o);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\t\t\n\t\tlang.mixin(du, {\n\t\t\tcoerceType: function(target, source){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCoerces one object to the type of another.\n\t\t\t\t// target: Object\n\t\t\t\t//\t\tobject, which typeof result is used to coerce \"source\" object.\n\t\t\t\t// source: Object\n\t\t\t\t//\t\tobject, which will be forced to change type.\n\t\t\t\tswitch(typeof target){\n\t\t\t\t\tcase \"number\":\treturn Number(eval(\"(\" + source + \")\"));\n\t\t\t\t\tcase \"string\":\treturn String(source);\n\t\t\t\t\tcase \"boolean\":\treturn Boolean(eval(\"(\" + source + \")\"));\n\t\t\t\t}\n\t\t\t\treturn eval(\"(\" + source + \")\");\n\t\t\t},\n\t\t\t\n\t\t\tupdateWithObject: function(target, source, conv){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUpdates an existing object in place with properties from an \"source\" object.\n\t\t\t\t// target: Object\n\t\t\t\t//\t\tthe \"target\" object to be updated\n\t\t\t\t// source: Object\n\t\t\t\t//\t\tthe \"source\" object, whose properties will be used to source the existed object.\n\t\t\t\t// conv: Boolean?\n\t\t\t\t//\t\tforce conversion to the original type\n\t\t\t\tif(!source){ return target; }\n\t\t\t\tfor(var x in target){\n\t\t\t\t\tif(x in source && !(x in empty)){\n\t\t\t\t\t\tvar t = target[x];\n\t\t\t\t\t\tif(t && typeof t == \"object\"){\n\t\t\t\t\t\t\tdu.updateWithObject(t, source[x], conv);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttarget[x] = conv ? du.coerceType(t, source[x]) : clone(source[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target;\t// Object\n\t\t\t},\n\t\t\n\t\t\tupdateWithPattern: function(target, source, pattern, conv){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUpdates an existing object in place with properties from an \"source\" object.\n\t\t\t\t// target: Object\n\t\t\t\t//\t\tthe \"target\" object to be updated\n\t\t\t\t// source: Object\n\t\t\t\t//\t\tthe \"source\" object, whose properties will be used to source the existed object.\n\t\t\t\t// pattern: Object\n\t\t\t\t//\t\tobject, whose properties will be used to pull values from the \"source\"\n\t\t\t\t// conv: Boolean?\n\t\t\t\t//\t\tforce conversion to the original type\n\t\t\t\tif(!source || !pattern){ return target; }\n\t\t\t\tfor(var x in pattern){\n\t\t\t\t\tif(x in source && !(x in empty)){\n\t\t\t\t\t\ttarget[x] = conv ? du.coerceType(pattern[x], source[x]) : clone(source[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target;\t// Object\n\t\t\t},\n\t\t\t\n\t\t\tmerge: function(object, mixin){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tMerge two objects structurally, mixin properties will override object's properties.\n\t\t\t\t// object: Object\n\t\t\t\t//\t\toriginal object.\n\t\t\t\t// mixin: Object\n\t\t\t\t//\t\tadditional object, which properties will override object's properties.\n\t\t\t\tif(mixin){\n\t\t\t\t\tvar otype = opts.call(object), mtype = opts.call(mixin), t, i, l, m;\n\t\t\t\t\tswitch(mtype){\n\t\t\t\t\t\tcase \"[object Array]\":\n\t\t\t\t\t\t\tif(mtype == otype){\n\t\t\t\t\t\t\t\tt = new Array(Math.max(object.length, mixin.length));\n\t\t\t\t\t\t\t\tfor(i = 0, l = t.length; i < l; ++i){\n\t\t\t\t\t\t\t\t\tt[i] = du.merge(object[i], mixin[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mixin.slice(0);\n\t\t\t\t\t\tcase \"[object Object]\":\n\t\t\t\t\t\t\tif(mtype == otype && object){\n\t\t\t\t\t\t\t\tt = lang.delegate(object);\n\t\t\t\t\t\t\t\tfor(i in mixin){\n\t\t\t\t\t\t\t\t\tif(i in object){\n\t\t\t\t\t\t\t\t\t\tl = object[i];\n\t\t\t\t\t\t\t\t\t\tm = mixin[i];\n\t\t\t\t\t\t\t\t\t\tif(m !== l){\n\t\t\t\t\t\t\t\t\t\t\tt[i] = du.merge(l, m);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tt[i] = lang.clone(mixin[i]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn lang.clone(mixin);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mixin;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn du;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 188 */\n/*!***********************************************!*\\\n  !*** ../dojox/charting/plot2d/_PlotEvents.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/connect */ 42)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, hub){\n\t\n\t\treturn declare(\"dojox.charting.plot2d._PlotEvents\", null, {\n\t\t\tconstructor: function(){\n\t\t\t\tthis._shapeEvents = [];\n\t\t\t\tthis._eventSeries = {};\n\t\t\t},\n\t\t\tdestroy: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDestroy any internal elements and event handlers.\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.inherited(arguments);\n\t\t\t},\n\t\t\tplotEvent: function(o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tStub function for use by specific plots.\n\t\t\t\t// o: Object\n\t\t\t\t//\t\tAn object intended to represent event parameters.\n\t\t\t},\n\t\t\traiseEvent: function(o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRaises events in predefined order\n\t\t\t\t// o: Object\n\t\t\t\t//\t\tAn object intended to represent event parameters.\n\t\t\t\tthis.plotEvent(o);\n\t\t\t\tvar t = lang.delegate(o);\n\t\t\t\tt.originalEvent = o.type;\n\t\t\t\tt.originalPlot  = o.plot;\n\t\t\t\tt.type = \"onindirect\";\n\t\t\t\tarr.forEach(this.chart.stack, function(plot){\n\t\t\t\t\tif(plot !== this && plot.plotEvent){\n\t\t\t\t\t\tt.plot = plot;\n\t\t\t\t\t\tplot.plotEvent(t);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t},\n\t\t\tconnect: function(object, method){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tHelper function to connect any object's method to our plotEvent.\n\t\t\t\t// object: Object\n\t\t\t\t//\t\tThe object to connect to.\n\t\t\t\t// method: String|Function\n\t\t\t\t//\t\tThe method to fire when our plotEvent is fired.\n\t\t\t\t// returns: Array\n\t\t\t\t//\t\tThe handle as returned from dojo.connect (see dojo.connect).\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn hub.connect(this, \"plotEvent\", object, method);\t//\tArray\n\t\t\t},\n\t\t\tevents: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tFind out if any event handlers have been connected to our plotEvent.\n\t\t\t\t// returns: Boolean\n\t\t\t\t//\t\tA flag indicating that there are handlers attached.\n\t\t\t\treturn !!this.plotEvent.after;\n\t\t\t},\n\t\t\tresetEvents: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReset all events attached to our plotEvent (i.e. disconnect).\n\t\t\t\tif(this._shapeEvents.length){\n\t\t\t\t\tarr.forEach(this._shapeEvents, function(item){\n\t\t\t\t\t\titem.shape.disconnect(item.handle);\n\t\t\t\t\t});\n\t\t\t\t\tthis._shapeEvents = [];\n\t\t\t\t}\n\t\t\t\tthis.raiseEvent({type: \"onplotreset\", plot: this});\n\t\t\t},\n\t\t\t_connectSingleEvent: function(o, eventName){\n\t\t\t\tthis._shapeEvents.push({\n\t\t\t\t\tshape:  o.eventMask,\n\t\t\t\t\thandle: o.eventMask.connect(eventName, this, function(e){\n\t\t\t\t\t\to.type  = eventName;\n\t\t\t\t\t\to.event = e;\n\t\t\t\t\t\tthis.raiseEvent(o);\n\t\t\t\t\t\to.event = null;\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t},\n\t\t\t_connectEvents: function(o){\n\t\t\t\tif(o){\n\t\t\t\t\to.chart = this.chart;\n\t\t\t\t\to.plot  = this;\n\t\t\t\t\to.hAxis = this.hAxis || null;\n\t\t\t\t\to.vAxis = this.vAxis || null;\n\t\t\t\t\to.eventMask = o.eventMask || o.shape;\n\t\t\t\t\tthis._connectSingleEvent(o, \"onmouseover\");\n\t\t\t\t\tthis._connectSingleEvent(o, \"onmouseout\");\n\t\t\t\t\tthis._connectSingleEvent(o, \"onclick\");\n\t\t\t\t}\n\t\t\t},\n\t\t\t_reconnectEvents: function(seriesName){\n\t\t\t\tvar a = this._eventSeries[seriesName];\n\t\t\t\tif(a){\n\t\t\t\t\tarr.forEach(a, this._connectEvents, this);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfireEvent: function(seriesName, eventName, index, eventObject){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tEmulates firing an event for a given data value (specified by\n\t\t\t\t//\t\tan index) of a given series.\n\t\t\t\t// seriesName: String\n\t\t\t\t//\t\tSeries name.\n\t\t\t\t// eventName: String\n\t\t\t\t//\t\tEvent name to emulate.\n\t\t\t\t// index: Number\n\t\t\t\t//\t\tValid data value index used to raise an event.\n\t\t\t\t// eventObject: Object?\n\t\t\t\t//\t\tOptional event object. Especially useful for synthetic events.\n\t\t\t\t//\t\tDefault: null.\n\t\t\t\tvar s = this._eventSeries[seriesName];\n\t\t\t\tif(s && s.length && index < s.length){\n\t\t\t\t\tvar o = s[index];\n\t\t\t\t\to.type  = eventName;\n\t\t\t\t\to.event = eventObject || null;\n\t\t\t\t\tthis.raiseEvent(o);\n\t\t\t\t\to.event = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 189 */\n/*!********************************************!*\\\n  !*** ../dojox/lang/functional/reversed.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/kernel */ 4) ,__webpack_require__(/*! ./lambda */ 176)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, kernel, df){\n\t// This module adds high-level functions and related constructs:\n\t//\t- reversed versions of array-processing functions similar to standard JS functions\n\t\n\t// Notes:\n\t//\t- this module provides reversed versions of standard array-processing functions:\n\t//\t\tforEachRev, mapRev, filterRev\n\t\n\t// Defined methods:\n\t//\t- take any valid lambda argument as the functional argument\n\t//\t- operate on dense arrays\n\t//\t- take a string as the array argument\n\t\n\t\tlang.mixin(df, {\n\t\t\t// JS 1.6 standard array functions, which can take a lambda as a parameter.\n\t\t\t// Consider using dojo._base.array functions, if you don't need the lambda support.\n\t\t\tfilterRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a new array with all elements that pass the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar t = [], v, i = a.length - 1;\n\t\t\t\tfor(; i >= 0; --i){\n\t\t\t\t\tv = a[i];\n\t\t\t\t\tif(f.call(o, v, i, a)){ t.push(v); }\n\t\t\t\t}\n\t\t\t\treturn t;\t// Array\n\t\t\t},\n\t\t\tforEachRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\texecutes a provided function once per array element.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tfor(var i = a.length - 1; i >= 0; f.call(o, a[i], i, a), --i);\n\t\t\t},\n\t\t\tmapRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcreates a new array with the results of calling\n\t\t\t\t//\t\ta provided function on every element in this array.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar n = a.length, t = new Array(n), i = n - 1, j = 0;\n\t\t\t\tfor(; i >= 0; t[j++] = f.call(o, a[i], i, a), --i);\n\t\t\t\treturn t;\t// Array\n\t\t\t},\n\t\t\teveryRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ttests whether all elements in the array pass the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tfor(var i = a.length - 1; i >= 0; --i){\n\t\t\t\t\tif(!f.call(o, a[i], i, a)){\n\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\t// Boolean\n\t\t\t},\n\t\t\tsomeRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\ttests whether some element in the array passes the test\n\t\t\t\t//\t\timplemented by the provided function.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tfor(var i = a.length - 1; i >= 0; --i){\n\t\t\t\t\tif(f.call(o, a[i], i, a)){\n\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\t// Boolean\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn df;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 190 */\n/*!*************************************************!*\\\n  !*** ../dojox/charting/plot2d/commonStacked.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t\t__webpack_require__(/*! dojo/_base/lang */ 9),\n\t\t__webpack_require__(/*! dojox/lang/functional */ 175),\n\t\t__webpack_require__(/*! ./common */ 165)\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, df, common){\n\t\t\n\t\tvar commonStacked = lang.getObject(\"dojox.charting.plot2d.commonStacked\", true);\n\t\treturn lang.mixin(commonStacked, {\n\t\t\tcollectStats: function(series, isNullValue){\n\t\t\t\tvar stats = lang.delegate(common.defaultStats);\n\t\t\t\tfor(var i = 0; i < series.length; ++i){\n\t\t\t\t\tvar run = series[i];\n\t\t\t\t\tfor(var j = 0; j < run.data.length; j++){\n\t\t\t\t\t\tvar x, y;\n\t\t\t\t\t\tif(run.data[j] !== null){\n\t\t\t\t\t\t\tif(typeof run.data[j] == \"number\" || !run.data[j].hasOwnProperty(\"x\")){\n\t\t\t\t\t\t\t\ty = commonStacked.getIndexValue(series, i, j, isNullValue)[0];\n\t\t\t\t\t\t\t\tx = j+1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tx = run.data[j].x;\n\t\t\t\t\t\t\t\tif(x !== null){\n\t\t\t\t\t\t\t\t\ty = commonStacked.getValue(series, i, x, isNullValue)[0];\n\t\t\t\t\t\t\t\t\ty = y != null && y.y ? y.y:null; \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, y);\n\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn stats;\n\t\t\t},\n\t\t\t\n\t\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t\t// collect references to non-empty sets\n\t\t\t\tvar sets = df.filter(values, \"x\"), n = sets.length;\n\t\t\t\tif(!n){\n\t\t\t\t\t// nothing to do at all\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\n\t\t\t\t// stack values\n\t\t\t\tvar previousSet = {};\n\t\t\t\tfor(var i = 0; i < n; ++i){\n\t\t\t\t\tvar extractedSet = sets[i];\n\t\t\t\t\tfor(var j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\textractedSet[j] = (extractedSet[j] || 0) + (previousSet[j] || 0);\n\t\t\t\t\t}\n\t\t\t\t\tpreviousSet = extractedSet;\n\t\t\t\t}\n\t\n\t\t\t\t// transform to pixels\n\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\tfor(j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\textractedSet[j] = this.isNullValue(extractedSet[j]) ? 0 :\n\t\t\t\t\t\t\ttransform(extractedSet[j]) - baseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// correct the minimal width\n\t\t\t\tif(this.opt.minWidth){\n\t\t\t\t\tvar minWidth = this.opt.minWidth;\n\t\n\t\t\t\t\t// unstack\n\t\t\t\t\tfor(i = n - 1; i; --i){\n\t\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\t\tpreviousSet  = sets[i - 1];\n\t\t\t\t\t\tfor(j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\t\textractedSet[j] = extractedSet[j] - previousSet[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// now let's go over all values and correct them, if needed\n\t\t\t\t\tvar min = extractedSet.min, max = extractedSet.max;\n\t\t\t\t\tfor(var j = min; j < max; ++j){\n\t\n\t\t\t\t\t\t// find a total length of stack\n\t\t\t\t\t\tvar sum = 0, counter = 0;\n\t\t\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\t\t\tvar value = sets[i][j];\n\t\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\t\tsum += value;\n\t\t\t\t\t\t\t\t++counter;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(sum <= counter * minWidth){\n\t\t\t\t\t\t\t// the corner case: all values are very small\n\t\t\t\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\t\t\t\tvalue = sets[i][j];\n\t\t\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\t\t\tsets[i][j] = minWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\t// next stack\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// distributing overflow up\n\t\t\t\t\t\tvar overflow = 0;\n\t\t\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\t\t\tvalue = extractedSet[j];\n\t\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\t\tif(value < minWidth){\n\t\t\t\t\t\t\t\t\toverflow += minWidth - value;\n\t\t\t\t\t\t\t\t\textractedSet[j] = minWidth;\n\t\t\t\t\t\t\t\t}else if(overflow > 0){\n\t\t\t\t\t\t\t\t\t// calculate available space\n\t\t\t\t\t\t\t\t\tvar available = extractedSet[j] - minWidth;\n\t\t\t\t\t\t\t\t\tif(available >= overflow){\n\t\t\t\t\t\t\t\t\t\textractedSet[j] -= overflow;\n\t\t\t\t\t\t\t\t\t\toverflow = 0;\n\t\t\t\t\t\t\t\t\t}else if(available > 0){\n\t\t\t\t\t\t\t\t\t\textractedSet[j] = minWidth;\n\t\t\t\t\t\t\t\t\t\toverflow -= available;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// distributing overflow down, if any\n\t\t\t\t\t\tif(overflow > 0){\n\t\t\t\t\t\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\t\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\t\t\t\tvalue = extractedSet[j];\n\t\t\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\t\t\t// calculate available space\n\t\t\t\t\t\t\t\t\tavailable = extractedSet[j] - minWidth;\n\t\t\t\t\t\t\t\t\tif(available >= overflow){\n\t\t\t\t\t\t\t\t\t\textractedSet[j] -= overflow;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(available > 0){\n\t\t\t\t\t\t\t\t\t\textractedSet[j] = minWidth;\n\t\t\t\t\t\t\t\t\t\toverflow -= available;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// stack\n\t\t\t\t\tfor(i = 1; i < n; ++i){\n\t\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\t\tpreviousSet  = sets[i - 1];\n\t\t\t\t\t\tfor(j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\t\textractedSet[j] = extractedSet[j] + previousSet[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn values;\n\t\t\t},\n\t\n\t\t\tgetIndexValue: function(series, i, index, isNullValue){\n\t\t\t\tvar value = 0, v, j;\n\t\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\t\tv = series[j].data[index];\n\t\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\t\tif(isNaN(v)){ v = v.y || 0; }\n\t\t\t\t\t\tvalue += v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\n\t\t\tgetValue: function(series, i, x, isNullValue){\n\t\t\t\tvar value = null, j, z;\n\t\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\t\tfor(z = 0; z < series[j].data.length; z++){\n\t\t\t\t\t\tv = series[j].data[z];\n\t\t\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\t\t\tif(v.x == x){\n\t\t\t\t\t\t\t\tif(!value){\n\t\t\t\t\t\t\t\t\tvalue = {x: x};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(v.y != null){\n\t\t\t\t\t\t\t\t\tif(value.y == null){\n\t\t\t\t\t\t\t\t\t\tvalue.y = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvalue.y += v.y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(v.x > x){break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t\n\t\t\tgetIndexValue: function(series, i, index, isNullValue){\n\t\t\t\tvar value = 0, v, j, pvalue;\n\t\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\t\tif(series[j].hidden){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpvalue = value;\n\t\t\t\t\tv = series[j].data[index];\n\t\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\t\tif(isNaN(v)){ v = v.y || 0; }\n\t\t\t\t\t\tvalue += v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [value , pvalue];\n\t\t\t},\n\t\t\t\n\t\t\tgetValue: function(series, i, x, isNullValue){\n\t\t\t\tvar value = null, j, z, v, pvalue;\n\t\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\t\tif(series[j].hidden){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(z = 0; z < series[j].data.length; z++){\n\t\t\t\t\t\tpvalue = value;\n\t\t\t\t\t\tv = series[j].data[z];\n\t\t\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\t\t\tif(v.x == x){\n\t\t\t\t\t\t\t\tif(!value){\n\t\t\t\t\t\t\t\t\tvalue = {x: x};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(v.y != null){\n\t\t\t\t\t\t\t\t\tif(value.y == null){\n\t\t\t\t\t\t\t\t\t\tvalue.y = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvalue.y += v.y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(v.x > x){break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [value, pvalue];\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 191 */\n/*!**********************************!*\\\n  !*** ../dojox/charting/Chart.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../main */ 177), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13),__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/dom-style */ 37),\n\t\t__webpack_require__(/*! dojo/dom */ 14), __webpack_require__(/*! dojo/dom-geometry */ 36), __webpack_require__(/*! dojo/dom-construct */ 39),__webpack_require__(/*! dojo/_base/Color */ 120), __webpack_require__(/*! dojo/sniff */ 10),\n\t\t__webpack_require__(/*! ./Element */ 183), __webpack_require__(/*! ./SimpleTheme */ 192), __webpack_require__(/*! ./Series */ 194), __webpack_require__(/*! ./axis2d/common */ 184), __webpack_require__(/*! dojox/gfx/shape */ 169),\n\t\t__webpack_require__(/*! dojox/gfx */ 166), __webpack_require__.dj.h(/*! dojo/has!dojo-bidi?./bidi/Chart */ \"dojo-bidi?195\"), __webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/fold */ 201), __webpack_require__(/*! dojox/lang/functional/reversed */ 189)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojox, lang, arr, declare, domStyle,\n\t\t \t\t dom, domGeom, domConstruct, Color, has,\n\t\t \t\t Element, SimpleTheme, Series, common, shape,\n\t\t \t\t g, BidiChart, func){\n\t\t/*=====\n\t\tvar __ChartCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tThe keyword arguments that can be passed in a Chart constructor.\n\t\t\t// margins: Object?\n\t\t\t//\t\tOptional margins for the chart, in the form of { l, t, r, b}.\n\t\t\t// stroke: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional outline/stroke for the chart.\n\t\t\t// fill: dojox.gfx.Fill?\n\t\t\t//\t\tAn optional fill for the chart.\n\t\t\t// delayInMs: Number\n\t\t\t//\t\tDelay in ms for delayedRender(). Default: 200.\n\t\t};\n\t\t=====*/\n\t\n\t\t/*=====\n\t\tvar __SeriesCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tAn optional arguments object that can be used in the Series constructor.\n\t\t\t// plot: String?\n\t\t\t//\t\tThe plot (by name) that this series belongs to.\n\t\t};\n\t\t=====*/\n\t\n\t\t/*=====\n\t\tvar __BaseAxisCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tOptional arguments used in the definition of an invisible axis.\n\t\t\t// vertical: Boolean?\n\t\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t\t// min: Number?\n\t\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t\t// max: Number?\n\t\t\t//\t\tThe largest value on an axis. Default is 1.\n\t\t};\n\t\t=====*/\n\t\n\t\tvar dc = lang.getObject(\"charting\", true, dojox),\n\t\t\tclear = func.lambda(\"item.clear()\"),\n\t\t\tpurge = func.lambda(\"item.purgeGroup()\"),\n\t\t\tdestroy = func.lambda(\"item.destroy()\"),\n\t\t\tmakeClean = func.lambda(\"item.dirty = false\"),\n\t\t\tmakeDirty = func.lambda(\"item.dirty = true\"),\n\t\t\tgetName = func.lambda(\"item.name\"),\n\t\t\tdefaultMargins = {l: 10, t: 10, r: 10, b: 10};\n\t\n\t\tvar Chart = declare(has(\"dojo-bidi\")? \"dojox.charting.NonBidiChart\" : \"dojox.charting.Chart\", null, {\n\t\t\t// summary:\n\t\t\t//\t\tThe main chart object in dojox.charting.  This will create a two dimensional\n\t\t\t//\t\tchart based on dojox.gfx.\n\t\t\t//\n\t\t\t// description:\n\t\t\t//\t\tdojox.charting.Chart is the primary object used for any kind of charts.  It\n\t\t\t//\t\tis simple to create--just pass it a node reference, which is used as the\n\t\t\t//\t\tcontainer for the chart--and a set of optional keyword arguments and go.\n\t\t\t//\n\t\t\t//\t\tNote that like most of dojox.gfx, most of dojox.charting.Chart's methods are\n\t\t\t//\t\tdesigned to return a reference to the chart itself, to allow for functional\n\t\t\t//\t\tchaining.  This makes defining everything on a Chart very easy to do.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tCreate an area chart, with smoothing.\n\t\t\t//\t|\trequire([\"dojox/charting/Chart\", \"dojox/charting/themes/Shrooms\", \"dojox/charting/plot2d/Areas\", ...],\n\t\t\t// \t|\t\tfunction(Chart, Shrooms, Areas, ...){\n\t\t\t//\t|\t\tnew Chart(node)\n\t\t\t//\t|\t\t\t.addPlot(\"default\", { type: Areas, tension: \"X\" })\n\t\t\t//\t|\t\t\t.setTheme(Shrooms)\n\t\t\t//\t|\t\t\t.addSeries(\"Series A\", [1, 2, 0.5, 1.5, 1, 2.8, 0.4])\n\t\t\t//\t|\t\t\t.addSeries(\"Series B\", [2.6, 1.8, 2, 1, 1.4, 0.7, 2])\n\t\t\t//\t|\t\t\t.addSeries(\"Series C\", [6.3, 1.8, 3, 0.5, 4.4, 2.7, 2])\n\t\t\t//\t|\t\t\t.render();\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tThe form of data in a data series can take a number of forms: a simple array,\n\t\t\t//\t\tan array of objects {x,y}, or something custom (as determined by the plot).\n\t\t\t//\t\tHere's an example of a Candlestick chart, which expects an object of\n\t\t\t//\t\t{ open, high, low, close }.\n\t\t\t//\t|\trequire([\"dojox/charting/Chart\", \"dojox/charting/plot2d/Candlesticks\", ...],\n\t\t\t// \t|\t\tfunction(Chart, Candlesticks, ...){\n\t\t\t//\t|\t\tnew Chart(node)\n\t\t\t//\t|\t\t\t.addPlot(\"default\", {type: Candlesticks, gap: 1})\n\t\t\t//\t|\t\t\t.addAxis(\"x\", {fixLower: \"major\", fixUpper: \"major\", includeZero: true})\n\t\t\t//\t|\t\t\t.addAxis(\"y\", {vertical: true, fixLower: \"major\", fixUpper: \"major\", natural: true})\n\t\t\t//\t|\t\t\t.addSeries(\"Series A\", [\n\t\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 },\n\t\t\t//\t|\t\t\t\t\t{ open: 16, close: 22, high: 26, low: 6, mid: 18 },\n\t\t\t//\t|\t\t\t\t\t{ open: 22, close: 18, high: 22, low: 11, mid: 21 },\n\t\t\t//\t|\t\t\t\t\t{ open: 18, close: 29, high: 32, low: 14, mid: 27 },\n\t\t\t//\t|\t\t\t\t\t{ open: 29, close: 24, high: 29, low: 13, mid: 27 },\n\t\t\t//\t|\t\t\t\t\t{ open: 24, close: 8, high: 24, low: 5 },\n\t\t\t//\t|\t\t\t\t\t{ open: 8, close: 16, high: 22, low: 2 },\n\t\t\t//\t|\t\t\t\t\t{ open: 16, close: 12, high: 19, low: 7 },\n\t\t\t//\t|\t\t\t\t\t{ open: 12, close: 20, high: 22, low: 8 },\n\t\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 },\n\t\t\t//\t|\t\t\t\t\t{ open: 16, close: 22, high: 26, low: 6, mid: 18 },\n\t\t\t//\t|\t\t\t\t\t{ open: 22, close: 18, high: 22, low: 11, mid: 21 },\n\t\t\t//\t|\t\t\t\t\t{ open: 18, close: 29, high: 32, low: 14, mid: 27 },\n\t\t\t//\t|\t\t\t\t\t{ open: 29, close: 24, high: 29, low: 13, mid: 27 },\n\t\t\t//\t|\t\t\t\t\t{ open: 24, close: 8, high: 24, low: 5 },\n\t\t\t//\t|\t\t\t\t\t{ open: 8, close: 16, high: 22, low: 2 },\n\t\t\t//\t|\t\t\t\t\t{ open: 16, close: 12, high: 19, low: 7 },\n\t\t\t//\t|\t\t\t\t\t{ open: 12, close: 20, high: 22, low: 8 },\n\t\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 },\n\t\t\t//\t|\t\t\t\t\t{ open: 16, close: 22, high: 26, low: 6 },\n\t\t\t//\t|\t\t\t\t\t{ open: 22, close: 18, high: 22, low: 11 },\n\t\t\t//\t|\t\t\t\t\t{ open: 18, close: 29, high: 32, low: 14 },\n\t\t\t//\t|\t\t\t\t\t{ open: 29, close: 24, high: 29, low: 13 },\n\t\t\t//\t|\t\t\t\t\t{ open: 24, close: 8, high: 24, low: 5 },\n\t\t\t//\t|\t\t\t\t\t{ open: 8, close: 16, high: 22, low: 2 },\n\t\t\t//\t|\t\t\t\t\t{ open: 16, close: 12, high: 19, low: 7 },\n\t\t\t//\t|\t\t\t\t\t{ open: 12, close: 20, high: 22, low: 8 },\n\t\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 }\n\t\t\t//\t|\t\t\t\t],\n\t\t\t//\t|\t\t\t\t{ stroke: { color: \"green\" }, fill: \"lightgreen\" }\n\t\t\t//\t|\t\t\t)\n\t\t\t//\t|\t\t\t.render();\n\t\t\t//\t|\t});\n\t\t\t\n\t\t\t// theme: dojox/charting/SimpleTheme?\n\t\t\t//\t\tAn optional theme to use for styling the chart.\n\t\t\t// axes: dojox/charting/axis2d/Base{}?\n\t\t\t//\t\tA map of axes for use in plotting a chart.\n\t\t\t// stack: dojox/charting/plot2d/Base[]\n\t\t\t//\t\tA stack of plotters.\n\t\t\t// plots: dojox/charting/plot2d/Base{}\n\t\t\t//\t\tA map of plotter indices\n\t\t\t// series: dojox/charting/Series[]\n\t\t\t//\t\tThe stack of data runs used to create plots.\n\t\t\t// runs: dojox/charting/Series{}\n\t\t\t//\t\tA map of series indices\n\t\t\t// margins: Object?\n\t\t\t//\t\tThe margins around the chart. Default is { l:10, t:10, r:10, b:10 }.\n\t\t\t// stroke: dojox.gfx.Stroke?\n\t\t\t//\t\tThe outline of the chart (stroke in vector graphics terms).\n\t\t\t// fill: dojox.gfx.Fill?\n\t\t\t//\t\tThe color for the chart.\n\t\t\t// node: DOMNode\n\t\t\t//\t\tThe container node passed to the constructor.\n\t\t\t// surface: dojox/gfx/shape.Surface\n\t\t\t//\t\tThe main graphics surface upon which a chart is drawn.\n\t\t\t// dirty: Boolean\n\t\t\t//\t\tA boolean flag indicating whether or not the chart needs to be updated/re-rendered.\n\t\t\t// htmlLabels: Boolean\n\t\t\t//\t\tA boolean flag indicating whether or not it should try to use HTML-based labels for the title or not.\n\t\t\t//\t\tThe default is true.  The only caveat is IE and Opera browsers will always use GFX-based labels.\n\t\n\t\t\tconstructor: function(/* DOMNode */node, /* __ChartCtorArgs? */kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for a new Chart.  Initializes all parameters used for a chart.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tThe newly created chart.\n\t\n\t\t\t\t// initialize parameters\n\t\t\t\tif(!kwArgs){ kwArgs = {}; }\n\t\t\t\tthis.margins = kwArgs.margins || defaultMargins;\n\t\t\t\tthis._customMargins = !!kwArgs.margins;\n\t\t\t\tthis.stroke    = kwArgs.stroke;\n\t\t\t\tthis.fill      = kwArgs.fill;\n\t\t\t\tthis.delayInMs = kwArgs.delayInMs || 200;\n\t\t\t\tthis.title     = kwArgs.title;\n\t\t\t\tthis.titleGap  = kwArgs.titleGap;\n\t\t\t\tthis.titlePos  = kwArgs.titlePos;\n\t\t\t\tthis.titleFont = kwArgs.titleFont;\n\t\t\t\tthis.titleFontColor = kwArgs.titleFontColor;\n\t\t\t\tthis.titleAlign = kwArgs.titleAlign; // This can be middle, left, right, or edge \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // edge is left or right aligned with chart plot edge depending on bidi.\n\t\t\t\tthis.chartTitle = null;\n\t\t\t\tthis.htmlLabels = true;\n\t\t\t\tif(\"htmlLabels\" in kwArgs){\n\t\t\t\t\tthis.htmlLabels = kwArgs.htmlLabels;\n\t\t\t\t}\n\t\n\t\t\t\t// default initialization\n\t\t\t\tthis.theme = null;\n\t\t\t\tthis.axes = {};\t\t// map of axes\n\t\t\t\tthis.stack = [];\t// stack of plotters\n\t\t\t\tthis.plots = {};\t// map of plotter indices\n\t\t\t\tthis.series = [];\t// stack of data runs\n\t\t\t\tthis.runs = {};\t\t// map of data run indices\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\t// create a surface\n\t\t\t\tthis.node = dom.byId(node);\n\t\t\t\tvar box = domGeom.getMarginBox(node);\n\t\t\t\tthis.surface = g.createSurface(this.node, box.w || 400, box.h || 300);\n\t\t\t\tif(this.surface.declaredClass.indexOf(\"vml\") == -1){\n\t\t\t\t\t// except if vml use native clipping\n\t\t\t\t\tthis._nativeClip = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdestroy: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCleanup when a chart is to be destroyed.\n\t\t\t\t// returns: void\n\t\t\t\tarr.forEach(this.series, destroy);\n\t\t\t\tarr.forEach(this.stack,  destroy);\n\t\t\t\tfunc.forIn(this.axes, destroy);\n\t\t\t\tthis.surface.destroy();\n\t\t\t\tif(this.chartTitle && this.chartTitle.tagName){\n\t\t\t\t\t// destroy title if it is a DOM node\n\t\t\t\t\tdomConstruct.destroy(this.chartTitle);\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetCoords: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the coordinates and dimensions of the containing DOMNode, as\n\t\t\t\t//\t\treturned by dojo.coords.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tThe resulting coordinates of the chart.  See dojo.coords for details.\n\t\t\t\tvar node = this.node;\n\t\t\t\tvar s = domStyle.getComputedStyle(node), coords = domGeom.getMarginBox(node, s);\n\t\t\t\tvar abs = domGeom.position(node, true);\n\t\t\t\tcoords.x = abs.x;\n\t\t\t\tcoords.y = abs.y;\n\t\t\t\treturn coords;\t//\tObject\n\t\t\t},\n\t\t\tsetTheme: function(theme){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet a theme of the chart.\n\t\t\t\t// theme: dojox/charting/SimpleTheme\n\t\t\t\t//\t\tThe theme to be used for visual rendering.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tthis.theme = theme.clone();\n\t\t\t\tif(!this._customMargins){\n\t\t\t\t\tthis.margins = this.theme.chart.margins || defaultMargins;\n\t\t\t\t}\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\taddAxis: function(name, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAdd an axis to the chart, for rendering.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the axis.\n\t\t\t\t// kwArgs: __BaseAxisCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object for use in defining details of an axis.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tvar axis, axisType = kwArgs && kwArgs.type || \"Default\";\n\t\t\t\tif(typeof axisType == \"string\"){\n\t\t\t\t\tif(!dc.axis2d || !dc.axis2d[axisType]){\n\t\t\t\t\t\tthrow Error(\"Can't find axis: \" + axisType + \" - Check \" + \"require() dependencies.\");\n\t\t\t\t\t}\n\t\t\t\t\taxis = new dc.axis2d[axisType](this, kwArgs);\n\t\t\t\t}else{\n\t\t\t\t\taxis = new axisType(this, kwArgs);\n\t\t\t\t}\n\t\t\t\taxis.name = name;\n\t\t\t\taxis.dirty = true;\n\t\t\t\tif(name in this.axes){\n\t\t\t\t\tthis.axes[name].destroy();\n\t\t\t\t}\n\t\t\t\tthis.axes[name] = axis;\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tgetAxis: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the given axis, by name.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name the axis was defined by.\n\t\t\t\t// returns: dojox/charting/axis2d/Default\n\t\t\t\t//\t\tThe axis as stored in the chart's axis map.\n\t\t\t\treturn this.axes[name];\t//\tdojox/charting/axis2d/Default\n\t\t\t},\n\t\t\tremoveAxis: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRemove the axis that was defined using name.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe axis name, as defined in addAxis.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.axes){\n\t\t\t\t\t// destroy the axis\n\t\t\t\t\tthis.axes[name].destroy();\n\t\t\t\t\tdelete this.axes[name];\n\t\t\t\t\t// mark the chart as dirty\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\taddPlot: function(name, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAdd a new plot to the chart, defined by name and using the optional keyword arguments object.\n\t\t\t\t//\t\tNote that dojox.charting assumes the main plot to be called \"default\"; if you do not have\n\t\t\t\t//\t\ta plot called \"default\" and attempt to add data series to the chart without specifying the\n\t\t\t\t//\t\tplot to be rendered on, you WILL get errors.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the plot to be added to the chart.  If you only plan on using one plot, call it \"default\".\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__PlotCtorArgs\n\t\t\t\t//\t\tAn object with optional parameters for the plot in question.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tvar plot, plotType = kwArgs && kwArgs.type || \"Default\";\n\t\t\t\tif(typeof plotType == \"string\"){\n\t\t\t\t\tif(!dc.plot2d || !dc.plot2d[plotType]){\n\t\t\t\t\t\tthrow Error(\"Can't find plot: \" + plotType + \" - didn't you forget to dojo\" + \".require() it?\");\n\t\t\t\t\t}\n\t\t\t\t\tplot = new dc.plot2d[plotType](this, kwArgs);\n\t\t\t\t}else{\n\t\t\t\t\tplot = new plotType(this, kwArgs);\n\t\t\t\t}\n\t\t\t\tplot.name = name;\n\t\t\t\tplot.dirty = true;\n\t\t\t\tif(name in this.plots){\n\t\t\t\t\tthis.stack[this.plots[name]].destroy();\n\t\t\t\t\tthis.stack[this.plots[name]] = plot;\n\t\t\t\t}else{\n\t\t\t\t\tthis.plots[name] = this.stack.length;\n\t\t\t\t\tthis.stack.push(plot);\n\t\t\t\t}\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tgetPlot: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the given plot, by name.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name the plot was defined by.\n\t\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t\t//\t\tThe plot.\n\t\t\t\treturn this.stack[this.plots[name]];\n\t\t\t},\n\t\t\tremovePlot: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRemove the plot defined using name from the chart's plot stack.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the plot as defined using addPlot.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.plots){\n\t\t\t\t\t// get the index and remove the name\n\t\t\t\t\tvar index = this.plots[name];\n\t\t\t\t\tdelete this.plots[name];\n\t\t\t\t\t// destroy the plot\n\t\t\t\t\tthis.stack[index].destroy();\n\t\t\t\t\t// remove the plot from the stack\n\t\t\t\t\tthis.stack.splice(index, 1);\n\t\t\t\t\t// update indices to reflect the shift\n\t\t\t\t\tfunc.forIn(this.plots, function(idx, name, plots){\n\t\t\t\t\t\tif(idx > index){\n\t\t\t\t\t\t\tplots[name] = idx - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t// remove all related series\n\t\t\t\t\tvar ns = arr.filter(this.series, function(run){ return run.plot != name; });\n\t\t\t\t\tif(ns.length < this.series.length){\n\t\t\t\t\t\t// kill all removed series\n\t\t\t\t\t\tarr.forEach(this.series, function(run){\n\t\t\t\t\t\t\tif(run.plot == name){\n\t\t\t\t\t\t\t\trun.destroy();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// rebuild all necessary data structures\n\t\t\t\t\t\tthis.runs = {};\n\t\t\t\t\t\tarr.forEach(ns, function(run, index){\n\t\t\t\t\t\t\tthis.runs[run.plot] = index;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\tthis.series = ns;\n\t\t\t\t\t}\n\t\t\t\t\t// mark the chart as dirty\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tgetPlotOrder: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns an array of plot names in the current order\n\t\t\t\t//\t\t(the top-most plot is the first).\n\t\t\t\t// returns: Array\n\t\t\t\treturn func.map(this.stack, getName); // Array\n\t\t\t},\n\t\t\tsetPlotOrder: function(newOrder){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSets new order of plots. newOrder cannot add or remove\n\t\t\t\t//\t\tplots. Wrong names, or dups are ignored.\n\t\t\t\t// newOrder: Array\n\t\t\t\t//\t\tArray of plot names compatible with getPlotOrder().\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tvar names = {},\n\t\t\t\t\torder = func.filter(newOrder, function(name){\n\t\t\t\t\t\tif(!(name in this.plots) || (name in names)){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnames[name] = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}, this);\n\t\t\t\tif(order.length < this.stack.length){\n\t\t\t\t\tfunc.forEach(this.stack, function(plot){\n\t\t\t\t\t\tvar name = plot.name;\n\t\t\t\t\t\tif(!(name in names)){\n\t\t\t\t\t\t\torder.push(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tvar newStack = func.map(order, function(name){\n\t\t\t\t\t\treturn this.stack[this.plots[name]];\n\t\t\t\t\t}, this);\n\t\t\t\tfunc.forEach(newStack, function(plot, i){\n\t\t\t\t\tthis.plots[plot.name] = i;\n\t\t\t\t}, this);\n\t\t\t\tthis.stack = newStack;\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tmovePlotToFront: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tMoves a given plot to front.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tPlot's name to move.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.plots){\n\t\t\t\t\tvar index = this.plots[name];\n\t\t\t\t\tif(index){\n\t\t\t\t\t\tvar newOrder = this.getPlotOrder();\n\t\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\t\tnewOrder.unshift(name);\n\t\t\t\t\t\treturn this.setPlotOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tmovePlotToBack: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tMoves a given plot to back.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tPlot's name to move.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.plots){\n\t\t\t\t\tvar index = this.plots[name];\n\t\t\t\t\tif(index < this.stack.length - 1){\n\t\t\t\t\t\tvar newOrder = this.getPlotOrder();\n\t\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\t\tnewOrder.push(name);\n\t\t\t\t\t\treturn this.setPlotOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\taddSeries: function(name, data, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAdd a data series to the chart for rendering.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the data series to be plotted.\n\t\t\t\t// data: Array|Object\n\t\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t\t// kwArgs: __SeriesCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object that will be mixed into\n\t\t\t\t//\t\tthe resultant series object.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tvar run = new Series(this, data, kwArgs);\n\t\t\t\trun.name = name;\n\t\t\t\tif(name in this.runs){\n\t\t\t\t\tthis.series[this.runs[name]].destroy();\n\t\t\t\t\tthis.series[this.runs[name]] = run;\n\t\t\t\t}else{\n\t\t\t\t\tthis.runs[name] = this.series.length;\n\t\t\t\t\tthis.series.push(run);\n\t\t\t\t}\n\t\t\t\tthis.dirty = true;\n\t\t\t\t// fix min/max\n\t\t\t\tif(!(\"ymin\" in run) && \"min\" in run){ run.ymin = run.min; }\n\t\t\t\tif(!(\"ymax\" in run) && \"max\" in run){ run.ymax = run.max; }\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tgetSeries: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the given series, by name.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name the series was defined by.\n\t\t\t\t// returns: dojox/charting/Series\n\t\t\t\t//\t\tThe series.\n\t\t\t\treturn this.series[this.runs[name]];\n\t\t\t},\n\t\t\tremoveSeries: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRemove the series defined by name from the chart.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the series as defined by addSeries.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.runs){\n\t\t\t\t\t// get the index and remove the name\n\t\t\t\t\tvar index = this.runs[name];\n\t\t\t\t\tdelete this.runs[name];\n\t\t\t\t\t// destroy the run\n\t\t\t\t\tthis.series[index].destroy();\n\t\t\t\t\t// remove the run from the stack of series\n\t\t\t\t\tthis.series.splice(index, 1);\n\t\t\t\t\t// update indices to reflect the shift\n\t\t\t\t\tfunc.forIn(this.runs, function(idx, name, runs){\n\t\t\t\t\t\tif(idx > index){\n\t\t\t\t\t\t\truns[name] = idx - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tupdateSeries: function(name, data, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUpdate the given series with a new set of data points.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the series as defined in addSeries.\n\t\t\t\t// data: Array|Object\n\t\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t\t// offsets: Boolean?\n\t\t\t\t//\t\tIf true recomputes the offsets of the chart based on the new\n\t\t\t\t//\t\tdata. This is useful if the range of data is drastically changing\n\t\t\t\t//\t\tand offsets need to be recomputed.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.runs){\n\t\t\t\t\tvar run = this.series[this.runs[name]];\n\t\t\t\t\trun.update(data);\n\t\t\t\t\tif(offsets){\n\t\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis._invalidateDependentPlots(run.plot, false);\n\t\t\t\t\t\tthis._invalidateDependentPlots(run.plot, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tgetSeriesOrder: function(plotName){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns an array of series names in the current order\n\t\t\t\t//\t\t(the top-most series is the first) within a plot.\n\t\t\t\t// plotName: String\n\t\t\t\t//\t\tPlot's name.\n\t\t\t\t// returns: Array\n\t\t\t\treturn func.map(func.filter(this.series, function(run){\n\t\t\t\t\t\treturn run.plot == plotName;\n\t\t\t\t\t}), getName);\n\t\t\t},\n\t\t\tsetSeriesOrder: function(newOrder){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSets new order of series within a plot. newOrder cannot add\n\t\t\t\t//\t\tor remove series. Wrong names, or dups are ignored.\n\t\t\t\t// newOrder: Array\n\t\t\t\t//\t\tArray of series names compatible with getPlotOrder(). All\n\t\t\t\t//\t\tseries should belong to the same plot.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tvar plotName, names = {},\n\t\t\t\t\torder = func.filter(newOrder, function(name){\n\t\t\t\t\t\tif(!(name in this.runs) || (name in names)){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar run = this.series[this.runs[name]];\n\t\t\t\t\t\tif(plotName){\n\t\t\t\t\t\t\tif(run.plot != plotName){\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tplotName = run.plot;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnames[name] = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}, this);\n\t\t\t\tfunc.forEach(this.series, function(run){\n\t\t\t\t\tvar name = run.name;\n\t\t\t\t\tif(!(name in names) && run.plot == plotName){\n\t\t\t\t\t\torder.push(name);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tvar newSeries = func.map(order, function(name){\n\t\t\t\t\t\treturn this.series[this.runs[name]];\n\t\t\t\t\t}, this);\n\t\t\t\tthis.series = newSeries.concat(func.filter(this.series, function(run){\n\t\t\t\t\treturn run.plot != plotName;\n\t\t\t\t}));\n\t\t\t\tfunc.forEach(this.series, function(run, i){\n\t\t\t\t\tthis.runs[run.name] = i;\n\t\t\t\t}, this);\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tmoveSeriesToFront: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tMoves a given series to front of a plot.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tSeries' name to move.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.runs){\n\t\t\t\t\tvar index = this.runs[name],\n\t\t\t\t\t\tnewOrder = this.getSeriesOrder(this.series[index].plot);\n\t\t\t\t\tif(name != newOrder[0]){\n\t\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\t\tnewOrder.unshift(name);\n\t\t\t\t\t\treturn this.setSeriesOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tmoveSeriesToBack: function(name){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tMoves a given series to back of a plot.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tSeries' name to move.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(name in this.runs){\n\t\t\t\t\tvar index = this.runs[name],\n\t\t\t\t\t\tnewOrder = this.getSeriesOrder(this.series[index].plot);\n\t\t\t\t\tif(name != newOrder[newOrder.length - 1]){\n\t\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\t\tnewOrder.push(name);\n\t\t\t\t\t\treturn this.setSeriesOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tresize: function(width, height){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tResize the chart to the dimensions of width and height.\n\t\t\t\t// description:\n\t\t\t\t//\t\tResize the chart and its surface to the width and height dimensions.\n\t\t\t\t//\t\tIf a single argument of the form {w: value1, h: value2} is provided take that argument as the dimensions to use.\n\t\t\t\t//\t\tFinally if no argument is provided, resize the surface to the marginBox of the chart.\n\t\t\t\t// width: Number|Object?\n\t\t\t\t//\t\tThe new width of the chart or the box definition.\n\t\t\t\t// height: Number?\n\t\t\t\t//\t\tThe new height of the chart.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tswitch(arguments.length){\n\t\t\t\t\t// case 0, do not resize the div, just the surface\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t// argument, override node box\n\t\t\t\t\t\tdomGeom.setMarginBox(this.node, width);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t// argument, override node box\n\t\t\t\t\t\tdomGeom.setMarginBox(this.node, {w: width, h: height});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// in all cases take back the computed box\n\t\t\t\tvar box = domGeom.getMarginBox(this.node);\n\t\t\t\tvar d = this.surface.getDimensions();\n\t\t\t\tif(d.width != box.w || d.height != box.h){\n\t\t\t\t\t// and set it on the surface\n\t\t\t\t\tthis.surface.setDimensions(box.w, box.h);\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\treturn this.render();\t//\tdojox/charting/Chart\n\t\t\t\t}else{\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetGeometry: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns a map of information about all axes in a chart and what they represent\n\t\t\t\t//\t\tin terms of scaling (see dojox.charting.axis2d.Default.getScaler).\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tAn map of geometry objects, a one-to-one mapping of axes.\n\t\t\t\tvar ret = {};\n\t\t\t\tfunc.forIn(this.axes, function(axis){\n\t\t\t\t\tif(axis.initialized()){\n\t\t\t\t\t\tret[axis.name] = {\n\t\t\t\t\t\t\tname:\t\taxis.name,\n\t\t\t\t\t\t\tvertical:\taxis.vertical,\n\t\t\t\t\t\t\tscaler:\t\taxis.scaler,\n\t\t\t\t\t\t\tticks:\t\taxis.ticks\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn ret;\t//\tObject\n\t\t\t},\n\t\t\tsetAxisWindow: function(name, scale, offset, zoom){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tZooms an axis and all dependent plots. Can be used to zoom in 1D.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the axis as defined by addAxis.\n\t\t\t\t// scale: Number\n\t\t\t\t//\t\tThe scale on the target axis.\n\t\t\t\t// offset: Number\n\t\t\t\t//\t\tAny offest, as measured by axis tick\n\t\t\t\t// zoom: Boolean|Object?\n\t\t\t\t//\t\tThe chart zooming animation trigger.  This is null by default,\n\t\t\t\t//\t\te.g. {duration: 1200}, or just set true.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tvar axis = this.axes[name];\n\t\t\t\tif(axis){\n\t\t\t\t\taxis.setWindow(scale, offset);\n\t\t\t\t\tarr.forEach(this.stack,function(plot){\n\t\t\t\t\t\tif(plot.hAxis == name || plot.vAxis == name){\n\t\t\t\t\t\t\tplot.zoom = zoom;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tsetWindow: function(sx, sy, dx, dy, zoom){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tZooms in or out any plots in two dimensions.\n\t\t\t\t// sx: Number\n\t\t\t\t//\t\tThe scale for the x axis.\n\t\t\t\t// sy: Number\n\t\t\t\t//\t\tThe scale for the y axis.\n\t\t\t\t// dx: Number\n\t\t\t\t//\t\tThe pixel offset on the x axis.\n\t\t\t\t// dy: Number\n\t\t\t\t//\t\tThe pixel offset on the y axis.\n\t\t\t\t// zoom: Boolean|Object?\n\t\t\t\t//\t\tThe chart zooming animation trigger.  This is null by default,\n\t\t\t\t//\t\te.g. {duration: 1200}, or just set true.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(!(\"plotArea\" in this)){\n\t\t\t\t\tthis.calculateGeometry();\n\t\t\t\t}\n\t\t\t\tfunc.forIn(this.axes, function(axis){\n\t\t\t\t\tvar scale, offset, bounds = axis.getScaler().bounds,\n\t\t\t\t\t\ts = bounds.span / (bounds.upper - bounds.lower);\n\t\t\t\t\tif(axis.vertical){\n\t\t\t\t\t\tscale  = sy;\n\t\t\t\t\t\toffset = dy / s / scale;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tscale  = sx;\n\t\t\t\t\t\toffset = dx / s / scale;\n\t\t\t\t\t}\n\t\t\t\t\taxis.setWindow(scale, offset);\n\t\t\t\t});\n\t\t\t\tarr.forEach(this.stack, function(plot){ plot.zoom = zoom; });\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tzoomIn:\tfunction(name, range, delayed){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tZoom the chart to a specific range on one axis.  This calls render()\n\t\t\t\t//\t\tdirectly as a convenience method.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the axis as defined by addAxis.\n\t\t\t\t// range: Array\n\t\t\t\t//\t\tThe end points of the zoom range, measured in axis ticks.\n\t\t\t\tvar axis = this.axes[name];\n\t\t\t\tif(axis){\n\t\t\t\t\tvar scale, offset, bounds = axis.getScaler().bounds;\n\t\t\t\t\tvar lower = Math.min(range[0],range[1]);\n\t\t\t\t\tvar upper = Math.max(range[0],range[1]);\n\t\t\t\t\tlower = range[0] < bounds.lower ? bounds.lower : lower;\n\t\t\t\t\tupper = range[1] > bounds.upper ? bounds.upper : upper;\n\t\t\t\t\tscale = (bounds.upper - bounds.lower) / (upper - lower);\n\t\t\t\t\toffset = lower - bounds.lower;\n\t\t\t\t\tthis.setAxisWindow(name, scale, offset);\n\t\t\t\t\tif(delayed){\n\t\t\t\t\t\tthis.delayedRender();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis.render();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tcalculateGeometry: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the geometry of the chart based on the defined axes of\n\t\t\t\t//\t\ta chart.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(this.dirty){\n\t\t\t\t\treturn this.fullGeometry();\n\t\t\t\t}\n\t\n\t\t\t\t// calculate geometry\n\t\t\t\tvar dirty = arr.filter(this.stack, function(plot){\n\t\t\t\t\t\treturn plot.dirty ||\n\t\t\t\t\t\t\t(plot.hAxis && this.axes[plot.hAxis].dirty) ||\n\t\t\t\t\t\t\t(plot.vAxis && this.axes[plot.vAxis].dirty);\n\t\t\t\t\t}, this);\n\t\t\t\tcalculateAxes(dirty, this.plotArea);\n\t\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tfullGeometry: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the full geometry of the chart.  This includes passing\n\t\t\t\t//\t\tover all major elements of a chart (plots, axes, series, container)\n\t\t\t\t//\t\tin order to ensure proper rendering.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tthis._makeDirty();\n\t\n\t\t\t\t// clear old values\n\t\t\t\tarr.forEach(this.stack, clear);\n\t\n\t\t\t\t// rebuild new connections, and add defaults\n\t\n\t\t\t\t// set up a theme\n\t\t\t\tif(!this.theme){\n\t\t\t\t\tthis.setTheme(new SimpleTheme());\n\t\t\t\t}\n\t\n\t\t\t\t// assign series\n\t\t\t\tarr.forEach(this.series, function(run){\n\t\t\t\t\tif(!(run.plot in this.plots)){\n\t\t\t\t\t\t// TODO remove auto-assignment\n\t\t\t\t\t\tif(!dc.plot2d || !dc.plot2d.Default){\n\t\t\t\t\t\t\tthrow Error(\"Can't find plot: Default - didn't you forget to dojo\" + \".require() it?\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar plot = new dc.plot2d.Default(this, {});\n\t\t\t\t\t\tplot.name = run.plot;\n\t\t\t\t\t\tthis.plots[run.plot] = this.stack.length;\n\t\t\t\t\t\tthis.stack.push(plot);\n\t\t\t\t\t}\n\t\t\t\t\tthis.stack[this.plots[run.plot]].addSeries(run);\n\t\t\t\t}, this);\n\t\t\t\t// assign axes\n\t\t\t\tarr.forEach(this.stack, function(plot){\n\t\t\t\t\tif(plot.assignAxes){\n\t\t\t\t\t\tplot.assignAxes(this.axes);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\n\t\t\t\t// calculate geometry\n\t\n\t\t\t\t// 1st pass\n\t\t\t\tvar dim = this.dim = this.surface.getDimensions();\n\t\t\t\tdim.width  = g.normalizedLength(dim.width);\n\t\t\t\tdim.height = g.normalizedLength(dim.height);\n\t\t\t\tfunc.forIn(this.axes, clear);\n\t\t\t\tcalculateAxes(this.stack, dim);\n\t\n\t\t\t\t// assumption: we don't have stacked axes yet\n\t\t\t\tvar offsets = this.offsets = {l: 0, r: 0, t: 0, b: 0};\n\t\t\t\t// chart mirroring starts\n\t\t\t\tvar self = this;\n\t\t\t\tfunc.forIn(this.axes, function(axis){\n\t\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\t\tself._resetLeftBottom(axis);\n\t\t\t\t\t}\n\t\t\t\t\tfunc.forIn(axis.getOffsets(), function(o, i){ offsets[i] = Math.max(o, offsets[i]); });\n\t\t\t\t});\n\t\t\t\t// chart mirroring ends\n\t\t\t\t// add title area\n\t\t\t\tif(this.title){\n\t\t\t\t\tthis.titleGap = (this.titleGap==0) ? 0 : this.titleGap || this.theme.chart.titleGap || 20;\n\t\t\t\t\tthis.titlePos = this.titlePos || this.theme.chart.titlePos || \"top\";\n\t\t\t\t\tthis.titleFont = this.titleFont || this.theme.chart.titleFont;\n\t\t\t\t\tthis.titleFontColor = this.titleFontColor || this.theme.chart.titleFontColor || \"black\";\n\t\t\t\t\tthis.titleAlign = this.titleAlign || this.theme && this.theme.chart && this.theme.chart.titleAlign || \"middle\";\n\t\t\t\t\tvar tsize = g.normalizedLength(g.splitFontString(this.titleFont).size);\n\t\t\t\t\toffsets[this.titlePos == \"top\" ? \"t\" : \"b\"] += (tsize + this.titleGap);\n\t\t\t\t}\n\t\t\t\t// add margins\n\t\t\t\tfunc.forIn(this.margins, function(o, i){ offsets[i] += o; });\n\t\n\t\t\t\t// 2nd pass with realistic dimensions\n\t\t\t\tthis.plotArea = {\n\t\t\t\t\twidth: dim.width - offsets.l - offsets.r,\n\t\t\t\t\theight: dim.height - offsets.t - offsets.b\n\t\t\t\t};\n\t\t\t\tfunc.forIn(this.axes, clear);\n\t\t\t\tcalculateAxes(this.stack, this.plotArea);\n\t\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\trender: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender the chart according to the current information defined.  This should\n\t\t\t\t//\t\tbe the last call made when defining/creating a chart, or if data within the\n\t\t\t\t//\t\tchart has been changed.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\n\t\t\t\t// do we have a delayed renderer pending? If yes we need to clear it\n\t\t\t\tif(this._delayedRenderHandle){\n\t\t\t\t\tclearTimeout(this._delayedRenderHandle);\n\t\t\t\t\tthis._delayedRenderHandle = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(this.theme){\n\t\t\t\t\tthis.theme.clear();\n\t\t\t\t}\n\t\n\t\t\t\tif(this.dirty){\n\t\t\t\t\treturn this.fullRender();\n\t\t\t\t}\n\t\n\t\t\t\tthis.calculateGeometry();\n\t\n\t\t\t\t// go over the stack backwards\n\t\t\t\tfunc.forEachRev(this.stack, function(plot){ plot.render(this.dim, this.offsets); }, this);\n\t\n\t\t\t\t// go over axes\n\t\t\t\tfunc.forIn(this.axes, function(axis){ axis.render(this.dim, this.offsets); }, this);\n\t\n\t\t\t\tthis._makeClean();\n\t\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tfullRender: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tForce a full rendering of the chart, including full resets on the chart itself.\n\t\t\t\t//\t\tYou should not call this method directly unless absolutely necessary.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\n\t\t\t\t// calculate geometry\n\t\t\t\tthis.fullGeometry();\n\t\t\t\tvar offsets = this.offsets, dim = this.dim;\n\t\t\t\tvar w = Math.max(0, dim.width  - offsets.l - offsets.r),\n\t\t\t\t\th = Math.max(0, dim.height - offsets.t - offsets.b);\n\t\n\t\t\t\t// get required colors\n\t\t\t\t//var requiredColors = func.foldl(this.stack, \"z + plot.getRequiredColors()\", 0);\n\t\t\t\t//this.theme.defineColors({num: requiredColors, cache: false});\n\t\n\t\t\t\t// clear old shapes\n\t\t\t\tarr.forEach(this.series, purge);\n\t\t\t\tfunc.forIn(this.axes, purge);\n\t\t\t\tarr.forEach(this.stack,  purge);\n\t\t\t\tvar children = this.surface.children;\n\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\tif(shape.dispose){\n\t\t\t\t\tfor(var i = 0; i < children.length;++i){\n\t\t\t\t\t\tshape.dispose(children[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.chartTitle && this.chartTitle.tagName){\n\t\t\t\t\t// destroy title if it is a DOM node\n\t\t\t\t    domConstruct.destroy(this.chartTitle);\n\t\t\t\t}\n\t\t\t\tthis.surface.clear();\n\t\t\t\tthis.chartTitle = null;\n\t\n\t\t\t\tthis._renderChartBackground(dim, offsets);\n\t\t\t\tif(this._nativeClip){\n\t\t\t\t\tthis._renderPlotBackground(dim, offsets, w, h);\n\t\t\t\t}else{\n\t\t\t\t\t// VML\n\t\t\t\t\tthis._renderPlotBackground(dim, offsets, w, h);\n\t\t\t\t}\n\t\n\t\t\t\t// go over the stack backwards\n\t\t\t\tfunc.foldr(this.stack, function(z, plot){ return plot.render(dim, offsets), 0; }, 0);\n\t\n\t\t\t\tif(!this._nativeClip){\n\t\t\t\t\t// VML, matting-clipping\n\t\t\t\t\tthis._renderChartBackground(dim, offsets);\n\t\t\t\t}\n\t\n\t\t\t\t//create title: Whether to make chart title as a widget which extends dojox.charting.Element?\n\t\t\t\tif(this.title){\n\t\t\t\t\tthis._renderTitle(dim, offsets);\n\t\t\t\t}\n\t\n\t\t\t\t// go over axes\n\t\t\t\tfunc.forIn(this.axes, function(axis){ axis.render(dim, offsets); });\n\t\n\t\t\t\tthis._makeClean();\n\t\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\t_renderTitle: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tInternal function to render the chart title.\n\t\t\t\t// dim:\n\t\t\t\t//\t\tThe dimension object of the chart\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\tvar forceHtmlLabels = (g.renderer == \"canvas\") && this.htmlLabels,\n\t\t\t\t\tlabelType = forceHtmlLabels || !has(\"ie\") && !has(\"opera\") && this.htmlLabels ? \"html\" : \"gfx\",\n\t\t\t\t\ttsize = g.normalizedLength(g.splitFontString(this.titleFont).size),\n\t\t\t\t\ttBox = g._base._getTextBox(this.title,{ font: this.titleFont });\n\t\t\t\t\t\n\t\t\t\tvar titleAlign = this.titleAlign;\n\t\t\t\tvar isRtl = has(\"dojo-bidi\") && this.isRightToLeft();\n\t\t\t\tvar posX = dim.width/2; // Default is middle.\n\t\t\t\tif(titleAlign === \"edge\"){\n\t\t\t\t\ttitleAlign = \"left\";\n\t\t\t\t\tif(isRtl){\n\t\t\t\t\t\tposX = dim.width - (offsets.r + tBox.w);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tposX = offsets.l;\n\t\t\t\t\t}\n\t\t\t\t}else if(titleAlign != \"middle\"){\n\t\t\t\t\tif(isRtl){\n\t\t\t\t\t\t// We're in BIDI mode, reverse the alignment.\n\t\t\t\t\t\ttitleAlign = titleAlign === \"left\" ? \"right\" : \"left\";\n\t\t\t\t\t}\n\t\t\t\t\tif(titleAlign === \"left\"){\n\t\t\t\t\t\tposX = this.margins.l;\n\t\t\t\t\t}else if(titleAlign === \"right\"){\n\t\t\t\t\t\ttitleAlign = \"left\";\n\t\t\t\t\t\tposX = dim.width - (this.margins.l + tBox.w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.chartTitle = common.createText[labelType](\n\t\t\t\t\tthis,\n\t\t\t\t\tthis.surface,\n\t\t\t\t\tposX,\n\t\t\t\t\tthis.titlePos==\"top\" ? tsize + this.margins.t : dim.height - this.margins.b,\n\t\t\t\t\ttitleAlign,\n\t\t\t\t\tthis.title,\n\t\t\t\t\tthis.titleFont,\n\t\t\t\t\tthis.titleFontColor\n\t\t\t\t);\n\t\t\t},\n\t\t\t_renderChartBackground: function(dim, offsets){\n\t\t\t\tvar t = this.theme, rect;\n\t\t\t\t// chart background\n\t\t\t\tvar fill   = this.fill   !== undefined ? this.fill   : (t.chart && t.chart.fill);\n\t\t\t\tvar stroke = this.stroke !== undefined ? this.stroke : (t.chart && t.chart.stroke);\n\t\n\t\t\t\t// TRT: support for \"inherit\" as a named value in a theme.\n\t\t\t\tif(fill == \"inherit\"){\n\t\t\t\t\t//\tfind the background color of the nearest ancestor node, and use that explicitly.\n\t\t\t\t\tvar node = this.node;\n\t\t\t\t\tfill = new Color(domStyle.get(node, \"backgroundColor\"));\n\t\t\t\t\twhile(fill.a==0 && node!=document.documentElement){\n\t\t\t\t\t\tfill = new Color(domStyle.get(node, \"backgroundColor\"));\n\t\t\t\t\t\tnode = node.parentNode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif(fill){\n\t\t\t\t\tif(this._nativeClip){\n\t\t\t\t\t\tfill = Element.prototype._shapeFill(Element.prototype._plotFill(fill, dim),\n\t\t\t\t\t\t\t{ x:0, y: 0, width: dim.width + 1, height: dim.height + 1 });\n\t\t\t\t\t\tthis.surface.createRect({ width: dim.width + 1, height: dim.height + 1 }).setFill(fill);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// VML\n\t\t\t\t\t\tfill = Element.prototype._plotFill(fill, dim, offsets);\n\t\t\t\t\t\tif(offsets.l){\t// left\n\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\twidth:  offsets.l,\n\t\t\t\t\t\t\t\theight: dim.height + 1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(offsets.r){\t// right\n\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\tx: dim.width - offsets.r,\n\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\twidth:  offsets.r + 1,\n\t\t\t\t\t\t\t\theight: dim.height + 2\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(offsets.t){\t// top\n\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\twidth:  dim.width + 1,\n\t\t\t\t\t\t\t\theight: offsets.t\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(offsets.b){\t// bottom\n\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b,\n\t\t\t\t\t\t\t\twidth:  dim.width + 1,\n\t\t\t\t\t\t\t\theight: offsets.b + 2\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(stroke){\n\t\t\t\t\tthis.surface.createRect({\n\t\t\t\t\t\twidth:  dim.width - 1,\n\t\t\t\t\t\theight: dim.height - 1\n\t\t\t\t\t}).setStroke(stroke);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderPlotBackground: function(dim, offsets, w, h){\n\t\t\t\tvar t = this.theme;\n\t\n\t\t\t\t// draw a plot background\n\t\t\t\tvar fill   = t.plotarea && t.plotarea.fill;\n\t\t\t\tvar stroke = t.plotarea && t.plotarea.stroke;\n\t\t\t\t// size might be neg if offsets are bigger that chart size this happens quite often at\n\t\t\t\t// initialization time if the chart widget is used in a BorderContainer\n\t\t\t\t// this will fail on IE/VML\n\t\t\t\tvar rect = {\n\t\t\t\t\tx: offsets.l - 1, y: offsets.t - 1,\n\t\t\t\t\twidth:  w + 2,\n\t\t\t\t\theight: h + 2\n\t\t\t\t};\n\t\t\t\tif(fill){\n\t\t\t\t\tfill = Element.prototype._shapeFill(Element.prototype._plotFill(fill, dim, offsets), rect);\n\t\t\t\t\tthis.surface.createRect(rect).setFill(fill);\n\t\t\t\t}\n\t\t\t\tif(stroke){\n\t\t\t\t\tthis.surface.createRect({\n\t\t\t\t\t\tx: offsets.l, y: offsets.t,\n\t\t\t\t\t\twidth:  w + 1,\n\t\t\t\t\t\theight: h + 1\n\t\t\t\t\t}).setStroke(stroke);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelayedRender: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDelayed render, which is used to collect multiple updates\n\t\t\t\t//\t\twithin a delayInMs time window.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\n\t\t\t\tif(!this._delayedRenderHandle){\n\t\t\t\t\tthis._delayedRenderHandle = setTimeout(\n\t\t\t\t\t\tlang.hitch(this, function(){\n\t\t\t\t\t\t\tthis.render();\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tthis.delayInMs\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\tconnectToPlot: function(name, object, method){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tA convenience method to connect a function to a plot.\n\t\t\t\t// name: String\n\t\t\t\t//\t\tThe name of the plot as defined by addPlot.\n\t\t\t\t// object: Object\n\t\t\t\t//\t\tThe object to be connected.\n\t\t\t\t// method: Function\n\t\t\t\t//\t\tThe function to be executed.\n\t\t\t\t// returns: Array\n\t\t\t\t//\t\tA handle to the connection, as defined by dojo.connect (see dojo.connect).\n\t\t\t\treturn name in this.plots ? this.stack[this.plots[name]].connect(object, method) : null;\t//\tArray\n\t\t\t},\n\t\t\tfireEvent: function(seriesName, eventName, index){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tFires a synthetic event for a series item.\n\t\t\t\t// seriesName: String\n\t\t\t\t//\t\tSeries name.\n\t\t\t\t// eventName: String\n\t\t\t\t//\t\tEvent name to simulate: onmouseover, onmouseout, onclick.\n\t\t\t\t// index: Number\n\t\t\t\t//\t\tValid data value index for the event.\n\t\t\t\t// returns: dojox/charting/Chart\n\t\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\t\tif(seriesName in this.runs){\n\t\t\t\t\tvar plotName = this.series[this.runs[seriesName]].plot;\n\t\t\t\t\tif(plotName in this.plots){\n\t\t\t\t\t\tvar plot = this.stack[this.plots[plotName]];\n\t\t\t\t\t\tif(plot){\n\t\t\t\t\t\t\tplot.fireEvent(seriesName, eventName, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t\t},\n\t\t\t_makeClean: function(){\n\t\t\t\t// reset dirty flags\n\t\t\t\tarr.forEach(this.axes,   makeClean);\n\t\t\t\tarr.forEach(this.stack,  makeClean);\n\t\t\t\tarr.forEach(this.series, makeClean);\n\t\t\t\tthis.dirty = false;\n\t\t\t},\n\t\t\t_makeDirty: function(){\n\t\t\t\t// reset dirty flags\n\t\t\t\tarr.forEach(this.axes,   makeDirty);\n\t\t\t\tarr.forEach(this.stack,  makeDirty);\n\t\t\t\tarr.forEach(this.series, makeDirty);\n\t\t\t\tthis.dirty = true;\n\t\t\t},\n\t\t\t_invalidateDependentPlots: function(plotName, /* Boolean */ verticalAxis){\n\t\t\t\tif(plotName in this.plots){\n\t\t\t\t\tvar plot = this.stack[this.plots[plotName]], axis,\n\t\t\t\t\t\taxisName = verticalAxis ? \"vAxis\" : \"hAxis\";\n\t\t\t\t\tif(plot[axisName]){\n\t\t\t\t\t\taxis = this.axes[plot[axisName]];\n\t\t\t\t\t\tif(axis && axis.dependOnData()){\n\t\t\t\t\t\t\taxis.dirty = true;\n\t\t\t\t\t\t\t// find all plots and mark them dirty\n\t\t\t\t\t\t\tarr.forEach(this.stack, function(p){\n\t\t\t\t\t\t\t\tif(p[axisName] && p[axisName] == plot[axisName]){\n\t\t\t\t\t\t\t\t\tp.dirty = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tplot.dirty = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetDir : function(dir){\n\t\t\t\treturn this; \n\t\t\t},\n\t\t\t_resetLeftBottom: function(axis){\n\t\t\t},\n\t\t\tformatTruncatedLabel: function(element, label, labelType){\t\t\t\n\t\t\t}\n\t\t});\n\t\n\t\tfunction hSection(stats){\n\t\t\treturn {min: stats.hmin, max: stats.hmax};\n\t\t}\n\t\n\t\tfunction vSection(stats){\n\t\t\treturn {min: stats.vmin, max: stats.vmax};\n\t\t}\n\t\n\t\tfunction hReplace(stats, h){\n\t\t\tstats.hmin = h.min;\n\t\t\tstats.hmax = h.max;\n\t\t}\n\t\n\t\tfunction vReplace(stats, v){\n\t\t\tstats.vmin = v.min;\n\t\t\tstats.vmax = v.max;\n\t\t}\n\t\n\t\tfunction combineStats(target, source){\n\t\t\tif(target && source){\n\t\t\t\ttarget.min = Math.min(target.min, source.min);\n\t\t\t\ttarget.max = Math.max(target.max, source.max);\n\t\t\t}\n\t\t\treturn target || source;\n\t\t}\n\t\n\t\tfunction calculateAxes(stack, plotArea){\n\t\t\tvar plots = {}, axes = {};\n\t\t\tarr.forEach(stack, function(plot){\n\t\t\t\tvar stats = plots[plot.name] = plot.getSeriesStats();\n\t\t\t\tif(plot.hAxis){\n\t\t\t\t\taxes[plot.hAxis] = combineStats(axes[plot.hAxis], hSection(stats));\n\t\t\t\t}\n\t\t\t\tif(plot.vAxis){\n\t\t\t\t\taxes[plot.vAxis] = combineStats(axes[plot.vAxis], vSection(stats));\n\t\t\t\t}\n\t\t\t});\n\t\t\tarr.forEach(stack, function(plot){\n\t\t\t\tvar stats = plots[plot.name];\n\t\t\t\tif(plot.hAxis){\n\t\t\t\t\thReplace(stats, axes[plot.hAxis]);\n\t\t\t\t}\n\t\t\t\tif(plot.vAxis){\n\t\t\t\t\tvReplace(stats, axes[plot.vAxis]);\n\t\t\t\t}\n\t\t\t\tplot.initializeScalers(plotArea, stats);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn has(\"dojo-bidi\")? declare(\"dojox.charting.Chart\", [Chart, BidiChart]) : Chart;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 192 */\n/*!****************************************!*\\\n  !*** ../dojox/charting/SimpleTheme.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13),__webpack_require__(/*! dojo/_base/declare */ 33),__webpack_require__(/*! dojo/_base/Color */ 120), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/gradutils */ 193)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, Color, dlu, dgg){\n\t\t\n\t\tvar SimpleTheme = declare(\"dojox.charting.SimpleTheme\", null, {\n\t\t// summary:\n\t\t//\t\tA SimpleTheme or Theme is a pre-defined object, primarily JSON-based, that makes up the definitions to\n\t\t//\t\tstyle a chart.\n\t\t//\n\t\t// description:\n\t\t//\t\tWhile you can set up style definitions on a chart directly (usually through the various add methods\n\t\t//\t\ton a dojox.charting.Chart object), a Theme simplifies this manual setup by allowing you to\n\t\t//\t\tpre-define all of the various visual parameters of each element in a chart.\n\t\t//\n\t\t//\t\tMost of the properties of a Theme are straight-forward; if something is line-based (such as\n\t\t//\t\tan axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,\n\t\t//\t\tif an element is primarily block-based (such as the background of a chart), it will be primarily\n\t\t//\t\tfill-based.\n\t\t//\n\t\t//\t\tIn addition (for convenience), a Theme definition does not have to contain the entire JSON-based\n\t\t//\t\tstructure.  Each theme is built on top of a default theme (which serves as the basis for the theme\n\t\t//\t\t\"GreySkies\"), and is mixed into the default theme object.  This allows you to create a theme based,\n\t\t//\t\tsay, solely on colors for data series.\n\t\t//\n\t\t//\t\tDefining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples\n\t\t//\t\ton how to define your own.\n\t\t//\n\t\t//\t\tWhen you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter\n\t\t//\t\tthe theme itself after setting the theme value on a chart, and expect it to change your chart.  If you\n\t\t//\t\tare looking to make alterations to a theme for a chart, the suggestion would be to create your own\n\t\t//\t\ttheme, based on the one you want to use, that makes those alterations before it is applied to a chart.\n\t\t//\n\t\t//\t\tFinally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main\n\t\t//\t\thelper of which is the ~next~ method, in which a chart asks for the information for the next data series\n\t\t//\t\tto be rendered.\n\t\t//\n\t\t//\t\tA note on colors:\n\t\t//\t\tA theme palette is usually comprised of 5 different color definitions, and\n\t\t//\t\tno more.  If you have a need to render a chart with more than 5 data elements, you can simply \"push\"\n\t\t//\t\tnew color definitions into the theme's .color array.  Make sure that you do that with the actual\n\t\t//\t\ttheme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme\n\t\t//\t\ton a chart).\n\t\t//\n\t\t// example:\n\t\t//\t\tThe default theme (and structure) looks like so:\n\t\t//\t|\t// all objects are structs used directly in dojox.gfx\n\t\t//\t|\tchart:{\n\t\t//\t|\t\tmargins: {l: 10, t: 10, r: 10, b: 10},\n\t\t//\t|\t\tstroke: null,\n\t\t//\t|\t\tfill: \"white\",\n\t\t//\t|\t\tpageStyle: null // suggested page style as an object suitable for dojo.style()\n\t\t//\t|\t},\n\t\t//\t|\tplotarea:{\n\t\t//\t|\t\tstroke: null,\n\t\t//\t|\t\tfill: \"white\"\n\t\t//\t|\t},\n\t\t//\t|\taxis:{\n\t\t//\t|\t\tstroke:\t{ // the axis itself\n\t\t//\t|\t\t\tcolor: \"#333\",\n\t\t//\t|\t\t\twidth: 1\n\t\t//\t|\t\t},\n\t\t//\t|\t\ttick: {\t// used as a foundation for all ticks\n\t\t//\t|\t\t\tcolor:     \"#666\",\n\t\t//\t|\t\t\tposition:  \"center\",\n\t\t//\t|\t\t\tfont:      \"normal normal normal 7pt Tahoma\",\t// labels on axis\n\t\t//\t|\t\t\tfontColor: \"#333\"\t\t\t\t\t\t\t\t// color of labels\n\t\t//\t|\t\t},\n\t\t//\t|\t\tmajorTick:\t{ // major ticks on axis, and used for major gridlines\n\t\t//\t|\t\t\twidth:  1,\n\t\t//\t|\t\t\tlength: 6\n\t\t//\t|\t\t},\n\t\t//\t|\t\tminorTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t\t//\t|\t\t\twidth:  0.8,\n\t\t//\t|\t\t\tlength: 3\n\t\t//\t|\t\t},\n\t\t//\t|\t\tmicroTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t\t//\t|\t\t\twidth:  0.5,\n\t\t//\t|\t\t\tlength: 1\n\t\t//\t|\t\t},\n\t\t//\t|\t\ttitle: {\n\t\t//\t|\t\t\tgap:  15,\n\t\t//\t|\t\t\tfont: \"normal normal normal 11pt Tahoma\",\t// title font\n\t\t//\t|\t\t\tfontColor: \"#333\",\t\t\t\t\t\t\t// title font color\n\t\t//\t|\t\t\torientation: \"axis\"\t\t\t\t\t\t// \"axis\": facing the axis, \"away\": facing away\n\t\t//\t|\t\t}\n\t\t//\t|\t},\n\t\t//\t|\tseries: {\n\t\t//\t|\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// line\n\t\t//\t|\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t\t//\t|\t\t//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},\n\t\t//\t|\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t\t//\t|\t\t//filter:  dojox/gfx/filters.createFilter(),\n\t\t//\t|\t\tfilter: null,\t\t\t\t\t\t\t\t// no filter, to use a filter you must use gfx SVG render and require dojox/gfx/svgext\n\t\t//\t|\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill, if appropriate\n\t\t//\t|\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// if there's a label\n\t\t//\t|\t\tfontColor: \"#000\"\t\t\t\t\t\t\t// color of labels\n\t\t//\t|\t\tlabelWiring: {width: 1, color: \"#ccc\"},\t\t// connect marker and target data item(slice, column, bar...)\n\t\t//\t|\t},\n\t\t//\t|\tmarker: {\t// any markers on a series\n\t\t//\t|\t\tsymbol:  \"m-3,3 l3,-6 3,6 z\",\t\t\t\t// symbol\n\t\t//\t|\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// stroke\n\t\t//\t|\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t\t//\t|\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t\t//\t|\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill if needed\n\t\t//\t|\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// label\n\t\t//\t|\t\tfontColor: \"#000\"\n\t\t//\t|\t},\n\t\t//\t|\tgrid: {\t// grid, when not present axis tick strokes are used instead\n\t\t//\t|\t\tmajorLine: {\t// major grid line\n\t\t//\t|\t\t\tcolor:     \"#666\",\n\t\t//\t|\t\t\twidth:  1,\n\t\t//\t|\t\t\tlength: 6\n\t\t//\t|\t\t},\n\t\t//\t|\t\tminorLine: {\t// minor grid line\n\t\t//\t|\t\t\tcolor:     \"#666\",\n\t\t//\t|\t\t\twidth:  0.8,\n\t\t//\t|\t\t\tlength: 3\n\t\t//\t|\t\t},\n\t\t//\t|\t\tfill: \"grey\",  // every other stripe\n\t\t//\t|\t\talternateFill: \"grey\" // alternate stripe\n\t\t//\t|\t},\n\t\t//\t|\tindicator: {\n\t\t//\t|\t\tlineStroke:  {width: 1.5, color: \"#333\"},\t\t// line\n\t\t//\t|\t\tlineOutline: {width: 0.1, color: \"#ccc\"},\t\t// line outline\n\t\t//\t|\t\tlineShadow: null,\t\t\t\t\t\t\t\t// no line shadow\n\t\t//\t|\t\tlineFill: null,\t\t\t\t\t\t\t\t\t// fill between lines for dual indicators\n\t\t//\t|\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t\t// label background stroke\n\t\t//\t|\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t\t// label background outline\n\t\t//\t|\t\tshadow: null,\t\t\t\t\t\t\t\t\t// no label background shadow\n\t\t//\t|\t\tfill:  \"#ccc\",\t\t\t\t\t\t\t\t\t// label background fill\n\t\t//\t|\t\tradius: 3,\t\t\t\t\t\t\t\t\t\t// radius of the label background\n\t\t//\t|\t\tfont:    \"normal normal normal 10pt Tahoma\",\t// label font\n\t\t//\t|\t\tfontColor: \"#000\"\t\t\t\t\t\t\t\t// label color\n\t\t//\t|\t\tmarkerFill:    \"#ccc\",\t\t\t\t\t\t\t// marker fill\n\t\t//\t|\t\tmarkerSymbol:  \"m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0\",\t// marker symbol\n\t\t//\t|\t\tmarkerStroke:  {width: 1.5, color: \"#333\"},\t\t// marker stroke\n\t\t//\t|\t\tmarkerOutline: {width: 0.1, color: \"#ccc\"},\t\t// marker outline\n\t\t//\t|\t\tmarkerShadow: null,\t\t\t\t\t\t\t\t// no marker shadow\n\t\t//\t|\t}\n\t\t//\n\t\t// example:\n\t\t//\t\tDefining a new theme is pretty simple:\n\t\t//\t|\tvar Grasslands = new SimpleTheme({\n\t\t//\t|\t\tcolors: [ \"#70803a\", \"#dde574\", \"#788062\", \"#b1cc5d\", \"#eff2c2\" ]\n\t\t//\t|\t});\n\t\t//\t|\n\t\t//\t|\tmyChart.setTheme(Grasslands);\n\t\n\t\tshapeSpaces: {shape: 1, shapeX: 1, shapeY: 1},\n\t\n\t\tconstructor: function(kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tInitialize a theme using the keyword arguments.  Note that the arguments\n\t\t\t//\t\tlook like the example (above), and may include a few more parameters.\n\t\t\tkwArgs = kwArgs || {};\n\t\n\t\t\t// populate theme with defaults updating them if needed\n\t\t\tvar def = SimpleTheme.defaultTheme;\n\t\t\tarr.forEach([\"chart\", \"plotarea\", \"axis\", \"grid\", \"series\", \"marker\", \"indicator\"], function(name){\n\t\t\t\tthis[name] = lang.delegate(def[name], kwArgs[name]);\n\t\t\t}, this);\n\t\n\t\t\t// personalize theme\n\t\t\tif(kwArgs.seriesThemes && kwArgs.seriesThemes.length){\n\t\t\t\tthis.colors  = null;\n\t\t\t\tthis.seriesThemes = kwArgs.seriesThemes.slice(0);\n\t\t\t}else{\n\t\t\t\tthis.seriesThemes = null;\n\t\t\t\tthis.colors = (kwArgs.colors || SimpleTheme.defaultColors).slice(0);\n\t\t\t}\n\t\t\tthis.markerThemes = null;\n\t\t\tif(kwArgs.markerThemes && kwArgs.markerThemes.length){\n\t\t\t\tthis.markerThemes = kwArgs.markerThemes.slice(0);\n\t\t\t}\n\t\t\tthis.markers = kwArgs.markers ? lang.clone(kwArgs.markers) : lang.delegate(SimpleTheme.defaultMarkers);\n\t\n\t\t\t// set flags\n\t\t\tthis.noGradConv = kwArgs.noGradConv;\n\t\t\tthis.noRadialConv = kwArgs.noRadialConv;\n\t\t\tif(kwArgs.reverseFills){\n\t\t\t\tthis.reverseFills();\n\t\t\t}\n\t\n\t\t\t//\tprivate housekeeping\n\t\t\tthis._current = 0;\n\t\t\tthis._buildMarkerArray();\n\t\t},\n\t\n\t\tclone: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClone the current theme.\n\t\t\t// returns: dojox.charting.SimpleTheme\n\t\t\t//\t\tThe cloned theme; any alterations made will not affect the original.\n\t\t\tvar theme = new this.constructor({\n\t\t\t\t// theme components\n\t\t\t\tchart: this.chart,\n\t\t\t\tplotarea: this.plotarea,\n\t\t\t\taxis: this.axis,\n\t\t\t\tgrid: this.grid,\n\t\t\t\tseries: this.series,\n\t\t\t\tmarker: this.marker,\n\t\t\t\t// individual arrays\n\t\t\t\tcolors: this.colors,\n\t\t\t\tmarkers: this.markers,\n\t\t\t\tindicator: this.indicator,\n\t\t\t\tseriesThemes: this.seriesThemes,\n\t\t\t\tmarkerThemes: this.markerThemes,\n\t\t\t\t// flags\n\t\t\t\tnoGradConv: this.noGradConv,\n\t\t\t\tnoRadialConv: this.noRadialConv\n\t\t\t});\n\t\t\t// copy custom methods\n\t\t\tarr.forEach(\n\t\t\t\t[\"clone\", \"clear\", \"next\", \"skip\", \"addMixin\", \"post\", \"getTick\"],\n\t\t\t\tfunction(name){\n\t\t\t\t\tif(this.hasOwnProperty(name)){\n\t\t\t\t\t\ttheme[name] = this[name];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthis\n\t\t\t);\n\t\t\treturn theme;\t//\tdojox.charting.SimpleTheme\n\t\t},\n\t\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear and reset the internal pointer to start fresh.\n\t\t\tthis._current = 0;\n\t\t},\n\t\n\t\tnext: function(elementType, mixin, doPost){\n\t\t\t// summary:\n\t\t\t//\t\tGet the next color or series theme.\n\t\t\t// elementType: String?\n\t\t\t//\t\tAn optional element type (for use with series themes)\n\t\t\t// mixin: Object?\n\t\t\t//\t\tAn optional object to mix into the theme.\n\t\t\t// doPost: Boolean?\n\t\t\t//\t\tA flag to post-process the results.\n\t\t\t// returns: Object\n\t\t\t//\t\tAn object of the structure { series, marker, symbol }\n\t\t\tvar merge = dlu.merge, series, marker;\n\t\t\tif(this.colors){\n\t\t\t\tseries = lang.delegate(this.series);\n\t\t\t\tmarker = lang.delegate(this.marker);\n\t\t\t\tvar color = new Color(this.colors[this._current % this.colors.length]), old;\n\t\t\t\t// modify the stroke\n\t\t\t\tif(series.stroke && series.stroke.color){\n\t\t\t\t\tseries.stroke = lang.delegate(series.stroke);\n\t\t\t\t\told = new Color(series.stroke.color);\n\t\t\t\t\tseries.stroke.color = new Color(color);\n\t\t\t\t\tseries.stroke.color.a = old.a;\n\t\t\t\t}else{\n\t\t\t\t\tseries.stroke = {color: color};\n\t\t\t\t}\n\t\t\t\tif(marker.stroke && marker.stroke.color){\n\t\t\t\t\tmarker.stroke = lang.delegate(marker.stroke);\n\t\t\t\t\told = new Color(marker.stroke.color);\n\t\t\t\t\tmarker.stroke.color = new Color(color);\n\t\t\t\t\tmarker.stroke.color.a = old.a;\n\t\t\t\t}else{\n\t\t\t\t\tmarker.stroke = {color: color};\n\t\t\t\t}\n\t\t\t\t// modify the fill\n\t\t\t\tif(!series.fill || series.fill.type){\n\t\t\t\t\tseries.fill = color;\n\t\t\t\t}else{\n\t\t\t\t\told = new Color(series.fill);\n\t\t\t\t\tseries.fill = new Color(color);\n\t\t\t\t\tseries.fill.a = old.a;\n\t\t\t\t}\n\t\t\t\tif(!marker.fill || marker.fill.type){\n\t\t\t\t\tmarker.fill = color;\n\t\t\t\t}else{\n\t\t\t\t\told = new Color(marker.fill);\n\t\t\t\t\tmarker.fill = new Color(color);\n\t\t\t\t\tmarker.fill.a = old.a;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tseries = this.seriesThemes ?\n\t\t\t\t\tmerge(this.series, this.seriesThemes[this._current % this.seriesThemes.length]) :\n\t\t\t\t\tthis.series;\n\t\t\t\tmarker = this.markerThemes ?\n\t\t\t\t\tmerge(this.marker, this.markerThemes[this._current % this.markerThemes.length]) :\n\t\t\t\t\tseries;\n\t\t\t}\n\t\n\t\t\tvar symbol = marker && marker.symbol || this._markers[this._current % this._markers.length];\n\t\n\t\t\tvar theme = {series: series, marker: marker, symbol: symbol};\n\t\t\t\n\t\t\t// advance the counter\n\t\t\t++this._current;\n\t\n\t\t\tif(mixin){\n\t\t\t\ttheme = this.addMixin(theme, elementType, mixin);\n\t\t\t}\n\t\t\tif(doPost){\n\t\t\t\ttheme = this.post(theme, elementType);\n\t\t\t}\n\t\n\t\t\treturn theme;\t//\tObject\n\t\t},\n\t\n\t\tskip: function(){\n\t\t\t// summary:\n\t\t\t//\t\tSkip the next internal color.\n\t\t\t++this._current;\n\t\t},\n\t\n\t\taddMixin: function(theme, elementType, mixin, doPost){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a mixin object to the passed theme and process.\n\t\t\t// theme: dojox/charting/SimpleTheme\n\t\t\t//\t\tThe theme to mixin to.\n\t\t\t// elementType: String\n\t\t\t//\t\tThe type of element in question. Can be \"line\", \"bar\" or \"circle\"\n\t\t\t// mixin: Object|Array\n\t\t\t//\t\tThe object or objects to mix into the theme.\n\t\t\t// doPost: Boolean\n\t\t\t//\t\tIf true, run the new theme through the post-processor.\n\t\t\t// returns: dojox/charting/SimpleTheme\n\t\t\t//\t\tThe new theme.\n\t\t\tif(lang.isArray(mixin)){\n\t\t\t\tarr.forEach(mixin, function(m){\n\t\t\t\t\ttheme = this.addMixin(theme, elementType, m);\n\t\t\t\t}, this);\n\t\t\t}else{\n\t\t\t\tvar t = {};\n\t\t\t\tif(\"color\" in mixin){\n\t\t\t\t\tif(elementType == \"line\" || elementType == \"area\"){\n\t\t\t\t\t\tlang.setObject(\"series.stroke.color\", mixin.color, t);\n\t\t\t\t\t\tlang.setObject(\"marker.stroke.color\", mixin.color, t);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlang.setObject(\"series.fill\", mixin.color, t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tarr.forEach([\"stroke\", \"outline\", \"shadow\", \"fill\", \"filter\", \"font\", \"fontColor\", \"labelWiring\"], function(name){\n\t\t\t\t\tvar markerName = \"marker\" + name.charAt(0).toUpperCase() + name.substr(1),\n\t\t\t\t\t\tb = markerName in mixin;\n\t\t\t\t\tif(name in mixin){\n\t\t\t\t\t\tlang.setObject(\"series.\" + name, mixin[name], t);\n\t\t\t\t\t\tif(!b){\n\t\t\t\t\t\t\tlang.setObject(\"marker.\" + name, mixin[name], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(b){\n\t\t\t\t\t\tlang.setObject(\"marker.\" + name, mixin[markerName], t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(\"marker\" in mixin){\n\t\t\t\t\tt.symbol = mixin.marker;\n\t\t\t\t\tt.symbol = mixin.marker;\n\t\t\t\t}\n\t\t\t\ttheme = dlu.merge(theme, t);\n\t\t\t}\n\t\t\tif(doPost){\n\t\t\t\ttheme = this.post(theme, elementType);\n\t\t\t}\n\t\t\treturn theme;\t//\tdojox/charting/SimpleTheme\n\t\t},\n\t\n\t\tpost: function(theme, elementType){\n\t\t\t// summary:\n\t\t\t//\t\tProcess any post-shape fills.\n\t\t\t// theme: dojox/charting/SimpleTheme\n\t\t\t//\t\tThe theme to post process with.\n\t\t\t// elementType: String\n\t\t\t//\t\tThe type of element being filled.  Can be \"bar\" or \"circle\".\n\t\t\t// returns: dojox/charting/SimpleTheme\n\t\t\t//\t\tThe post-processed theme.\n\t\t\tvar fill = theme.series.fill, t;\n\t\t\tif(!this.noGradConv && this.shapeSpaces[fill.space] && fill.type == \"linear\"){\n\t\t\t\tif(elementType == \"bar\"){\n\t\t\t\t\t// transpose start and end points\n\t\t\t\t\tt = {\n\t\t\t\t\t\tx1: fill.y1,\n\t\t\t\t\t\ty1: fill.x1,\n\t\t\t\t\t\tx2: fill.y2,\n\t\t\t\t\t\ty2: fill.x2\n\t\t\t\t\t};\n\t\t\t\t}else if(!this.noRadialConv && fill.space == \"shape\" && (elementType == \"slice\" || elementType == \"circle\")){\n\t\t\t\t\t// switch to radial\n\t\t\t\t\tt = {\n\t\t\t\t\t\ttype: \"radial\",\n\t\t\t\t\t\tcx: 0,\n\t\t\t\t\t\tcy: 0,\n\t\t\t\t\t\tr:  100\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(t){\n\t\t\t\t\treturn dlu.merge(theme, {series: {fill: t}});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn theme;\t//\tdojox/charting/SimpleTheme\n\t\t},\n\t\n\t\tgetTick: function(name, mixin){\n\t\t\t// summary:\n\t\t\t//\t\tCalculates and merges tick parameters.\n\t\t\t// name: String\n\t\t\t//\t\tTick name, can be \"major\", \"minor\", or \"micro\".\n\t\t\t// mixin: Object?\n\t\t\t//\t\tOptional object to mix in to the tick.\n\t\t\tvar tick = this.axis.tick, tickName = name + \"Tick\",\n\t\t\t\tmerge = dlu.merge;\n\t\t\tif(tick){\n\t\t\t\tif(this.axis[tickName]){\n\t\t\t\t\ttick = merge(tick, this.axis[tickName]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttick = this.axis[tickName];\n\t\t\t}\n\t\t\tif(mixin){\n\t\t\t\tif(tick){\n\t\t\t\t\tif(mixin[tickName]){\n\t\t\t\t\t\ttick = merge(tick, mixin[tickName]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\ttick = mixin[tickName];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tick;\t//\tObject\n\t\t},\n\t\n\t\tinspectObjects: function(f){\n\t\t\tarr.forEach([\"chart\", \"plotarea\", \"axis\", \"grid\", \"series\", \"marker\", \"indicator\"], function(name){\n\t\t\t\tf(this[name]);\n\t\t\t}, this);\n\t\t\tif(this.seriesThemes){\n\t\t\t\tarr.forEach(this.seriesThemes, f);\n\t\t\t}\n\t\t\tif(this.markerThemes){\n\t\t\t\tarr.forEach(this.markerThemes, f);\n\t\t\t}\n\t\t},\n\t\n\t\treverseFills: function(){\n\t\t\tthis.inspectObjects(function(o){\n\t\t\t\tif(o && o.fill){\n\t\t\t\t\to.fill = dgg.reverse(o.fill);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\taddMarker:function(/*String*/ name, /*String*/ segment){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a custom marker to this theme.\n\t\t\t// example:\n\t\t\t//\t|\tmyTheme.addMarker(\"Ellipse\", foo);\n\t\t\tthis.markers[name] = segment;\n\t\t\tthis._buildMarkerArray();\n\t\t},\n\t\n\t\tsetMarkers:function(/*Object*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\tSet all the markers of this theme at once.  obj should be a\n\t\t\t//\t\tdictionary of keys and path segments.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tmyTheme.setMarkers({ \"CIRCLE\": foo });\n\t\t\tthis.markers = obj;\n\t\t\tthis._buildMarkerArray();\n\t\t},\n\t\n\t\t_buildMarkerArray: function(){\n\t\t\tthis._markers = [];\n\t\t\tfor(var p in this.markers){\n\t\t\t\tthis._markers.push(this.markers[p]);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tlang.mixin(SimpleTheme, {\n\t\tdefaultMarkers: {\n\t\t\tCIRCLE:   \"m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0\",\n\t\t\tSQUARE:   \"m-3,-3 l0,6 6,0 0,-6 z\",\n\t\t\tDIAMOND:  \"m0,-3 l3,3 -3,3 -3,-3 z\",\n\t\t\tCROSS:    \"m0,-3 l0,6 m-3,-3 l6,0\",\n\t\t\tX:        \"m-3,-3 l6,6 m0,-6 l-6,6\",\n\t\t\tTRIANGLE: \"m-3,3 l3,-6 3,6 z\",\n\t\t\tTRIANGLE_INVERTED: \"m-3,-3 l3,6 3,-6 z\"\n\t\t},\n\t\n\t\tdefaultColors:[\n\t\t\t// gray skies\n\t\t\t\"#54544c\", \"#858e94\", \"#6e767a\", \"#948585\", \"#474747\"\n\t\t],\n\t\n\t\tdefaultTheme: {\n\t\t\t// all objects are structs used directly in dojox.gfx\n\t\t\tchart:{\n\t\t\t\tstroke: null,\n\t\t\t\tfill: \"white\",\n\t\t\t\tpageStyle: null,\n\t\t\t\ttitleGap:\t\t20,\n\t\t\t\ttitlePos:\t\t\"top\",\n\t\t\t\ttitleFont:      \"normal normal bold 14pt Tahoma\",\t// chart title\n\t\t\t\ttitleFontColor: \"#333\",\n\t\t\t\ttitleAlign: \"middle\"\n\t\t\t},\n\t\t\tplotarea:{\n\t\t\t\tstroke: null,\n\t\t\t\tfill: \"white\"\n\t\t\t},\n\t\t\t// TODO: label rotation on axis\n\t\t\taxis:{\n\t\t\t\tstroke:\t{ // the axis itself\n\t\t\t\t\tcolor: \"#333\",\n\t\t\t\t\twidth: 1\n\t\t\t\t},\n\t\t\t\ttick: {\t// used as a foundation for all ticks\n\t\t\t\t\tcolor:     \"#666\",\n\t\t\t\t\tposition:  \"center\",\n\t\t\t\t\tfont:      \"normal normal normal 7pt Tahoma\",\t// labels on axis\n\t\t\t\t\tfontColor: \"#333\",\t\t\t\t\t\t\t\t// color of labels\n\t\t\t\t\tlabelGap:  4                                    // gap between a tick and its label in pixels\n\t\t\t\t},\n\t\t\t\tmajorTick:\t{ // major ticks on axis, and used for major gridlines\n\t\t\t\t\twidth:  1,\n\t\t\t\t\tlength: 6\n\t\t\t\t},\n\t\t\t\tminorTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t\t\t\t\twidth:  0.8,\n\t\t\t\t\tlength: 3\n\t\t\t\t},\n\t\t\t\tmicroTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t\t\t\t\twidth:  0.5,\n\t\t\t\t\tlength: 1\n\t\t\t\t},\n\t\t\t\ttitle: {\n\t\t\t\t\tgap:  15,\n\t\t\t\t\tfont: \"normal normal normal 11pt Tahoma\",\t// title font\n\t\t\t\t\tfontColor: \"#333\",\t\t\t\t\t\t\t// title font color\n\t\t\t\t\torientation: \"axis\"\t\t\t\t\t\t// \"axis\": facing the axis, \"away\": facing away\n\t\t\t\t}\n\t\t\t},\n\t\t\tseries: {\n\t\t\t\t// used as a \"main\" theme for series, sThemes augment it\n\t\t\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// line\n\t\t\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t\t\t\t//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},\n\t\t\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t\t\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill, if appropriate\n\t\t\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// if there's a label\n\t\t\t\tfontColor: \"#000\",\t\t\t\t\t\t\t// color of labels\n\t\t\t\tlabelWiring: {width: 1, color: \"#ccc\"}\t\t// connect marker and target data item(slice, column, bar...)\n\t\t\t},\n\t\t\tmarker: {\t// any markers on a series\n\t\t\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// stroke\n\t\t\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t\t\t\t//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},\n\t\t\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t\t\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill if needed\n\t\t\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// label\n\t\t\t\tfontColor: \"#000\"\n\t\t\t},\n\t\t\tindicator: {\n\t\t\t\tlineStroke:  {width: 1.5, color: \"#333\"},\t\t\n\t\t\t\tlineOutline: {width: 0.1, color: \"#ccc\"},\t\t\n\t\t\t\tlineShadow: null,\n\t\t\t\tlineFill: null,\n\t\t\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t\n\t\t\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t\n\t\t\t\tshadow: null,\t\t\t\t\t\t\t\t\n\t\t\t\tfill : \"#ccc\",\n\t\t\t\tradius: 3,\n\t\t\t\tfont:    \"normal normal normal 10pt Tahoma\",\t\n\t\t\t\tfontColor: \"#000\",\t\t\t\t\t\t\t\n\t\t\t\tmarkerFill:    \"#ccc\",\t\t\t\t\t\t\t\n\t\t\t\tmarkerSymbol:  \"m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0\",\t\t\t\n\t\t\t\tmarkerStroke:  {width: 1.5, color: \"#333\"},\t\t\n\t\t\t\tmarkerOutline: {width: 0.1, color: \"#ccc\"},\t\t\n\t\t\t\tmarkerShadow: null\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t});\n\t\n\treturn SimpleTheme;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 193 */\n/*!*********************************!*\\\n  !*** ../dojox/gfx/gradutils.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Various generic utilities to deal with a linear gradient\n\t\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./matrix */ 170), __webpack_require__(/*! dojo/_base/Color */ 120)], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang, m, Color){\n\t  \n\t\tvar gradutils = g.gradutils = {};\n\t\n\t\tfunction findColor(o, c){\n\t\t\tif(o <= 0){\n\t\t\t\treturn c[0].color;\n\t\t\t}\n\t\t\tvar len = c.length;\n\t\t\tif(o >= 1){\n\t\t\t\treturn c[len - 1].color;\n\t\t\t}\n\t\t\t//TODO: use binary search\n\t\t\tfor(var i = 0; i < len; ++i){\n\t\t\t\tvar stop = c[i];\n\t\t\t\tif(stop.offset >= o){\n\t\t\t\t\tif(i){\n\t\t\t\t\t\tvar prev = c[i - 1];\n\t\t\t\t\t\treturn Color.blendColors(new Color(prev.color), new Color(stop.color),\n\t\t\t\t\t\t\t(o - prev.offset) / (stop.offset - prev.offset));\n\t\t\t\t\t}\n\t\t\t\t\treturn stop.color;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c[len - 1].color;\n\t\t}\n\t\n\t\tgradutils.getColor = function(fill, pt){\n\t\t\t// summary:\n\t\t\t//\t\tsample a color from a gradient using a point\n\t\t\t// fill: Object\n\t\t\t//\t\tfill object\n\t\t\t// pt: dojox/gfx.Point\n\t\t\t//\t\tpoint where to sample a color\n\t\t\tvar o;\n\t\t\tif(fill){\n\t\t\t\tswitch(fill.type){\n\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\tvar angle = Math.atan2(fill.y2 - fill.y1, fill.x2 - fill.x1),\n\t\t\t\t\t\t\trotation = m.rotate(-angle),\n\t\t\t\t\t\t\tprojection = m.project(fill.x2 - fill.x1, fill.y2 - fill.y1),\n\t\t\t\t\t\t\tp = m.multiplyPoint(projection, pt),\n\t\t\t\t\t\t\tpf1 = m.multiplyPoint(projection, fill.x1, fill.y1),\n\t\t\t\t\t\t\tpf2 = m.multiplyPoint(projection, fill.x2, fill.y2),\n\t\t\t\t\t\t\tscale = m.multiplyPoint(rotation, pf2.x - pf1.x, pf2.y - pf1.y).x;\n\t\t\t\t\t\to = m.multiplyPoint(rotation, p.x - pf1.x, p.y - pf1.y).x / scale;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\tvar dx = pt.x - fill.cx, dy = pt.y - fill.cy;\n\t\t\t\t\t\to = Math.sqrt(dx * dx + dy * dy) / fill.r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn findColor(o, fill.colors);\t// dojo/_base/Color\n\t\t\t}\n\t\t\t// simple color\n\t\t\treturn new Color(fill || [0, 0, 0, 0]);\t// dojo/_base/Color\n\t\t};\n\t\n\t\tgradutils.reverse = function(fill){\n\t\t\t// summary:\n\t\t\t//\t\treverses a gradient\n\t\t\t// fill: Object\n\t\t\t//\t\tfill object\n\t\t\tif(fill){\n\t\t\t\tswitch(fill.type){\n\t\t\t\t\tcase \"linear\":\n\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\tfill = lang.delegate(fill);\n\t\t\t\t\t\tif(fill.colors){\n\t\t\t\t\t\t\tvar c = fill.colors, l = c.length, i = 0, stop,\n\t\t\t\t\t\t\t\tn = fill.colors = new Array(c.length);\n\t\t\t\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\t\t\t\tstop = c[i];\n\t\t\t\t\t\t\t\tn[i] = {\n\t\t\t\t\t\t\t\t\toffset: 1 - stop.offset,\n\t\t\t\t\t\t\t\t\tcolor:  stop.color\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn.sort(function(a, b){ return a.offset - b.offset; });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fill;\t// Object\n\t\t};\n\t\n\t\treturn gradutils;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 194 */\n/*!***********************************!*\\\n  !*** ../dojox/charting/Series.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Element */ 183)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, Element){ \n\t\t/*=====\n\t\tvar __SeriesCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tAn optional arguments object that can be used in the Series constructor.\n\t\t\t// plot: String?\n\t\t\t//\t\tThe plot (by name) that this series belongs to.\n\t\t};\n\t\t=====*/\n\t\treturn declare(\"dojox.charting.Series\", Element, {\n\t\t\t// summary:\n\t\t\t//\t\tAn object representing a series of data for plotting on a chart.\n\t\t\tconstructor: function(chart, data, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate a new data series object for use within charting.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart that this series belongs to.\n\t\t\t\t// data: Array|Object\n\t\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t\t// kwArgs: __SeriesCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to set details for this series.\n\t\t\t\tlang.mixin(this, kwArgs);\n\t\t\t\tif(typeof this.plot != \"string\"){ this.plot = \"default\"; }\n\t\t\t\tthis.update(data);\n\t\t\t},\n\t\t\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear the calculated additional parameters set on this series.\n\t\t\t\tthis.dyn = {};\n\t\t\t},\n\t\t\t\n\t\t\tupdate: function(data){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet data and make this object dirty, so it can be redrawn.\n\t\t\t\t// data: Array|Object\n\t\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t\tif(lang.isArray(data)){\n\t\t\t\t\tthis.data = data;\n\t\t\t\t}else{\n\t\t\t\t\tthis.source = data;\n\t\t\t\t\tthis.data = this.source.data;\n\t\t\t\t\tif(this.source.setSeriesObject){\n\t\t\t\t\t\tthis.source.setSeriesObject(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.clear();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 195 */\n/*!***************************************!*\\\n  !*** ../dojox/charting/bidi/Chart.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojox/main */ 177), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/dom-style */ 37), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/sniff */ 10),\n\t\t__webpack_require__(/*! dojo/dom */ 14),__webpack_require__(/*! dojo/dom-construct */ 39),\n\t\t__webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/gfx/_gfxBidiSupport */ 196), __webpack_require__(/*! ../axis2d/common */ 184), __webpack_require__(/*! dojox/string/BidiEngine */ 199),\n\t\t__webpack_require__(/*! dojox/lang/functional */ 175),__webpack_require__(/*! dojo/dom-attr */ 40),__webpack_require__(/*! ./_bidiutils */ 200)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojox, declare, lang, domStyle, arr, has, dom, domConstruct, g, gBidi, da, BidiEngine, df, domAttr,utils){\n\t\t// module:\n\t\t//\t\tdojox/charting/bidi/Chart\t\t\t\t\t\t\t\n\t\tvar bidiEngine = new BidiEngine();\n\t\tvar dc = lang.getObject(\"charting\", true, dojox);\n\t\tfunction validateTextDir(textDir){\n\t\t\treturn /^(ltr|rtl|auto)$/.test(textDir) ? textDir : null;\n\t\t};\n\t\t\n\t\treturn declare(null, {\n\t\t\t// textDir: String\n\t\t\t//\t\tBi-directional support,\tthe main variable which is responsible for the direction of the text.\n\t\t\t//\t\tThe text direction can be different than the GUI direction by using this parameter.\n\t\t\t//\t\tAllowed values:\n\t\t\t//\n\t\t\t//\t\t1. \"ltr\"\n\t\t\t//\t\t2. \"rtl\"\n\t\t\t//\t\t3. \"auto\" - contextual the direction of a text defined by first strong letter.\n\t\t\t//\n\t\t\t//\t\tBy default is as the page direction.\n\t\t\ttextDir:\"\",\n\t\t\t\n\t\t\t// dir: String\n\t\t\t//\t\tMirroring support,\tthe main variable which is responsible for the direction of the chart.\n\t\t\t//\n\t\t\t//\t\tAllowed values:\n\t\t\t//\t\t1. \"ltr\"\n\t\t\t//\t\t2. \"rtl\"\n\t\t\t//\n\t\t\t//\t\tBy default is ltr.\n\t\t\tdir: \"\",\n\t\t\tisMirrored: false,\n\t\t\t\n\t\t\tgetTextDir: function(text){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturn direction of the text. \n\t\t\t\t// description:\n\t\t\t\t//\t\tIf textDir is ltr or rtl returns the value.\n\t\t\t\t//\t\tIf it's auto, calls to another function that responsible \n\t\t\t\t//\t\tfor checking the value, and defining the direction.\t\t\t\n\t\t\t\t// text:\n\t\t\t\t//\t\tUsed in case textDir is \"auto\", this case the direction is according to the first\n\t\t\t\t//\t\tstrong (directionally - which direction is strong defined) letter.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprotected.\n\t\t\t\tvar textDir = this.textDir == \"auto\" ? bidiEngine.checkContextual(text) : this.textDir;\n\t\t\t\t// providing default value\n\t\t\t\tif(!textDir){\n\t\t\t\t\ttextDir = domStyle.get(this.node, \"direction\");\n\t\t\t\t}\n\t\t\t\treturn textDir;\n\t\t\t},\n\t\n\t\t\tpostscript: function(node,args){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tKicks off chart instantiation.\n\t\t\t\t// description:\n\t\t\t\t//\t\tUsed for setting the textDir of the chart. \n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\n\t\t\t\t// validate textDir\n\t\t\t\tvar textDir = args ? (args[\"textDir\"] ? validateTextDir(args[\"textDir\"]) : \"\") : \"\";\n\t\t\t\t// if textDir wasn't defined or was defined wrong, apply default value\n\t\t\t\ttextDir = textDir ? textDir : domStyle.get(this.node, \"direction\");\n\t\t\t\tthis.textDir = textDir;\n\t\n\t\t\t\tthis.surface.textDir = textDir;\n\t\t\t\t\n\t\t\t\t// two data structures, used for storing data for further enablement to change\n\t\t\t\t// textDir dynamically\n\t\t\t\tthis.htmlElementsRegistry = [];\n\t\t\t\tthis.truncatedLabelsRegistry = [];\n\t\t\t\t// chart mirroring starts\n\t\t\t\tvar chartDir = \"ltr\";\n\t\t\t\tif(domAttr.has(node, \"direction\")){\n\t\t\t\t\tchartDir = domAttr.get(node, \"direction\");\n\t\t\t\t}\n\t\t\t\tthis.setDir(args ? (args.dir ? args.dir: chartDir) : chartDir);\n\t\t\t\t// chart mirroring ends\n\t\t\t},\n\t\n\t\t\tsetTextDir: function(newTextDir, obj){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSetter for the textDir attribute.\n\t\t\t\t// description:\n\t\t\t\t//\t\tAllows dynamically set the textDir, goes over all the text-children and  \n\t\t\t\t//\t\tupdates their base text direction.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tpublic\n\t\t\t\n\t\t\t\tif(newTextDir == this.textDir){\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tif(validateTextDir(newTextDir) != null){\n\t\t\t\t\tthis.textDir = newTextDir;\n\t\t\t\t\t\n\t\t\t\t\t// set automatically all the gfx objects that were created by this surface\n\t\t\t\t\t// (groups, text objects)\n\t\t\t\t\tthis.surface.setTextDir(newTextDir);\n\t\t\t\t\n\t\t\t\t\t// truncated labels that were created with gfx creator need to recalculate dir\n\t\t\t\t\t// for case like: \"111111A\" (A stands for bidi character) and the truncation\n\t\t\t\t\t// is \"111...\" If the textDir is auto, the display should be: \"...111\" but in gfx\n\t\t\t\t\t// case we will get \"111...\". Because this.surface.setTextDir will calculate the dir of truncated\n\t\t\t\t\t// label, which value is \"111...\" but th real is \"111111A\".\n\t\t\t\t\t// each time we created a gfx truncated label we stored it in the truncatedLabelsRegistry, so update now \n\t\t\t\t\t// the registry.\n\t\t\t\t\tif(this.truncatedLabelsRegistry && newTextDir == \"auto\"){\n\t\t\t\t\t\tarr.forEach(this.truncatedLabelsRegistry, function(elem){\n\t\t\t\t\t\t\tvar tDir = this.getTextDir(elem[\"label\"]);\n\t\t\t\t\t\t\tif(elem[\"element\"].textDir != tDir){\n\t\t\t\t\t\t\t\telem[\"element\"].setShape({textDir: tDir});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// re-render axes with html labels. for recalculation of the labels\n\t\t\t\t\t// positions etc.\n\t\t\t\t\t// create array of keys for all the axis in chart \n\t\t\t\t\tvar axesKeyArr = df.keys(this.axes);\n\t\t\t\t\tif(axesKeyArr.length > 0){\n\t\t\t\t\t\t// iterate over the axes, and for each that have html labels render it.\n\t\t\t\t\t\tarr.forEach(axesKeyArr, function(key, index, arr){\n\t\t\t\t\t\t\t// get the axis \n\t\t\t\t\t\t\tvar axis = this.axes[key];\n\t\t\t\t\t\t\t// if the axis has html labels \n\t\t\t\t\t\t\tif(axis.htmlElements[0]){\n\t\t\t\t\t\t\t\taxis.dirty = true;\n\t\t\t\t\t\t\t\taxis.render(this.dim, this.offsets);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},this);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// recreate title\n\t\t\t\t\t\tif(this.title){\n\t\t\t\t\t\t\tthis._renderTitle(this.dim, this.offsets);\n\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// case of pies, spiders etc.\n\t\t\t\t\t\tarr.forEach(this.htmlElementsRegistry, function(elem, index, arr){\n\t\t\t\t\t\t\tvar tDir = newTextDir == \"auto\" ? this.getTextDir(elem[4]) : newTextDir;\n\t\t\t\t\t\t\tif(elem[0].children[0] && elem[0].children[0].dir != tDir){\n\t\t\t\t\t\t\t\tdomConstruct.destroy(elem[0].children[0]);\n\t\t\t\t\t\t\t\telem[0].children[0] = da.createText[\"html\"]\n\t\t\t\t\t\t\t\t\t\t(this, this.surface, elem[1], elem[2], elem[3], elem[4], elem[5], elem[6]).children[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\tsetDir : function(dir){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSetter for the dir attribute.\n\t\t\t\t// description:\n\t\t\t\t//\t\tAllows dynamically set the dri attribute, which will used to\n\t\t\t\t//\t\tupdates the chart rendering direction.\n\t\t\t\t//\tdir : the desired chart direction [rtl: for right to left ,ltr: for left to right]\n\t \n\t\t\t\tif(dir == \"rtl\" || dir == \"ltr\"){\n\t\t\t\t\tif(this.dir != dir){\n\t\t\t\t\t\tthis.isMirrored = true;\n\t\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\t}\n\t\t\t\t\tthis.dir = dir;\n\t\t\t\t}\t\t\t\n\t\t\t\treturn this; \n\t\t\t},\n\t\t\t\n\t\t\tisRightToLeft: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcheck the direction of the chart.\n\t\t\t\t// description:\n\t\t\t\t//\t\tcheck the dir attribute to determine the rendering direction\n\t\t\t\t//\t\tof the chart.\n\t\t\t\treturn this.dir == \"rtl\";\n\t        },\n\t        \n\t\t\tapplyMirroring: function(plot, dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tapply the mirroring operation to the current chart plots.\n\t\t\t\t//\n\t\t\t\tutils.reverseMatrix(plot, dim, offsets, this.dir == \"rtl\");\n\t\t\t\t//force the direction of the node to be ltr to properly render the axes and the plots labels.\n\t\t\t\tdomStyle.set(this.node, \"direction\", \"ltr\");\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\tformatTruncatedLabel: function(element, label, labelType){\n\t\t\t\tthis.truncateBidi(element, label, labelType);\n\t\t\t},\n\t\n\t\t\ttruncateBidi: function(elem, label, labelType){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tEnables bidi support for truncated labels.\n\t\t\t\t// description:\n\t\t\t\t//\t\tCan be two types of labels: html or gfx.\n\t\t\t\t//\n\t\t\t\t//\t\t####gfx labels:\n\t\t\t\t//\n\t\t\t\t//\t\tNeed to be stored in registry to be used when the textDir will be set dynamically.\n\t\t\t\t//\t\tAdditional work on truncated labels is needed for case as 111111A (A stands for \"bidi\" character rtl directioned).\n\t\t\t\t//\t\tlet's say in this case the truncation is \"111...\" If the textDir is auto, the display should be: \"...111\" but in gfx\n\t\t\t\t//\t\tcase we will get \"111...\". Because this.surface.setTextDir will calculate the dir of truncated\n\t\t\t\t//\t\tlabel, which value is \"111...\" but th real is \"111111A\".\n\t\t\t\t//\t\teach time we created a gfx truncated label we store it in the truncatedLabelsRegistry.\n\t\t\t\t//\n\t\t\t\t//\t\t####html labels:\n\t\t\t\t//\n\t\t\t\t//\t\tno need for repository (stored in another place). Here we only need to update the current dir according to textDir.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\n\t\t\t\tif(labelType == \"gfx\"){\n\t\t\t\t\t// store truncated gfx labels in the data structure.\n\t\t\t\t\tthis.truncatedLabelsRegistry.push({element: elem, label: label});\n\t\t\t\t\tif(this.textDir == \"auto\"){\n\t\t\t\t\t\telem.setShape({textDir: this.getTextDir(label)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(labelType == \"html\" && this.textDir == \"auto\"){\n\t\t\t\t\telem.children[0].dir = this.getTextDir(label);\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\trender: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tthis.isMirrored = false;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t_resetLeftBottom: function(axis){\n\t\t\t\tif(axis.vertical && this.isMirrored){\n\t\t\t\t\taxis.opt.leftBottom = !axis.opt.leftBottom;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\n\n/***/ },\n/* 196 */\n/*!***************************************!*\\\n  !*** ../dojox/gfx/_gfxBidiSupport.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/lang */ 9),__webpack_require__(/*! dojo/_base/sniff */ 46), __webpack_require__(/*! dojo/dom */ 14), __webpack_require__(/*! dojo/_base/html */ 197), __webpack_require__(/*! dojo/_base/array */ 13),\n\t\t\t__webpack_require__(/*! ./utils */ 198), __webpack_require__(/*! ./shape */ 169), __webpack_require__(/*! ./path */ 171), __webpack_require__(/*! dojox/string/BidiEngine */ 199)], __WEBPACK_AMD_DEFINE_RESULT__ = function(g, lang, has, dom, html, arr, utils, shapeLib, pathLib, BidiEngine){\n\t\tlang.getObject(\"dojox.gfx._gfxBidiSupport\", true);\n\t\n\t\t/*=====\n\t\t// Prevent changes here from masking the definitions in _base.js from the doc parser\n\t\tvar origG = g;\n\t\tg = {};\n\t\t=====*/\n\t\n\t\tswitch (g.renderer){\n\t\t\tcase 'vml':\n\t\t\t\tg.isVml = true;\n\t\t\t\tbreak;\n\t\t\tcase 'svg':\n\t\t\t\tg.isSvg = true;\n\t\t\t\tif(g.svg.useSvgWeb){\n\t\t\t\t\tg.isSvgWeb = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'silverlight':\n\t\t\t\tg.isSilverlight = true;\n\t\t\t\tbreak;\n\t\t\tcase 'canvas':\n\t\t\tcase 'canvasWithEvents':\n\t\t\t\tg.isCanvas = true;\n\t\t\t\tbreak;\n\t\t}\n\t\n\t\tvar bidi_const = {\n\t\t\tLRM : '\\u200E',\n\t\t\tLRE : '\\u202A',\n\t\t\tPDF : '\\u202C',\n\t\t\tRLM : '\\u200f',\n\t\t\tRLE : '\\u202B'\n\t\t};\n\t\n\t\t/*===== g = origG; =====*/\n\t\n\t\t// the object that performs text transformations.\n\t\tvar bidiEngine = new BidiEngine();\n\t\n\t\tlang.extend(g.shape.Surface, {\n\t\t\t// textDir: String\n\t\t\t//\t\tWill be used as default for Text/TextPath/Group objects that created by this surface\n\t\t\t//\t\tand textDir wasn't directly specified for them, though the bidi support was loaded.\n\t\t\t//\t\tCan be set in two ways:\n\t\t\t//\n\t\t\t//\t\t1. When the surface is created and textDir value passed to it as fourth\n\t\t\t//\t\tparameter.\n\t\t\t//\t\t2. Using the setTextDir(String) function, when this function is used the value\n\t\t\t//\t\tof textDir propagates to all of it's children and the children of children (for Groups) etc.\n\t\t\ttextDir: \"\",\n\t\n\t\t\tsetTextDir: function(/*String*/newTextDir){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUsed for propagation and change of textDir.\n\t\t\t\t//\t\tnewTextDir will be forced as textDir for all of it's children (Group/Text/TextPath).\n\t\t\t\tsetTextDir(this, newTextDir);\n\t\t\t},\n\t\n\t\t\tgetTextDir: function(){\n\t\t\t\treturn this.textDir;\n\t\t\t}\n\t\t});\n\t\n\t\tlang.extend(g.Group, {                          \n\t\t\t// textDir: String\n\t\t\t//\t\tWill be used for inheritance, or as default for text objects\n\t\t\t//\t\tthat textDir wasn't directly specified for them but the bidi support was required.\n\t\t\ttextDir: \"\",\n\t\n\t\t\tsetTextDir: function(/*String*/newTextDir){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUsed for propagation and change of textDir.\n\t\t\t\t//\t\tnewTextDir will be forced as textDir for all of it's children (Group/Text/TextPath).\n\t\t\t\tsetTextDir(this, newTextDir);\n\t\t\t},\n\t\n\t\t\tgetTextDir: function(){\n\t\t\t\treturn this.textDir;\n\t\t\t}\t\n\t\t});\n\t\t\n\t\tlang.extend(g.Text, {  \n\t\t\t// summary:\n\t\t\t//\t\tOverrides some of dojox/gfx.Text properties, and adds some\n\t\t\t//\t\tfor bidi support.\n\t\t\t\n\t\t\t// textDir: String\n\t\t\t//\t\tUsed for displaying bidi scripts in right layout.\n\t\t\t//\t\tDefines the base direction of text that displayed, can have 3 values:\n\t\t\t//\n\t\t\t//\t\t1. \"ltr\" - base direction is left to right.\n\t\t\t//\t\t2. \"rtl\" - base direction is right to left.\n\t\t\t//\t\t3. \"auto\" - base direction is contextual (defined by first strong character).\n\t\t\ttextDir: \"\",\n\t\n\t\t\tformatText: function (/*String*/ text, /*String*/ textDir){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tApplies the right transform on text, according to renderer.\n\t\t\t\t// text:\t\n\t\t\t\t//\t\tthe string for manipulation, by default return value.\n\t\t\t\t// textDir:\t\n\t\t\t\t//\t\tText direction.\n\t\t\t\t//\t\tCan be:\n\t\t\t\t//\n\t\t\t\t//\t\t1. \"ltr\" - for left to right layout.\n\t\t\t\t//\t\t2. \"rtl\" - for right to left layout\n\t\t\t\t//\t\t3. \"auto\" - for contextual layout: the first strong letter decides the direction.\n\t\t\t\t// description:\n\t\t\t\t//\t\tFinds the right transformation that should be applied on the text, according to renderer.\n\t\t\t\t//\t\tWas tested in:\n\t\t\t\t//\n\t\t\t\t//\t\tRenderers (browser for testing):\n\t\t\t\t//\n\t\t\t\t//\t\t- canvas (FF, Chrome, Safari),\n\t\t\t\t//\t\t- vml (IE),\n\t\t\t\t//\t\t- svg (FF, Chrome, Safari, Opera),\n\t\t\t\t//\t\t- silverlight (IE, Chrome, Safari, Opera),\n\t\t\t\t//\t\t- svgWeb(FF, Chrome, Safari, Opera, IE).\n\t\t\t\t//\n\t\t\t\t//\t\tBrowsers [browser version that was tested]:\n\t\t\t\t//\n\t\t\t\t//\t\t- IE [6,7,8], FF [3.6],\n\t\t\t\t//\t\t- Chrome (latest for March 2011),\n\t\t\t\t//\t\t- Safari [5.0.3],\n\t\t\t\t//\t\t- Opera [11.01].\n\t\n\t\t\t\tif(textDir && text && text.length > 1){\n\t\t\t\t\tvar sourceDir = \"ltr\", targetDir = textDir;\n\t\t\n\t\t\t\t\tif(targetDir == \"auto\"){\n\t\t\t\t\t\t//is auto by default\n\t\t\t\t\t\tif(g.isVml){\n\t\t\t\t\t\t\treturn text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttargetDir = bidiEngine.checkContextual(text);\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tif(g.isVml){\n\t\t\t\t\t\tsourceDir = bidiEngine.checkContextual(text);\n\t\t\t\t\t\tif(targetDir != sourceDir){\n\t\t\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\t\t\treturn !bidiEngine.hasBidiChar(text) ? bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\") : bidi_const.RLM + bidi_const.RLM + text;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\treturn bidi_const.LRM + text;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tif(g.isSvgWeb){\n\t\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\t\treturn bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tif(g.isSilverlight){\n\t\t\t\t\t\treturn (targetDir == \"rtl\") ? bidiEngine.bidiTransform(text,\"IRNNN\",\"VLYNN\") : bidiEngine.bidiTransform(text,\"ILNNN\",\"VLYNN\");\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tif(g.isCanvas){\n\t\t\t\t\t\treturn (targetDir == \"rtl\") ? bidi_const.RLE + text + bidi_const.PDF : bidi_const.LRE + text + bidi_const.PDF;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tif(g.isSvg){\n\t\t\t\t\t\tif(has(\"ff\") < 4){\n\t\t\t\t\t\t\treturn (targetDir == \"rtl\") ? bidiEngine.bidiTransform(text,\"IRYNN\",\"VLNNN\") : bidiEngine.bidiTransform(text,\"ILYNN\",\"VLNNN\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn bidi_const.LRM + (targetDir == \"rtl\" ? bidi_const.RLE : bidi_const.LRE) + text + bidi_const.PDF;\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treturn text;\n\t\t\t},\t\n\t\n\t\t\tbidiPreprocess: function(newShape){     \n\t\t\t\treturn newShape;\n\t\t\t}\n\t\t});\n\t\n\t\tlang.extend(g.TextPath, {\n\t\t\t// textDir: String\n\t\t\t//\t\tUsed for displaying bidi scripts in right layout.\n\t\t\t//\t\tDefines the base direction of text that displayed, can have 3 values:\n\t\t\t//\n\t\t\t//\t\t1. \"ltr\" - base direction is left to right.\n\t\t\t//\t\t2. \"rtl\" - base direction is right to left.\n\t\t\t//\t\t3. \"auto\" - base direction is contextual (defined by first strong character).\n\t\t\ttextDir: \"\",\n\t\n\t\t\tformatText: function (/*String*/text, /*String*/textDir){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tApplies the right transform on text, according to renderer.\n\t\t\t\t// text:\n\t\t\t\t//\t\tthe string for manipulation, by default return value.\n\t\t\t\t// textDir:\n\t\t\t\t//\t\ttext direction direction.\n\t\t\t\t//\t\tCan be:\n\t\t\t\t//\n\t\t\t\t//\t\t1. \"ltr\" - for left to right layout.\n\t\t\t\t//\t\t2. \"rtl\" - for right to left layout\n\t\t\t\t//\t\t3. \"auto\" - for contextual layout: the first strong letter decides the direction.\n\t\t\t\t// description:\n\t\t\t\t//\t\tFinds the right transformation that should be applied on the text, according to renderer.\n\t\t\t\t//\t\tWas tested in:\n\t\t\t\t//\n\t\t\t\t//\t\tRenderers:\n\t\t\t\t//\t\tcanvas (FF, Chrome, Safari), vml (IE), svg (FF, Chrome, Safari, Opera), silverlight (IE8), svgWeb(FF, Chrome, Safari, Opera, IE).\n\t\t\t\t//\n\t\t\t\t//\t\tBrowsers:\n\t\t\t\t//\t\tIE [6,7,8], FF [3.6], Chrome (latest for February 2011), Safari [5.0.3], Opera [11.01].\n\t\n\t\t\t\tif(textDir && text && text.length > 1){\n\t\t\t\t\tvar sourceDir = \"ltr\", targetDir = textDir;\n\t\n\t\t\t\t\tif(targetDir == \"auto\"){\n\t\t\t\t\t\t//is auto by default\n\t\t\t\t\t\tif(g.isVml){\n\t\t\t\t\t\t\treturn text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttargetDir = bidiEngine.checkContextual(text);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif(g.isVml){\n\t\t\t\t\t\tsourceDir = bidiEngine.checkContextual(text);\n\t\t\t\t\t\tif(targetDir != sourceDir){\n\t\t\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\t\t\treturn !bidiEngine.hasBidiChar(text) ? bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\") : bidi_const.RLM + bidi_const.RLM + text;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\treturn bidi_const.LRM + text;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t}\n\t\t\t\t\tif(g.isSvgWeb){\n\t\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\t\treturn bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t}\n\t\t\t\t\t//unlike the g.Text that is rendered in logical layout for Bidi scripts.\n\t\t\t\t\t//for g.TextPath in svg always visual -> bidi script is unreadable (except Opera and FF start from version 4)\n\t\t\t\t\tif(g.isSvg){\n\t\t\t\t\t\tif(has(\"opera\") || has(\"ff\") >= 4){\n\t\t\t\t\t\t\ttext = bidi_const.LRM + (targetDir == \"rtl\"? bidi_const.RLE : bidi_const.LRE) + text + bidi_const.PDF;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttext = (targetDir == \"rtl\") ? bidiEngine.bidiTransform(text,\"IRYNN\",\"VLNNN\") : bidiEngine.bidiTransform(text,\"ILYNN\",\"VLNNN\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\n\t\t\t\treturn text;\n\t\t\t},\n\t\t\tbidiPreprocess: function(newText){\n\t\t\t\tif(newText && (typeof newText == \"string\")){\n\t\t\t\t\tthis.origText = newText;\n\t\t\t\t\tnewText = this.formatText(newText,this.textDir);\n\t\t\t\t}\n\t\t\t\treturn newText;\n\t\t\t}\n\t\t});\t\n\t\t\t\n\t\tvar extendMethod = function(shape, method, before, after){\n\t\t\t// summary:\n\t\t\t//\t\tSome helper function. Used for extending methods of shape.\n\t\t\t// shape: Object\n\t\t\t//\t\tThe shape we overriding it's method.\n\t\t\t// method: String\n\t\t\t//\t\tThe method that is extended, the original method is called before or after\n\t\t\t//\t\tfunctions that passed to extendMethod.\n\t\t\t// before: function\n\t\t\t//\t\tIf defined this function will be executed before the original method.\n\t\t\t// after: function\n\t\t\t//\t\tIf defined this function will be executed after the original method.\n\t\t\tvar old = shape.prototype[method];\n\t\t\tshape.prototype[method] = \n\t\t\t\tfunction(){\n\t\t\t\t\tvar rBefore;\n\t\t\t\t\tif (before){\n\t\t\t\t\t\trBefore = before.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\tvar r = old.call(this, rBefore);\n\t\t\t\t\tif (after){\n\t\t\t\t\t\tr = after.call(this, r, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn r;\n\t\t\t\t};\n\t\t};\n\t\n\t\tvar bidiPreprocess = function(newText){\n\t\t\tif (newText){  \n\t\t\t\tif (newText.textDir){\n\t\t\t\t\tnewText.textDir = validateTextDir(newText.textDir);\n\t\t\t\t}\n\t\t\t\tif (newText.text && (newText.text instanceof Array)){\n\t\t\t\t\tnewText.text = newText.text.join(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(newText && (newText.text != undefined || newText.textDir) && (this.textDir != newText.textDir || newText.text != this.origText)){\n\t\t\t\t// store the original text. \n\t\t\t\tthis.origText = (newText.text != undefined) ? newText.text : this.origText;\n\t\t\t\tif(newText.textDir){\n\t\t\t\t\tthis.textDir = newText.textDir;\n\t\t\t\t}\n\t\t\t\tnewText.text = this.formatText(this.origText,this.textDir);\n\t\t\t}\n\t\t\treturn this.bidiPreprocess(newText);\n\t\n\t\t};\n\t\n\t\t// Instead of adding bidiPreprocess to all renders one by one\n\t\t// use the extendMethod, at first there's a need for bidi transformation \n\t\t// on text then call to original setShape.\n\t\textendMethod(g.Text,\"setShape\", bidiPreprocess, null);\n\t\textendMethod(g.TextPath,\"setText\", bidiPreprocess, null);\n\t\t\n\t\tvar restoreText = function(origObj){\n\t\t\tvar obj = lang.clone(origObj);\n\t\t\tif (obj && this.origText){\n\t\t\t\tobj.text = this.origText;\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t\n\t\t// Instead of adding restoreText to all renders one by one\n\t\t// use the extendMethod, at first get the shape by calling the original getShape,\n\t\t// than resrore original text (without the text transformations).\n\t\textendMethod(g.Text, \"getShape\", null, restoreText);\n\t\textendMethod(g.TextPath, \"getText\", null, restoreText);\n\t\n\t\tvar groupTextDir = function(group, args){\n\t\t\tvar textDir;\n\t\t\tif (args && args[0]){\n\t\t\t\ttextDir = validateTextDir(args[0]);\n\t\t\t}\n\t\t\tgroup.setTextDir(textDir ? textDir : this.textDir);\n\t\t\treturn group;\t// dojox/gfx.Group\n\t\t};\n\t\n\t\t// In creation of Group there's a need to update it's textDir,\n\t\t// so instead of doing it in renders one by one (vml vs others)\n\t\t// use the extendMethod, at first the original createGroup is applied, the\n\t\t// groupTextDir which is setts Group's textDir as it's father's or if was defined\n\t\t// by user by this value.\n\t\textendMethod(g.Surface, \"createGroup\", null, groupTextDir);\n\t\textendMethod(g.Group, \"createGroup\", null, groupTextDir);\n\t\n\t\tvar textDirPreprocess =  function(text){\n\t\t\t// inherit from surface / group  if textDir is defined there\n\t\t\tif(text){\n\t\t\t\tvar textDir = text.textDir ? validateTextDir(text.textDir) : this.textDir;\n\t\t\t\tif(textDir){\n\t\t\t\t\ttext.textDir = textDir;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t};\n\t\n\t\t// In creation there's a need to some preprocess,\n\t\t// so instead of doing it in renders one by one (vml vs others)\n\t\t// use the extendMethod, at first the textDirPreprocess function handles the input\n\t\t// then the original createXXXXXX is applied.\n\t\textendMethod(g.Surface,\"createText\", textDirPreprocess, null);\n\t\textendMethod(g.Surface,\"createTextPath\", textDirPreprocess, null);\n\t\textendMethod(g.Group,\"createText\", textDirPreprocess, null);\n\t\textendMethod(g.Group,\"createTextPath\", textDirPreprocess, null);\n\t\n\t\t/*=====\n\t\t// don't mask definition of original createSurface() function from doc parser\n\t\tg = {};\n\t\t=====*/\n\t\n\t\tg.createSurface = function(parentNode, width, height, textDir) {\n\t\t\tvar s = g[g.renderer].createSurface(parentNode, width, height);\n\t\t\tvar tDir = validateTextDir(textDir);\n\t\t\t\n\t\t\tif(g.isSvgWeb){\n\t\t\t\ts.textDir = tDir ? tDir : html.style(dom.byId(parentNode),\"direction\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\t// if textDir was defined use it, else get default value.\n\t\t\t//s.textDir = tDir ? tDir : html.style(s.rawNode,\"direction\");\n\t\t\tif(g.isVml || g.isSvg || g.isCanvas){\n\t\t\t\ts.textDir = tDir ? tDir : html.style(s.rawNode,\"direction\");\n\t\t\t}\n\t\t\tif(g.isSilverlight){\n\t\t\t\t// allow this once rawNode will be able for the silverlight\n\t\t\t\t//s.textDir = tDir ? tDir : dojo.style(s.rawNode,\"direction\");\n\t\t\t\ts.textDir = tDir ? tDir : html.style(s._nodes[1],\"direction\");\n\t\t\t}\n\t\t\t\n\t\t\treturn s;\n\t\t};\n\t\t/*===== g = origG; =====*/\n\t\n\t\t// some helper functions\n\t\t\n\t\tfunction setTextDir(/*Object*/ obj, /*String*/ newTextDir){\n\t\t\tvar tDir = validateTextDir(newTextDir);\n\t\t\tif (tDir){\n\t\t\t\tg.utils.forEach(obj,function(e){\n\t\t\t\t\tif(e instanceof g.Surface || e instanceof g.Group){\n\t\t\t\t\t\te.textDir = tDir;\n\t\t\t\t\t}\t\t\n\t\t\t\t\tif(e instanceof g.Text){\n\t\t\t\t\t\te.setShape({textDir: tDir});\n\t\t\t\t\t}\n\t\t\t\t\tif(e instanceof g.TextPath){\n\t\t\t\t\t\te.setText({textDir: tDir})\n\t\t\t\t\t}\n\t\t\t\t}, obj);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\n\t\tfunction validateTextDir(textDir){\n\t\t\tvar validValues = [\"ltr\",\"rtl\",\"auto\"]; \n\t\t\tif (textDir){\n\t\t\t\ttextDir = textDir.toLowerCase();\n\t\t\t\tif (arr.indexOf(validValues, textDir) < 0){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn textDir;\n\t\t}\n\t\n\t\treturn g; // return gfx api augmented with bidi support\t\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\n\n/***/ },\n/* 197 */\n/*!*****************************!*\\\n  !*** ../dojo/_base/html.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ 4), __webpack_require__(/*! ../dom */ 14), __webpack_require__(/*! ../dom-style */ 37), __webpack_require__(/*! ../dom-attr */ 40), __webpack_require__(/*! ../dom-prop */ 41), __webpack_require__(/*! ../dom-class */ 35), __webpack_require__(/*! ../dom-construct */ 39), __webpack_require__(/*! ../dom-geometry */ 36)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, dom, style, attr, prop, cls, ctr, geom){\r\n\t\t// module:\r\n\t\t//\t\tdojo/dom\r\n\t\r\n\t\t/*=====\r\n\t\treturn {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis module is a stub for the core dojo DOM API.\r\n\t\t};\r\n\t\t=====*/\r\n\t\r\n\t\t// mix-in dom\r\n\t\tdojo.byId = dom.byId;\r\n\t\tdojo.isDescendant = dom.isDescendant;\r\n\t\tdojo.setSelectable = dom.setSelectable;\r\n\t\r\n\t\t// mix-in dom-attr\r\n\t\tdojo.getAttr = attr.get;\r\n\t\tdojo.setAttr = attr.set;\r\n\t\tdojo.hasAttr = attr.has;\r\n\t\tdojo.removeAttr = attr.remove;\r\n\t\tdojo.getNodeProp = attr.getNodeProp;\r\n\t\r\n\t\tdojo.attr = function(node, name, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets or sets an attribute on an HTML element.\r\n\t\t\t// description:\r\n\t\t\t//\t\tHandles normalized getting and setting of attributes on DOM\r\n\t\t\t//\t\tNodes. If 2 arguments are passed, and a the second argument is a\r\n\t\t\t//\t\tstring, acts as a getter.\r\n\t\t\t//\r\n\t\t\t//\t\tIf a third argument is passed, or if the second argument is a\r\n\t\t\t//\t\tmap of attributes, acts as a setter.\r\n\t\t\t//\r\n\t\t\t//\t\tWhen passing functions as values, note that they will not be\r\n\t\t\t//\t\tdirectly assigned to slots on the node, but rather the default\r\n\t\t\t//\t\tbehavior will be removed and the new behavior will be added\r\n\t\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\r\n\t\t\t//\t\twill be normalized and that some caveats with regards to\r\n\t\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\r\n\t\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\r\n\t\t\t//\t\tpassed event object instead of returning a boolean value from\r\n\t\t\t//\t\tthe handler itself.\r\n\t\t\t// node: DOMNode|String\r\n\t\t\t//\t\tid or reference to the element to get or set the attribute on\r\n\t\t\t// name: String|Object\r\n\t\t\t//\t\tthe name of the attribute to get or set.\r\n\t\t\t// value: String?\r\n\t\t\t//\t\tThe value to set for the attribute\r\n\t\t\t// returns:\r\n\t\t\t//\t\twhen used as a getter, the value of the requested attribute\r\n\t\t\t//\t\tor null if that attribute does not have a specified or\r\n\t\t\t//\t\tdefault value;\r\n\t\t\t//\r\n\t\t\t//\t\twhen used as a setter, the DOM node\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// get the current value of the \"foo\" attribute on a node\r\n\t\t\t//\t|\tdojo.attr(dojo.byId(\"nodeId\"), \"foo\");\r\n\t\t\t//\t|\t// or we can just pass the id:\r\n\t\t\t//\t|\tdojo.attr(\"nodeId\", \"foo\");\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// use attr() to set the tab index\r\n\t\t\t//\t|\tdojo.attr(\"nodeId\", \"tabIndex\", 3);\r\n\t\t\t//\t|\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tSet multiple values at once, including event handlers:\r\n\t\t\t//\t|\tdojo.attr(\"formId\", {\r\n\t\t\t//\t|\t\t\"foo\": \"bar\",\r\n\t\t\t//\t|\t\t\"tabIndex\": -1,\r\n\t\t\t//\t|\t\t\"method\": \"POST\",\r\n\t\t\t//\t|\t\t\"onsubmit\": function(e){\r\n\t\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\r\n\t\t\t//\t|\t\t\t// of returning true or false will have no effect here\r\n\t\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\r\n\t\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\r\n\t\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\r\n\t\t\t//\t|\t\t\t// doesn't proceed.\r\n\t\t\t//\t|\t\t\tdojo.stopEvent(e);\r\n\t\t\t//\t|\r\n\t\t\t//\t|\t\t\t// submit the form with Ajax\r\n\t\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tStyle is s special case: Only set with an object hash of styles\r\n\t\t\t//\t|\tdojo.attr(\"someNode\",{\r\n\t\t\t//\t|\t\tid:\"bar\",\r\n\t\t\t//\t|\t\tstyle:{\r\n\t\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tAgain, only set style as an object hash of styles:\r\n\t\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\r\n\t\t\t//\t|\tdojo.attr(\"someNode\", \"style\", obj);\r\n\t\t\t//\t|\r\n\t\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\r\n\t\t\t//\t|\tdojo.style(\"someNode\", obj);\r\n\t\r\n\t\t\tif(arguments.length == 2){\r\n\t\t\t\treturn attr[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\r\n\t\t\t}\r\n\t\t\treturn attr.set(node, name, value);\r\n\t\t};\r\n\t\r\n\t\t// mix-in dom-class\r\n\t\tdojo.hasClass = cls.contains;\r\n\t\tdojo.addClass = cls.add;\r\n\t\tdojo.removeClass = cls.remove;\r\n\t\tdojo.toggleClass = cls.toggle;\r\n\t\tdojo.replaceClass = cls.replace;\r\n\t\r\n\t\t// mix-in dom-construct\r\n\t\tdojo._toDom = dojo.toDom = ctr.toDom;\r\n\t\tdojo.place = ctr.place;\r\n\t\tdojo.create = ctr.create;\r\n\t\tdojo.empty = function(node){ ctr.empty(node); };\r\n\t\tdojo._destroyElement = dojo.destroy = function(node){ ctr.destroy(node); };\r\n\t\r\n\t\t// mix-in dom-geometry\r\n\t\tdojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;\r\n\t\tdojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;\r\n\t\tdojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;\r\n\t\tdojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;\r\n\t\tdojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;\r\n\t\tdojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;\r\n\t\tdojo.setMarginBox = geom.setMarginBox;\r\n\t\tdojo._getContentBox = dojo.getContentBox = geom.getContentBox;\r\n\t\tdojo.setContentSize = geom.setContentSize;\r\n\t\tdojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;\r\n\t\tdojo._docScroll = dojo.docScroll = geom.docScroll;\r\n\t\tdojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;\r\n\t\tdojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;\r\n\t\tdojo.position = geom.position;\r\n\t\r\n\t\tdojo.marginBox = function marginBox(/*DomNode|String*/node, /*Object?*/box){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGetter/setter for the margin-box of node.\r\n\t\t\t// description:\r\n\t\t\t//\t\tGetter/setter for the margin-box of node.\r\n\t\t\t//\t\tReturns an object in the expected format of box (regardless\r\n\t\t\t//\t\tif box is passed). The object might look like:\r\n\t\t\t//\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\r\n\t\t\t//\t\tfor a node offset from its parent 50px to the left, 200px from\r\n\t\t\t//\t\tthe top with a margin width of 300px and a margin-height of\r\n\t\t\t//\t\t150px.\r\n\t\t\t// node:\r\n\t\t\t//\t\tid or reference to DOM Node to get/set box for\r\n\t\t\t// box:\r\n\t\t\t//\t\tIf passed, denotes that dojo.marginBox() should\r\n\t\t\t//\t\tupdate/set the margin box for node. Box is an object in the\r\n\t\t\t//\t\tabove format. All properties are optional if passed.\r\n\t\t\t// example:\r\n\t\t\t//\t\tRetrieve the margin box of a passed node\r\n\t\t\t//\t|\tvar box = dojo.marginBox(\"someNodeId\");\r\n\t\t\t//\t|\tconsole.dir(box);\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tSet a node's margin box to the size of another node\r\n\t\t\t//\t|\tvar box = dojo.marginBox(\"someNodeId\");\r\n\t\t\t//\t|\tdojo.marginBox(\"someOtherNode\", box);\r\n\t\t\treturn box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); // Object\r\n\t\t};\r\n\t\r\n\t\tdojo.contentBox = function contentBox(/*DomNode|String*/node, /*Object?*/box){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGetter/setter for the content-box of node.\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns an object in the expected format of box (regardless if box is passed).\r\n\t\t\t//\t\tThe object might look like:\r\n\t\t\t//\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\r\n\t\t\t//\t\tfor a node offset from its parent 50px to the left, 200px from\r\n\t\t\t//\t\tthe top with a content width of 300px and a content-height of\r\n\t\t\t//\t\t150px. Note that the content box may have a much larger border\r\n\t\t\t//\t\tor margin box, depending on the box model currently in use and\r\n\t\t\t//\t\tCSS values set/inherited for node.\r\n\t\t\t//\t\tWhile the getter will return top and left values, the\r\n\t\t\t//\t\tsetter only accepts setting the width and height.\r\n\t\t\t// node:\r\n\t\t\t//\t\tid or reference to DOM Node to get/set box for\r\n\t\t\t// box:\r\n\t\t\t//\t\tIf passed, denotes that dojo.contentBox() should\r\n\t\t\t//\t\tupdate/set the content box for node. Box is an object in the\r\n\t\t\t//\t\tabove format, but only w (width) and h (height) are supported.\r\n\t\t\t//\t\tAll properties are optional if passed.\r\n\t\t\treturn box ? geom.setContentSize(node, box) : geom.getContentBox(node); // Object\r\n\t\t};\r\n\t\r\n\t\tdojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated: Use position() for border-box x/y/w/h\r\n\t\t\t//\t\tor marginBox() for margin-box w/h/l/t.\r\n\t\t\t//\r\n\t\t\t//\t\tReturns an object that measures margin-box (w)idth/(h)eight\r\n\t\t\t//\t\tand absolute position x/y of the border-box. Also returned\r\n\t\t\t//\t\tis computed (l)eft and (t)op values in pixels from the\r\n\t\t\t//\t\tnode's offsetParent as returned from marginBox().\r\n\t\t\t//\t\tReturn value will be in the form:\r\n\t\t\t//|\t\t\t{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }\r\n\t\t\t//\t\tDoes not act as a setter. If includeScroll is passed, the x and\r\n\t\t\t//\t\ty params are affected as one would expect in dojo.position().\r\n\t\t\tdojo.deprecated(\"dojo.coords()\", \"Use dojo.position() or dojo.marginBox().\");\r\n\t\t\tnode = dom.byId(node);\r\n\t\t\tvar s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);\r\n\t\t\tvar abs = geom.position(node, includeScroll);\r\n\t\t\tmb.x = abs.x;\r\n\t\t\tmb.y = abs.y;\r\n\t\t\treturn mb;\t// Object\r\n\t\t};\r\n\t\r\n\t\t// mix-in dom-prop\r\n\t\tdojo.getProp = prop.get;\r\n\t\tdojo.setProp = prop.set;\r\n\t\r\n\t\tdojo.prop = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets or sets a property on an HTML element.\r\n\t\t\t// description:\r\n\t\t\t//\t\tHandles normalized getting and setting of properties on DOM\r\n\t\t\t//\t\tNodes. If 2 arguments are passed, and a the second argument is a\r\n\t\t\t//\t\tstring, acts as a getter.\r\n\t\t\t//\r\n\t\t\t//\t\tIf a third argument is passed, or if the second argument is a\r\n\t\t\t//\t\tmap of attributes, acts as a setter.\r\n\t\t\t//\r\n\t\t\t//\t\tWhen passing functions as values, note that they will not be\r\n\t\t\t//\t\tdirectly assigned to slots on the node, but rather the default\r\n\t\t\t//\t\tbehavior will be removed and the new behavior will be added\r\n\t\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\r\n\t\t\t//\t\twill be normalized and that some caveats with regards to\r\n\t\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\r\n\t\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\r\n\t\t\t//\t\tpassed event object instead of returning a boolean value from\r\n\t\t\t//\t\tthe handler itself.\r\n\t\t\t// node:\r\n\t\t\t//\t\tid or reference to the element to get or set the property on\r\n\t\t\t// name:\r\n\t\t\t//\t\tthe name of the property to get or set.\r\n\t\t\t// value:\r\n\t\t\t//\t\tThe value to set for the property\r\n\t\t\t// returns:\r\n\t\t\t//\t\twhen used as a getter, the value of the requested property\r\n\t\t\t//\t\tor null if that attribute does not have a specified or\r\n\t\t\t//\t\tdefault value;\r\n\t\t\t//\r\n\t\t\t//\t\twhen used as a setter, the DOM node\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// get the current value of the \"foo\" property on a node\r\n\t\t\t//\t|\tdojo.prop(dojo.byId(\"nodeId\"), \"foo\");\r\n\t\t\t//\t|\t// or we can just pass the id:\r\n\t\t\t//\t|\tdojo.prop(\"nodeId\", \"foo\");\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// use prop() to set the tab index\r\n\t\t\t//\t|\tdojo.prop(\"nodeId\", \"tabIndex\", 3);\r\n\t\t\t//\t|\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tSet multiple values at once, including event handlers:\r\n\t\t\t//\t|\tdojo.prop(\"formId\", {\r\n\t\t\t//\t|\t\t\"foo\": \"bar\",\r\n\t\t\t//\t|\t\t\"tabIndex\": -1,\r\n\t\t\t//\t|\t\t\"method\": \"POST\",\r\n\t\t\t//\t|\t\t\"onsubmit\": function(e){\r\n\t\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\r\n\t\t\t//\t|\t\t\t// of returning true or false will have no effect here\r\n\t\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\r\n\t\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\r\n\t\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\r\n\t\t\t//\t|\t\t\t// doesn't proceed.\r\n\t\t\t//\t|\t\t\tdojo.stopEvent(e);\r\n\t\t\t//\t|\r\n\t\t\t//\t|\t\t\t// submit the form with Ajax\r\n\t\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tStyle is s special case: Only set with an object hash of styles\r\n\t\t\t//\t|\tdojo.prop(\"someNode\",{\r\n\t\t\t//\t|\t\tid:\"bar\",\r\n\t\t\t//\t|\t\tstyle:{\r\n\t\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tAgain, only set style as an object hash of styles:\r\n\t\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\r\n\t\t\t//\t|\tdojo.prop(\"someNode\", \"style\", obj);\r\n\t\t\t//\t|\r\n\t\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\r\n\t\t\t//\t|\tdojo.style(\"someNode\", obj);\r\n\t\r\n\t\t\tif(arguments.length == 2){\r\n\t\t\t\treturn prop[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\r\n\t\t\t}\r\n\t\t\t// setter\r\n\t\t\treturn prop.set(node, name, value);\r\n\t\t};\r\n\t\r\n\t\t// mix-in dom-style\r\n\t\tdojo.getStyle = style.get;\r\n\t\tdojo.setStyle = style.set;\r\n\t\tdojo.getComputedStyle = style.getComputedStyle;\r\n\t\tdojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;\r\n\t\r\n\t\tdojo.style = function(node, name, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAccesses styles on a node. If 2 arguments are\r\n\t\t\t//\t\tpassed, acts as a getter. If 3 arguments are passed, acts\r\n\t\t\t//\t\tas a setter.\r\n\t\t\t// description:\r\n\t\t\t//\t\tGetting the style value uses the computed style for the node, so the value\r\n\t\t\t//\t\twill be a calculated value, not just the immediate node.style value.\r\n\t\t\t//\t\tAlso when getting values, use specific style names,\r\n\t\t\t//\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\r\n\t\t\t//\t\t\"border\" are not necessarily reflected as expected.\r\n\t\t\t//\t\tIf you want to get node dimensions, use `dojo.marginBox()`,\r\n\t\t\t//\t\t`dojo.contentBox()` or `dojo.position()`.\r\n\t\t\t// node: DOMNode|String\r\n\t\t\t//\t\tid or reference to node to get/set style for\r\n\t\t\t// name: String|Object?\r\n\t\t\t//\t\tthe style property to set in DOM-accessor format\r\n\t\t\t//\t\t(\"borderWidth\", not \"border-width\") or an object with key/value\r\n\t\t\t//\t\tpairs suitable for setting each property.\r\n\t\t\t// value: String?\r\n\t\t\t//\t\tIf passed, sets value on the node for style, handling\r\n\t\t\t//\t\tcross-browser concerns.  When setting a pixel value,\r\n\t\t\t//\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\r\n\t\t\t//\t\tOtherwise, in some cases, some browsers will not apply the style.\r\n\t\t\t// returns:\r\n\t\t\t//\t\twhen used as a getter, return the computed style of the node if passing in an ID or node,\r\n\t\t\t//\t\tor return the normalized, computed value for the property when passing in a node and a style property\r\n\t\t\t// example:\r\n\t\t\t//\t\tPassing only an ID or node returns the computed style object of\r\n\t\t\t//\t\tthe node:\r\n\t\t\t//\t|\tdojo.style(\"thinger\");\r\n\t\t\t// example:\r\n\t\t\t//\t\tPassing a node and a style property returns the current\r\n\t\t\t//\t\tnormalized, computed value for that property:\r\n\t\t\t//\t|\tdojo.style(\"thinger\", \"opacity\"); // 1 by default\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tPassing a node, a style property, and a value changes the\r\n\t\t\t//\t\tcurrent display of the node and returns the new computed value\r\n\t\t\t//\t|\tdojo.style(\"thinger\", \"opacity\", 0.5); // == 0.5\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\r\n\t\t\t//\t|\tdojo.style(\"thinger\", {\r\n\t\t\t//\t|\t\t\"opacity\": 0.5,\r\n\t\t\t//\t|\t\t\"border\": \"3px solid black\",\r\n\t\t\t//\t|\t\t\"height\": \"300px\"\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\r\n\t\t\t//\t\tfont-size becomes fontSize, and so on.\r\n\t\t\t//\t|\tdojo.style(\"thinger\",{\r\n\t\t\t//\t|\t\tfontSize:\"14pt\",\r\n\t\t\t//\t|\t\tletterSpacing:\"1.2em\"\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tdojo/NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\r\n\t\t\t//\t\tdojo.style() on every element of the list. See: `dojo/query` and `dojo/NodeList`\r\n\t\t\t//\t|\tdojo.query(\".someClassName\").style(\"visibility\",\"hidden\");\r\n\t\t\t//\t|\t// or\r\n\t\t\t//\t|\tdojo.query(\"#baz > div\").style({\r\n\t\t\t//\t|\t\topacity:0.75,\r\n\t\t\t//\t|\t\tfontSize:\"13pt\"\r\n\t\t\t//\t|\t});\r\n\t\r\n\t\t\tswitch(arguments.length){\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\treturn style.get(node);\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\treturn style[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\r\n\t\t\t}\r\n\t\t\t// setter\r\n\t\t\treturn style.set(node, name, value);\r\n\t\t};\r\n\t\r\n\t\treturn dojo;\r\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ },\n/* 198 */\n/*!*****************************!*\\\n  !*** ../dojox/gfx/utils.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ 4),__webpack_require__(/*! dojo/_base/lang */ 9),__webpack_require__(/*! ./_base */ 167), __webpack_require__(/*! dojo/_base/html */ 197),__webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/window */ 15), __webpack_require__(/*! dojo/_base/json */ 99), \n\t\t__webpack_require__(/*! dojo/_base/Deferred */ 101), __webpack_require__(/*! dojo/_base/sniff */ 46), __webpack_require__.dj.c(/*! dojox/gfx/utils */ 198),__webpack_require__(/*! dojo/_base/config */ 7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(kernel, lang, g, html, arr, win, jsonLib, Deferred, has, require, config){\n\t\tvar gu = g.utils = {};\n\t\n\t\tlang.mixin(gu, {\n\t\t\tforEach: function(\n\t\t\t\t/*dojox/gfx/shape.Surface|dojox/gfx/shape.Shape*/ object,\n\t\t\t\t/*Function|String|Array*/ f, /*Object?*/ o\n\t\t\t){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tTakes a shape or a surface and applies a function \"f\" to in the context of \"o\"\n\t\t\t\t//\t\t(or global, if missing). If \"shape\" was a surface or a group, it applies the same\n\t\t\t\t//\t\tfunction to all children recursively effectively visiting all shapes of the underlying scene graph.\n\t\t\t\t// object:\n\t\t\t\t//\t\tThe gfx container to iterate.\n\t\t\t\t// f:\n\t\t\t\t//\t\tThe function to apply.\n\t\t\t\t// o:\n\t\t\t\t//\t\tThe scope.\n\t\t\t\to = o || kernel.global;\n\t\t\t\tf.call(o, object);\n\t\t\t\tif(object instanceof g.Surface || object instanceof g.Group){\n\t\t\t\t\tarr.forEach(object.children, function(shape){\n\t\t\t\t\t\tgu.forEach(shape, f, o);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tserialize: function(object){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tTakes a shape or a surface and returns an object, which describes underlying shapes.\n\t\t\t\t// object: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t\t//\t\tThe container to serialize.\n\t\n\t\t\t\tvar t = {}, v, isSurface = object instanceof g.Surface;\n\t\t\t\tif(isSurface || object instanceof g.Group){\n\t\t\t\t\tt.children = arr.map(object.children, gu.serialize);\n\t\t\t\t\tif(isSurface){\n\t\t\t\t\t\treturn t.children;\t// Array\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tt.shape = object.getShape();\n\t\t\t\t}\n\t\t\t\tif(object.getTransform){\n\t\t\t\t\tv = object.getTransform();\n\t\t\t\t\tif(v){ t.transform = v; }\n\t\t\t\t}\n\t\t\t\tif(object.getStroke){\n\t\t\t\t\tv = object.getStroke();\n\t\t\t\t\tif(v){ t.stroke = v; }\n\t\t\t\t}\n\t\t\t\tif(object.getFill){\n\t\t\t\t\tv = object.getFill();\n\t\t\t\t\tif(v){ t.fill = v; }\n\t\t\t\t}\n\t\t\t\tif(object.getFont){\n\t\t\t\t\tv = object.getFont();\n\t\t\t\t\tif(v){ t.font = v; }\n\t\t\t\t}\n\t\t\t\treturn t;\t// Object\n\t\t\t},\n\t\n\t\t\ttoJson: function(object, prettyPrint){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tWorks just like serialize() but returns a JSON string. If prettyPrint is true, the string is pretty-printed to make it more human-readable.\n\t\t\t\t// object: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t\t//\t\tThe container to serialize.\n\t\t\t\t// prettyPrint: Boolean?\n\t\t\t\t//\t\tIndicates whether the output string should be formatted.\n\t\t\t\t// returns: String\n\t\t\t\t\n\t\t\t\treturn jsonLib.toJson(gu.serialize(object), prettyPrint);\t// String\n\t\t\t},\n\t\n\t\t\tdeserialize: function(parent, object){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tTakes a surface or a shape and populates it with an object produced by serialize().\n\t\t\t\t// parent: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t\t//\t\tThe destination container for the deserialized shapes.\n\t\t\t\t// object: dojox/gfx/shape.Shape|Array\n\t\t\t\t//\t\tThe shapes to deserialize.\n\t\n\t\t\t\tif(object instanceof Array){\n\t\t\t\t\treturn arr.map(object, lang.hitch(null, gu.deserialize, parent));\t// Array\n\t\t\t\t}\n\t\t\t\tvar shape = (\"shape\" in object) ? parent.createShape(object.shape) : parent.createGroup();\n\t\t\t\tif(\"transform\" in object){\n\t\t\t\t\tshape.setTransform(object.transform);\n\t\t\t\t}\n\t\t\t\tif(\"stroke\" in object){\n\t\t\t\t\tshape.setStroke(object.stroke);\n\t\t\t\t}\n\t\t\t\tif(\"fill\" in object){\n\t\t\t\t\tshape.setFill(object.fill);\n\t\t\t\t}\n\t\t\t\tif(\"font\" in object){\n\t\t\t\t\tshape.setFont(object.font);\n\t\t\t\t}\n\t\t\t\tif(\"children\" in object){\n\t\t\t\t\tarr.forEach(object.children, lang.hitch(null, gu.deserialize, shape));\n\t\t\t\t}\n\t\t\t\treturn shape;\t// dojox/gfx/shape.Shape\n\t\t\t},\n\t\n\t\t\tfromJson: function(parent, json){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tWorks just like deserialize() but takes a JSON representation of the object.\n\t\t\t\t// parent: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t\t//\t\tThe destination container for the deserialized shapes.\n\t\t\t\t// json: String\n\t\t\t\t//\t\tThe shapes to deserialize.\n\t\n\t\t\t\treturn gu.deserialize(parent, jsonLib.fromJson(json));\t// Array|dojox/gfx/shape.Shape\n\t\t\t},\n\t\n\t\t\ttoSvg: function(/*dojox/gfx/shape.Surface*/surface){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tFunction to serialize a GFX surface to SVG text.\n\t\t\t\t// description:\n\t\t\t\t//\t\tFunction to serialize a GFX surface to SVG text.  The value of this output\n\t\t\t\t//\t\tis that there are numerous serverside parser libraries that can render\n\t\t\t\t//\t\tSVG into images in various formats.  This provides a way that GFX objects\n\t\t\t\t//\t\tcan be captured in a known format and sent serverside for serialization\n\t\t\t\t//\t\tinto an image.\n\t\t\t\t// surface:\n\t\t\t\t//\t\tThe GFX surface to serialize.\n\t\t\t\t// returns:\n\t\t\t\t//\t\tDeferred object that will be called when SVG serialization is complete.\n\t\t\t\n\t\t\t\t//Since the init and even surface creation can be async, we need to\n\t\t\t\t//return a deferred that will be called when content has serialized.\n\t\t\t\tvar deferred = new Deferred();\n\t\t\t\n\t\t\t\tif(g.renderer === \"svg\"){\n\t\t\t\t\t//If we're already in SVG mode, this is easy and quick.\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar svg = gu._cleanSvg(gu._innerXML(surface.rawNode));\n\t\t\t\t\t\tdeferred.callback(svg);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tdeferred.errback(e);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//Okay, now we have to get creative with hidden iframes and the like to\n\t\t\t\t\t//serialize SVG.\n\t\t\t\t\tif (!gu._initSvgSerializerDeferred) {\n\t\t\t\t\t\tgu._initSvgSerializer();\n\t\t\t\t\t}\n\t\t\t\t\tvar jsonForm = gu.toJson(surface);\n\t\t\t\t\tvar serializer = function(){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tvar sDim = surface.getDimensions();\n\t\t\t\t\t\t\tvar width = sDim.width;\n\t\t\t\t\t\t\tvar\theight = sDim.height;\n\t\n\t\t\t\t\t\t\t//Create an attach point in the iframe for the contents.\n\t\t\t\t\t\t\tvar node = gu._gfxSvgProxy.document.createElement(\"div\");\n\t\t\t\t\t\t\tgu._gfxSvgProxy.document.body.appendChild(node);\n\t\t\t\t\t\t\t//Set the node scaling.\n\t\t\t\t\t\t\twin.withDoc(gu._gfxSvgProxy.document, function() {\n\t\t\t\t\t\t\t\thtml.style(node, \"width\", width);\n\t\t\t\t\t\t\t\thtml.style(node, \"height\", height);\n\t\t\t\t\t\t\t}, this);\n\t\n\t\t\t\t\t\t\t//Create temp surface to render object to and render.\n\t\t\t\t\t\t\tvar ts = gu._gfxSvgProxy[dojox._scopeName].gfx.createSurface(node, width, height);\n\t\n\t\t\t\t\t\t\t//It's apparently possible that a suface creation is async, so we need to use\n\t\t\t\t\t\t\t//the whenLoaded function.  Probably not needed for SVG, but making it common\n\t\t\t\t\t\t\tvar draw = function(surface) {\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\tgu._gfxSvgProxy[dojox._scopeName].gfx.utils.fromJson(surface, jsonForm);\n\t\n\t\t\t\t\t\t\t\t\t//Get contents and remove temp surface.\n\t\t\t\t\t\t\t\t\tvar svg = gu._cleanSvg(node.innerHTML);\n\t\t\t\t\t\t\t\t\tsurface.clear();\n\t\t\t\t\t\t\t\t\tsurface.destroy();\n\t\t\t\t\t\t\t\t\tgu._gfxSvgProxy.document.body.removeChild(node);\n\t\t\t\t\t\t\t\t\tdeferred.callback(svg);\n\t\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\t\tdeferred.errback(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tts.whenLoaded(null,draw);\n\t\t\t\t\t\t }catch (ex) {\n\t\t\t\t\t\t\tdeferred.errback(ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t//See if we can call it directly or pass it to the deferred to be\n\t\t\t\t\t//called on initialization.\n\t\t\t\t\tif(gu._initSvgSerializerDeferred.fired > 0){\n\t\t\t\t\t\tserializer();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgu._initSvgSerializerDeferred.addCallback(serializer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn deferred; //dojo.Deferred that will be called when serialization finishes.\n\t\t\t},\n\t\n\t\t\t//iFrame document used for handling SVG serialization.\n\t\t\t_gfxSvgProxy: null,\n\t\n\t\t\t//Serializer loaded.\n\t\t\t_initSvgSerializerDeferred: null,\n\t\n\t\t\t_svgSerializerInitialized: function() {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tInternal function to call when the serializer init completed.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\tgu._initSvgSerializerDeferred.callback(true);\n\t\t\t},\n\t\n\t\t\t_initSvgSerializer: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tInternal function to initialize the hidden iframe where SVG rendering\n\t\t\t\t//\t\twill occur.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\tif(!gu._initSvgSerializerDeferred){\n\t\t\t\t\tgu._initSvgSerializerDeferred = new Deferred();\n\t\t\t\t\tvar f = win.doc.createElement(\"iframe\");\n\t\t\t\t\thtml.style(f, {\n\t\t\t\t\t\tdisplay: \"none\",\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\twidth: \"1em\",\n\t\t\t\t\t\theight: \"1em\",\n\t\t\t\t\t\ttop: \"-10000px\"\n\t\t\t\t\t});\n\t\t\t\t\tvar intv;\n\t\t\t\t\tif(has(\"ie\")){\n\t\t\t\t\t\tf.onreadystatechange = function(){\n\t\t\t\t\t\t\tif(f.contentWindow.document.readyState == \"complete\"){\n\t\t\t\t\t\t\t\tf.onreadystatechange = function() {};\n\t\t\t\t\t\t\t\tintv = setInterval(function() {\n\t\t\t\t\t\t\t\t\tif(f.contentWindow[kernel.scopeMap[\"dojo\"][1]._scopeName] &&\n\t\t\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx &&\n\t\t\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils){\n\t\t\t\t\t\t\t\t\t\tclearInterval(intv);\n\t\t\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._gfxSvgProxy = f.contentWindow;\n\t\t\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._svgSerializerInitialized();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, 50);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}else{\n\t\t\t\t\t\tf.onload = function(){\n\t\t\t\t\t\t\tf.onload = function() {};\n\t\t\t\t\t\t\tintv = setInterval(function() {\n\t\t\t\t\t\t\t\tif(f.contentWindow[kernel.scopeMap[\"dojo\"][1]._scopeName] &&\n\t\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx &&\n\t\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils){\n\t\t\t\t\t\t\t\t\tclearInterval(intv);\n\t\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._gfxSvgProxy = f.contentWindow;\n\t\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._svgSerializerInitialized();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 50);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t//We have to load the GFX SVG proxy frame.  Default is to use the one packaged in dojox.\n\t\t\t\t\tvar uri = (config[\"dojoxGfxSvgProxyFrameUrl\"]||require.toUrl(\"dojox/gfx/resources/gfxSvgProxyFrame.html\"));\n\t\t\t\t\tf.setAttribute(\"src\", uri.toString());\n\t\t\t\t\twin.body().appendChild(f);\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_innerXML: function(/*Node*/node){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tImplementation of MS's innerXML function, borrowed from dojox.xml.parser.\n\t\t\t\t// node:\n\t\t\t\t//\t\tThe node from which to generate the XML text representation.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\tif(node.innerXML){\n\t\t\t\t\treturn node.innerXML;\t//String\n\t\t\t\t}else if(node.xml){\n\t\t\t\t\treturn node.xml;\t\t//String\n\t\t\t\t}else if(typeof XMLSerializer != \"undefined\"){\n\t\t\t\t\treturn (new XMLSerializer()).serializeToString(node);\t//String\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\n\t\t\t_cleanSvg: function(svg) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tInternal function that cleans up artifacts in extracted SVG content.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\tif(svg){\n\t\t\t\t\t//Make sure the namespace is set.\n\t\t\t\t\tif(svg.indexOf(\"xmlns=\\\"http://www.w3.org/2000/svg\\\"\") == -1){\n\t\t\t\t\t\tsvg = svg.substring(4, svg.length);\n\t\t\t\t\t\tsvg = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\" + svg;\n\t\t\t\t\t}\n\t\t\t\t\t//Same for xmlns:xlink (missing in Chrome and Safari)\n\t\t\t\t\tif(svg.indexOf(\"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\") == -1){\n\t\t\t\t\t\tsvg = svg.substring(4, svg.length);\n\t\t\t\t\t\tsvg = \"<svg xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\" + svg;\n\t\t\t\t\t}\n\t\t\t\t\t//and add namespace to href attribute if not done yet \n\t\t\t\t\t//(FF 5+ adds xlink:href but not the xmlns def)\n\t\t\t\t\tif(svg.indexOf(\"xlink:href\") === -1){\n\t\t\t\t\t\tsvg = svg.replace(/href\\s*=/g, \"xlink:href=\");\n\t\t\t\t\t}\n\t\t\t\t\t// in IE, <image are serialized as <img>\n\t\t\t\t\tsvg = svg.replace(/<img\\b([^>]*)>/gi,\"<image $1 />\");\n\t\t\t\t\t//Do some other cleanup, like stripping out the\n\t\t\t\t\t//dojoGfx attributes and quoting ids.\n\t\t\t\t\tsvg = svg.replace(/\\bdojoGfx\\w*\\s*=\\s*(['\"])\\w*\\1/g, \"\");\n\t\t\t\t\tsvg = svg.replace(/\\b__gfxObject__\\s*=\\s*(['\"])\\w*\\1/g, \"\");\n\t\t\t\t\tsvg = svg.replace(/[=]([^\"']+?)(\\s|>)/g,'=\"$1\"$2');\n\t\t\t\t\t\n\t\t\t\t\t// Undefined strokes (IE 8 seralization weirdness) should be removed to  \n\t\t\t\t\t// allow default.  'undefined' is not a valid value. \n\t\t\t\t\tsvg = svg.replace(/\\bstroke-opacity\\w*\\s*=\\s*(['\"])undefined\\1/g, \"\"); \t\t\t\t\n\t\t\t\t}\n\t\t\t\treturn svg;  //Cleaned SVG text.\n\t\t\t}\n\t\t});\n\t\n\t\treturn gu;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 199 */\n/*!*************************************!*\\\n  !*** ../dojox/string/BidiEngine.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/Stateful */ 53)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang,declare,Stateful) {\n\t\tlang.getObject(\"string\", true, dojox);\n\t\n\t\tvar BidiEngine = declare(\"dojox.string.BidiEngine\", Stateful, {\n\t\t\t// summary:\n\t\t\t//\t\tThis class provides a bidi transformation engine, i.e.\n\t\t\t//\t\tfunctions for reordering and shaping bidi text.\n\t\t\t// description:\n\t\t\t//\t\tBidi stands for support for languages with a bidirectional script. \n\t\t\t//\n\t\t\t//\t\tUsually Unicode Bidi Algorithm used by OS platform (and web browsers) is capable of properly \n\t\t\t//\t\ttransforming Bidi text and as a result it is adequately displayed on the screen. \n\t\t\t//\t\tHowever, in some situations, Unicode Bidi Algorithm is not invoked or is not properly applied.  \n\t\t\t//\t\tThis may occur in situation in which software responsible for rendering the text is not leveraging \n\t\t\t//\t\tUnicode Bidi Algorithm implemented by OS (e.g. GFX renderers).\n\t\t\t//\n\t\t\t//\t\tBidi engine provided in this class implements Unicode Bidi Algorithm as specified at\n\t\t\t//\t\thttp://www.unicode.org/reports/tr9/.\n\t\t\t//\n\t\t\t//\t\tFor more information on basic Bidi concepts please read\n\t\t\t//\t\t\"Bidirectional script support - A primer\" available from\n\t\t\t//\t\thttp://www.ibm.com/developerworks/websphere/library/techarticles/bidi/bidigen.html.\n\t\t\t//\n\t\t\t//\t\tAs of February 2011, Bidi engine has following limitations:\n\t\t\t//\n\t\t\t//\t\t1. No support for following numeric shaping options:\n\t\t\t//\t\t\t- H - Hindi,\n\t\t\t//\t\t\t- C - Contextual, \n\t\t\t//\t\t\t- N - Nominal.\n\t\t\t//\t\t2. No support for following shaping options:\n\t\t\t//\t\t\t- I - Initial shaping,\n\t\t\t//\t\t\t- M - Middle shaping,\n\t\t\t//\t\t\t- F - Final shaping,\n\t\t\t//\t\t\t- B - Isolated shaping.\n\t\t\t//\t\t3. No support for LRE/RLE/LRO/RLO/PDF (they are handled like neutrals).\n\t\t\t//\t\t4. No support for Windows compatibility.\n\t\t\t//\t\t5. No support for  insert/remove marks.\n\t\t\t//\t\t6. No support for code pages. \n\t\t\t//\t\t\t\n\t\t\t\n\t\t\t// Input Bidi layout in which inputText is passed to the function.\n\t\t\tinputFormat: \"ILYNN\",\n\t\t\t\n\t\t\t// Output Bidi layout to which inputText should be transformed.\n\t\t\toutputFormat: \"VLNNN\",\n\t\n\t\t\t// Array, containing positions of each character from the source text in the resulting text. \n\t\t\tsourceToTarget: [],\n\t\t\t\n\t\t\t// Array, containing positions of each character from the resulting text in the source text. \n\t\t\ttargetToSource: [],\n\t\t\t\n\t\t\t// Array, containing bidi level of each character from the source text\n\t\t\tlevels: [],\n\t\n\t\t\tbidiTransform: function (/*String*/text, /*String*/formatIn, /*String*/formatOut) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCentral public API for Bidi engine. Transforms the text according to formatIn, formatOut \n\t\t\t\t//\t\tparameters. If formatIn or formatOut parametrs are not valid throws an exception.\n\t\t\t\t// inputText:\n\t\t\t\t//\t\tInput text subject to application of Bidi transformation.\n\t\t\t\t// formatIn:\n\t\t\t\t//\t\tInput Bidi layout in which inputText is passed to the function.\n\t\t\t\t// formatOut:\n\t\t\t\t//\t\tOutput Bidi layout to which inputText should be transformed.\n\t\t\t\t// description:\n\t\t\t\t//\t\tBoth formatIn and formatOut parameters are 5 letters long strings. \n\t\t\t\t//\t\tFor example - \"ILYNN\". Each letter is associated with specific attribute of Bidi layout. \n\t\t\t\t//\t\tPossible and default values for each one of the letters are provided below:\n\t\t\t\t//\n\t\t\t\t//\t\tFirst letter:\n\t\t\t\t//\n\t\t\t\t//\t\t- Letter position/index:\n\t\t\t\t//\t\t\t1\n\t\t\t\t//\t\t- Letter meaning:\n\t\t\t\t//\t\t\tOrdering Schema.\n\t\t\t\t//\t\t- Possible values:\n\t\t\t\t//\t\t\t- I - Implicit (Logical).\n\t\t\t\t//\t\t\t- V - Visual.\n\t\t\t\t//\t\t- Default value:\n\t\t\t\t//\t\t\tI\n\t\t\t\t//\n\t\t\t\t//\t\tSecond letter:\n\t\t\t\t//\n\t\t\t\t//\t\t- Letter position/index:\n\t\t\t\t//\t\t\t2\n\t\t\t\t//\t\t- Letter meaning:\n\t\t\t\t//\t\t\tOrientation.\n\t\t\t\t//\t\t- Possible values:\n\t\t\t\t//\t\t\t- L - Left To Right.\n\t\t\t\t//\t\t\t- R - Right To Left.\n\t\t\t\t//\t\t\t- C - Contextual Left to Right.\n\t\t\t\t//\t\t\t- D - Contextual Right to Left.\n\t\t\t\t//\t\t- Default value:\n\t\t\t\t//\t\t\tL\t\t\n\t\t\t\t//\n\t\t\t\t//\t\tThird letter:\n\t\t\t\t//\n\t\t\t\t//\t\t- Letter position/index:\n\t\t\t\t//\t\t\t3\n\t\t\t\t//\t\t- Letter meaning:\n\t\t\t\t//\t\t\tSymmetric Swapping.\n\t\t\t\t//\t\t- Possible values:\n\t\t\t\t//\t\t\t- Y - Symmetric swapping is on.\n\t\t\t\t//\t\t\t- N - Symmetric swapping is off.\n\t\t\t\t//\t\t- Default value:\n\t\t\t\t//\t\t\tY\t\t\n\t\t\t\t//\n\t\t\t\t//\t\tFourth letter:\n\t\t\t\t//\n\t\t\t\t//\t\t- Letter position/index:\n\t\t\t\t//\t\t\t4\n\t\t\t\t//\t\t- Letter meaning:\n\t\t\t\t//\t\t\tShaping.\n\t\t\t\t//\t\t- Possible values:\n\t\t\t\t//\t\t\t- S - Text is shaped.\n\t\t\t\t//\t\t\t- N - Text is not shaped.\n\t\t\t\t//\t\t- Default value:\n\t\t\t\t//\t\t\tN\t\t\t\t\n\t\t\t\t//\n\t\t\t\t//\t\tFifth letter:\n\t\t\t\t//\n\t\t\t\t//\t\t- Letter position/index:\n\t\t\t\t//\t\t\t5\n\t\t\t\t//\t\t- Letter meaning:\n\t\t\t\t//\t\t\tNumeric Shaping.\n\t\t\t\t//\t\t- Possible values:\n\t\t\t\t//\t\t\t- N - Nominal.\n\t\t\t\t//\t\t- Default value:\n\t\t\t\t//\t\t\tN\t\t\t\t\n\t\t\t\t//\n\t\t\t\t//\t\tThe output of this function is original text (passed via first argument) transformed from \n\t\t\t\t//\t\tinput Bidi layout (second argument) to output Bidi layout (last argument). \n\t\t\t\t//\n\t\t\t\t//\t\tSample call:\n\t\t\t\t//\t|\tmytext = bidiTransform(\"HELLO WORLD\", \"ILYNN\", \"VLYNN\");\n\t\t\t\t//\t\tIn this case, \"HELLO WORLD\" text is transformed from Logical - LTR to Visual - LTR Bidi layout \n\t\t\t\t//\t\twith default values for symmetric swapping (Yes), shaping (Not shaped) and numeric shaping \n\t\t\t\t//\t\t(Nominal).\n\t\t\t\t// returns: String\n\t\t\t\t//\t\tOriginal text transformed from input Bidi layout (second argument)\n\t\t\t\t//\t\tto output Bidi layout (last argument).\n\t\t\t\t//\t\tThrows an exception if the bidi layout strings are not valid.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tpublic\n\t\n\t\t\t\tthis.sourceToTarget = [];\n\t\t\t\tthis.targetToSource = [];\n\t\t\t\tif (!text) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tinitMaps(this.sourceToTarget, this.targetToSource, text.length);\n\t\t\t\tif (!this.checkParameters(formatIn, formatOut)) {\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tformatIn = this.inputFormat;\n\t\t\t\tformatOut = this.outputFormat;\n\t\t\t\tvar result = text;\n\t\t\t\tvar bdx = BDX;\n\t\t\t\tvar orientIn = getOrientation(formatIn.charAt(1)),\n\t\t\t\t\torientOut = getOrientation(formatOut.charAt(1)),\n\t\t\t\t\tosIn = (formatIn.charAt(0) === \"I\") ? \"L\" : formatIn.charAt(0),\n\t\t\t\t\tosOut = (formatOut.charAt(0) === \"I\") ? \"L\" : formatOut.charAt(0),\n\t\t\t\t\tinFormat = osIn + orientIn,\n\t\t\t\t\toutFormat = osOut + orientOut,\n\t\t\t\t\tswap = formatIn.charAt(2) + formatOut.charAt(2);\n\t\t\n\t\t\t\tbdx.defInFormat = inFormat;\n\t\t\t\tbdx.defOutFormat = outFormat;\n\t\t\t\tbdx.defSwap = swap;\n\t\n\t\t\t\tvar stage1Text = doBidiReorder(text, inFormat, outFormat, swap, bdx),\n\t\t\t\t\tisRtl = false;\n\t\n\t\t\t\tif (formatOut.charAt(1) === \"R\") {\n\t\t\t\t\tisRtl = true;\n\t\t\t\t} else if (formatOut.charAt(1) === \"C\" || formatOut.charAt(1) === \"D\") {\n\t\t\t\t\tisRtl = this.checkContextual(stage1Text);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.sourceToTarget = stMap;\n\t\t\t\tthis.targetToSource = reverseMap(this.sourceToTarget);\n\t\t\t\ttsMap = this.targetToSource;\n\t\t\t\t\n\t\t\t\tif (formatIn.charAt(3) === formatOut.charAt(3)) {\n\t\t\t\t\tresult = stage1Text;\n\t\t\t\t} else if (formatOut.charAt(3) === \"S\") {\n\t\t\t\t\tresult = shape(isRtl, stage1Text, true);\n\t\t\t\t} else {  //formatOut.charAt(3) === \"N\"\n\t\t\t\t\tresult = deshape(stage1Text, isRtl, true);\n\t\t\t\t}\n\t\t\t\tthis.sourceToTarget = stMap;\n\t\t\t\tthis.targetToSource = tsMap;\n\t\t\t\tthis.levels = lvMap;\n\t\t\t\treturn result;\n\t\t\t},\n\t\n\t\t\t_inputFormatSetter: function (format) {\n\t\t\t\tif (!validFormat.test(format)) {\n\t\t\t\t\tthrow new Error(\"dojox/string/BidiEngine: the bidi layout string is wrong!\");\n\t\t\t\t}\n\t\t\t\tthis.inputFormat = format;\n\t\t\t},\n\t\n\t\t\t_outputFormatSetter: function (format) {\n\t\t\t\tif (!validFormat.test(format)) {\n\t\t\t\t\tthrow new Error(\"dojox/string/BidiEngine: the bidi layout string is wrong!\");\n\t\t\t\t}\n\t\t\t\tthis.outputFormat = format;\n\t\t\t},\n\t\n\t\t\tcheckParameters: function (/*String*/formatIn, /*String*/formatOut) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tChecks layout parameters.\n\t\t\t\t// formatIn:\n\t\t\t\t//\t\tInput Bidi layout in which inputText is passed to the function.\n\t\t\t\t// formatOut:\n\t\t\t\t//\t\tOutput Bidi layout to which inputText should be transformed.\t\t\t\n\t\t\t\t// description:\n\t\t\t\t//\t\tChecks, that layout parameters are different and contain allowed values.\n\t\t\t\t//\t\tAllowed values for format string are:\n\t\t\t\t//\t\t\t- 1st letter: I, V\n\t\t\t\t//\t\t\t- 2nd letter: L, R, C, D\n\t\t\t\t//\t\t\t- 3rd letter: Y, N\n\t\t\t\t//\t\t\t- 4th letter: S, N\n\t\t\t\t//\t\t\t- 5th letter: N\n\t\t\t\t// returns: /*Boolean*/\n\t\t\t\t//\t\ttrue - if layout parameters are valid.\n\t\t\t\t//\t\tfalse - otherwise. \n\t\t\t\t// tags:\n\t\t\t\t//\t\tprivate\n\t\t\t\t\n\t\t\t\tif (!formatIn) {\n\t\t\t\t\tformatIn = this.inputFormat;\n\t\t\t\t} else {\n\t\t\t\t\tthis.set(\"inputFormat\", formatIn);\n\t\t\t\t}\n\t\t\t\tif (!formatOut) {\n\t\t\t\t\tformatOut = this.outputFormat;\n\t\t\t\t} else {\n\t\t\t\t\tthis.set(\"outputFormat\", formatOut);\n\t\t\t\t}\n\t\t\t\tif (formatIn === formatOut) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\tcheckContextual: function (/*String*/text) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDetermine the base direction of a bidi text according\n\t\t\t\t//\t\tto its first strong directional character.\n\t\t\t\t// text: \n\t\t\t\t//\t\tThe text to check.\n\t\t\t\t// returns: /*String*/\n\t\t\t\t//\t\t\"ltr\" or \"rtl\" according to the first strong character.\n\t\t\t\t//\t\tIf there is no strong character, returns the value of the\n\t\t\t\t//\t\tdocument dir property.\n\t\t\t\t// tags:\n\t\t\t\t//\t\tpublic\t\t\n\t\t\t\tvar dir = firstStrongDir(text);\n\t\t\t\tif (dir !== \"ltr\" && dir !== \"rtl\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdir = document.dir.toLowerCase();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t}\n\t\t\t\t\tif (dir !== \"ltr\" && dir !== \"rtl\") {\n\t\t\t\t\t\tdir = \"ltr\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn dir;\n\t\t\t},\n\t\n\t\t\thasBidiChar: function (/*String*/text) {\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturn true if text contains RTL directed character.\n\t\t\t\t// text:\n\t\t\t\t//\t\tThe source string.\n\t\t\t\t// description:\n\t\t\t\t//\t\tSearches for RTL directed character. \n\t\t\t\t//\t\tReturns true if found, else returns false.\n\t\t\t\t// returns: /*Boolean*/\n\t\t\t\t//\t\ttrue - if text has a RTL directed character.\n\t\t\t\t//\t\tfalse - otherwise. \n\t\t\t\t// tags:\n\t\t\t\t//\t\tpublic\n\t\t\n\t\t\t    return bidiChars.test(text);\n\t\t\t}\n\t\t});\n\t\n\t\tfunction doBidiReorder(/*String*/text, /*String*/inFormat,\n\t\t\t\t\t/*String*/outFormat, /*String*/swap, /*Object*/bdx) {\n\t\t\t// summary:\n\t\t\t//\t\tReorder the source text according to the bidi attributes\n\t\t\t//\t\tof source and result.\n\t\t\t// text:\n\t\t\t//\t\tThe text to reorder.\n\t\t\t// inFormat:\n\t\t\t//\t\tOrdering scheme and base direction of the source text.\n\t\t\t//\t\tCan be \"LLTR\", \"LRTL\", \"LCLR\", \"LCRL\", \"VLTR\", \"VRTL\",\n\t\t\t//\t\t\"VCLR\", \"VCRL\".\n\t\t\t//\t\tThe first letter is \"L\" for logical ordering scheme,\n\t\t\t//\t\t\"V\" for visual ordering scheme.\n\t\t\t//\t\tThe other letters specify the base direction.\n\t\t\t//\t\t\"CLR\" means contextual direction defaulting to LTR if\n\t\t\t//\t\tthere is no strong letter.\n\t\t\t//\t\t\"CRL\" means contextual direction defaulting to RTL if\n\t\t\t//\t\tthere is no strong letter.\n\t\t\t//\t\tThe initial value is \"LLTR\", if none, the initial value is used.\n\t\t\t// outFormat:\n\t\t\t//\t\tRequired ordering scheme and base direction of the\n\t\t\t//\t\tresult. Has the same format as inFormat.\n\t\t\t//\t\tIf none, the initial value \"VLTR\" is used.\n\t\t\t// swap:\n\t\t\t//\t\tSymmetric swapping attributes of source and result.\n\t\t\t//\t\tThe allowed values can be \"YN\", \"NY\", \"YY\" and \"NN\".\n\t\t\t//\t\tThe first letter reflects the symmetric swapping attribute\n\t\t\t//\t\tof the source, the second letter that of the result.\n\t\t\t// bdx: Object\n\t\t\t//\t\tUsed for intermediate data storage\n\t\t\t// returns:\n\t\t\t//\t\tText reordered according to source and result attributes.\n\t\t\t\n\t\t\tvar params = prepareReorderingParameters(text, {inFormat: inFormat, outFormat: outFormat, swap: swap}, bdx);\n\t\t\tif (params.inFormat === params.outFormat) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\tinFormat = params.inFormat;\n\t\t\toutFormat = params.outFormat;\n\t\t\tswap = params.swap;\n\t\t\tvar inOrdering = inFormat.substring(0, 1),\n\t\t\tinOrientation = inFormat.substring(1, 4),\n\t\t\toutOrdering = outFormat.substring(0, 1),\n\t\t\toutOrientation = outFormat.substring(1, 4);\n\t\t\tbdx.inFormat = inFormat;\n\t\t\tbdx.outFormat = outFormat;\n\t\t\tbdx.swap = swap;\n\t\t\tif ((inOrdering === \"L\") && (outFormat === \"VLTR\")) { //core cases\n\t\t\t\t//cases: LLTR->VLTR, LRTL->VLTR\n\t\t\t\tif (inOrientation === \"LTR\") {\n\t\t\t\t\tbdx.dir = LTR;\n\t\t\t\t\treturn doReorder(text, bdx);\n\t\t\t\t}\n\t\t\t\tif (inOrientation === \"RTL\") {\n\t\t\t\t\tbdx.dir = RTL;\n\t\t\t\t\treturn doReorder(text, bdx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((inOrdering === \"V\") && (outOrdering === \"V\")) {\n\t\t\t\t//inOrientation != outOrientation\n\t\t\t\t//cases: VRTL->VLTR, VLTR->VRTL\n\t\t\t\tbdx.dir = inOrientation === \"RTL\"? RTL : LTR;\n\t\t\t\treturn invertStr(text, bdx);\n\t\t\t}\n\t\t\tif ((inOrdering === \"L\") && (outFormat === \"VRTL\")) {\n\t\t\t\t//cases: LLTR->VRTL, LRTL->VRTL\n\t\t\t\tif (inOrientation === \"LTR\") {\n\t\t\t\t\tbdx.dir = LTR;\n\t\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\t} else {\n\t\t\t\t\t//inOrientation == RTL\n\t\t\t\t\tbdx.dir = RTL;\n\t\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\t}\n\t\t\t\treturn invertStr(text);\n\t\t\t}\n\t\t\tif ((inFormat === \"VLTR\") && (outFormat === \"LLTR\")) {\n\t\t\t\t//case: VLTR->LLTR\n\t\t\t\tbdx.dir = LTR;\n\t\t\t\treturn doReorder(text, bdx);\n\t\t\t}\n\t\t\tif ((inOrdering === \"V\") && (outOrdering === \"L\") && (inOrientation !== outOrientation)) {\n\t\t\t\t//cases: VLTR->LRTL, VRTL->LLTR\n\t\t\t\ttext = invertStr(text);\n\t\t\t\treturn (inOrientation === \"RTL\") ? doBidiReorder(text, \"LLTR\", \"VLTR\", swap, bdx) :\n\t\t\t\t\t\t\t\t\t\t\t\t\tdoBidiReorder(text, \"LRTL\", \"VRTL\", swap, bdx);\n\t\t\t}\n\t\t\tif ((inFormat === \"VRTL\") && (outFormat === \"LRTL\")) {\n\t\t\t\t//case VRTL->LRTL\n\t\t\t\treturn doBidiReorder(text, \"LRTL\", \"VRTL\", swap, bdx);\n\t\t\t}\n\t\t\tif ((inOrdering === \"L\") && (outOrdering === \"L\")) {\n\t\t\t\t//inOrientation != outOrientation\n\t\t\t\t//cases: LRTL->LLTR, LLTR->LRTL\n\t\t\t\tvar saveSwap = bdx.swap;\n\t\t\t\tbdx.swap = saveSwap.substr(0, 1) + \"N\";\n\t\t\t\tif (inOrientation === \"RTL\") {\n\t\t\t\t\t//LRTL->LLTR\n\t\t\t\t\tbdx.dir = RTL;\n\t\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\t\tbdx.swap = \"N\" + saveSwap.substr(1, 2);\n\t\t\t\t\tbdx.dir = LTR;\n\t\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\t} else { //LLTR->LRTL\n\t\t\t\t\tbdx.dir = LTR;\n\t\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\t\tbdx.swap = \"N\" + saveSwap.substr(1, 2);\n\t\t\t\t\ttext = doBidiReorder(text, \"VLTR\", \"LRTL\", bdx.swap, bdx);\n\t\t\t\t}\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction prepareReorderingParameters(/*String*/text, /*Object*/params, /*Object*/bdx) {\n\t\t\t// summary:\n\t\t\t//\t\tPrepare reordering parameters\n\t\t\t// text:\n\t\t\t//\t\tThe text to reorder.\n\t\t\t// params:\n\t\t\t//      Object, containing reordering parameters: \n\t\t\t//         - inFormat: Ordering scheme and base direction of the source text.\n\t\t\t//         - outFormat: Required ordering scheme and base direction of the result.\n\t\t\t//         - swap: Symmetric swapping attributes of source and result.\n\t\t\t// bdx: Object\n\t\t\t//\t\tUsed for intermediate data storage\t\t\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\t\n\t\t\tif (params.inFormat === undefined) {\n\t\t\t\tparams.inFormat = bdx.defInFormat;\n\t\t\t}\n\t\t\tif (params.outFormat === undefined) {\n\t\t\t\tparams.outFormat = bdx.defOutFormat;\n\t\t\t}\n\t\t\tif (params.swap === undefined) {\n\t\t\t\tparams.swap = bdx.defSwap;\n\t\t\t}\n\t\t\tif (params.inFormat === params.outFormat) {\n\t\t\t\treturn params;\n\t\t\t}\n\t\t\tvar dir, inOrdering = params.inFormat.substring(0, 1),\n\t\t\tinOrientation = params.inFormat.substring(1, 4),\n\t\t\toutOrdering = params.outFormat.substring(0, 1),\n\t\t\toutOrientation = params.outFormat.substring(1, 4);\n\t\t\tif (inOrientation.charAt(0) === \"C\") {\n\t\t\t\tdir = firstStrongDir(text);\n\t\t\t\tif (dir === \"ltr\" || dir === \"rtl\") {\n\t\t\t\t\tinOrientation = dir.toUpperCase();\n\t\t\t\t} else {\n\t\t\t\t\tinOrientation = params.inFormat.charAt(2) === \"L\" ? \"LTR\" : \"RTL\";\n\t\t\t\t}\n\t\t\t\tparams.inFormat = inOrdering + inOrientation;\n\t\t\t}\n\t\t\tif (outOrientation.charAt(0) === \"C\") {\n\t\t\t\tdir = firstStrongDir(text);\n\t\t\t\tif (dir === \"rtl\") {\n\t\t\t\t\toutOrientation = \"RTL\";\n\t\t\t\t} else if (dir === \"ltr\") {\n\t\t\t\t\tdir = lastStrongDir(text);\n\t\t\t\t\toutOrientation = dir.toUpperCase();\n\t\t\t\t} else {\n\t\t\t\t\toutOrientation = params.outFormat.charAt(2) === \"L\" ? \"LTR\" : \"RTL\";\n\t\t\t\t}\n\t\t\t\tparams.outFormat = outOrdering + outOrientation;\n\t\t\t}\n\t\t\treturn params;\n\t\t}\n\t\n\t\tfunction shape(/*boolean*/rtl, /*String*/text, /*boolean*/compress) {\n\t\t\t// summary:\n\t\t\t//\t\tShape the source text.\n\t\t\t// rtl:\n\t\t\t//\t\tFlag indicating if the text is in RTL direction (logical\n\t\t\t//\t\tdirection for Arabic words).\n\t\t\t// text:\n\t\t\t//\t\tThe text to shape.\n\t\t\t// compress:\n\t\t\t//\t\tA flag indicates to insert extra space after the lam alef compression\n\t\t\t//\t\tto preserve the buffer size or not insert an extra space which will lead\n\t\t\t//\t\tto decrease the buffer size. This option can be:\n\t\t\t//\n\t\t\t//\t\t- true (default) to not insert extra space after compressing Lam+Alef into one character Lamalef\n\t\t\t//\t\t- false to insert an extra space after compressed Lamalef to preserve the buffer size\n\t\t\t// returns:\n\t\t\t//\t\ttext shaped.\n\t\t\t// tags:\n\t\t\t//\t\tprivate.\n\t\t\t\n\t\t\tif (text.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rtl === undefined) {\n\t\t\t\trtl = true;\n\t\t\t}\n\t\t\tif (compress === undefined) {\n\t\t\t\tcompress = true;\n\t\t\t}\n\t\t\ttext = String(text);\n\t\t\t\n\t\t\tvar str06 = text.split(\"\"),\n\t\t\t\tIx = 0,\n\t\t\t\tstep = +1,\n\t\t\t\tnIEnd = str06.length;\n\t\t\tif (!rtl) {\n\t\t\t\tIx = str06.length - 1;\n\t\t\t\tstep = -1;\n\t\t\t\tnIEnd = 1;\n\t\t\t}\n\t\t\tvar compressArray = doShape(str06, Ix, step, nIEnd, compress);\n\t\t\tvar outBuf = \"\";\n\t\t\tfor (var idx = 0; idx < str06.length; idx++) {\n\t\t\t\tif (!(compress && indexOf(compressArray, compressArray.length, idx) > -1)) {\n\t\t\t\t\toutBuf += str06[idx];\n\t\t\t\t} else {\n\t\t\t\t\tupdateMap(tsMap, idx, !rtl, -1);\n\t\t\t\t\tstMap.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn outBuf;\n\t\t}\n\t\t\n\t\tfunction doShape(str06, Ix, step, nIEnd, compress) {\n\t\t\t// summary:\n\t\t\t//\t\tShape the source text.\n\t\t\t// str06:\n\t\t\t//\t\tArray containing source text\n\t\t\t// Ix:\n\t\t\t//\t\tIndex of the first handled element\n\t\t\t// step:\n\t\t\t//\t\tdirection of the process\n\t\t\t// nIEnd:\n\t\t\t//\t\tIndex of the last handled element\n\t\t\t// compress:\n\t\t\t//\t\tA flag indicates to insert extra space after the lam alef compression\n\t\t\t//\t\tto preserve the buffer size or not insert an extra space which will lead\n\t\t\t//\t\tto decrease the buffer size.\t\t\n\t\t\t// returns:\n\t\t\t//\t\tArray, contained shaped text.\n\t\t\t// tags:\n\t\t\t//\t\tprivate.\n\t\t\t\n\t\t\tvar previousCursive = 0, compressArray = [], compressArrayIndx = 0;\n\t\t\tfor (var index = Ix; index * step < nIEnd; index = index + step) {\n\t\t\t\tif (isArabicAlefbet(str06[index]) || isArabicDiacritics(str06[index])) {\n\t\t\t\t\t// Arabic letter Lam\n\t\t\t\t\tif (str06[index] === \"\\u0644\" && isNextAlef(str06, (index + step), step, nIEnd)) {\n\t\t\t\t\t\tstr06[index] = (previousCursive === 0) ?\n\t\t\t\t\t\t\t\tgetLamAlefFE(str06[index + step], LamAlefInialTableFE) :\n\t\t\t\t\t\t\t\tgetLamAlefFE(str06[index + step], LamAlefMedialTableFE);\n\t\t\t\t\t\tindex += step;\n\t\t\t\t\t\tsetAlefToSpace(str06, index, step, nIEnd);\n\t\t\t\t\t\tif (compress) {\n\t\t\t\t\t\t\tcompressArray[compressArrayIndx] = index;\n\t\t\t\t\t\t\tcompressArrayIndx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousCursive = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar currentChr = str06[index];\n\t\t\t\t\tif (previousCursive === 1) {\n\t\t\t\t\t\t// if next is Arabic\n\t\t\t\t\t\t// Character is in medial form\n\t\t\t\t\t\t// else character is in final form\n\t\t\t\t\t\tstr06[index] = (isNextArabic(str06, (index + step), step, nIEnd)) ?\n\t\t\t\t\t\t\tgetMedialFormCharacterFE(str06[index]) : getFormCharacterFE(str06[index], FinalForm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isNextArabic(str06, (index + step), step, nIEnd) === true) {\n\t\t\t\t\t\t\t//character is in Initial form\n\t\t\t\t\t\t\tstr06[index] = getFormCharacterFE(str06[index], InitialForm);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr06[index] = getFormCharacterFE(str06[index], IsolatedForm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//exam if the current character is cursive\n\t\t\t\t\tif (!isArabicDiacritics(currentChr)) {\n\t\t\t\t\t\tpreviousCursive = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (isStandAlonCharacter(currentChr) === true) {\n\t\t\t\t\t\tpreviousCursive = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpreviousCursive = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn compressArray;\n\t\t}\n\t\t\n\t\tfunction firstStrongDir(/*String*/text) {\n\t\t\t// summary:\n\t\t\t//\t\tReturn the first strong character direction\n\t\t\t// text:\n\t\t\t//\t\tThe source string.\n\t\t\t// description:\n\t\t\t//\t\tSearches for first \"strong\" character. \n\t\t\t//\t\tReturns if strong character was found with the direction defined by this \n\t\t\t//\t\tcharacter, if no strong character was found returns an empty string.\n\t\t\t// returns: String\n\t\t\t//\t\t\"ltr\" - if the first strong character is Latin.\n\t\t\t//\t\t\"rtl\" - if the first strong character is RTL directed character.\n\t\t\t//\t\t\"\" - if the strong character wasn't found.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\n\t\t\tvar fdc = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(text);\n\t\t\t// if found return the direction that defined by the character\n\t\t\treturn fdc ? (fdc[0] <= \"z\" ? \"ltr\" : \"rtl\") : \"\";\n\t\t}\n\t\t\n\t\tfunction lastStrongDir(text) {\n\t\t\t// summary:\n\t\t\t//\t\tReturn the last strong character direction\n\t\t\t// text:\n\t\t\t//\t\tThe source string.\n\t\t\t// description:\n\t\t\t//\t\tSearches for first (from the end) \"strong\" character. \n\t\t\t//\t\tReturns if strong character was found with the direction defined by this \n\t\t\t//\t\tcharacter, if no strong character was found returns an empty string.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\t\t\n\t\t\tvar chars = text.split(\"\");\n\t\t\tchars.reverse();\n\t\t\treturn firstStrongDir(chars.join(\"\"));\n\t\t}\n\t\t\n\t\tfunction deshape(/*String*/text, /*boolean*/rtl, /*boolean*/consumeNextSpace) {\n\t\t\t// summary:\n\t\t\t//\t\tdeshape the source text.\n\t\t\t// text:\n\t\t\t//\t\tthe text to be deshape.\n\t\t\t// rtl:\n\t\t\t//\t\tflag indicating if the text is in RTL direction (logical\n\t\t\t//\t\tdirection for Arabic words).\n\t\t\t// consumeNextSpace:\n\t\t\t//\t\tflag indicating whether to consume the space next to the \n\t\t\t//\t\tthe lam alef if there is a space followed the Lamalef character to preserve the buffer size. \n\t\t\t//\t\tIn case there is no space next to the lam alef the buffer size will be increased due to the\n\t\t\t//\t\texpansion of the lam alef one character into lam+alef two characters\n\t\t\t// returns:\n\t\t\t//\t\ttext deshaped.\n\t\t\tif (text.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (consumeNextSpace === undefined) {\n\t\t\t\tconsumeNextSpace = true;\n\t\t\t}\n\t\t\tif (rtl === undefined) {\n\t\t\t\trtl = true;\n\t\t\t}\n\t\t\ttext = String(text);\n\t\t\n\t\t\tvar outBuf = \"\", strFE = [];\n\t\t\tstrFE = text.split(\"\");\n\t\t\tfor (var i = 0; i < text.length; i++) {\n\t\t\t\tvar increase = false;\n\t\t\t\tif (strFE[i] >= \"\\uFE70\" && strFE[i] < \"\\uFEFF\") {\n\t\t\t\t\tvar chNum = text.charCodeAt(i);\n\t\t\t\t\tif (strFE[i] >= \"\\uFEF5\" && strFE[i] <= \"\\uFEFC\") {\n\t\t\t\t\t\t//expand the LamAlef\n\t\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\t\t//Lam + Alef\n\t\t\t\t\t\t\tif (i > 0 && consumeNextSpace && strFE[i - 1] === \" \") {\n\t\t\t\t\t\t\t\toutBuf = outBuf.substring(0, outBuf.length - 1) + \"\\u0644\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toutBuf += \"\\u0644\";\n\t\t\t\t\t\t\t\tincrease = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toutBuf += AlefTable[(chNum - 65269) / 2];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutBuf += AlefTable[(chNum - 65269) / 2];\n\t\t\t\t\t\t\toutBuf += \"\\u0644\";\n\t\t\t\t\t\t\tif (i + 1 < text.length && consumeNextSpace && strFE[i + 1] === \" \") {\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tincrease = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (increase) {\n\t\t\t\t\t\t\tupdateMap(tsMap, i, true, 1);\n\t\t\t\t\t\t\tstMap.splice(i, 0, stMap[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutBuf += FETo06Table[chNum - 65136];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutBuf += strFE[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn outBuf;\n\t\t}\n\t\t\n\t\tfunction doReorder(str, bdx) {\n\t\t\t// summary:\n\t\t\t//\t\tHelper to the doBidiReorder. Manages the UBA.\n\t\t\t// str:\n\t\t\t//\t\tthe string to reorder.\n\t\t\t// bdx: Object\n\t\t\t//\t\tUsed for intermediate data storage\t\t\n\t\t\t// returns:\n\t\t\t//\t\ttext reordered according to source and result attributes.\n\t\t\t// tags: \n\t\t\t//\t\tprivate\t\n\t\t\tvar chars = str.split(\"\"), levels = [];\n\t\t\n\t\t\tcomputeLevels(chars, levels, bdx);\n\t\t\tswapChars(chars, levels, bdx);\n\t\t\tinvertLevel(2, chars, levels, bdx);\n\t\t\tinvertLevel(1, chars, levels, bdx);\n\t\t\tlvMap = levels;\n\t\t\treturn chars.join(\"\");\n\t\t}\n\t\n\t\tfunction computeLevels(chars, levels, bdx) {\n\t\t\tvar len = chars.length,\n\t\t\t\timpTab = bdx.dir ? impTabRtl : impTabLtr,\n\t\t\t\tprevState = null, newClass = null, newLevel = null, newState = 0,\n\t\t\t\taction = null, cond = null, condPos = -1, i = null, ix = null,\n\t\t\t\ttypes = [],\n\t\t\t\tclasses = [];\n\t\t\tbdx.hiLevel = bdx.dir;\n\t\t\tbdx.lastArabic = false;\n\t\t\tbdx.hasUbatAl = false;\n\t\t\tbdx.hasUbatB = false;\n\t\t\tbdx.hasUbatS = false;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\ttypes[i] = getCharacterType(chars[i]);\n\t\t\t}\n\t\t\tfor (ix = 0; ix < len; ix++) {\n\t\t\t\tprevState = newState;\n\t\t\t\tclasses[ix] = newClass = getCharClass(chars, types, classes, ix, bdx);\n\t\t\t\tnewState = impTab[prevState][newClass];\n\t\t\t\taction = newState & 0xF0;\n\t\t\t\tnewState &= 0x0F;\n\t\t\t\tlevels[ix] = newLevel = impTab[newState][ITIL];\n\t\t\t\tif (action > 0) {\n\t\t\t\t\tif (action === 0x10) {\t// set conditional run to level 1\n\t\t\t\t\t\tfor (i = condPos; i < ix; i++) {\n\t\t\t\t\t\t\tlevels[i] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcondPos = -1;\n\t\t\t\t\t} else {\t// 0x20 confirm the conditional run\n\t\t\t\t\t\tcondPos = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcond = impTab[newState][ITCOND];\n\t\t\t\tif (cond) {\n\t\t\t\t\tif (condPos === -1) {\n\t\t\t\t\t\tcondPos = ix;\n\t\t\t\t\t}\n\t\t\t\t} else {\t// unconditional level\n\t\t\t\t\tif (condPos > -1) {\n\t\t\t\t\t\tfor (i = condPos; i < ix; i++) {\n\t\t\t\t\t\t\tlevels[i] = newLevel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcondPos = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (types[ix] === UBAT_B) {\n\t\t\t\t\tlevels[ix] = 0;\n\t\t\t\t}\n\t\t\t\tbdx.hiLevel |= newLevel;\n\t\t\t}\n\t\t\tif (bdx.hasUbatS) {\n\t\t\t\thandleUbatS(types, levels, len, bdx);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction handleUbatS(types, levels, len, bdx) {\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tif (types[i] === UBAT_S) {\n\t\t\t\t\tlevels[i] = bdx.dir;\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (types[j] === UBAT_WS) {\n\t\t\t\t\t\t\tlevels[j] = bdx.dir;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction swapChars(chars, levels, bdx) {\n\t\t\t// summary:\n\t\t\t//\t\tSwap characters with symmetrical mirroring as all kinds of parenthesis.\n\t\t\t//\t\t(When needed).\n\t\t\t// chars:\n\t\t\t//\t\tThe source string as Array of characters.\n\t\t\t// levels:\n\t\t\t//\t\tAn array (like hash) of flags for each character in the source string,\n\t\t\t//\t\tthat defines if swapping should be applied on the following character.\n\t\t\t// bdx: Object\n\t\t\t//\t\tUsed for intermediate data storage\n\t\t\t// tags:\n\t\t\t//\t\tprivate\t\n\t\t\n\t\t\tif (bdx.hiLevel === 0 || bdx.swap.substr(0, 1) === bdx.swap.substr(1, 2)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = 0; i < chars.length; i++) {\n\t\t\t\tif (levels[i] === 1) {\n\t\t\t\t\tchars[i] = getMirror(chars[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction getCharacterType(ch) {\n\t\t\t// summary:\n\t\t\t//\t\tReturn the type of the character.\n\t\t\t// ch:\n\t\t\t//\t\tThe character to be checked.\n\t\t\n\t\t\t// description:\n\t\t\t//\t\tCheck the type of the character according to MasterTable,\n\t\t\t//\t\ttype = LTR, RTL, neutral,Arabic-Indic digit etc.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\t\t\t\n\t\t\tvar uc = ch.charCodeAt(0),\n\t\t\t\thi = MasterTable[uc >> 8];\n\t\t\treturn (hi < TBBASE) ? hi : UnicodeTable[hi - TBBASE][uc & 0xFF];\n\t\t}\n\t\t\n\t\tfunction invertStr(str, bdx) {\n\t\t\t// summary:\n\t\t\t//\t\tReturn the reversed string.\n\t\t\t// str:\n\t\t\t//\t\tThe string to be reversed.\n\t\t\t// description:\n\t\t\t//\t\tReverse the string str.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\t\t\t\t\t\n\t\t\tvar chars = str.split(\"\");\n\t\t\tif (bdx) {\n\t\t\t\tvar levels = [];\n\t\t\t\tcomputeLevels(chars, levels, bdx);\n\t\t\t\tlvMap = levels;\n\t\t\t}\n\t\t\tchars.reverse();\n\t\t\tstMap.reverse();\n\t\t\treturn chars.join(\"\");\n\t\t}\n\t\t\n\t\tfunction indexOf(cArray, cLength, idx) {\n\t\t\tfor (var i = 0; i < cLength; i++) {\n\t\t\t\tif (cArray[i] === idx) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfunction isArabicAlefbet(c) {\n\t\t\tfor (var i = 0; i < ArabicAlefBetIntervalsBegine.length; i++) {\n\t\t\t\tif (c >= ArabicAlefBetIntervalsBegine[i] && c <= ArabicAlefBetIntervalsEnd[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction isNextArabic(str06, index, step, nIEnd) {\n\t\t\twhile (((index) * step) < nIEnd && isArabicDiacritics(str06[index])) {\n\t\t\t\tindex += step;\n\t\t\t}\n\t\t\tif (((index) * step) < nIEnd && isArabicAlefbet(str06[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction isNextAlef(str06, index, step, nIEnd) {\n\t\t\twhile (((index) * step) < nIEnd && isArabicDiacritics(str06[index])) {\n\t\t\t\tindex += step;\n\t\t\t}\n\t\t\tvar c = \" \";\n\t\t\tif (((index) * step) < nIEnd) {\n\t\t\t\tc = str06[index];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < AlefTable.length; i++) {\n\t\t\t\tif (AlefTable[i] === c) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction invertLevel(lev, chars, levels, bdx) {\n\t\t\tif (bdx.hiLevel < lev) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (lev === 1 && bdx.dir === RTL && !bdx.hasUbatB) {\n\t\t\t\tchars.reverse();\n\t\t\t\tstMap.reverse();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar len = chars.length, start = 0, end, lo, hi, tmp;\n\t\t\twhile (start < len) {\n\t\t\t\tif (levels[start] >= lev) {\n\t\t\t\t\tend = start + 1;\n\t\t\t\t\twhile (end < len && levels[end] >= lev) {\n\t\t\t\t\t\tend++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (lo = start, hi = end - 1 ; lo < hi; lo++, hi--) {\n\t\t\t\t\t\ttmp = chars[lo];\n\t\t\t\t\t\tchars[lo] = chars[hi];\n\t\t\t\t\t\tchars[hi] = tmp;\n\t\t\t\t\t\ttmp = stMap[lo];\n\t\t\t\t\t\tstMap[lo] = stMap[hi];\n\t\t\t\t\t\tstMap[hi] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tstart = end;\n\t\t\t\t}\n\t\t\t\tstart++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction getCharClass(chars, types, classes, ix, bdx) {\n\t\t\t// summary:\n\t\t\t//\t\tReturn the class if ix character in chars.\n\t\t\t// chars:\n\t\t\t//\t\tThe source string as Array of characters.\n\t\t\t// types:\n\t\t\t//\t\tArray of types, for each character in chars.\n\t\t\t// classes:\n\t\t\t//\t\tArray of classes that already been solved. \n\t\t\t// ix:\n\t\t\t//\t\tthe index of checked character.\n\t\t\t// bdx: Object\n\t\t\t//\t\tUsed for intermediate data storage\t\t\n\t\t\t// tags:\n\t\t\t//\t\tprivate\t\t\t\t\n\t\t\tvar cType = types[ix],\n\t\t\t\tresults = {\n\t\t\t\t\tUBAT_L : function () { bdx.lastArabic = false; return UBAT_L; },\n\t\t\t\t\tUBAT_R : function () { bdx.lastArabic = false; return UBAT_R; },\n\t\t\t\t\tUBAT_ON : function () { return UBAT_ON; },\n\t\t\t\t\tUBAT_AN : function () { return UBAT_AN; },\n\t\t\t\t\tUBAT_EN : function () { return bdx.lastArabic ? UBAT_AN : UBAT_EN; },\n\t\t\t\t\tUBAT_AL : function () { bdx.lastArabic = true; bdx.hasUbatAl = true; return UBAT_R; },\n\t\t\t\t\tUBAT_WS : function () { return UBAT_ON; },\n\t\t\t\t\tUBAT_CS : function () {\n\t\t\t\t\t\t\t\t\t\t\tvar wType, nType;\n\t\t\t\t\t\t\t\t\t\t\tif (ix < 1 || (ix + 1) >= types.length ||\n\t\t\t\t\t\t\t\t\t\t\t\t((wType = classes[ix - 1]) !== UBAT_EN && wType !== UBAT_AN) ||\n\t\t\t\t\t\t\t\t\t\t\t\t((nType = types[ix + 1]) !== UBAT_EN && nType !== UBAT_AN)) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (bdx.lastArabic) {\n\t\t\t\t\t\t\t\t\t\t\t\tnType = UBAT_AN;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn nType === wType ? nType : UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\tUBAT_ES : function () {\n\t\t\t\t\t\t\t\t\t\t\tvar wType = ix > 0 ? classes[ix - 1] : UBAT_B;\n\t\t\t\t\t\t\t\t\t\t\tif (wType === UBAT_EN && (ix + 1) < types.length && types[ix + 1] === UBAT_EN) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_EN;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\tUBAT_ET : function () {\n\t\t\t\t\t\t\t\t\t\t\tif (ix > 0 && classes[ix - 1] === UBAT_EN) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_EN;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (bdx.lastArabic) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tvar i = ix + 1,\n\t\t\t\t\t\t\t\t\t\t\t\tlen = types.length;\n\t\t\t\t\t\t\t\t\t\t\twhile (i < len && types[i] === UBAT_ET) {\n\t\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (i < len && types[i] === UBAT_EN) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_EN;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\tUBAT_NSM : function () {\n\t\t\t\t\t\t\t\t\t\t\tif (bdx.inFormat === \"VLTR\") {\t// visual to implicit transformation\n\t\t\t\t\t\t\t\t\t\t\t\tvar len = types.length,\n\t\t\t\t\t\t\t\t\t\t\t\t\ti = ix + 1;\n\t\t\t\t\t\t\t\t\t\t\t\twhile (i < len && types[i] === UBAT_NSM) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (i < len) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar c = chars[ix],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c === 0xFB1E,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twType = types[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (rtlCandidate && (wType === UBAT_R || wType === UBAT_AL)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_R;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (ix < 1 || types[ix - 1] === UBAT_B) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn classes[ix - 1];\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\tUBAT_B : function () { bdx.lastArabic = true; bdx.hasUbatB = true; return bdx.dir; },\n\t\t\t\t\tUBAT_S : function () { bdx.hasUbatS = true; return UBAT_ON; },\n\t\t\t\t\tUBAT_LRE : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\t\tUBAT_RLE : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\t\tUBAT_LRO : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\t\tUBAT_RLO : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\t\tUBAT_PDF : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\t\tUBAT_BN : function () { return UBAT_ON; }\n\t\t\t\t};\n\t\t\treturn results[TYPES_NAMES[cType]]();\n\t\t}\n\t\n\t\tfunction getMirror(c) {\n\t\t\t// summary:\n\t\t\t//\t\tCalculates the mirrored character of c\n\t\t\t// c:\n\t\t\t//\t\tThe character to be mirrored.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\t\t\t\t\t\n\t\t\tvar mid, low = 0, high = SwapTable.length - 1;\n\t\t\n\t\t\twhile (low <= high) {\n\t\t\t\tmid = Math.floor((low + high) / 2);\n\t\t\t\tif (c < SwapTable[mid][0]) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (c > SwapTable[mid][0]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn SwapTable[mid][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\t\n\t\tfunction isStandAlonCharacter(c) {\n\t\t\tfor (var i = 0; i < StandAlonForm.length; i++) {\n\t\t\t\tif (StandAlonForm[i] === c) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction getMedialFormCharacterFE(c) {\n\t\t\tfor (var i = 0; i < BaseForm.length; i++) {\n\t\t\t\tif (c === BaseForm[i]) {\n\t\t\t\t\treturn MedialForm[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\t\n\t\tfunction getFormCharacterFE(/*char*/ c, /*char[]*/formArr) {\n\t\t\tfor (var i = 0; i < BaseForm.length; i++) {\n\t\t\t\tif (c === BaseForm[i]) {\n\t\t\t\t\treturn formArr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\t\n\t\tfunction isArabicDiacritics(c) {\n\t\t\treturn\t(c >= \"\\u064b\" && c <= \"\\u0655\") ? true : false;\n\t\t}\n\t\t\n\t\tfunction getOrientation(/*Char*/ oc) {\n\t\t\tif (oc === \"L\") {\n\t\t\t\treturn \"LTR\";\n\t\t\t}\n\t\t\tif (oc === \"R\") {\n\t\t\t\treturn \"RTL\";\n\t\t\t}\n\t\t\tif (oc === \"C\") {\n\t\t\t\treturn \"CLR\";\n\t\t\t}\n\t\t\tif (oc === \"D\") {\n\t\t\t\treturn \"CRL\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction setAlefToSpace(str06, index, step, nIEnd) {\n\t\t\twhile (((index) * step) < nIEnd && isArabicDiacritics(str06[index])) {\n\t\t\t\tindex += step;\n\t\t\t}\n\t\t\tif (((index) * step) < nIEnd) {\n\t\t\t\tstr06[index] = \" \";\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction getLamAlefFE(alef06, LamAlefForm) {\n\t\t\tfor (var i = 0; i < AlefTable.length; i++) {\n\t\t\t\tif (alef06 === AlefTable[i]) {\n\t\t\t\t\treturn LamAlefForm[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn alef06;\n\t\t}\n\t\n\t\tfunction initMaps(map1, map2, length) {\n\t\t\tstMap = [];\n\t\t\tlvMap = [];\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tmap1[i] = i;\n\t\t\t\tmap2[i] = i;\n\t\t\t\tstMap[i] = i;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction reverseMap(sourceMap) {\n\t\t\tvar map = new Array(sourceMap.length);\n\t\t\tfor (var i = 0; i < sourceMap.length; i++) {\n\t\t\t\tmap[sourceMap[i]] = i;\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\t\n\t\tfunction updateMap(map, value, isGreater, update) {\n\t\t\tfor (var i = 0; i < map.length; i++) {\n\t\t\t\tif (map[i] > value || (!isGreater && map[i] === value)) {\n\t\t\t\t\tmap[i] += update;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar stMap = [];\n\t\tvar tsMap = [];\n\t\tvar lvMap = [];\n\t\t\t\n\t\tvar\tBDX = {\n\t\t\t\tdir: 0,\n\t\t\t\tdefInFormat: \"LLTR\",\n\t\t\t\tdefoutFormat: \"VLTR\",\n\t\t\t\tdefSwap: \"YN\",\n\t\t\t\tinFormat: \"LLTR\",\n\t\t\t\toutFormat: \"VLTR\",\n\t\t\t\tswap: \"YN\",\n\t\t\t\thiLevel: 0,\n\t\t\t\tlastArabic: false,\n\t\t\t\thasUbatAl: false,\n\t\t\t\thasBlockSep: false,\n\t\t\t\thasSegSep: false\n\t\t\t};\n\t\t\n\t\tvar ITIL = 5;\n\t\t\n\t\tvar ITCOND = 6;\n\t\t\n\t\tvar LTR = 0;\n\t\t\n\t\tvar RTL = 1;\n\t\n\t\tvar validFormat = /^[(I|V)][(L|R|C|D)][(Y|N)][(S|N)][N]$/;\n\t\n\t\tvar bidiChars = /[\\u0591-\\u06ff\\ufb1d-\\ufefc]/;\n\t\n\t\t/****************************************************************************/\n\t\t/* Array in which directional characters are replaced by their symmetric.\t*/\n\t\t/****************************************************************************/\n\t\tvar SwapTable = [\n\t\t\t[ \"\\u0028\", \"\\u0029\" ],\t/* Round brackets\t\t\t\t\t*/\n\t\t\t[ \"\\u0029\", \"\\u0028\" ],\n\t\t\t[ \"\\u003C\", \"\\u003E\" ],\t/* Less than/greater than\t\t\t*/\n\t\t\t[ \"\\u003E\", \"\\u003C\" ],\n\t\t\t[ \"\\u005B\", \"\\u005D\" ],\t/* Square brackets\t\t\t\t\t*/\n\t\t\t[ \"\\u005D\", \"\\u005B\" ],\n\t\t\t[ \"\\u007B\", \"\\u007D\" ],\t/* Curly brackets\t\t\t\t\t*/\n\t\t\t[ \"\\u007D\", \"\\u007B\" ],\n\t\t\t[ \"\\u00AB\", \"\\u00BB\" ],\t/* Double angle quotation marks\t\t*/\n\t\t\t[ \"\\u00BB\", \"\\u00AB\" ],\n\t\t\t[ \"\\u2039\", \"\\u203A\" ],\t/* single angle quotation mark\t\t*/\n\t\t\t[ \"\\u203A\", \"\\u2039\" ],\n\t\t\t[ \"\\u207D\", \"\\u207E\" ],\t/* Superscript parentheses\t\t\t*/\n\t\t\t[ \"\\u207E\", \"\\u207D\" ],\n\t\t\t[ \"\\u208D\", \"\\u208E\" ],\t/* Subscript parentheses\t\t\t*/\n\t\t\t[ \"\\u208E\", \"\\u208D\" ],\n\t\t\t[ \"\\u2264\", \"\\u2265\" ],\t/* Less/greater than or equal\t\t*/\n\t\t\t[ \"\\u2265\", \"\\u2264\" ],\n\t\t\t[ \"\\u2329\", \"\\u232A\" ],\t/* Angle brackets\t\t\t\t\t*/\n\t\t\t[ \"\\u232A\", \"\\u2329\" ],\n\t\t\t[ \"\\uFE59\", \"\\uFE5A\" ],\t/* Small round brackets\t\t\t\t*/\n\t\t\t[ \"\\uFE5A\", \"\\uFE59\" ],\n\t\t\t[ \"\\uFE5B\", \"\\uFE5C\" ],\t/* Small curly brackets\t\t\t\t*/\n\t\t\t[ \"\\uFE5C\", \"\\uFE5B\" ],\n\t\t\t[ \"\\uFE5D\", \"\\uFE5E\" ],\t/* Small tortoise shell brackets\t*/\n\t\t\t[ \"\\uFE5E\", \"\\uFE5D\" ],\n\t\t\t[ \"\\uFE64\", \"\\uFE65\" ],\t/* Small less than/greater than\t\t*/\n\t\t\t[ \"\\uFE65\", \"\\uFE64\" ]\n\t\t];\n\t\tvar AlefTable = [\"\\u0622\", \"\\u0623\", \"\\u0625\", \"\\u0627\"];\n\t\t\n\t\tvar LamAlefInialTableFE = [\"\\ufef5\", \"\\ufef7\", \"\\ufef9\", \"\\ufefb\"];\n\t\t\n\t\tvar LamAlefMedialTableFE = [\"\\ufef6\", \"\\ufef8\", \"\\ufefa\", \"\\ufefc\"];\n\t\t/**\n\t\t * Arabic Characters in the base form\n\t\t */\n\t\tvar BaseForm = [\"\\u0627\", \"\\u0628\", \"\\u062A\", \"\\u062B\", \"\\u062C\", \"\\u062D\", \"\\u062E\", \"\\u062F\", \"\\u0630\", \"\\u0631\",\n\t                    \"\\u0632\", \"\\u0633\", \"\\u0634\", \"\\u0635\", \"\\u0636\", \"\\u0637\", \"\\u0638\", \"\\u0639\", \"\\u063A\", \"\\u0641\",\n\t                    \"\\u0642\", \"\\u0643\", \"\\u0644\", \"\\u0645\", \"\\u0646\", \"\\u0647\", \"\\u0648\", \"\\u064A\", \"\\u0625\", \"\\u0623\",\n\t                    \"\\u0622\", \"\\u0629\", \"\\u0649\", \"\\u0644\", \"\\u0645\", \"\\u0646\", \"\\u0647\", \"\\u0648\", \"\\u064A\", \"\\u0625\",\n\t                    \"\\u0623\", \"\\u0622\", \"\\u0629\", \"\\u0649\", \"\\u06CC\", \"\\u0626\", \"\\u0624\", \"\\u064B\", \"\\u064C\", \"\\u064D\",\n\t                    \"\\u064E\", \"\\u064F\", \"\\u0650\", \"\\u0651\", \"\\u0652\", \"\\u0621\"];\n\t\t\n\t\t/**\n\t\t * Arabic shaped characters in Isolated form\n\t\t */\n\t\tvar IsolatedForm = [\"\\uFE8D\", \"\\uFE8F\", \"\\uFE95\", \"\\uFE99\", \"\\uFE9D\", \"\\uFEA1\", \"\\uFEA5\", \"\\uFEA9\", \"\\uFEAB\",\n\t                        \"\\uFEAD\", \"\\uFEAF\", \"\\uFEB1\", \"\\uFEB5\", \"\\uFEB9\", \"\\uFEBD\", \"\\uFEC1\", \"\\uFEC5\", \"\\uFEC9\",\n\t                        \"\\uFECD\", \"\\uFED1\", \"\\uFED5\", \"\\uFED9\", \"\\uFEDD\", \"\\uFEE1\", \"\\uFEE5\", \"\\uFEE9\", \"\\uFEED\",\n\t                        \"\\uFEF1\", \"\\uFE87\", \"\\uFE83\", \"\\uFE81\", \"\\uFE93\", \"\\uFEEF\", \"\\uFBFC\", \"\\uFE89\", \"\\uFE85\",\n\t                        \"\\uFE70\", \"\\uFE72\", \"\\uFE74\", \"\\uFE76\", \"\\uFE78\", \"\\uFE7A\", \"\\uFE7C\", \"\\uFE7E\", \"\\uFE80\"];\n\t\t\n\t\t/**\n\t\t * Arabic shaped characters in Final form\n\t\t */\n\t\tvar FinalForm = [\"\\uFE8E\", \"\\uFE90\", \"\\uFE96\", \"\\uFE9A\", \"\\uFE9E\", \"\\uFEA2\", \"\\uFEA6\", \"\\uFEAA\", \"\\uFEAC\", \"\\uFEAE\",\n\t                     \"\\uFEB0\", \"\\uFEB2\", \"\\uFEB6\", \"\\uFEBA\", \"\\uFEBE\", \"\\uFEC2\", \"\\uFEC6\", \"\\uFECA\", \"\\uFECE\", \"\\uFED2\",\n\t                     \"\\uFED6\", \"\\uFEDA\", \"\\uFEDE\", \"\\uFEE2\", \"\\uFEE6\", \"\\uFEEA\", \"\\uFEEE\", \"\\uFEF2\", \"\\uFE88\", \"\\uFE84\",\n\t                     \"\\uFE82\", \"\\uFE94\", \"\\uFEF0\", \"\\uFBFD\", \"\\uFE8A\", \"\\uFE86\", \"\\uFE70\", \"\\uFE72\", \"\\uFE74\", \"\\uFE76\",\n\t                     \"\\uFE78\", \"\\uFE7A\", \"\\uFE7C\", \"\\uFE7E\", \"\\uFE80\"];\n\t\t\n\t\t/**\n\t\t * Arabic shaped characters in Media form\n\t\t */\n\t\tvar MedialForm = [\"\\uFE8E\", \"\\uFE92\", \"\\uFE98\", \"\\uFE9C\", \"\\uFEA0\", \"\\uFEA4\", \"\\uFEA8\", \"\\uFEAA\", \"\\uFEAC\",\n\t                      \"\\uFEAE\", \"\\uFEB0\", \"\\uFEB4\", \"\\uFEB8\", \"\\uFEBC\", \"\\uFEC0\", \"\\uFEC4\", \"\\uFEC8\", \"\\uFECC\",\n\t                      \"\\uFED0\", \"\\uFED4\", \"\\uFED8\", \"\\uFEDC\", \"\\uFEE0\", \"\\uFEE4\", \"\\uFEE8\", \"\\uFEEC\", \"\\uFEEE\",\n\t                      \"\\uFEF4\", \"\\uFE88\", \"\\uFE84\", \"\\uFE82\", \"\\uFE94\", \"\\uFEF0\", \"\\uFBFF\", \"\\uFE8C\", \"\\uFE86\",\n\t                      \"\\uFE71\", \"\\uFE72\", \"\\uFE74\", \"\\uFE77\", \"\\uFE79\", \"\\uFE7B\", \"\\uFE7D\", \"\\uFE7F\", \"\\uFE80\"];\n\t\t\n\t\t/**\n\t\t * Arabic shaped characters in Initial form\n\t\t */\n\t\tvar InitialForm = [\"\\uFE8D\", \"\\uFE91\", \"\\uFE97\", \"\\uFE9B\", \"\\uFE9F\", \"\\uFEA3\", \"\\uFEA7\", \"\\uFEA9\", \"\\uFEAB\",\n\t                       \"\\uFEAD\", \"\\uFEAF\", \"\\uFEB3\", \"\\uFEB7\", \"\\uFEBB\", \"\\uFEBF\", \"\\uFEC3\", \"\\uFEC7\", \"\\uFECB\",\n\t                       \"\\uFECF\", \"\\uFED3\", \"\\uFED7\", \"\\uFEDB\", \"\\uFEDF\", \"\\uFEE3\", \"\\uFEE7\", \"\\uFEEB\", \"\\uFEED\",\n\t                       \"\\uFEF3\", \"\\uFE87\", \"\\uFE83\", \"\\uFE81\", \"\\uFE93\", \"\\uFEEF\", \"\\uFBFE\", \"\\uFE8B\", \"\\uFE85\",\n\t                       \"\\uFE70\", \"\\uFE72\", \"\\uFE74\", \"\\uFE76\", \"\\uFE78\", \"\\uFE7A\", \"\\uFE7C\", \"\\uFE7E\", \"\\uFE80\"];\n\t\t\n\t\t/**\n\t\t * Arabic characters that couldn't join to the next character\n\t\t */\n\t\tvar StandAlonForm = [\"\\u0621\", \"\\u0627\", \"\\u062F\", \"\\u0630\", \"\\u0631\", \"\\u0632\", \"\\u0648\", \"\\u0622\", \"\\u0629\",\n\t                         \"\\u0626\", \"\\u0624\", \"\\u0625\", \"\\u0675\", \"\\u0623\"];\n\t\t\n\t\tvar FETo06Table = [\"\\u064B\", \"\\u064B\", \"\\u064C\", \"\\u061F\", \"\\u064D\", \"\\u061F\", \"\\u064E\", \"\\u064E\", \"\\u064F\",\n\t                       \"\\u064F\", \"\\u0650\", \"\\u0650\", \"\\u0651\", \"\\u0651\", \"\\u0652\", \"\\u0652\", \"\\u0621\", \"\\u0622\",\n\t                       \"\\u0622\", \"\\u0623\", \"\\u0623\", \"\\u0624\", \"\\u0624\", \"\\u0625\", \"\\u0625\", \"\\u0626\", \"\\u0626\",\n\t                       \"\\u0626\", \"\\u0626\", \"\\u0627\", \"\\u0627\", \"\\u0628\", \"\\u0628\", \"\\u0628\", \"\\u0628\", \"\\u0629\",\n\t                       \"\\u0629\", \"\\u062A\", \"\\u062A\", \"\\u062A\", \"\\u062A\", \"\\u062B\", \"\\u062B\", \"\\u062B\", \"\\u062B\",\n\t                       \"\\u062C\", \"\\u062C\", \"\\u062C\", \"\\u062c\", \"\\u062D\", \"\\u062D\", \"\\u062D\", \"\\u062D\", \"\\u062E\",\n\t                       \"\\u062E\", \"\\u062E\", \"\\u062E\", \"\\u062F\", \"\\u062F\", \"\\u0630\", \"\\u0630\", \"\\u0631\", \"\\u0631\",\n\t                       \"\\u0632\", \"\\u0632\", \"\\u0633\", \"\\u0633\", \"\\u0633\", \"\\u0633\", \"\\u0634\", \"\\u0634\", \"\\u0634\",\n\t                       \"\\u0634\", \"\\u0635\", \"\\u0635\", \"\\u0635\", \"\\u0635\", \"\\u0636\", \"\\u0636\", \"\\u0636\", \"\\u0636\",\n\t                       \"\\u0637\", \"\\u0637\", \"\\u0637\", \"\\u0637\", \"\\u0638\", \"\\u0638\", \"\\u0638\", \"\\u0638\", \"\\u0639\",\n\t                       \"\\u0639\", \"\\u0639\", \"\\u0639\", \"\\u063A\", \"\\u063A\", \"\\u063A\", \"\\u063A\", \"\\u0641\", \"\\u0641\",\n\t                       \"\\u0641\", \"\\u0641\", \"\\u0642\", \"\\u0642\", \"\\u0642\", \"\\u0642\", \"\\u0643\", \"\\u0643\", \"\\u0643\",\n\t                       \"\\u0643\", \"\\u0644\", \"\\u0644\", \"\\u0644\", \"\\u0644\", \"\\u0645\", \"\\u0645\", \"\\u0645\", \"\\u0645\",\n\t                       \"\\u0646\", \"\\u0646\", \"\\u0646\", \"\\u0646\", \"\\u0647\", \"\\u0647\", \"\\u0647\", \"\\u0647\", \"\\u0648\",\n\t                       \"\\u0648\", \"\\u0649\", \"\\u0649\", \"\\u064A\", \"\\u064A\", \"\\u064A\", \"\\u064A\", \"\\uFEF5\", \"\\uFEF6\",\n\t                       \"\\uFEF7\", \"\\uFEF8\", \"\\uFEF9\", \"\\uFEFA\", \"\\uFEFB\", \"\\uFEFC\", \"\\u061F\", \"\\u061F\", \"\\u061F\"];\n\t\n\t\tvar ArabicAlefBetIntervalsBegine = [\"\\u0621\", \"\\u0641\"];\n\t\t\n\t\tvar ArabicAlefBetIntervalsEnd = [\"\\u063A\", \"\\u064a\"];\n\t\t\n\t\tvar\timpTabLtr = [\n\t\t/*\t\tL,\t\tR,\t\tEN,\t\tAN,\t\tN,\t\tIL,\t\tCond */\n\t\t\t[\t0,\t\t3,\t\t0,\t\t1,\t\t0,\t\t0,\t\t0\t], /* 0 LTR text\t*/\n\t\t\t[\t0,\t\t3,\t\t0,\t\t1,\t\t2,\t\t2,\t\t0\t], /* 1 LTR+AN\t\t*/\n\t\t\t[\t0,\t\t3,\t\t0,\t\t0x11,\t2,\t\t0,\t\t1\t], /* 2 LTR+AN+N\t*/\n\t\t\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t1,\t\t0\t], /* 3 RTL text\t*/\n\t\t\t[\t0,\t\t3,\t\t0x15,\t0x15,\t4,\t\t0,\t\t1\t], /* 4 RTL cont\t*/\n\t\t\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t2,\t\t0\t]  /* 5 RTL+EN/AN\t*/\n\t\t];\n\t\tvar impTabRtl = [\n\t\t/*\t\tL,\t\tR,\t\tEN,\t\tAN,\t\tN,\t\tIL,\t\tCond */\n\t\t\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t1,\t\t0\t], /* 0 RTL text\t*/\n\t\t\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t2,\t\t0\t], /* 1 RTL+EN/AN\t*/\n\t\t\t[\t2,\t\t0,\t\t2,\t\t1,\t\t3,\t\t2,\t\t0\t], /* 2 LTR text\t*/\n\t\t\t[\t2,\t\t0,\t\t2,\t\t0x21,\t3,\t\t1,\t\t1\t]  /* 3 LTR+cont\t*/\n\t\t];\n\t\t\n\t\tvar UBAT_L\t= 0; /* left to right\t\t\t\t*/\n\t\tvar UBAT_R\t= 1; /* right to left\t\t\t\t*/\n\t\tvar UBAT_EN = 2; /* European digit\t\t\t\t*/\n\t\tvar UBAT_AN = 3; /* Arabic-Indic digit\t\t\t*/\n\t\tvar UBAT_ON = 4; /* neutral\t\t\t\t\t\t*/\n\t\tvar UBAT_B\t= 5; /* block separator\t\t\t\t*/\n\t\tvar UBAT_S\t= 6; /* segment separator\t\t\t*/\n\t\tvar UBAT_AL = 7; /* Arabic Letter\t\t\t\t*/\n\t\tvar UBAT_WS = 8; /* white space\t\t\t\t\t*/\n\t\tvar UBAT_CS = 9; /* common digit separator\t\t*/\n\t\tvar UBAT_ES = 10; /* European digit separator\t*/\n\t\tvar UBAT_ET = 11; /* European digit terminator\t*/\n\t\tvar UBAT_NSM = 12; /* Non Spacing Mark\t\t\t*/\n\t\tvar UBAT_LRE = 13; /* LRE\t\t\t\t\t\t*/\n\t\tvar UBAT_RLE = 14; /* RLE\t\t\t\t\t\t*/\n\t\tvar UBAT_PDF = 15; /* PDF\t\t\t\t\t\t*/\n\t\tvar UBAT_LRO = 16; /* LRO\t\t\t\t\t\t*/\n\t\tvar UBAT_RLO = 17; /* RLO\t\t\t\t\t\t*/\n\t\tvar UBAT_BN\t= 18; /* Boundary Neutral\t\t\t*/\n\t\n\t\tvar TYPES_NAMES = [ \"UBAT_L\", \"UBAT_R\", \"UBAT_EN\", \"UBAT_AN\", \"UBAT_ON\", \"UBAT_B\", \"UBAT_S\", \"UBAT_AL\", \"UBAT_WS\",\n\t\t\t\t\t\t\t\"UBAT_CS\", \"UBAT_ES\", \"UBAT_ET\", \"UBAT_NSM\", \"UBAT_LRE\", \"UBAT_RLE\", \"UBAT_PDF\", \"UBAT_LRO\",\n\t\t\t\t\t\t\t\"UBAT_RLO\", \"UBAT_BN\" ];\n\t\tvar TBBASE = 100;\n\t\t\n\t\tvar TB00 = TBBASE + 0;\n\t\tvar TB05 = TBBASE + 1;\n\t\tvar TB06 = TBBASE + 2;\n\t\tvar TB07 = TBBASE + 3;\n\t\tvar TB20 = TBBASE + 4;\n\t\tvar TBFB = TBBASE + 5;\n\t\tvar TBFE = TBBASE + 6;\n\t\tvar TBFF = TBBASE + 7;\n\t\t\n\t\tvar L\t= UBAT_L;\n\t\tvar R\t= UBAT_R;\n\t\tvar EN\t= UBAT_EN;\n\t\tvar AN\t= UBAT_AN;\n\t\tvar ON\t= UBAT_ON;\n\t\tvar B\t= UBAT_B;\n\t\tvar S\t= UBAT_S;\n\t\tvar AL\t= UBAT_AL;\n\t\tvar WS\t= UBAT_WS;\n\t\tvar CS\t= UBAT_CS;\n\t\tvar ES\t= UBAT_ES;\n\t\tvar ET\t= UBAT_ET;\n\t\tvar NSM\t= UBAT_NSM;\n\t\tvar LRE\t= UBAT_LRE;\n\t\tvar RLE\t= UBAT_RLE;\n\t\tvar PDF\t= UBAT_PDF;\n\t\tvar LRO\t= UBAT_LRO;\n\t\tvar RLO\t= UBAT_RLO;\n\t\tvar BN\t= UBAT_BN;\n\t\t\n\t\tvar MasterTable = [\n\t /*******************************************************************************************************/\n\t /*     0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F     */\n\t /*******************************************************************************************************/\n\t /*0-*/ TB00, L,    L,    L,    L,    TB05, TB06, TB07, R,    L,    L,    L,    L,    L,    L,    L,\n\t /*1-*/ L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,\n\t /*2-*/ TB20, ON,   ON,   ON,   L,    ON,   L,    ON,   L,    ON,   ON,   ON,   L,    L,    ON,   ON,\n\t /*3-*/ L,    L,    L,    L,    L,    ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*4-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    ON,\n\t /*5-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*6-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*7-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*8-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*9-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,\n\t /*A-*/ L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    ON,   ON,   ON,\n\t /*B-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*C-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*D-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    ON,   ON,   L,    L,    ON,   ON,   L,\n\t /*E-*/ L,    ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n\t /*F-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    L,    TBFB, AL,   AL,   TBFE, TBFF\n\t\t];\n\t\n\t\tvar UnicodeTable = [\n\t        [ /*\tTable 00: Unicode 00xx */\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  S,   B,   S,   WS,  B,   BN,  BN,\n\t    /*1-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  B,   B,   B,   S,\n\t    /*2-*/  WS,  ON,  ON,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ES,  CS,  ES,  CS,  CS,\n\t    /*3-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  CS,  ON,  ON,  ON,  ON,  ON,\n\t    /*4-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*5-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,\n\t    /*6-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  BN,\n\t    /*8-*/  BN,  BN,  BN,  BN,  BN,  B,   BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,\n\t    /*9-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,\n\t    /*A-*/  CS,  ON,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  L,   ON,  ON,  BN,  ON,  ON,\n\t    /*B-*/  ET,  ET,  EN,  EN,  ON,  L,   ON,  ON,  ON,  EN,  L,   ON,  ON,  ON,  ON,  ON,\n\t    /*C-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*D-*/  L,   L,   L,   L,   L,   L,   L,   ON,  L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*E-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*F-*/  L,   L,   L,   L,   L,   L,   L,   ON,  L,   L,   L,   L,   L,   L,   L,   L\n\t\t\t],\n\t\t\t[ /*\tTable 01: Unicode 05xx */\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*1-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*2-*/  L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*3-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*4-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*5-*/  L,   L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   L,   L,   L,   L,\n\t    /*6-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*8-*/  L,   L,   L,   L,   L,   L,   L,   L,   ON,  L,   ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*9-*/  ON,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*A-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*B-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, R,   NSM,\n\t    /*C-*/  R,   NSM, NSM, R,   NSM, NSM, R,   NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*D-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n\t    /*E-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   ON,  ON,  ON,  ON,  ON,\n\t    /*F-*/  R,   R,   R,   R,   R,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON\n\t\t\t],\n\t\t\t[ /*\tTable 02: Unicode 06xx */\n\t    /****************************************************************************************/\n\t\t/*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t\t/****************************************************************************************/\n\t    /*0-*/  AN,  AN,  AN,  AN,  ON,  ON,  ON,  ON,  AL,  ET,  ET,  AL,  CS,  AL,  ON,  ON,\n\t    /*1-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, AL,  ON,  ON,  AL,  AL,\n\t    /*2-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*3-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*4-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM,\n\t    /*5-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*6-*/  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  ET,  AN,  AN,  AL,  AL,  AL,\n\t    /*7-*/  NSM, AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*C-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*D-*/  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, AN,  ON,  NSM,\n\t    /*E-*/  NSM, NSM, NSM, NSM, NSM, AL,  AL,  NSM, NSM, ON,  NSM, NSM, NSM, NSM, AL,  AL,\n\t    /*F-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  AL,  AL,  AL,  AL,  AL,  AL\n\t\t\t],\n\t\t\t[\t/*\tTable\t03:\tUnicode\t07xx\t*/\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  ON,  AL,\n\t    /*1-*/  AL,  NSM, AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*2-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*3-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*4-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, ON,  ON,  AL,  AL,  AL,\n\t    /*5-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*6-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*7-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*B-*/  NSM, AL,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*C-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n\t    /*D-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n\t    /*E-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   NSM, NSM, NSM, NSM, NSM,\n\t    /*F-*/  NSM, NSM, NSM, NSM, R,   R,   ON,  ON,  ON,  ON,  R,   ON,  ON,  ON,  ON,  ON\n\t\t\t],\n\t\t\t[\t/*\tTable\t04:\tUnicode\t20xx\t*/\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  BN,  BN,  BN,  L,   R,\n\t    /*1-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*2-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  WS,  B,   LRE, RLE, PDF, LRO, RLO, CS,\n\t    /*3-*/  ET,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*4-*/  ON,  ON,  ON,  ON,  CS,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*5-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  WS,\n\t    /*6-*/  BN,  BN,  BN,  BN,  BN,  ON,  ON,  ON,  ON,  ON,  BN,  BN,  BN,  BN,  BN,  BN,\n\t    /*7-*/  EN,  L,   ON,  ON,  EN,  EN,  EN,  EN,  EN,  EN,  ES,  ES,  ON,  ON,  ON,  L,\n\t    /*8-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  ES,  ES,  ON,  ON,  ON,  ON,\n\t    /*9-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,\n\t    /*A-*/  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,\n\t    /*B-*/  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*C-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*D-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*E-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*F-*/  NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON\n\t\t\t],\n\t\t\t[\t/*\tTable\t05:\tUnicode\tFBxx\t*/\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*1-*/  ON,  ON,  ON,  L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  R,   NSM, R,\n\t    /*2-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   ES,  R,   R,   R,   R,   R,   R,\n\t    /*3-*/  R,   R,   R,   R,   R,   R,   R,   ON,  R,   R,   R,   R,   R,   ON,  R,   ON,\n\t    /*4-*/  R,   R,   ON,  R,   R,   ON,  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n\t    /*5-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*6-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*7-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*C-*/  AL,  AL,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*D-*/  ON,  ON,  ON,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*E-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*F-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL\n\t\t\t],\n\t\t\t[\t/*\tTable\t06:\tUnicode\tFExx\t*/\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n\t    /*1-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*2-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*3-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*4-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*5-*/  CS,  ON,  CS,  ON,  ON,  CS,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ET,\n\t    /*6-*/  ON,  ON,  ES,  ES,  ON,  ON,  ON,  ON,  ON,  ET,  ET,  ON,  ON,  ON,  ON,  ON,\n\t    /*7-*/  AL,  AL,  AL,  AL,  AL,  ON,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*C-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*D-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*E-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n\t    /*F-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  ON,  ON,  BN\n\t\t\t],\n\t\t\t[\t/*\tTable\t07:\tUnicode\tFFxx\t*/\n\t    /****************************************************************************************/\n\t    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t    /****************************************************************************************/\n\t    /*0-*/  ON,  ON,  ON,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ES,  CS,  ES,  CS,  CS,\n\t    /*1-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  CS,  ON,  ON,  ON,  ON,  ON,\n\t    /*2-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*3-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,\n\t    /*4-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*5-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,\n\t    /*6-*/  ON,  ON,  ON,  ON,  ON,  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*8-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*9-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*A-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n\t    /*B-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,\n\t    /*C-*/  ON,  ON,  L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   L,   L,   L,\n\t    /*D-*/  ON,  ON,  L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   ON,  ON,  ON,\n\t    /*E-*/  ET,  ET,  ON,  ON,  ON,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n\t    /*F-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON\n\t\t\t]\n\t\t];\n\t\n\t\treturn BidiEngine;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 200 */\n/*!********************************************!*\\\n  !*** ../dojox/charting/bidi/_bidiutils.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t  !(module.exports = {\n\t\t\treverseMatrix: function(plot, dim, offsets, rtl){\n\t\t\t\t//summary:\n\t\t\t\t//\treverse the underlying matrix of the plots to perform the mirroring behavior.\n\t\t\t\t//plot:\n\t\t\t\t//  the plot which has the matrix to be reversed.\n\t\t\t\t//dim:\n\t\t\t\t//  the dimension (width,height) of the chart.\n\t\t\t\t//offsets:\n\t\t\t\t//  the offsets of the chart\n\t\t\t\tvar shift = offsets.l - offsets.r;\n\t\t\t\tvar xx = rtl? -1 : 1;\n\t\t\t\tvar xy = 0;\n\t\t\t\tvar yx = 0;\n\t\t\t\tvar yy = 1;\n\t\t\t\tvar dx = rtl? dim.width + shift : 0;\n\t\t\t\tvar dy = 0;\n\t\t\t\tif(plot.matrix){\n\t\t\t\t\txx = xx * Math.abs(plot.matrix.xx);\n\t\t\t\t\tyy = plot.matrix.yy;\n\t\t\t\t\txy = plot.matrix.xy;\n\t\t\t\t\tyx = plot.matrix.yx;\n\t\t\t\t\tdy = plot.matrix.xy;\n\t\t\t\t}\n\t\t\t\tplot.setTransform({xx: xx, xy: xy, yx: yx, yy: yy, dx: dx, dy: dy});\n\t \t}\n\t });\n\n\n/***/ },\n/* 201 */\n/*!****************************************!*\\\n  !*** ../dojox/lang/functional/fold.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/kernel */ 4), __webpack_require__(/*! ./lambda */ 176)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, kernel, df){\n\t\n\t// This module adds high-level functions and related constructs:\n\t//\t- \"fold\" family of functions\n\t\n\t// Notes:\n\t//\t- missing high-level functions are provided with the compatible API:\n\t//\t\tfoldl, foldl1, foldr, foldr1\n\t//\t- missing JS standard functions are provided with the compatible API:\n\t//\t\treduce, reduceRight\n\t//\t- the fold's counterpart: unfold\n\t\n\t// Defined methods:\n\t//\t- take any valid lambda argument as the functional argument\n\t//\t- operate on dense arrays\n\t//\t- take a string as the array argument\n\t//\t- take an iterator objects as the array argument (only foldl, foldl1, and reduce)\n\t\n\t\tvar empty = {};\n\t\n\t\tlang.mixin(df, {\n\t\t\t// classic reduce-class functions\n\t\t\tfoldl: function(/*Array|String|Object*/ a, /*Function*/ f, /*Object*/ z, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trepeatedly applies a binary function to an array from left\n\t\t\t\t//\t\tto right using a seed value as a starting point; returns the final\n\t\t\t\t//\t\tvalue.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar i, n;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tfor(i = 0, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tfor(i = 0; a.hasNext(); z = f.call(o, z, a.next(), i++, a));\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tz = f.call(o, z, a[i], i, a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn z;\t// Object\n\t\t\t},\n\t\t\tfoldl1: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trepeatedly applies a binary function to an array from left\n\t\t\t\t//\t\tto right; returns the final value.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar z, i, n;\n\t\t\t\tif(lang.isArray(a)){\n\t\t\t\t\t// array\n\t\t\t\t\tz = a[0];\n\t\t\t\t\tfor(i = 1, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);\n\t\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t\t// iterator\n\t\t\t\t\tif(a.hasNext()){\n\t\t\t\t\t\tz = a.next();\n\t\t\t\t\t\tfor(i = 1; a.hasNext(); z = f.call(o, z, a.next(), i++, a));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// object/dictionary\n\t\t\t\t\tvar first = true;\n\t\t\t\t\tfor(i in a){\n\t\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\t\tif(first){\n\t\t\t\t\t\t\t\tz = a[i];\n\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tz = f.call(o, z, a[i], i, a);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn z;\t// Object\n\t\t\t},\n\t\t\tfoldr: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object*/ z, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trepeatedly applies a binary function to an array from right\n\t\t\t\t//\t\tto left using a seed value as a starting point; returns the final\n\t\t\t\t//\t\tvalue.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tfor(var i = a.length; i > 0; --i, z = f.call(o, z, a[i], i, a));\n\t\t\t\treturn z;\t// Object\n\t\t\t},\n\t\t\tfoldr1: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\trepeatedly applies a binary function to an array from right\n\t\t\t\t//\t\tto left; returns the final value.\n\t\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\t\tvar n = a.length, z = a[n - 1], i = n - 1;\n\t\t\t\tfor(; i > 0; --i, z = f.call(o, z, a[i], i, a));\n\t\t\t\treturn z;\t// Object\n\t\t\t},\n\t\t\t// JS 1.8 standard array functions, which can take a lambda as a parameter.\n\t\t\treduce: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ z){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tapply a function simultaneously against two values of the array\n\t\t\t\t//\t\t(from left-to-right) as to reduce it to a single value.\n\t\t\t\treturn arguments.length < 3 ? df.foldl1(a, f) : df.foldl(a, f, z);\t// Object\n\t\t\t},\n\t\t\treduceRight: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ z){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tapply a function simultaneously against two values of the array\n\t\t\t\t//\t\t(from right-to-left) as to reduce it to a single value.\n\t\t\t\treturn arguments.length < 3 ? df.foldr1(a, f) : df.foldr(a, f, z);\t// Object\n\t\t\t},\n\t\t\t// the fold's counterpart: unfold\n\t\t\tunfold: function(/*Function|String|Array*/ pr, /*Function|String|Array*/ f,\n\t\t\t\t\t\t\t/*Function|String|Array*/ g, /*Object*/ z, /*Object?*/ o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tbuilds an array by unfolding a value\n\t\t\t\to = o || kernel.global; f = df.lambda(f); g = df.lambda(g); pr = df.lambda(pr);\n\t\t\t\tvar t = [];\n\t\t\t\tfor(; !pr.call(o, z); t.push(f.call(o, z)), z = g.call(o, z));\n\t\t\t\treturn t;\t// Array\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 202 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/axis2d/Default.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/sniff */ 10), __webpack_require__(/*! dojo/_base/declare */ 33),\n\t\t__webpack_require__(/*! dojo/_base/connect */ 42), __webpack_require__(/*! dojo/dom-geometry */ 36), __webpack_require__(/*! ./Invisible */ 203),\n\t\t__webpack_require__(/*! ../scaler/linear */ 205), __webpack_require__(/*! ./common */ 184), __webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/lang/functional */ 175),\n\t\t__webpack_require__.dj.h(/*! dojo/has!dojo-bidi?../bidi/axis2d/Default */ \"dojo-bidi?206\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, has, declare, connect, domGeom, Invisible,\n\t\t\t\tlin, acommon, g, du, df, BidiDefault){\n\t\n\t\t/*=====\n\t\tvar __AxisCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tOptional arguments used in the definition of an axis.\n\t\t\t// vertical: Boolean?\n\t\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t\t// fixUpper: String?\n\t\t\t//\t\tAlign the greatest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t\t// fixLower: String?\n\t\t\t//\t\tAlign the smallest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t\t// natural: Boolean?\n\t\t\t//\t\tEnsure tick marks are made on \"natural\" numbers. Defaults to false.\n\t\t\t// leftBottom: Boolean?\n\t\t\t//\t\tDeprecated: use position instead. The position of a vertical axis; if true, will be placed against the left-bottom corner of the chart.  Defaults to true.\n\t\t\t// includeZero: Boolean?\n\t\t\t//\t\tInclude 0 on the axis rendering.  Default is false.\n\t\t\t// fixed: Boolean?\n\t\t\t//\t\tForce all axis labels to be fixed numbers.  Default is true.\n\t\t\t// majorLabels: Boolean?\n\t\t\t//\t\tFlag to draw labels at major ticks. Default is true.\n\t\t\t// minorTicks: Boolean?\n\t\t\t//\t\tFlag to draw minor ticks on an axis.  Default is true.\n\t\t\t// minorLabels: Boolean?\n\t\t\t//\t\tFlag to labels on minor ticks when there is enough space. Default is true.\n\t\t\t// microTicks: Boolean?\n\t\t\t//\t\tFlag to draw micro ticks on an axis. Default is false.\n\t\t\t// htmlLabels: Boolean?\n\t\t\t//\t\tFlag to use HTML (as opposed to the native vector graphics engine) to draw labels. Default is true.\n\t\t\t// min: Number?\n\t\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t\t// max: Number?\n\t\t\t//\t\tThe largest value on an axis. Default is 1.\n\t\t\t// from: Number?\n\t\t\t//\t\tForce the chart to render data visible from this value. Default is 0.\n\t\t\t// to: Number?\n\t\t\t//\t\tForce the chart to render data visible to this value. Default is 1.\n\t\t\t// majorTickStep: Number?\n\t\t\t//\t\tThe amount to skip before a major tick is drawn. When not set the major ticks step is computed from\n\t\t\t//\t\tthe data range.\n\t\t\t// minorTickStep: Number?\n\t\t\t//\t\tThe amount to skip before a minor tick is drawn. When not set the minor ticks step is computed from\n\t\t\t//\t\tthe data range.\n\t\t\t// microTickStep: Number?\n\t\t\t//\t\tThe amount to skip before a micro tick is drawn. When not set the micro ticks step is computed from\n\t\t\t// labels: Object[]?\n\t\t\t//\t\tAn array of labels for major ticks, with corresponding numeric values, ordered by value.\n\t\t\t// labelFunc: Function?\n\t\t\t//\t\tAn optional function to use to compute label text. It takes precedence over\n\t\t\t//\t\tthe default text when available. The function must be of the following form:\n\t\t\t//\t|\t\tfunction labelFunc(text, value, precision) {}\n\t\t\t//\t\t`text` is the already pre-formatted text. Pre-formatting is done using `dojo/number` is available, `Date.toFixed` otherwise.\n\t\t\t//\t\t`value`  is the raw axis value.\n\t\t\t//\t\t`precision` is the requested precision to be applied.\n\t\t\t// maxLabelSize: Number?\n\t\t\t//\t\tThe maximum size, in pixels, for a label.  To be used with the optional label function.\n\t\t\t// stroke: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to be used for drawing an axis.\n\t\t\t// majorTick: Object?\n\t\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a major tick.\n\t\t\t// minorTick: Object?\n\t\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a minor tick.\n\t\t\t// microTick: Object?\n\t\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a micro tick.\n\t\t\t// tick: Object?\n\t\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a tick.\n\t\t\t// font: String?\n\t\t\t//\t\tAn optional font definition (as used in the CSS font property) for labels.\n\t\t\t// fontColor: String|dojo.Color?\n\t\t\t//\t\tAn optional color to be used in drawing labels.\n\t\t\t// titleGap: Number?\n\t\t\t//\t\tAn optional grap between axis title and axis label\n\t\t\t// titleFont: String?\n\t\t\t//\t\tAn optional font definition for axis title\n\t\t\t// titleFontColor: String?\n\t\t\t//\t\tAn optional axis title color\n\t\t\t// titleOrientation: String?\n\t\t\t//\t\tAn optional orientation for axis title. \"axis\" means the title facing the axis, \"away\" means facing away.\n\t\t\t//\t\tIf no value is set \"axis\" is used.\n\t\t\t// enableCache: Boolean?\n\t\t\t//\t\tWhether the ticks and labels are cached from one rendering to another. This improves the rendering performance of\n\t\t\t//\t\tsuccessive rendering but penalize the first rendering. For labels it is only working with gfx labels\n\t\t\t//\t\tnot html ones.  Default false.\n\t\t\t// dropLabels: Boolean?\n\t\t\t//\t\tWhether the axis automatically drops labels at regular interval or not to avoid labels overlapping.\n\t\t\t//\t\tThis gives better results but require more computations.  You can disable it to save computation\n\t\t\t//\t\ttime when you know your labels won't overlap. Default is true.\n\t\t\t// labelSizeChange: Boolean?\n\t\t\t//\t\tIndicates to the axis whether the axis labels are changing their size on zoom. If false this allows to\n\t\t\t//\t\toptimize the axis by avoiding recomputing labels maximum size on zoom actions. Default is false.\n\t\t\t// position: String?\n\t\t\t//\t\tThe position of the axis. Values: \"leftOrBottom\", \"center\" or \"rightOrTop\". Default is \"leftOrBottom\".\n\t\t};\n\t\t=====*/\n\t\n\t\tvar centerAnchorLimit = 45;\t// in degrees\n\t\n\t\tvar Default = declare(has(\"dojo-bidi\")? \"dojox.charting.axis2d.NonBidiDefault\" : \"dojox.charting.axis2d.Default\", Invisible, {\n\t\t\t// summary:\n\t\t\t//\t\tThe default axis object used in dojox.charting.  See dojox.charting.Chart.addAxis for details.\n\t\n\t\t\t// defaultParams: Object\n\t\t\t//\t\tThe default parameters used to define any axis.\n\t\t\t// optionalParams: Object\n\t\t\t//\t\tAny optional parameters needed to define an axis.\n\t\n\t\t\t/*=====\n\t\t\t// TODO: the documentation tools need these to be pre-defined in order to pick them up\n\t\t\t//\tcorrectly, but the code here is partially predicated on whether or not the properties\n\t\t\t//\tactually exist.  For now, we will leave these undocumented but in the code for later. -- TRT\n\t\n\t\t\t// opt: Object\n\t\t\t//\t\tThe actual options used to define this axis, created at initialization.\n\t\t\t// scaler: Object\n\t\t\t//\t\tThe calculated helper object to tell charts how to draw an axis and any data.\n\t\t\t// ticks: Object\n\t\t\t//\t\tThe calculated tick object that helps a chart draw the scaling on an axis.\n\t\t\t// dirty: Boolean\n\t\t\t//\t\tThe state of the axis (whether it needs to be redrawn or not)\n\t\t\t// scale: Number\n\t\t\t//\t\tThe current scale of the axis.\n\t\t\t// offset: Number\n\t\t\t//\t\tThe current offset of the axis.\n\t\n\t\t\topt: null,\n\t\t\tscaler: null,\n\t\t\tticks: null,\n\t\t\tdirty: true,\n\t\t\tscale: 1,\n\t\t\toffset: 0,\n\t\t\t=====*/\n\t\t\tdefaultParams: {\n\t\t\t\tvertical:\tfalse,\t\t// true for vertical axis\n\t\t\t\tfixUpper:\t\"none\",\t// align the upper on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\t\tfixLower:\t\"none\",\t// align the lower on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\t\tnatural:\t false,\t\t// all tick marks should be made on natural numbers\n\t\t\t\tleftBottom:  true,\t\t// position of the axis, used with \"vertical\" - deprecated: use position instead\n\t\t\t\tincludeZero: false,\t\t// 0 should be included\n\t\t\t\tfixed:\t   true,\t\t// all labels are fixed numbers\n\t\t\t\tmajorLabels: true,\t\t// draw major labels\n\t\t\t\tminorTicks:  true,\t\t// draw minor ticks\n\t\t\t\tminorLabels: true,\t\t// draw minor labels\n\t\t\t\tmicroTicks:  false,\t\t// draw micro ticks\n\t\t\t\trotation:\t0,\t\t\t// label rotation angle in degrees\n\t\t\t\thtmlLabels:  true,\t\t// use HTML to draw labels\n\t\t\t\tenableCache: false,\t\t// whether we cache or not\n\t\t\t\tdropLabels: true,\t\t// whether we automatically drop overlapping labels or not\n\t\t\t\tlabelSizeChange: false, // whether the labels size change on zoom\n\t\t\t\tposition: \"leftOrBottom\" // position of the axis: \"leftOrBottom\" (default), \"center\" or \"rightOrTop\"\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tmin:\t\t\t0,\t// minimal value on this axis\n\t\t\t\tmax:\t\t\t1,\t// maximal value on this axis\n\t\t\t\tfrom:\t\t\t0,\t// visible from this value\n\t\t\t\tto:\t\t\t\t1,\t// visible to this value\n\t\t\t\tmajorTickStep:\t4,\t// major tick step\n\t\t\t\tminorTickStep:\t2,\t// minor tick step\n\t\t\t\tmicroTickStep:\t1,\t// micro tick step\n\t\t\t\tlabels:\t\t\t[],\t// array of labels for major ticks\n\t\t\t\t// with corresponding numeric values\n\t\t\t\t// ordered by values\n\t\t\t\tlabelFunc:\t\tnull, // function to compute label values\n\t\t\t\tmaxLabelSize:\t0,\t// size in px. For use with labelFunc\n\t\t\t\tmaxLabelCharCount:\t0,\t// size in word count.\n\t\t\t\ttrailingSymbol:\tnull,\n\t\n\t\t\t\t// TODO: add support for minRange!\n\t\t\t\t// minRange:\t\t1,\t// smallest distance from min allowed on the axis\n\t\n\t\t\t\t// theme components\n\t\t\t\tstroke:\t\t\t{},\t// stroke for an axis\n\t\t\t\tmajorTick:\t\t{},\t// stroke + length for a tick\n\t\t\t\tminorTick:\t\t{},\t// stroke + length for a tick\n\t\t\t\tmicroTick:\t\t{},\t// stroke + length for a tick\n\t\t\t\ttick:\t\t   {},\t// stroke + length for a tick\n\t\t\t\tfont:\t\t\t\"\",\t// font for labels\n\t\t\t\tfontColor:\t\t\"\",\t// color for labels as a string\n\t\t\t\ttitle:\t\t\t\t \"\",\t// axis title\n\t\t\t\ttitleGap:\t\t\t 0,\t\t// gap between axis title and axis label\n\t\t\t\ttitleFont:\t\t\t \"\",\t\t// axis title font\n\t\t\t\ttitleFontColor:\t\t \"\",\t\t// axis title font color\n\t\t\t\ttitleOrientation:\t \"\"\t\t// \"axis\" means the title facing the axis, \"away\" means facing away\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for an axis.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart the axis belongs to.\n\t\t\t\t// kwArgs: __AxisCtorArgs?\n\t\t\t\t//\t\tAny optional keyword arguments to be used to define this axis.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\tthis._textFreePool = [];\n\t\t\t\t\tthis._lineFreePool = [];\n\t\t\t\t\tthis._textUsePool = [];\n\t\t\t\t\tthis._lineUsePool = [];\n\t\t\t\t}\n\t\t\t\tthis._invalidMaxLabelSize = true;\n\t\t\t\t// replace deprecated leftBotton to position\n\t\t\t\tif(!(kwArgs && ('position' in kwArgs))){\n\t\t\t\t    this.opt.position = this.opt.leftBottom ? \"leftOrBottom\" : \"rightOrTop\";\n\t\t\t\t}\t\t\t\n\t\t\t\tthis.renderingOptions = { \"shape-rendering\": \"crispEdges\" };\n\t\t\t},\n\t\t\tsetWindow: function(scale, offset){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet the drawing \"window\" for the axis.\n\t\t\t\t// scale: Number\n\t\t\t\t//\t\tThe new scale for the axis.\n\t\t\t\t// offset: Number\n\t\t\t\t//\t\tThe new offset for the axis.\n\t\t\t\t// returns: dojox/charting/axis2d/Default\n\t\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\t\tif(scale != this.scale){\n\t\t\t\t\t// if scale changed we need to recompute new max label size\n\t\t\t\t\tthis._invalidMaxLabelSize = true;\n\t\t\t\t}\n\t\t\t\treturn this.inherited(arguments);\n\t\t\t},\n\t\n\t\t\t_groupLabelWidth: function(labels, font, wcLimit){\n\t\t\t\tif(!labels.length){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(labels.length > 50){\n\t\t\t\t\t// let's avoid degenerated cases\n\t\t\t\t\tlabels.length = 50;\n\t\t\t\t}\n\t\t\t\tif(lang.isObject(labels[0])){\n\t\t\t\t\tlabels = df.map(labels, function(label){ return label.text; });\n\t\t\t\t}\n\t\t\t\tif(wcLimit){\n\t\t\t\t\tlabels = df.map(labels, function(label){\n\t\t\t\t\t\treturn lang.trim(label).length == 0 ? \"\" : label.substring(0, wcLimit) + this.trailingSymbol;\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\tvar s = labels.join(\"<br>\");\n\t\t\t\treturn g._base._getTextBox(s, {font: font}).w || 0;\n\t\t\t},\n\t\n\t\t\t_getMaxLabelSize: function(min, max, span, rotation, font, size){\n\t\t\t\tif(this._maxLabelSize == null && arguments.length == 6){\n\t\t\t\t\tvar o = this.opt;\n\t\t\t\t\t// everything might have changed, reset the minMinorStep value\n\t\t\t\t\tthis.scaler.minMinorStep = this._prevMinMinorStep = 0;\n\t\t\t\t\tvar ob = lang.clone(o);\n\t\t\t\t\tdelete ob.to;\n\t\t\t\t\tdelete ob.from;\n\t\t\t\t\t// build all the ticks from min, to max not from to to _but_ using the step\n\t\t\t\t\t// that would be used if we where just displaying from to to from.\n\t\t\t\t\tvar sb = lin.buildScaler(min, max, span, ob, o.to - o.from);\n\t\t\t\t\tsb.minMinorStep = 0;\n\t\t\t\t\tthis._majorStart = sb.major.start;\n\t\t\t\t\t// we build all the ticks not only the ones we need to draw in order to get\n\t\t\t\t\t// a correct drop rate computation that works for any offset of this scale\n\t\t\t\t\tvar tb = lin.buildTicks(sb, o);\n\t\t\t\t\t// if there is not tick at all tb is null\n\t\t\t\t\tif(size && tb){\n\t\t\t\t\t\tvar majLabelW = 0, minLabelW = 0; // non rotated versions\n\t\t\t\t\t\t// we first collect all labels when needed\n\t\t\t\t\t\tvar tickLabelFunc = function(tick){\n\t\t\t\t\t\t\tif(tick.label){\n\t\t\t\t\t\t\t\tthis.push(tick.label);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar labels = [];\n\t\t\t\t\t\tif(this.opt.majorLabels){\n\t\t\t\t\t\t\tarr.forEach(tb.major, tickLabelFunc, labels);\n\t\t\t\t\t\t\tmajLabelW = this._groupLabelWidth(labels, font, ob.maxLabelCharCount);\n\t\t\t\t\t\t\tif(ob.maxLabelSize){\n\t\t\t\t\t\t\t\tmajLabelW = Math.min(ob.maxLabelSize, majLabelW);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// do the minor labels computation only if dropLabels is set\n\t\t\t\t\t\tlabels = [];\n\t\t\t\t\t\tif(this.opt.dropLabels && this.opt.minorLabels){\n\t\t\t\t\t\t\tarr.forEach(tb.minor, tickLabelFunc, labels);\n\t\t\t\t\t\t\tminLabelW = this._groupLabelWidth(labels, font, ob.maxLabelCharCount);\n\t\t\t\t\t\t\tif(ob.maxLabelSize){\n\t\t\t\t\t\t\t\tminLabelW = Math.min(ob.maxLabelSize, minLabelW);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._maxLabelSize = {\n\t\t\t\t\t\t\tmajLabelW: majLabelW, minLabelW: minLabelW,\n\t\t\t\t\t\t\tmajLabelH: size, minLabelH: size\n\t\t\t\t\t\t};\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis._maxLabelSize = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this._maxLabelSize;\n\t\t\t},\n\t\n\t\t\tcalculate: function(min, max, span){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\t// when the scale has not changed there is no reason for minMinorStep to change\n\t\t\t\tthis.scaler.minMinorStep = this._prevMinMinorStep;\n\t\t\t\t// we want to recompute the dropping mechanism only when the scale or the size of the axis is changing\n\t\t\t\t// not when for example when we scroll (otherwise effect would be weird)\n\t\t\t\tif((this._invalidMaxLabelSize || span != this._oldSpan) && (min != Infinity && max != -Infinity)){\n\t\t\t\t\tthis._invalidMaxLabelSize = false;\n\t\t\t\t\tif(this.opt.labelSizeChange){\n\t\t\t\t\t\tthis._maxLabelSize = null;\n\t\t\t\t\t}\n\t\t\t\t\tthis._oldSpan = span;\n\t\t\t\t\tvar o = this.opt;\n\t\t\t\t\tvar ta = this.chart.theme.axis, rotation = o.rotation % 360,\n\t\t\t\t\t\tlabelGap = this.chart.theme.axis.tick.labelGap,\n\t\t\t\t\t\t// TODO: we use one font --- of major tick, we need to use major and minor fonts\n\t\t\t\t\t\tfont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),\n\t\t\t\t\t\tsize = font ? g.normalizedLength(g.splitFontString(font).size) : 0,\n\t\t\t\t\t\t// even if we don't drop label we need to compute max size for offsets\n\t\t\t\t\t\tlabelW = this._getMaxLabelSize(min, max, span, rotation, font, size);\n\t\t\t\t\tif(typeof labelGap != \"number\"){\n\t\t\t\t\t\tlabelGap = 4; // in pixels\n\t\t\t\t\t}\n\t\t\t\t\tif(labelW && o.dropLabels){\n\t\t\t\t\t\tvar cosr = Math.abs(Math.cos(rotation * Math.PI / 180)),\n\t\t\t\t\t\t\tsinr = Math.abs(Math.sin(rotation * Math.PI / 180));\n\t\t\t\t\t\tvar majLabelW, minLabelW;\n\t\t\t\t\t\tif(rotation < 0){\n\t\t\t\t\t\t\trotation += 360;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\t\t// trivial cases: horizontal labels\n\t\t\t\t\t\t\t\tif(this.vertical){\n\t\t\t\t\t\t\t\t\tmajLabelW = minLabelW = size;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tmajLabelW = labelW.majLabelW;\n\t\t\t\t\t\t\t\t\tminLabelW = labelW.minLabelW;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\t\t// trivial cases: vertical\n\t\t\t\t\t\t\t\tif(this.vertical){\n\t\t\t\t\t\t\t\t\tmajLabelW = labelW.majLabelW;\n\t\t\t\t\t\t\t\t\tminLabelW = labelW.minLabelW;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tmajLabelW = minLabelW = size;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// all major labels are parallel they can't collapse except if the two ticks are\n\t\t\t\t\t\t\t\t// closer than the height of the text * cos(90-rotation)\n\t\t\t\t\t\t\t\tmajLabelW  = this.vertical ? Math.min(labelW.majLabelW, size / cosr) : Math.min(labelW.majLabelW, size / sinr);\n\t\t\t\t\t\t\t\t// for minor labels we need to rotated them\n\t\t\t\t\t\t\t\tvar gap1 = Math.sqrt(labelW.minLabelW * labelW.minLabelW + size * size),\n\t\t\t\t\t\t\t\t\tgap2 = this.vertical ? size * cosr + labelW.minLabelW * sinr : labelW.minLabelW * cosr + size * sinr;\n\t\t\t\t\t\t\t\tminLabelW = Math.min(gap1, gap2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we need to check both minor and major labels fit a minor step\n\t\t\t\t\t\tthis.scaler.minMinorStep = this._prevMinMinorStep =  Math.max(majLabelW, minLabelW) + labelGap;\n\t\t\t\t\t\tvar canMinorLabel = this.scaler.minMinorStep <= this.scaler.minor.tick * this.scaler.bounds.scale;\n\t\t\t\t\t\tif(!canMinorLabel){\n\t\t\t\t\t\t\t// we can't place minor labels, let's see if we can place major ones\n\t\t\t\t\t\t\t// in a major step and if not which skip interval we must follow\n\t\t\t\t\t\t\tthis._skipInterval = Math.floor((majLabelW + labelGap) / (this.scaler.major.tick * this.scaler.bounds.scale));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// everything fit well\n\t\t\t\t\t\t\tthis._skipInterval = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// drop label disabled\n\t\t\t\t\t\tthis._skipInterval = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// computes the tick subset we need for that scale/offset\n\t\t\t\tthis.ticks = lin.buildTicks(this.scaler, this.opt);\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\tgetOffsets: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the physical offset values for this axis (used in drawing data series). This method is not\n\t\t\t\t//\t\tsupposed to be called by the users but internally.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tThe calculated offsets in the form of { l, r, t, b } (left, right, top, bottom).\n\t\t\t\tvar s = this.scaler, offsets = { l: 0, r: 0, t: 0, b: 0 };\n\t\t\t\tif(!s){\n\t\t\t\t\treturn offsets;\n\t\t\t\t}\n\t\t\t\tvar o = this.opt,\n\t\t\t\t\tta = this.chart.theme.axis,\n\t\t\t\t\tlabelGap = this.chart.theme.axis.tick.labelGap,\n\t\t\t\t\t// TODO: we use one font --- of major tick, we need to use major and minor fonts\n\t\t\t\t\ttaTitleFont = o.titleFont || (ta.title && ta.title.font),\n\t\t\t\t\ttaTitleGap = (o.titleGap==0) ? 0 : o.titleGap || (ta.title && ta.title.gap),\n\t\t\t\t\ttaMajorTick = this.chart.theme.getTick(\"major\", o),\n\t\t\t\t\ttaMinorTick = this.chart.theme.getTick(\"minor\", o),\n\t\t\t\t\ttsize = taTitleFont ? g.normalizedLength(g.splitFontString(taTitleFont).size) : 0,\n\t\t\t\t\trotation = o.rotation % 360, position = o.position, \n\t\t\t\t\tleftBottom = position !== \"rightOrTop\",\n\t\t\t\t\tcosr = Math.abs(Math.cos(rotation * Math.PI / 180)),\n\t\t\t\t\tsinr = Math.abs(Math.sin(rotation * Math.PI / 180));\n\t\t\t\tthis.trailingSymbol = (o.trailingSymbol === undefined || o.trailingSymbol === null) ?\n\t\t\t\t\tthis.trailingSymbol : o.trailingSymbol;\n\t\t\t\tif(typeof labelGap != \"number\"){\n\t\t\t\t\tlabelGap = 4; // in pixels\n\t\t\t\t}\n\t\t\t\tif(rotation < 0){\n\t\t\t\t\trotation += 360;\n\t\t\t\t}\n\t\t\t\tvar maxLabelSize = this._getMaxLabelSize(); // don't need parameters, calculate has been called before => we use cached value\n\t\t\t\tif(maxLabelSize){\n\t\t\t\t\tvar side;\n\t\t\t\t\tvar labelWidth = Math.ceil(Math.max(maxLabelSize.majLabelW, maxLabelSize.minLabelW)) + 1,\n\t\t\t\t\t\tsize = Math.ceil(Math.max(maxLabelSize.majLabelH, maxLabelSize.minLabelH)) + 1;\n\t\t\t\t\tif(this.vertical){\n\t\t\t\t\t\tside = leftBottom ? \"l\" : \"r\";\n\t\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\t\toffsets[side] = position === \"center\" ? 0 : labelWidth;\n\t\t\t\t\t\t\t\toffsets.t = offsets.b = size / 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\t\toffsets[side] = size;\n\t\t\t\t\t\t\t\toffsets.t = offsets.b = labelWidth / 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif(rotation <= centerAnchorLimit || (180 < rotation && rotation <= (180 + centerAnchorLimit))){\n\t\t\t\t\t\t\t\t\toffsets[side] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"t\" : \"b\"] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"b\" : \"t\"] = size * cosr / 2;\n\t\t\t\t\t\t\t\t}else if(rotation > (360 - centerAnchorLimit) || (180 > rotation && rotation > (180 - centerAnchorLimit))){\n\t\t\t\t\t\t\t\t\toffsets[side] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"b\" : \"t\"] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"t\" : \"b\"] = size * cosr / 2;\n\t\t\t\t\t\t\t\t}else if(rotation < 90 || (180 < rotation && rotation < 270)){\n\t\t\t\t\t\t\t\t\toffsets[side] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"t\" : \"b\"] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\toffsets[side] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"b\" : \"t\"] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(position === \"center\"){\n\t\t\t\t\t\t    offsets[side] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\t\t\t\t\t\n\t\t\t\t\t\t    offsets[side] += labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) + (o.title ? (tsize + taTitleGap) : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tside = leftBottom ? \"b\" : \"t\";\n\t\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\t\toffsets[side] = position === \"center\" ? 0 : size;\n\t\t\t\t\t\t\t\toffsets.l = offsets.r = labelWidth / 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\t\toffsets[side] = labelWidth;\n\t\t\t\t\t\t\t\toffsets.l = offsets.r = size / 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif((90 - centerAnchorLimit) <= rotation && rotation <= 90 || (270 - centerAnchorLimit) <= rotation && rotation <= 270){\n\t\t\t\t\t\t\t\t\toffsets[side] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"r\" : \"l\"] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"l\" : \"r\"] = size * sinr / 2;\n\t\t\t\t\t\t\t\t}else if(90 <= rotation && rotation <= (90 + centerAnchorLimit) || 270 <= rotation && rotation <= (270 + centerAnchorLimit)){\n\t\t\t\t\t\t\t\t\toffsets[side] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"l\" : \"r\"] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"r\" : \"l\"] = size * sinr / 2;\n\t\t\t\t\t\t\t\t}else if(rotation < centerAnchorLimit || (180 < rotation && rotation < (180 + centerAnchorLimit))){\n\t\t\t\t\t\t\t\t\toffsets[side] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"r\" : \"l\"] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\toffsets[side] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t\t\toffsets[leftBottom ? \"l\" : \"r\"] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(position === \"center\"){\n\t\t\t\t\t\t    offsets[side] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\t\t\t\t\t\n\t\t\t\t\t\toffsets[side] += labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) + (o.title ? (tsize + taTitleGap) : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn offsets;\t//\tObject\n\t\t\t},\n\t\t\tcleanGroup: function(creator){\n\t\t\t\tif(this.opt.enableCache && this.group){\n\t\t\t\t\tthis._lineFreePool = this._lineFreePool.concat(this._lineUsePool);\n\t\t\t\t\tthis._lineUsePool = [];\n\t\t\t\t\tthis._textFreePool = this._textFreePool.concat(this._textUsePool);\n\t\t\t\t\tthis._textUsePool = [];\n\t\t\t\t}\n\t\t\t\tthis.inherited(arguments);\n\t\t\t},\n\t\t\tcreateText: function(labelType, creator, x, y, align, textContent, font, fontColor, labelWidth){\n\t\t\t\tif(!this.opt.enableCache || labelType==\"html\"){\n\t\t\t\t\treturn acommon.createText[labelType](\n\t\t\t\t\t\t\tthis.chart,\n\t\t\t\t\t\t\tcreator,\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\talign,\n\t\t\t\t\t\t\ttextContent,\n\t\t\t\t\t\t\tfont,\n\t\t\t\t\t\t\tfontColor,\n\t\t\t\t\t\t\tlabelWidth\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tvar text;\n\t\t\t\tif(this._textFreePool.length > 0){\n\t\t\t\t\ttext = this._textFreePool.pop();\n\t\t\t\t\ttext.setShape({x: x, y: y, text: textContent, align: align});\n\t\t\t\t\t// For now all items share the same font, no need to re-set it\n\t\t\t\t\t//.setFont(font).setFill(fontColor);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(text);\n\t\t\t\t}else{\n\t\t\t\t\ttext = acommon.createText[labelType](\n\t\t\t\t\t\t\tthis.chart,\n\t\t\t\t\t\t\tcreator,\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\talign,\n\t\t\t\t\t\t\ttextContent,\n\t\t\t\t\t\t\tfont,\n\t\t\t\t\t\t\tfontColor\t\t\t\t\t\t\n\t\t\t\t\t\t);\t\t\t\n\t\t\t\t}\n\t\t\t\tthis._textUsePool.push(text);\n\t\t\t\treturn text;\n\t\t\t},\n\t\t\tcreateLine: function(creator, params){\n\t\t\t\tvar line;\n\t\t\t\tif(this.opt.enableCache && this._lineFreePool.length > 0){\n\t\t\t\t\tline = this._lineFreePool.pop();\n\t\t\t\t\tline.setShape(params);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(line);\n\t\t\t\t}else{\n\t\t\t\t\tline = creator.createLine(params);\n\t\t\t\t}\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\tthis._lineUsePool.push(line);\n\t\t\t\t}\n\t\t\t\treturn line;\n\t\t\t},\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender/draw the axis.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height}.\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\t// returns: dojox/charting/axis2d/Default\n\t\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\t\t\n\t\t\t\tvar isRtl = this._isRtl();\t// chart mirroring\n\t\t\t\tif(!this.dirty || !this.scaler){\n\t\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Default\n\t\t\t\t}\n\t\t\t\t// prepare variable\n\t\t\t\tvar o = this.opt, ta = this.chart.theme.axis, position = o.position, \n\t\t\t\t       leftBottom = position !== \"rightOrTop\", rotation = o.rotation % 360,\n\t\t\t\t\tstart, stop, titlePos, titleRotation=0, titleOffset, axisVector, tickVector, anchorOffset, labelOffset, labelAlign,\n\t\t\t\t\tlabelGap = this.chart.theme.axis.tick.labelGap,\n\t\t\t\t\t// TODO: we use one font --- of major tick, we need to use major and minor fonts\n\t\t\t\t\ttaFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),\n\t\t\t\t\ttaTitleFont = o.titleFont || (ta.title && ta.title.font),\n\t\t\t\t\t// TODO: we use one font color --- we need to use different colors\n\t\t\t\t\ttaFontColor = o.fontColor || (ta.majorTick && ta.majorTick.fontColor) || (ta.tick && ta.tick.fontColor) || \"black\",\n\t\t\t\t\ttaTitleFontColor = o.titleFontColor || (ta.title && ta.title.fontColor) || \"black\",\n\t\t\t\t\ttaTitleGap = (o.titleGap==0) ? 0 : o.titleGap || (ta.title && ta.title.gap) || 15,\n\t\t\t\t\ttaTitleOrientation = o.titleOrientation || (ta.title && ta.title.orientation) || \"axis\",\n\t\t\t\t\ttaMajorTick = this.chart.theme.getTick(\"major\", o),\n\t\t\t\t\ttaMinorTick = this.chart.theme.getTick(\"minor\", o),\n\t\t\t\t\ttaMicroTick = this.chart.theme.getTick(\"micro\", o),\n\t\n\t\t\t\t\ttaStroke = \"stroke\" in o ? o.stroke : ta.stroke,\n\t\t\t\t\tsize = taFont ? g.normalizedLength(g.splitFontString(taFont).size) : 0,\n\t\t\t\t\tcosr = Math.abs(Math.cos(rotation * Math.PI / 180)),\n\t\t\t\t\tsinr = Math.abs(Math.sin(rotation * Math.PI / 180)),\n\t\t\t\t\ttsize = taTitleFont ? g.normalizedLength(g.splitFontString(taTitleFont).size) : 0;\n\t\t\t\tif(typeof labelGap != \"number\"){\n\t\t\t\t\tlabelGap = 4; // in pixels\n\t\t\t\t}\n\t\t\t\tif(rotation < 0){\n\t\t\t\t\trotation += 360;\n\t\t\t\t}\n\t\t\t\tvar cachedLabelW = this._getMaxLabelSize();\n\t\t\t\tcachedLabelW = cachedLabelW && cachedLabelW.majLabelW;\n\t\t\t\tif(this.vertical){\n\t\t\t\t\tstart = {y: dim.height - offsets.b};\n\t\t\t\t\tstop  = {y: offsets.t};\n\t\t\t\t\ttitlePos = {y: (dim.height - offsets.b + offsets.t)/2};\n\t\t\t\t\ttitleOffset = size * sinr + (cachedLabelW || 0) * cosr + labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) +\n\t\t\t\t\t\ttsize + taTitleGap;\n\t\t\t\t\taxisVector = {x: 0, y: -1};\n\t\t\t\t\tlabelOffset = {x: 0, y: 0};\n\t\t\t\t\ttickVector = {x: 1, y: 0};\n\t\t\t\t\tanchorOffset = {x: labelGap, y: 0};\n\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\t\tlabelOffset.x = -size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.y = -size * 0.4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(rotation < centerAnchorLimit){\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t\t}else if(rotation < 90){\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t\t}else if(rotation < (180 - centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t}else if(rotation < (180 + centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tlabelOffset.y = -size * 0.4;\n\t\t\t\t\t\t\t}else if(rotation < 270){\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tlabelOffset.x = leftBottom ? 0 : size * 0.4;\n\t\t\t\t\t\t\t}else if(rotation < (360 - centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.x = leftBottom ? 0 : size * 0.4;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(leftBottom){\n\t\t\t\t\t\tstart.x = stop.x = position === \"center\" ? dim.width/2 : offsets.l;\n\t\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"away\") ? 90 : 270;\n\t\t\t\t\t\ttitlePos.x = offsets.l - titleOffset + (titleRotation == 270 ? tsize : 0);\n\t\t\t\t\t\ttickVector.x = -1;\n\t\t\t\t\t\tanchorOffset.x = -anchorOffset.x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstart.x = stop.x = dim.width - offsets.r;\n\t\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"axis\") ? 90 : 270;\n\t\t\t\t\t\ttitlePos.x = dim.width - offsets.r + titleOffset - (titleRotation == 270 ? 0 : tsize);\n\t\t\t\t\t\tswitch(labelAlign){\n\t\t\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\t\tlabelOffset.x += size;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tstart = {x: offsets.l};\n\t\t\t\t\tstop  = {x: dim.width - offsets.r};\n\t\t\t\t\ttitlePos = {x: (dim.width - offsets.r + offsets.l)/2};\n\t\t\t\t\ttitleOffset = size * cosr + (cachedLabelW || 0) * sinr + labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) +\n\t\t\t\t\t\ttsize + taTitleGap;\n\t\t\t\t\taxisVector = {x: isRtl ? -1 : 1, y: 0}; \t// chart mirroring\n\t\t\t\t\tlabelOffset = {x: 0, y: 0};\n\t\t\t\t\ttickVector = {x: 0, y: 1};\n\t\t\t\t\tanchorOffset = {x: 0, y: labelGap};\n\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\t\tlabelOffset.y = size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.x = -size * 0.4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.x = size * 0.4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(rotation < (90 - centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? size : 0;\n\t\t\t\t\t\t\t}else if(rotation < (90 + centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tlabelOffset.x = -size * 0.4;\n\t\t\t\t\t\t\t}else if(rotation < 180){\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? 0 : -size;\n\t\t\t\t\t\t\t}else if(rotation < (270 - centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? 0 : -size;\n\t\t\t\t\t\t\t}else if(rotation < (270 + centerAnchorLimit)){\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? size * 0.4 : 0;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? size : 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(leftBottom){\n\t\t\t\t\t\tstart.y = stop.y = position === \"center\" ? dim.height/2 : dim.height - offsets.b;\n\t\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"axis\") ? 180 : 0;\n\t\t\t\t\t\ttitlePos.y = dim.height - offsets.b + titleOffset - (titleRotation ? tsize : 0);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstart.y = stop.y = offsets.t;\n\t\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"away\") ? 180 : 0;\n\t\t\t\t\t\ttitlePos.y = offsets.t - titleOffset + (titleRotation ? 0 : tsize);\n\t\t\t\t\t\ttickVector.y = -1;\n\t\t\t\t\t\tanchorOffset.y = -anchorOffset.y;\n\t\t\t\t\t\tswitch(labelAlign){\n\t\t\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\t\tlabelOffset.y -= size;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// render shapes\n\t\n\t\t\t\tthis.cleanGroup();\n\t\n\t\t\t\tvar s = this.group,\n\t\t\t\t\tc = this.scaler,\n\t\t\t\t\tt = this.ticks,\n\t\t\t\t\tf = lin.getTransformerFromModel(this.scaler),\n\t\t\t\t\t// GFX Canvas now supports labels, so let's _not_ fallback to HTML anymore on canvas, just use\n\t\t\t\t\t// HTML labels if explicitly asked + no rotation + no IE + no Opera\n\t\t\t\t\tlabelType = (!o.title || !titleRotation) && !rotation && this.opt.htmlLabels && !has(\"ie\") && !has(\"opera\") ? \"html\" : \"gfx\",\n\t\t\t\t\tdx = tickVector.x * taMajorTick.length,\n\t\t\t\t\tdy = tickVector.y * taMajorTick.length,\n\t\t\t\t\tskip = this._skipInterval;\n\t\n\t\t\t\ts.createLine({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: stop.x,\n\t\t\t\t\ty2: stop.y\n\t\t\t\t}).setStroke(taStroke);\n\t\n\t\t\t\t//create axis title\n\t\t\t\tif(o.title){\n\t\t\t\t\tvar axisTitle = acommon.createText[labelType](\n\t\t\t\t\t\tthis.chart,\n\t\t\t\t\t\ts,\n\t\t\t\t\t\ttitlePos.x,\n\t\t\t\t\t\ttitlePos.y,\n\t\t\t\t\t\t\"middle\",\n\t\t\t\t\t\to.title,\n\t\t\t\t\t\ttaTitleFont,\n\t\t\t\t\t\ttaTitleFontColor\n\t\t\t\t\t);\n\t\t\t\t\tif(labelType == \"html\"){\n\t\t\t\t\t\tthis.htmlElements.push(axisTitle);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//as soon as rotation is provided, labelType won't be \"html\"\n\t\t\t\t\t\t//rotate gfx labels\n\t\t\t\t\t\taxisTitle.setTransform(g.matrix.rotategAt(titleRotation, titlePos.x, titlePos.y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// go out nicely instead of try/catch\n\t\t\t\tif(t == null){\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\n\t\t\t\tvar rel = (t.major.length > 0)?(t.major[0].value - this._majorStart) / c.major.tick:0;\n\t\t\t\tvar canLabel = this.opt.majorLabels;\n\t\t\t\tarr.forEach(t.major, function(tick, i){\n\t\t\t\t\tvar offset = f(tick.value), elem,\n\t\t\t\t\t\tx = (isRtl ? stop.x : start.x) + axisVector.x * offset, // chart mirroring\n\t\t\t\t\t\ty = start.y + axisVector.y * offset;\n\t\t\t\t\ti += rel;\n\t\t\t\t\tthis.createLine(s, {\n\t\t\t\t\t\tx1: x, y1: y,\n\t\t\t\t\t\tx2: x + dx,\n\t\t\t\t\t\ty2: y + dy\n\t\t\t\t\t}).setStroke(taMajorTick);\n\t\t\t\t\tif(tick.label && (!skip || (i - (1 + skip)) % (1 + skip) == 0)){\n\t\t\t\t\t\tvar label = o.maxLabelCharCount ? this.getTextWithLimitCharCount(tick.label, taFont, o.maxLabelCharCount) : {\n\t\t\t\t\t\t\ttext: tick.label,\n\t\t\t\t\t\t\ttruncated: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tlabel = o.maxLabelSize ? this.getTextWithLimitLength(label.text, taFont, o.maxLabelSize, label.truncated) : label;\n\t\t\t\t\t\telem = this.createText(labelType,\n\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\tx + (taMajorTick.length > 0 ? dx : 0) + anchorOffset.x + (rotation ? 0 : labelOffset.x),\n\t\t\t\t\t\t\ty + (taMajorTick.length > 0 ? dy : 0) + anchorOffset.y + (rotation ? 0 : labelOffset.y),\n\t\t\t\t\t\t\tlabelAlign,\n\t\t\t\t\t\t\tlabel.text,\n\t\t\t\t\t\t\ttaFont,\n\t\t\t\t\t\t\ttaFontColor\n\t\t\t\t\t\t\t//cachedLabelW\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// if bidi support was required, the textDir is \"auto\" and truncation\n\t\t\t\t\t\t// took place, we need to update the dir of the element for cases as:\n\t\t\t\t\t\t// Fool label: 111111W (W for bidi character)\n\t\t\t\t\t\t// truncated label: 11...\n\t\t\t\t\t\t// in this case for auto textDir the dir will be \"ltr\" which is wrong.\n\t\t\t\t\t\tif(label.truncated){\n\t\t\t\t\t\t\tthis.chart.formatTruncatedLabel(elem, tick.label, labelType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlabel.truncated && this.labelTooltip(elem, this.chart, tick.label, label.text, taFont, labelType);\n\t\t\t\t\t\tif(labelType == \"html\"){\n\t\t\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t\t\t}else if(rotation){\n\t\t\t\t\t\t\telem.setTransform([\n\t\t\t\t\t\t\t\t{dx: labelOffset.x, dy: labelOffset.y},\n\t\t\t\t\t\t\t\tg.matrix.rotategAt(\n\t\t\t\t\t\t\t\t\trotation,\n\t\t\t\t\t\t\t\t\tx + (taMajorTick.length > 0 ? dx : 0) + anchorOffset.x,\n\t\t\t\t\t\t\t\t\ty + (taMajorTick.length > 0 ? dy : 0) + anchorOffset.y\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\n\t\t\t\tdx = tickVector.x * taMinorTick.length;\n\t\t\t\tdy = tickVector.y * taMinorTick.length;\n\t\t\t\tcanLabel = this.opt.minorLabels && c.minMinorStep <= c.minor.tick * c.bounds.scale;\n\t\t\t\tarr.forEach(t.minor, function(tick){\n\t\t\t\t\tvar offset = f(tick.value), elem,\n\t\t\t\t\t\tx = (isRtl ? stop.x : start.x)  + axisVector.x * offset,\n\t\t\t\t\t\ty = start.y + axisVector.y * offset; // chart mirroring\n\t\t\t\t\tthis.createLine(s, {\n\t\t\t\t\t\tx1: x, y1: y,\n\t\t\t\t\t\tx2: x + dx,\n\t\t\t\t\t\ty2: y + dy\n\t\t\t\t\t}).setStroke(taMinorTick);\n\t\t\t\t\tif(canLabel && tick.label){\n\t\t\t\t\t\tvar label = o.maxLabelCharCount ? this.getTextWithLimitCharCount(tick.label, taFont, o.maxLabelCharCount) : {\n\t\t\t\t\t\t\ttext: tick.label,\n\t\t\t\t\t\t\ttruncated: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tlabel = o.maxLabelSize ? this.getTextWithLimitLength(label.text, taFont, o.maxLabelSize, label.truncated) : label;\n\t\t\t\t\t\telem = this.createText(labelType,\n\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\tx + (taMinorTick.length > 0 ? dx : 0) + anchorOffset.x + (rotation ? 0 : labelOffset.x),\n\t\t\t\t\t\t\ty + (taMinorTick.length  > 0 ? dy : 0) + anchorOffset.y + (rotation ? 0 : labelOffset.y),\n\t\t\t\t\t\t\tlabelAlign,\n\t\t\t\t\t\t\tlabel.text,\n\t\t\t\t\t\t\ttaFont,\n\t\t\t\t\t\t\ttaFontColor\n\t\t\t\t\t\t\t//cachedLabelW\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// if bidi support was required, the textDir is \"auto\" and truncation\n\t\t\t\t\t\t// took place, we need to update the dir of the element for cases as:\n\t\t\t\t\t\t// Fool label: 111111W (W for bidi character)\n\t\t\t\t\t\t// truncated label: 11...\n\t\t\t\t\t\t// in this case for auto textDir the dir will be \"ltr\" which is wrong.\n\t\t\t\t\t\tif(label.truncated){\n\t\t\t\t\t\t\tthis.chart.formatTruncatedLabel(elem, tick.label, labelType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlabel.truncated && this.labelTooltip(elem, this.chart, tick.label, label.text, taFont, labelType);\n\t\t\t\t\t\tif(labelType == \"html\"){\n\t\t\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t\t\t}else if(rotation){\n\t\t\t\t\t\t\telem.setTransform([\n\t\t\t\t\t\t\t\t{dx: labelOffset.x, dy: labelOffset.y},\n\t\t\t\t\t\t\t\tg.matrix.rotategAt(\n\t\t\t\t\t\t\t\t\trotation,\n\t\t\t\t\t\t\t\t\tx + (taMinorTick.length > 0 ? dx : 0) + anchorOffset.x,\n\t\t\t\t\t\t\t\t\ty + (taMinorTick.length > 0 ? dy : 0) + anchorOffset.y\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\n\t\t\t\tdx = tickVector.x * taMicroTick.length;\n\t\t\t\tdy = tickVector.y * taMicroTick.length;\n\t\t\t\tarr.forEach(t.micro, function(tick){\n\t\t\t\t\tvar offset = f(tick.value),\n\t\t\t\t\t\tx = start.x + axisVector.x * offset,\n\t\t\t\t\t\ty = start.y + axisVector.y * offset;\n\t\t\t\t\t\tthis.createLine(s, {\n\t\t\t\t\t\t\tx1: x, y1: y,\n\t\t\t\t\t\t\tx2: x + dx,\n\t\t\t\t\t\t\ty2: y + dy\n\t\t\t\t\t\t}).setStroke(taMicroTick);\n\t\t\t\t}, this);\n\t\n\t\t\t\tthis.dirty = false;\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Default\n\t\t\t},\n\t\t\tlabelTooltip: function(elem, chart, label, truncatedLabel, font, elemType){\n\t\t\t\tvar modules = [\"dijit/Tooltip\"];\n\t\t\t\tvar aroundRect = {type: \"rect\"}, position = [\"above\", \"below\"],\n\t\t\t\t\tfontWidth = g._base._getTextBox(truncatedLabel, {font: font}).w || 0,\n\t\t\t\t\tfontHeight = font ? g.normalizedLength(g.splitFontString(font).size) : 0;\n\t\t\t\tif(elemType == \"html\"){\n\t\t\t\t\tlang.mixin(aroundRect, domGeom.position(elem.firstChild, true));\n\t\t\t\t\taroundRect.width = Math.ceil(fontWidth);\n\t\t\t\t\taroundRect.height = Math.ceil(fontHeight);\n\t\t\t\t\tthis._events.push({\n\t\t\t\t\t\tshape:  dojo,\n\t\t\t\t\t\thandle: connect.connect(elem.firstChild, \"onmouseover\", this, function(e){\n\t\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\t\tTooltip.show(label, aroundRect, position);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t\tthis._events.push({\n\t\t\t\t\t\tshape:  dojo,\n\t\t\t\t\t\thandle: connect.connect(elem.firstChild, \"onmouseout\", this, function(e){\n\t\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\t\tTooltip.hide(aroundRect);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t}else{\n\t\t\t\t\tvar shp = elem.getShape(),\n\t\t\t\t\t\tlt = chart.getCoords();\n\t\t\t\t\taroundRect = lang.mixin(aroundRect, {\n\t\t\t\t\t\tx: shp.x - fontWidth / 2,\n\t\t\t\t\t\ty: shp.y\n\t\t\t\t\t});\n\t\t\t\t\taroundRect.x += lt.x;\n\t\t\t\t\taroundRect.y += lt.y;\n\t\t\t\t\taroundRect.x = Math.round(aroundRect.x);\n\t\t\t\t\taroundRect.y = Math.round(aroundRect.y);\n\t\t\t\t\taroundRect.width = Math.ceil(fontWidth);\n\t\t\t\t\taroundRect.height = Math.ceil(fontHeight);\n\t\t\t\t\tthis._events.push({\n\t\t\t\t\t\tshape:  elem,\n\t\t\t\t\t\thandle: elem.connect(\"onmouseenter\", this, function(e){\n\t\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\t\tTooltip.show(label, aroundRect, position);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t\tthis._events.push({\n\t\t\t\t\t\tshape:  elem,\n\t\t\t\t\t\thandle: elem.connect(\"onmouseleave\", this, function(e){\n\t\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\t\tTooltip.hide(aroundRect);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t_isRtl: function(){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn has(\"dojo-bidi\")? declare(\"dojox.charting.axis2d.Default\", [Default, BidiDefault]) : Default;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 203 */\n/*!*********************************************!*\\\n  !*** ../dojox/charting/axis2d/Invisible.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Base */ 204), __webpack_require__(/*! ../scaler/linear */ 205),\n\t\t__webpack_require__(/*! dojox/lang/utils */ 187)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, Base, lin, du){\n\t\n\t/*=====\n\t\tvar __InvisibleAxisCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tOptional arguments used in the definition of an invisible axis.\n\t\t\t// vertical: Boolean?\n\t\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t\t// fixUpper: String?\n\t\t\t//\t\tAlign the greatest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t\t// fixLower: String?\n\t\t\t//\t\tAlign the smallest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t\t// natural: Boolean?\n\t\t\t//\t\tEnsure tick marks are made on \"natural\" numbers. Defaults to false.\n\t\t\t// leftBottom: Boolean?\n\t\t\t//\t\tThe position of a vertical axis; if true, will be placed against the left-bottom corner of the chart.  Defaults to true.\n\t\t\t// includeZero: Boolean?\n\t\t\t//\t\tInclude 0 on the axis rendering.  Default is false.\n\t\t\t// fixed: Boolean?\n\t\t\t//\t\tForce all axis labels to be fixed numbers.  Default is true.\n\t\t\t// min: Number?\n\t\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t\t// max: Number?\n\t\t\t//\t\tThe largest value on an axis. Default is 1.\n\t\t\t// from: Number?\n\t\t\t//\t\tForce the chart to render data visible from this value. Default is 0.\n\t\t\t// to: Number?\n\t\t\t//\t\tForce the chart to render data visible to this value. Default is 1.\n\t\t\t// majorTickStep: Number?\n\t\t\t//\t\tThe amount to skip before a major tick is drawn. When not set the major ticks step is computed from\n\t\t\t//\t\tthe data range.\n\t\t\t// minorTickStep: Number?\n\t\t\t//\t\tThe amount to skip before a minor tick is drawn. When not set the minor ticks step is computed from\n\t\t\t//\t\tthe data range.\n\t\t\t// microTickStep: Number?\n\t\t\t//\t\tThe amount to skip before a micro tick is drawn. When not set the micro ticks step is computed from\n\t\t};\n\t=====*/\n\t\n\t\treturn declare(\"dojox.charting.axis2d.Invisible\", Base, {\n\t\t\t// summary:\n\t\t\t//\t\tA axis object used in dojox.charting.  You can use that axis if you want the axis to be invisible.\n\t\t\t//\t\tSee dojox.charting.Chart.addAxis for details.\n\t\t\t//\n\t\t\t// defaultParams: Object\n\t\t\t//\t\tThe default parameters used to define any axis.\n\t\t\t// optionalParams: Object\n\t\t\t//\t\tAny optional parameters needed to define an axis.\n\t\n\t\t\t/*\n\t\t\t// TODO: the documentation tools need these to be pre-defined in order to pick them up\n\t\t\t//\tcorrectly, but the code here is partially predicated on whether or not the properties\n\t\t\t//\tactually exist.  For now, we will leave these undocumented but in the code for later. -- TRT\n\t\n\t\t\t// opt: Object\n\t\t\t//\t\tThe actual options used to define this axis, created at initialization.\n\t\t\t// scaler: Object\n\t\t\t//\t\tThe calculated helper object to tell charts how to draw an axis and any data.\n\t\t\t// ticks: Object\n\t\t\t//\t\tThe calculated tick object that helps a chart draw the scaling on an axis.\n\t\t\t// dirty: Boolean\n\t\t\t//\t\tThe state of the axis (whether it needs to be redrawn or not)\n\t\t\t// scale: Number\n\t\t\t//\t\tThe current scale of the axis.\n\t\t\t// offset: Number\n\t\t\t//\t\tThe current offset of the axis.\n\t\n\t\t\topt: null,\n\t\t\tscaler: null,\n\t\t\tticks: null,\n\t\t\tdirty: true,\n\t\t\tscale: 1,\n\t\t\toffset: 0,\n\t\t\t*/\n\t\t\tdefaultParams: {\n\t\t\t\tvertical:    false,\t\t// true for vertical axis\n\t\t\t\tfixUpper:    \"none\",\t// align the upper on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\t\tfixLower:    \"none\",\t// align the lower on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\t\tnatural:     false,\t\t// all tick marks should be made on natural numbers\n\t\t\t\tleftBottom:  true,\t\t// position of the axis, used with \"vertical\"\n\t\t\t\tincludeZero: false,\t\t// 0 should be included\n\t\t\t\tfixed:       true\t\t// all labels are fixed numbers\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tmin:\t\t\t0,\t// minimal value on this axis\n\t\t\t\tmax:\t\t\t1,\t// maximal value on this axis\n\t\t\t\tfrom:\t\t\t0,\t// visible from this value\n\t\t\t\tto:\t\t\t\t1,\t// visible to this value\n\t\t\t\tmajorTickStep:\t4,\t// major tick step\n\t\t\t\tminorTickStep:\t2,\t// minor tick step\n\t\t\t\tmicroTickStep:\t1\t// micro tick step\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for an invisible axis.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart the axis belongs to.\n\t\t\t\t// kwArgs: __InvisibleAxisCtorArgs?\n\t\t\t\t//\t\tAny optional keyword arguments to be used to define this axis.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t            du.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t},\n\t\t\tdependOnData: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tFind out whether or not the axis options depend on the data in the axis.\n\t\t\t\treturn !(\"min\" in this.opt) || !(\"max\" in this.opt);\t//\tBoolean\n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear out all calculated properties on this axis;\n\t\t\t\t// returns: dojox/charting/axis2d/Invisible\n\t\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\t\tdelete this.scaler;\n\t\t\t\tdelete this.ticks;\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Invisible\n\t\t\t},\n\t\t\tinitialized: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tFinds out if this axis has been initialized or not.\n\t\t\t\t// returns: Boolean\n\t\t\t\t//\t\tWhether a scaler has been calculated and if the axis is not dirty.\n\t\t\t\treturn \"scaler\" in this && !(this.dirty && this.dependOnData());\n\t\t\t},\n\t\t\tsetWindow: function(scale, offset){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet the drawing \"window\" for the axis.\n\t\t\t\t// scale: Number\n\t\t\t\t//\t\tThe new scale for the axis.\n\t\t\t\t// offset: Number\n\t\t\t\t//\t\tThe new offset for the axis.\n\t\t\t\t// returns: dojox/charting/axis2d/Invisible\n\t\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\t\tthis.scale  = scale;\n\t\t\t\tthis.offset = offset;\n\t\t\t\treturn this.clear();\t//\tdojox/charting/axis2d/Invisible\n\t\t\t},\n\t\t\tgetWindowScale: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the current windowing scale of the axis.\n\t\t\t\treturn \"scale\" in this ? this.scale : 1;\t//\tNumber\n\t\t\t},\n\t\t\tgetWindowOffset: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the current windowing offset for the axis.\n\t\t\t\treturn \"offset\" in this ? this.offset : 0;\t//\tNumber\n\t\t\t},\n\t\t\tcalculate: function(min, max, span, scalerType){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tPerform all calculations needed to render this axis.\n\t\t\t\t// min: Number\n\t\t\t\t//\t\tThe smallest value represented on this axis.\n\t\t\t\t// max: Number\n\t\t\t\t//\t\tThe largest value represented on this axis.\n\t\t\t\t// span: Number\n\t\t\t\t//\t\tThe span in pixels over which axis calculations are made.\n\t\t\t\t// scalerType: Object\n\t\t\t\t//\t\tAn optional scaler type object.\n\t\t\t\t// returns: dojox/charting/axis2d/Invisible\n\t\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\t\tif(this.initialized()){\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tvar o = this.opt;\n\t\t\t\t// we used to have a 4th function parameter to reach labels but\n\t\t\t\t// nobody was calling it with 4 parameters.\n\t\t\t\tthis.labels = o.labels;\n\t\t\t\tthis.scaler = (scalerType || lin).buildScaler(min, max, span, o);\n\t\t\t\t// store the absolute major tick start, this will be useful when dropping a label every n labels\n\t\t\t\t// TODO: if o.lower then it does not work\n\t\t\t\tvar tsb = this.scaler.bounds;\n\t\t\t\tif(\"scale\" in this){\n\t\t\t\t\t// calculate new range\n\t\t\t\t\to.from = tsb.lower + this.offset;\n\t\t\t\t\to.to   = (tsb.upper - tsb.lower) / this.scale + o.from;\n\t\t\t\t\t// make sure that bounds are correct\n\t\t\t\t\tif( !isFinite(o.from) ||\n\t\t\t\t\t\tisNaN(o.from) ||\n\t\t\t\t\t\t!isFinite(o.to) ||\n\t\t\t\t\t\tisNaN(o.to) ||\n\t\t\t\t\t\to.to - o.from >= tsb.upper - tsb.lower\n\t\t\t\t\t){\n\t\t\t\t\t\t// any error --- remove from/to bounds\n\t\t\t\t\t\tdelete o.from;\n\t\t\t\t\t\tdelete o.to;\n\t\t\t\t\t\tdelete this.scale;\n\t\t\t\t\t\tdelete this.offset;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// shift the window, if we are out of bounds\n\t\t\t\t\t\tif(o.from < tsb.lower){\n\t\t\t\t\t\t\to.to += tsb.lower - o.from;\n\t\t\t\t\t\t\to.from = tsb.lower;\n\t\t\t\t\t\t}else if(o.to > tsb.upper){\n\t\t\t\t\t\t\to.from += tsb.upper - o.to;\n\t\t\t\t\t\t\to.to = tsb.upper;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// update the offset\n\t\t\t\t\t\tthis.offset = o.from - tsb.lower;\n\t\t\t\t\t}\n\t\t\t\t\t// re-calculate the scaler\n\t\t\t\t\tthis.scaler = (scalerType || lin).buildScaler(min, max, span, o);\n\t\t\t\t\ttsb = this.scaler.bounds;\n\t\t\t\t\t// cleanup\n\t\t\t\t\tif(this.scale == 1 && this.offset == 0){\n\t\t\t\t\t\tdelete this.scale;\n\t\t\t\t\t\tdelete this.offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Invisible\n\t\t\t},\n\t\t\tgetScaler: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the pre-calculated scaler object.\n\t\t\t\treturn this.scaler;\t//\tObject\n\t\t\t},\n\t\t\tgetTicks: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet the pre-calculated ticks object.\n\t\t\t\treturn this.ticks;\t//\tObject\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 204 */\n/*!****************************************!*\\\n  !*** ../dojox/charting/axis2d/Base.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ../Element */ 183)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Element){\n\t\t/*=====\n\t\tvar __BaseAxisCtorArgs = {\n\t\t\t// summary:\n\t\t\t//\t\tOptional arguments used in the definition of an invisible axis.\n\t\t\t// vertical: Boolean?\n\t\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t\t// min: Number?\n\t\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t\t// max: Number?\n\t\t\t//\t\tThe largest value on an axis. Default is 1.\n\t\t};\n\t\t=====*/\n\t\treturn declare(\"dojox.charting.axis2d.Base\", Element, {\n\t\t\t// summary:\n\t\t\t//\t\tThe base class for any axis.  This is more of an interface/API\n\t\t\t//\t\tdefinition than anything else; see dojox.charting.axis2d.Default\n\t\t\t//\t\tfor more details.\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturn a new base axis.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this axis belongs to.\n\t\t\t\t// kwArgs: __BaseAxisCtorArgs?\n\t\t\t\t//\t\tAn optional arguments object to define the axis parameters.\n\t\t\t\tthis.vertical = kwArgs && kwArgs.vertical;\n\t\t\t\tthis.opt = {};\n\t\t\t\tthis.opt.min = kwArgs && kwArgs.min;\n\t\t\t\tthis.opt.max = kwArgs && kwArgs.max;\n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tStub function for clearing the axis.\n\t\t\t\t// returns: dojox/charting/axis2d/Base\n\t\t\t\t//\t\tA reference to the axis for functional chaining.\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Base\n\t\t\t},\n\t\t\tinitialized: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturn a flag as to whether or not this axis has been initialized.\n\t\t\t\t// returns: Boolean\n\t\t\t\t//\t\tIf the axis is initialized or not.\n\t\t\t\treturn false;\t//\tBoolean\n\t\t\t},\n\t\t\tcalculate: function(min, max, span){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tStub function to run the calculations needed for drawing this axis.\n\t\t\t\t// returns: dojox/charting/axis2d/Base\n\t\t\t\t//\t\tA reference to the axis for functional chaining.\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Base\n\t\t\t},\n\t\t\tgetScaler: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tA stub function to return the scaler object created during calculate.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tThe scaler object (see dojox.charting.scaler.linear for more information)\n\t\t\t\treturn null;\t//\tObject\n\t\t\t},\n\t\t\tgetTicks: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tA stub function to return the object that helps define how ticks are rendered.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tThe ticks object.\n\t\t\t\treturn null;\t//\tObject\n\t\t\t},\n\t\t\tgetOffsets: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tA stub function to return any offsets needed for axis and series rendering.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\treturn {l: 0, r: 0, t: 0, b: 0};\t//\tObject\n\t\t\t},\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tStub function to render this axis.\n\t\t\t\t// returns: dojox/charting/axis2d/Base\n\t\t\t\t//\t\tA reference to the axis for functional chaining.\n\t\t\t\tthis.dirty = false;\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Base\n\t\t\t},\n\t\t\tisNullValue: function(value){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tA stub function to determine a data value\n\t\t\t\t//\t\tthat should be ignored.\n\t\t\t\t// value: Number|Null|Object\n\t\t\t\t//\t\tA data value to be inspected.\n\t\t\t\t// returns: Boolean\n\t\t\t\t//\t\tIf the value makes sense for this axis or not.\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tnaturalBaseline: 0\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 205 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/scaler/linear.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./common */ 180)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, common){\n\t\tvar linear = lang.getObject(\"dojox.charting.scaler.linear\", true);\n\t\t\n\t\tvar deltaLimit = 3,\t// pixels\n\t\t\tgetLabel = common.getNumericLabel;\n\t\n\t\t\tfunction findString(/*String*/ val, /*Array*/ text){\n\t\t\t\tval = val.toLowerCase();\n\t\t\t\tfor(var i = text.length - 1; i >= 0; --i){\n\t\t\t\t\tif(val === text[i]){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\n\t\tvar calcTicks = function(min, max, kwArgs, majorTick, minorTick, microTick, span){\n\t\t\tkwArgs = lang.delegate(kwArgs);\n\t\t\tif(!majorTick){\n\t\t\t\tif(kwArgs.fixUpper == \"major\"){ kwArgs.fixUpper = \"minor\"; }\n\t\t\t\tif(kwArgs.fixLower == \"major\"){ kwArgs.fixLower = \"minor\"; }\n\t\t\t}\n\t\t\tif(!minorTick){\n\t\t\t\tif(kwArgs.fixUpper == \"minor\"){ kwArgs.fixUpper = \"micro\"; }\n\t\t\t\tif(kwArgs.fixLower == \"minor\"){ kwArgs.fixLower = \"micro\"; }\n\t\t\t}\n\t\t\tif(!microTick){\n\t\t\t\tif(kwArgs.fixUpper == \"micro\"){ kwArgs.fixUpper = \"none\"; }\n\t\t\t\tif(kwArgs.fixLower == \"micro\"){ kwArgs.fixLower = \"none\"; }\n\t\t\t}\n\t\t\tvar lowerBound = findString(kwArgs.fixLower, [\"major\"]) ?\n\t\t\t\t\tMath.floor(kwArgs.min / majorTick) * majorTick :\n\t\t\t\t\t\tfindString(kwArgs.fixLower, [\"minor\"]) ?\n\t\t\t\t\t\t\tMath.floor(kwArgs.min / minorTick) * minorTick :\n\t\t\t\t\t\t\t\tfindString(kwArgs.fixLower, [\"micro\"]) ?\n\t\t\t\t\t\t\t\t\tMath.floor(kwArgs.min / microTick) * microTick : kwArgs.min,\n\t\t\t\tupperBound = findString(kwArgs.fixUpper, [\"major\"]) ?\n\t\t\t\t\tMath.ceil(kwArgs.max / majorTick) * majorTick :\n\t\t\t\t\t\tfindString(kwArgs.fixUpper, [\"minor\"]) ?\n\t\t\t\t\t\t\tMath.ceil(kwArgs.max / minorTick) * minorTick :\n\t\t\t\t\t\t\t\tfindString(kwArgs.fixUpper, [\"micro\"]) ?\n\t\t\t\t\t\t\t\t\tMath.ceil(kwArgs.max / microTick) * microTick : kwArgs.max;\n\t\t\t\t\t\t\t\t\t\n\t\t\tif(kwArgs.useMin){ min = lowerBound; }\n\t\t\tif(kwArgs.useMax){ max = upperBound; }\n\t\t\t\n\t\t\tvar majorStart = (!majorTick || kwArgs.useMin && findString(kwArgs.fixLower, [\"major\"])) ?\n\t\t\t\t\tmin : Math.ceil(min / majorTick) * majorTick,\n\t\t\t\tminorStart = (!minorTick || kwArgs.useMin && findString(kwArgs.fixLower, [\"major\", \"minor\"])) ?\n\t\t\t\t\tmin : Math.ceil(min / minorTick) * minorTick,\n\t\t\t\tmicroStart = (! microTick || kwArgs.useMin && findString(kwArgs.fixLower, [\"major\", \"minor\", \"micro\"])) ?\n\t\t\t\t\tmin : Math.ceil(min / microTick) * microTick,\n\t\t\t\tmajorCount = !majorTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, [\"major\"]) ?\n\t\t\t\t\tMath.round((max - majorStart) / majorTick) :\n\t\t\t\t\tMath.floor((max - majorStart) / majorTick)) + 1,\n\t\t\t\tminorCount = !minorTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, [\"major\", \"minor\"]) ?\n\t\t\t\t\tMath.round((max - minorStart) / minorTick) :\n\t\t\t\t\tMath.floor((max - minorStart) / minorTick)) + 1,\n\t\t\t\tmicroCount = !microTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, [\"major\", \"minor\", \"micro\"]) ?\n\t\t\t\t\tMath.round((max - microStart) / microTick) :\n\t\t\t\t\tMath.floor((max - microStart) / microTick)) + 1,\n\t\t\t\tminorPerMajor  = minorTick ? Math.round(majorTick / minorTick) : 0,\n\t\t\t\tmicroPerMinor  = microTick ? Math.round(minorTick / microTick) : 0,\n\t\t\t\tmajorPrecision = majorTick ? Math.floor(Math.log(majorTick) / Math.LN10) : 0,\n\t\t\t\tminorPrecision = minorTick ? Math.floor(Math.log(minorTick) / Math.LN10) : 0,\n\t\t\t\tscale = span / (max - min);\n\t\t\tif(!isFinite(scale)){ scale = 1; }\n\t\t\t\n\t\t\treturn {\n\t\t\t\tbounds: {\n\t\t\t\t\tlower:\tlowerBound,\n\t\t\t\t\tupper:\tupperBound,\n\t\t\t\t\tfrom:\tmin,\n\t\t\t\t\tto:\t\tmax,\n\t\t\t\t\tscale:\tscale,\n\t\t\t\t\tspan:\tspan\n\t\t\t\t},\n\t\t\t\tmajor: {\n\t\t\t\t\ttick:\tmajorTick,\n\t\t\t\t\tstart:\tmajorStart,\n\t\t\t\t\tcount:\tmajorCount,\n\t\t\t\t\tprec:\tmajorPrecision\n\t\t\t\t},\n\t\t\t\tminor: {\n\t\t\t\t\ttick:\tminorTick,\n\t\t\t\t\tstart:\tminorStart,\n\t\t\t\t\tcount:\tminorCount,\n\t\t\t\t\tprec:\tminorPrecision\n\t\t\t\t},\n\t\t\t\tmicro: {\n\t\t\t\t\ttick:\tmicroTick,\n\t\t\t\t\tstart:\tmicroStart,\n\t\t\t\t\tcount:\tmicroCount,\n\t\t\t\t\tprec:\t0\n\t\t\t\t},\n\t\t\t\tminorPerMajor:\tminorPerMajor,\n\t\t\t\tmicroPerMinor:\tmicroPerMinor,\n\t\t\t\tscaler:\t\t\tlinear\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn lang.mixin(linear, {\n\t\t\tbuildScaler: function(/*Number*/ min, /*Number*/ max, /*Number*/ span, /*Object*/ kwArgs, /*Number?*/ delta, /*Number?*/ minorDelta){\n\t\t\t\tvar h = {fixUpper: \"none\", fixLower: \"none\", natural: false};\n\t\t\t\tif(kwArgs){\n\t\t\t\t\tif(\"fixUpper\" in kwArgs){ h.fixUpper = String(kwArgs.fixUpper); }\n\t\t\t\t\tif(\"fixLower\" in kwArgs){ h.fixLower = String(kwArgs.fixLower); }\n\t\t\t\t\tif(\"natural\"  in kwArgs){ h.natural  = Boolean(kwArgs.natural); }\n\t\t\t\t}\n\t\t\t\tminorDelta = !minorDelta || minorDelta < deltaLimit ? deltaLimit : minorDelta;\n\t\t\t\t\n\t\t\t\t// update bounds\n\t\t\t\tif(\"min\" in kwArgs){ min = kwArgs.min; }\n\t\t\t\tif(\"max\" in kwArgs){ max = kwArgs.max; }\n\t\t\t\tif(kwArgs.includeZero){\n\t\t\t\t\tif(min > 0){ min = 0; }\n\t\t\t\t\tif(max < 0){ max = 0; }\n\t\t\t\t}\n\t\t\t\th.min = min;\n\t\t\t\th.useMin = true;\n\t\t\t\th.max = max;\n\t\t\t\th.useMax = true;\n\t\t\t\t\n\t\t\t\tif(\"from\" in kwArgs){\n\t\t\t\t\tmin = kwArgs.from;\n\t\t\t\t\th.useMin = false;\n\t\t\t\t}\n\t\t\t\tif(\"to\" in kwArgs){\n\t\t\t\t\tmax = kwArgs.to;\n\t\t\t\t\th.useMax = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// check for erroneous condition\n\t\t\t\tif(max <= min){\n\t\t\t\t\treturn calcTicks(min, max, h, 0, 0, 0, span);\t// Object\n\t\t\t\t}\n\t\t\t\tif(!delta){\n\t\t\t\t\tdelta = max - min;\n\t\t\t\t}\n\t\t\t\tvar mag = Math.floor(Math.log(delta) / Math.LN10),\n\t\t\t\t\tmajor = kwArgs && (\"majorTickStep\" in kwArgs) ? kwArgs.majorTickStep : Math.pow(10, mag),\n\t\t\t\t\tminor = 0, micro = 0, ticks;\n\t\t\t\t\t\n\t\t\t\t// calculate minor ticks\n\t\t\t\tif(kwArgs && (\"minorTickStep\" in kwArgs)){\n\t\t\t\t\tminor = kwArgs.minorTickStep;\n\t\t\t\t}else{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tminor = major / 10;\n\t\t\t\t\t\tif(!h.natural || minor > 0.9){\n\t\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, 0, span);\n\t\t\t\t\t\t\tif(ticks.bounds.scale * ticks.minor.tick > minorDelta){ break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminor = major / 5;\n\t\t\t\t\t\tif(!h.natural || minor > 0.9){\n\t\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, 0, span);\n\t\t\t\t\t\t\tif(ticks.bounds.scale * ticks.minor.tick > minorDelta){ break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminor = major / 2;\n\t\t\t\t\t\tif(!h.natural || minor > 0.9){\n\t\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, 0, span);\n\t\t\t\t\t\t\tif(ticks.bounds.scale * ticks.minor.tick > minorDelta){ break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn calcTicks(min, max, h, major, 0, 0, span);\t// Object\n\t\t\t\t\t}while(false);\n\t\t\t\t}\n\t\t\n\t\t\t\t// calculate micro ticks\n\t\t\t\tif(kwArgs && (\"microTickStep\" in kwArgs)){\n\t\t\t\t\tmicro = kwArgs.microTickStep;\n\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t}else{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tmicro = minor / 10;\n\t\t\t\t\t\tif(!h.natural || micro > 0.9){\n\t\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t\t\t\tif(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmicro = minor / 5;\n\t\t\t\t\t\tif(!h.natural || micro > 0.9){\n\t\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t\t\t\tif(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmicro = minor / 2;\n\t\t\t\t\t\tif(!h.natural || micro > 0.9){\n\t\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t\t\t\tif(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmicro = 0;\n\t\t\t\t\t}while(false);\n\t\t\t\t}\n\t\t\n\t\t\t\treturn micro ? ticks : calcTicks(min, max, h, major, minor, 0, span);\t// Object\n\t\t\t},\n\t\t\tbuildTicks: function(/*Object*/ scaler, /*Object*/ kwArgs){\n\t\t\t\tvar step, next, tick,\n\t\t\t\t\tnextMajor = scaler.major.start,\n\t\t\t\t\tnextMinor = scaler.minor.start,\n\t\t\t\t\tnextMicro = scaler.micro.start;\n\t\t\t\tif(kwArgs.microTicks && scaler.micro.tick){\n\t\t\t\t\tstep = scaler.micro.tick, next = nextMicro;\n\t\t\t\t}else if(kwArgs.minorTicks && scaler.minor.tick){\n\t\t\t\t\tstep = scaler.minor.tick, next = nextMinor;\n\t\t\t\t}else if(scaler.major.tick){\n\t\t\t\t\tstep = scaler.major.tick, next = nextMajor;\n\t\t\t\t}else{\n\t\t\t\t\t// no ticks\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// make sure that we have finite bounds\n\t\t\t\tvar revScale = 1 / scaler.bounds.scale;\n\t\t\t\tif(scaler.bounds.to <= scaler.bounds.from || isNaN(revScale) || !isFinite(revScale) ||\n\t\t\t\t\t\tstep <= 0 || isNaN(step) || !isFinite(step)){\n\t\t\t\t\t// no ticks\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// loop over all ticks\n\t\t\t\tvar majorTicks = [], minorTicks = [], microTicks = [];\n\t\t\t\twhile(next <= scaler.bounds.to + revScale){\n\t\t\t\t\tif(Math.abs(nextMajor - next) < step / 2){\n\t\t\t\t\t\t// major tick\n\t\t\t\t\t\ttick = {value: nextMajor};\n\t\t\t\t\t\tif(kwArgs.majorLabels){\n\t\t\t\t\t\t\ttick.label = getLabel(nextMajor, scaler.major.prec, kwArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmajorTicks.push(tick);\n\t\t\t\t\t\tnextMajor += scaler.major.tick;\n\t\t\t\t\t\tnextMinor += scaler.minor.tick;\n\t\t\t\t\t\tnextMicro += scaler.micro.tick;\n\t\t\t\t\t}else if(Math.abs(nextMinor - next) < step / 2){\n\t\t\t\t\t\t// minor tick\n\t\t\t\t\t\tif(kwArgs.minorTicks){\n\t\t\t\t\t\t\ttick = {value: nextMinor};\n\t\t\t\t\t\t\tif(kwArgs.minorLabels && (scaler.minMinorStep <= scaler.minor.tick * scaler.bounds.scale)){\n\t\t\t\t\t\t\t\ttick.label = getLabel(nextMinor, scaler.minor.prec, kwArgs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tminorTicks.push(tick);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextMinor += scaler.minor.tick;\n\t\t\t\t\t\tnextMicro += scaler.micro.tick;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// micro tick\n\t\t\t\t\t\tif(kwArgs.microTicks){\n\t\t\t\t\t\t\tmicroTicks.push({value: nextMicro});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextMicro += scaler.micro.tick;\n\t\t\t\t\t}\n\t\t\t\t\tnext += step;\n\t\t\t\t}\n\t\t\t\treturn {major: majorTicks, minor: minorTicks, micro: microTicks};\t// Object\n\t\t\t},\n\t\t\tgetTransformerFromModel: function(/*Object*/ scaler){\n\t\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\t\treturn function(x){ return (x - offset) * scale; };\t// Function\n\t\t\t},\n\t\t\tgetTransformerFromPlot: function(/*Object*/ scaler){\n\t\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\t\treturn function(x){ return x / scale + offset; };\t// Function\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 206 */\n/*!************************************************!*\\\n  !*** ../dojox/charting/bidi/axis2d/Default.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/dom-style */ 37)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, domStyle){\n\t\t// module:\n\t\t//\t\tdojox/charting/bidi/axis2d/Default\t\t\t\n\t\treturn declare(null, {\n\t\t\tlabelTooltip: function(elem, chart, label, truncatedLabel, font, elemType){\n\t\t\t\t// additional preprocessing of the labels, needed for rtl base text direction in LTR\n\t\t\t\t// GUI, or for ltr base text direction for RTL GUI.\n\t\n\t\t\t\tvar isChartDirectionRtl = (domStyle.get(chart.node,\"direction\") == \"rtl\");\n\t\t\t\tvar isBaseTextDirRtl = (chart.getTextDir(label) == \"rtl\");\n\t\n\t\t\t\tif(isBaseTextDirRtl && !isChartDirectionRtl){\n\t\t\t\t\tlabel = \"<span dir='rtl'>\" + label +\"</span>\";\n\t\t\t\t}\n\t\t\t\tif(!isBaseTextDirRtl && isChartDirectionRtl){\n\t\t\t\t\tlabel = \"<span dir='ltr'>\" + label +\"</span>\";\n\t\t\t\t}\n\t\t\t\tthis.inherited(arguments);\n\t\t\t},\n\t\t\t\n\t\t\t_isRtl: function(){\n\t\t\t\treturn this.chart.isRightToLeft();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\n\n/***/ },\n/* 207 */\n/*!*****************************************!*\\\n  !*** ../dojox/charting/plot2d/Lines.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Default */ 164)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Default){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Lines\", Default, {\n\t\t\t// summary:\n\t\t\t//\t\tA convenience constructor to create a typical line chart.\n\t\t\tconstructor: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tPreset our default plot to be line-based.\n\t\t\t\tthis.opt.lines = true;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 208 */\n/*!*****************************************!*\\\n  !*** ../dojox/charting/plot2d/Areas.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Default */ 164)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Default){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Areas\", Default, {\n\t\t\t// summary:\n\t\t\t//\t\tRepresents an area chart.  See dojox/charting/plot2d/Default for details.\n\t\t\tconstructor: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for an Area chart.\n\t\t\t\tthis.opt.lines = true;\n\t\t\t\tthis.opt.areas = true;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 209 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/plot2d/Markers.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Default */ 164)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Default){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Markers\", Default, {\n\t\t\t// summary:\n\t\t\t//\t\tA convenience plot to draw a line chart with markers.\n\t\t\tconstructor: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet up the plot for lines and markers.\n\t\t\t\tthis.opt.markers = true;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 210 */\n/*!***********************************************!*\\\n  !*** ../dojox/charting/plot2d/MarkersOnly.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Default */ 164)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Default){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.MarkersOnly\", Default, {\n\t\t\t// summary:\n\t\t\t//\t\tA convenience object to draw only markers (like a scatter but not quite).\n\t\t\tconstructor: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tSet up our default plot to only have markers and no lines.\n\t\t\t\tthis.opt.lines   = false;\n\t\t\t\tthis.opt.markers = true;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 211 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/plot2d/Scatter.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/has */ 5), __webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165),\n\t\t__webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186), __webpack_require__(/*! dojox/gfx/gradutils */ 193)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx, gradutils){\n\t\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Scatter\", [CartesianBase, _PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tA plot object representing a typical scatter chart.\n\t\t\tdefaultParams: {\n\t\t\t\tshadows: null,\t// draw shadows\n\t\t\t\tanimate: null\t// animate chart to place\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\t// theme component\n\t\t\t\tmarkerStroke:\t\t{},\n\t\t\t\tmarkerOutline:\t\t{},\n\t\t\t\tmarkerShadow:\t\t{},\n\t\t\t\tmarkerFill:\t\t\t{},\n\t\t\t\tmarkerFont:\t\t\t\"\",\n\t\t\t\tmarkerFontColor:\t\"\",\n\t\t\t\tstyleFunc:\t\t\tnull\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate the scatter plot.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define this plot's parameters.\n\t\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t},\n\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t\t// returns: dojox/charting/plot2d/Scatter\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tvar s;\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\ts = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\t\t\tvar t = this.chart.theme, events = this.events();\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tif(!run.data.length){\n\t\t\t\t\t\trun.dirty = false;\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar theme = t.next(\"marker\", [this.opt, run]), lpoly,\n\t\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler);\n\t\t\t\t\tif(run.hidden){\n\t\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\t\trun.dyn.markerFill = theme.marker.fill;\n\t\t\t\t\t\trun.dyn.markerStroke = theme.marker.stroke;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ts = run.group;\n\t\t\t\t\tif(typeof run.data[0] == \"number\"){\n\t\t\t\t\t\tlpoly = arr.map(run.data, function(v, i){\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tx: ht(i + 1) + offsets.l,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlpoly = arr.map(run.data, function(v, i){\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowMarkers  = new Array(lpoly.length),\n\t\t\t\t\t\tfrontMarkers   = new Array(lpoly.length),\n\t\t\t\t\t\toutlineMarkers = new Array(lpoly.length);\n\t\n\t\t\t\t\tarr.forEach(lpoly, function(c, i){\n\t\t\t\t\t\tvar value = run.data[i], finalTheme;\n\t\t\t\t\t\tif(this.opt.styleFunc || typeof value != \"number\"){\n\t\t\t\t\t\t\tvar tMixin = typeof value != \"number\" ? [value] : [];\n\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinalTheme = t.addMixin(theme, \"marker\", tMixin, true);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinalTheme = t.post(theme, \"marker\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = \"M\" + c.x + \" \" + c.y + \" \" + finalTheme.symbol;\n\t\t\t\t\t\tif(finalTheme.marker.shadow){\n\t\t\t\t\t\t\tshadowMarkers[i] = s.createPath(\"M\" + (c.x + finalTheme.marker.shadow.dx) + \" \" +\n\t\t\t\t\t\t\t\t(c.y + finalTheme.marker.shadow.dy) + \" \" + finalTheme.symbol).\n\t\t\t\t\t\t\t\tsetStroke(finalTheme.marker.shadow).setFill(finalTheme.marker.shadow.color);\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateScatter(shadowMarkers[i], dim.height - offsets.b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(finalTheme.marker.outline){\n\t\t\t\t\t\t\tvar outline = dc.makeStroke(finalTheme.marker.outline);\n\t\t\t\t\t\t\toutline.width = 2 * outline.width + (finalTheme.marker.stroke && finalTheme.marker.stroke.width || 0);\n\t\t\t\t\t\t\toutlineMarkers[i] = s.createPath(path).setStroke(outline);\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateScatter(outlineMarkers[i], dim.height - offsets.b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar stroke = dc.makeStroke(finalTheme.marker.stroke),\n\t\t\t\t\t\t\tfill = this._plotFill(finalTheme.marker.fill, dim, offsets);\n\t\t\t\t\t\tif(fill && (fill.type === \"linear\" || fill.type == \"radial\")){\n\t\t\t\t\t\t\tvar color = gradutils.getColor(fill, {x: c.x, y: c.y});\n\t\t\t\t\t\t\tif(stroke){\n\t\t\t\t\t\t\t\tstroke.color = color;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfrontMarkers[i] = s.createPath(path).setStroke(stroke).setFill(color);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfrontMarkers[i] = s.createPath(path).setStroke(stroke).setFill(fill);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.labels){\n\t\t\t\t\t\t\tvar markerBox = frontMarkers[i].getBoundingBox();\n\t\t\t\t\t\t\tthis.createLabel(s, value, markerBox, finalTheme);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateScatter(frontMarkers[i], dim.height - offsets.b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t\tif(frontMarkers.length){\n\t\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\t\trun.dyn.markerStroke = frontMarkers[frontMarkers.length - 1].getStroke();\n\t\t\t\t\t\trun.dyn.markerFill   = frontMarkers[frontMarkers.length - 1].getFill();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif(events){\n\t\t\t\t\t\tvar eventSeries = new Array(frontMarkers.length);\n\t\t\t\t\t\tarr.forEach(frontMarkers, function(s, i){\n\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\telement: \"marker\",\n\t\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\tshape:   s,\n\t\t\t\t\t\t\t\toutline: outlineMarkers && outlineMarkers[i] || null,\n\t\t\t\t\t\t\t\tshadow:  shadowMarkers && shadowMarkers[i] || null,\n\t\t\t\t\t\t\t\tcx:      lpoly[i].x,\n\t\t\t\t\t\t\t\tcy:      lpoly[i].y\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif(typeof run.data[0] == \"number\"){\n\t\t\t\t\t\t\t\to.x = i + 1;\n\t\t\t\t\t\t\t\to.y = run.data[i];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\to.x = run.data[i].x;\n\t\t\t\t\t\t\t\to.y = run.data[i].y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdelete this._eventSeries[run.name];\n\t\t\t\t\t}\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Scatter\n\t\t\t},\n\t\t\t_animateScatter: function(shape, offset){\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: [0, offset], end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: [0, 0], end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 212 */\n/*!************************************************!*\\\n  !*** ../dojox/charting/plot2d/StackedLines.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! ./Stacked */ 163)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Stacked){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.StackedLines\", Stacked, {\n\t\t\t// summary:\n\t\t\t//\t\tA convenience object to create a stacked line chart.\n\t\t\tconstructor: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tForce our Stacked base to be lines only.\n\t\t\t\tthis.opt.lines = true;\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 213 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/plot2d/Columns.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/has */ 5), __webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165),\n\t\t\t__webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\t\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\t\tvar alwaysFalse = function(){ return false; };\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Columns\", [CartesianBase, _PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tThe plot object representing a column chart (vertical bars).\n\t\t\tdefaultParams: {\n\t\t\t\tgap:\t0,\t\t// gap between columns in pixels\n\t\t\t\tanimate: null,  // animate bars into place\n\t\t\t\tenableCache: false\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tminBarSize:\t1,\t// minimal column width in pixels\n\t\t\t\tmaxBarSize:\t1,\t// maximal column width in pixels\n\t\t\t\t// theme component\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfilter:     {},\n\t\t\t\tstyleFunc:  null,\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\"\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for a columns chart.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t\tthis.renderingOptions = { \"shape-rendering\": \"crispEdges\" };\n\t\t\t},\n\t\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = dc.collectSimpleStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\t\tstats.hmin -= 0.5;\n\t\t\t\tstats.hmax += 0.5;\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\n\t\t\tcreateRect: function(run, creator, params){\n\t\t\t\tvar rect;\n\t\t\t\tif(this.opt.enableCache && run._rectFreePool.length > 0){\n\t\t\t\t\trect = run._rectFreePool.pop();\n\t\t\t\t\trect.setShape(params);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(rect);\n\t\t\t\t}else{\n\t\t\t\t\trect = creator.createRect(params);\n\t\t\t\t}\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\trun._rectUsePool.push(rect);\n\t\t\t\t}\n\t\t\t\treturn rect;\n\t\t\t},\n\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t\t// returns: dojox/charting/plot2d/Columns\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tvar s;\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\ts = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\t\t\tvar t = this.chart.theme,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\tbaseline = Math.max(this._vScaler.bounds.lower,\n\t\t\t\t\t\tthis._vAxis ? this._vAxis.naturalBaseline : 0),\n\t\t\t\t\tbaselineHeight = vt(baseline),\n\t\t\t\t\tevents = this.events(),\n\t\t\t\t\tbar = this.getBarProperties();\n\t\n\t\t\t\tvar z = this.series.length;\n\t\t\t\tarr.forEach(this.series, function(serie){if(serie.hidden){z--;}});\n\t\n\t\t\t\t// Collect and calculate  all values\n\t\t\t\tvar extractedValues = this.extractValues(this._hScaler);\n\t\t\t\textractedValues = this.rearrangeValues(extractedValues, vt, baselineHeight);\n\t\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\t\trun._rectFreePool = (run._rectFreePool?run._rectFreePool:[]).concat(run._rectUsePool?run._rectUsePool:[]);\n\t\t\t\t\t\trun._rectUsePool = [];\n\t\t\t\t\t}\n\t\t\t\t\tvar theme = t.next(\"column\", [this.opt, run]),\n\t\t\t\t\t\teventSeries = new Array(run.data.length);\n\t\n\t\t\t\t\tif(run.hidden){\n\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tz--;\n\t\n\t\t\t\t\ts = run.group;\n\t\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t});\n\t\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t\t// data point to save time\n\t\t\t\t\tvar min = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0;\n\t\t\t\t\tvar max = indexed?Math.min(run.data.length, Math.ceil(this._hScaler.bounds.to)):run.data.length;\n\t\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\t\tif(!this.isNullValue(value)){\n\t\t\t\t\t\t\tvar val = this.getValue(value, j, i, indexed),\n\t\t\t\t\t\t\t\tvv = vt(val.y),\n\t\t\t\t\t\t\t\th = extractedValues[i][j],\n\t\t\t\t\t\t\t\tfinalTheme,\n\t\t\t\t\t\t\t\tsshape;\n\t\n\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof value != \"number\"){\n\t\t\t\t\t\t\t\tvar tMixin = typeof value != \"number\" ? [value] : [];\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(value));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfinalTheme = t.addMixin(theme, \"column\", tMixin, true);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinalTheme = t.post(theme, \"column\");\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif(bar.width >= 1){\n\t\t\t\t\t\t\t\tvar rect = {\n\t\t\t\t\t\t\t\t\tx: offsets.l + ht(val.x + 0.5) + bar.gap + bar.thickness * z,\n\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - baselineHeight - Math.max(h, 0),\n\t\t\t\t\t\t\t\t\twidth: bar.width,\n\t\t\t\t\t\t\t\t\theight: Math.abs(h)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif(finalTheme.series.shadow){\n\t\t\t\t\t\t\t\t\tvar srect = lang.clone(rect);\n\t\t\t\t\t\t\t\t\tsrect.x += finalTheme.series.shadow.dx;\n\t\t\t\t\t\t\t\t\tsrect.y += finalTheme.series.shadow.dy;\n\t\t\t\t\t\t\t\t\tsshape = this.createRect(run, s, srect).setFill(finalTheme.series.shadow.color).setStroke(finalTheme.series.shadow);\n\t\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\t\tthis._animateColumn(sshape, dim.height - offsets.b + baselineHeight, h);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvar specialFill = this._plotFill(finalTheme.series.fill, dim, offsets);\n\t\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, rect);\n\t\t\t\t\t\t\t\tvar shape = this.createRect(run, s, rect).setFill(specialFill).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\t\tthis.overrideShape(shape, {index: j, value: val});\n\t\t\t\t\t\t\t\tif(shape.setFilter && finalTheme.series.filter){\n\t\t\t\t\t\t\t\t\tshape.setFilter(finalTheme.series.filter);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trun.dyn.fill   = shape.getFill();\n\t\t\t\t\t\t\t\trun.dyn.stroke = shape.getStroke();\n\t\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\t\telement: \"column\",\n\t\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\t\t\t\tshadow:  sshape,\n\t\t\t\t\t\t\t\t\t\tcx:      val.x + 0.5,\n\t\t\t\t\t\t\t\t\t\tcy:      val.y,\n\t\t\t\t\t\t\t\t\t\tx:\t     indexed?j:run.data[j].x,\n\t\t\t\t\t\t\t\t\t\ty:\t \t indexed?run.data[j]:run.data[j].y\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// if val.py is here, this means we are stacking and we need to subtract previous\n\t\t\t\t\t\t\t\t// value to get the high in which we will lay out the label\n\t\t\t\t\t\t\t\tif(!isNaN(val.py) && val.py > baseline){\n\t\t\t\t\t\t\t\t\trect.height = h - vt(val.py);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.createLabel(s, value, rect, finalTheme);\n\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\tthis._animateColumn(shape, dim.height - offsets.b - baselineHeight, h);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Columns\n\t\t\t},\n\t\t\tgetValue: function(value, j, seriesIndex, indexed){\n\t\t\t\tvar y,x;\n\t\t\t\tif(indexed){\n\t\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\t\ty = value;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ty = value.y;\n\t\t\t\t\t}\n\t\t\t\t\tx = j;\n\t\t\t\t}else{\n\t\t\t\t\ty = value.y;\n\t\t\t\t\tx = value.x - 1;\n\t\t\t\t}\n\t\t\t\treturn { x: x, y: y };\n\t\t\t},\n\t\t\textractValues: function(scaler){\n\t\t\t\tvar extracted = [];\n\t\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t\t// data point to save time\n\t\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tmin = indexed ? Math.max(0, Math.floor(scaler.bounds.from - 1)) : 0,\n\t\t\t\t\t\tmax = indexed ? Math.min(run.data.length, Math.ceil(scaler.bounds.to)) : run.data.length,\n\t\t\t\t\t\textractedSet = extracted[i] = [];\n\t\t\t\t\textractedSet.min = min;\n\t\t\t\t\textractedSet.max = max;\n\t\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 :\n\t\t\t\t\t\t\t(typeof value == \"number\" ? value : value.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn extracted;\n\t\t\t},\n\t\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t\t// transform to pixels\n\t\t\t\tfor(var i = 0, n = values.length; i < n; ++i){\n\t\t\t\t\tvar extractedSet = values[i];\n\t\t\t\t\tif(extractedSet){\n\t\t\t\t\t\tfor(var j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\t\tvar value = extractedSet[j];\n\t\t\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 : transform(value) - baseline;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t},\n\t\n\t\t\tisNullValue: function(value){\n\t\t\t\tif(value === null || typeof value == \"undefined\"){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar h = this._hAxis ? this._hAxis.isNullValue : alwaysFalse,\n\t\t\t\t\tv = this._vAxis ? this._vAxis.isNullValue : alwaysFalse;\n\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\treturn v(0.5) || h(value);\n\t\t\t\t}\n\t\t\t\treturn v(isNaN(value.x) ? 0.5 : value.x + 0.5) || value.y === null || h(value.y);\n\t\t\t},\n\t\t\tgetBarProperties: function(){\n\t\t\t\tvar f = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt);\n\t\t\t\treturn {gap: f.gap, width: f.size, thickness: 0};\n\t\t\t},\n\t\t\t_animateColumn: function(shape, voffset, vsize){\n\t\t\t\tif(vsize===0){\n\t\t\t\t\tvsize = 1;\n\t\t\t\t}\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: [0, voffset - (voffset/vsize)], end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: [1, 1/vsize], end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 214 */\n/*!**************************************************!*\\\n  !*** ../dojox/charting/plot2d/StackedColumns.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./Columns */ 213), __webpack_require__(/*! ./commonStacked */ 190)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, lang, Columns, commonStacked){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.StackedColumns\", Columns, {\n\t\t\t// summary:\n\t\t\t//\t\tThe plot object representing a stacked column chart (vertical bars).\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = commonStacked.collectStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\t\tstats.hmin -= 0.5;\n\t\t\t\tstats.hmax += 0.5;\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\n\t\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t\treturn commonStacked.rearrangeValues.call(this, values, transform, baseline);\n\t \t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 215 */\n/*!****************************************************!*\\\n  !*** ../dojox/charting/plot2d/ClusteredColumns.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! ./Columns */ 213), __webpack_require__(/*! ./common */ 165)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, array, Columns, dc){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.ClusteredColumns\", Columns, {\n\t\t\t// summary:\n\t\t\t//\t\tA plot representing grouped or clustered columns (vertical bars)\n\t\t\tgetBarProperties: function(){\n\t\t\t\tvar length = this.series.length;\n\t\t\t\tarray.forEach(this.series, function(serie){if(serie.hidden){length--;}});\n\t\t\t\tvar f = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt, length);\n\t\t\t\treturn {gap: f.gap, width: f.size, thickness: f.size, clusterSize: length};\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 216 */\n/*!****************************************!*\\\n  !*** ../dojox/charting/plot2d/Bars.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/has */ 5), __webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165),\n\t\t__webpack_require__(/*! dojox/gfx/fx */ 186), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, fx, du, df, dfr){\n\t\t\t\n\t\t/*=====\n\t\tdeclare(\"dojox.charting.plot2d.__BarCtorArgs\", dojox.charting.plot2d.__DefaultCtorArgs, {\n\t\t\t// summary:\n\t\t\t//\t\tAdditional keyword arguments for bar charts.\n\t\t\n\t\t\t// minBarSize: Number?\n\t\t\t//\t\tThe minimum size for a bar in pixels.  Default is 1.\n\t\t\tminBarSize: 1,\n\t\t\n\t\t\t// maxBarSize: Number?\n\t\t\t//\t\tThe maximum size for a bar in pixels.  Default is 1.\n\t\t\tmaxBarSize: 1,\n\t\n\t\t\t// stroke: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to use for any series on the plot.\n\t\t\tstroke:\t\t{},\n\t\n\t\t\t// outline: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke used to outline any series on the plot.\n\t\t\toutline:\t{},\n\t\n\t\t\t// shadow: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\n\t\t\tshadow:\t\t{},\n\t\n\t\t\t// fill: dojox.gfx.Fill?\n\t\t\t//\t\tAny fill to be used for elements on the plot.\n\t\t\tfill:\t\t{},\n\t\n\t\t\t// filter: dojox.gfx.Filter?\n\t\t \t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\n\t\t \t//\t\tbe required for this to work.\n\t\t \tfilter:\t\t{},\n\t\n\t\t\t// styleFunc: Function?\n\t\t\t//\t\tA function that returns a styling object for the a given data item.\n\t\t\tstyleFunc:\tnull,\n\t\n\t\t\t// font: String?\n\t\t\t//\t\tA font definition to be used for labels and other text-based elements on the plot.\n\t\t\tfont:\t\t\"\",\n\t\n\t\t\t// fontColor: String|dojo.Color?\n\t\t\t//\t\tThe color to be used for any text-based elements on the plot.\n\t\t\tfontColor:\t\"\",\n\t\t\t\n\t\t\t// enableCache: Boolean?\n\t\t\t//\t\tWhether the bars rect are cached from one rendering to another. This improves the rendering performance of\n\t\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\n\t\t\tenableCache: false\n\t\t});\n\t\t=====*/\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\t\n\t\tvar alwaysFalse = function(){ return false; }\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Bars\", [CartesianBase, _PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tThe plot object representing a bar chart (horizontal bars).\n\t\t\tdefaultParams: {\n\t\t\t\tgap:\t0,\t\t// gap between columns in pixels\n\t\t\t\tanimate: null,   // animate bars into place\n\t\t\t\tenableCache: false\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tminBarSize:\t1,\t// minimal bar width in pixels\n\t\t\t\tmaxBarSize:\t1,\t// maximal bar width in pixels\n\t\t\t\t// theme component\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfilter:\t    {},\n\t\t\t\tstyleFunc:  null,\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\"\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for a bar chart.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t\tthis.renderingOptions = { \"shape-rendering\": \"crispEdges\" };\n\t\t\t},\n\t\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = dc.collectSimpleStats(this.series, lang.hitch(this, \"isNullValue\")), t;\n\t\t\t\tstats.hmin -= 0.5;\n\t\t\t\tstats.hmax += 0.5;\n\t\t\t\tt = stats.hmin, stats.hmin = stats.vmin, stats.vmin = t;\n\t\t\t\tt = stats.hmax, stats.hmax = stats.vmax, stats.vmax = t;\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\t\t\n\t\t\tcreateRect: function(run, creator, params){\n\t\t\t\tvar rect;\n\t\t\t\tif(this.opt.enableCache && run._rectFreePool.length > 0){\n\t\t\t\t\trect = run._rectFreePool.pop();\n\t\t\t\t\trect.setShape(params);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(rect);\n\t\t\t\t}else{\n\t\t\t\t\trect = creator.createRect(params);\n\t\t\t\t}\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\trun._rectUsePool.push(rect);\n\t\t\t\t}\n\t\t\t\treturn rect;\n\t\t\t},\n\t\n\t\t\tcreateLabel: function(group, value, bbox, theme){\n\t\t\t\tif(this.opt.labels && this.opt.labelStyle == \"outside\"){\n\t\t\t\t\tvar y = bbox.y + bbox.height / 2;\n\t\t\t\t\tvar x = bbox.x + bbox.width + this.opt.labelOffset;\n\t\t\t\t\tthis.renderLabel(group, x, y, this._getLabel(isNaN(value.y)?value:value.y), theme, \"start\");\n\t          \t}else{\n\t\t\t\t\tthis.inherited(arguments);\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t\t// returns: dojox/charting/plot2d/Bars\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets); // dojox/charting/plot2d/Bars\n\t\t\t\t}\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tthis.resetEvents();\n\t\t\t\tvar s;\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\ts = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\t\t\tvar t = this.chart.theme,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\tbaseline = Math.max(this._hScaler.bounds.lower,\n\t\t\t\t\t\tthis._hAxis ? this._hAxis.naturalBaseline : 0),\t\t\t\t\n\t\t\t\t\tbaselineWidth = ht(baseline),\n\t\t\t\t\tevents = this.events();\n\t\t\t\tvar bar = this.getBarProperties();\n\t\n\t\t\t\tvar actualLength = this.series.length;\n\t\t\t\tarr.forEach(this.series, function(serie){if(serie.hidden){actualLength--;}});\n\t\t\t\tvar z = actualLength;\n\t\t\t\t\n\t\t\t\t// Collect and calculate all values\n\t\t\t\tvar extractedValues = this.extractValues(this._vScaler);\n\t\t\t\textractedValues = this.rearrangeValues(extractedValues, ht, baselineWidth);\n\t\t\t\t\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\t\trun._rectFreePool = (run._rectFreePool?run._rectFreePool:[]).concat(run._rectUsePool?run._rectUsePool:[]);\n\t\t\t\t\t\trun._rectUsePool = [];\n\t\t\t\t\t}\n\t\t\t\t\tvar theme = t.next(\"bar\", [this.opt, run]);\n\t\t\t\t\tif(run.hidden){\n\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\t\trun.dyn.stroke = theme.series.stroke;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tz--;\n\t\n\t\t\t\t\tvar\teventSeries = new Array(run.data.length);\n\t\t\t\t\ts = run.group;\t\n\t\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t});\n\t\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t\t// data point to save time\n\t\t\t\t\tvar min = indexed?Math.max(0, Math.floor(this._vScaler.bounds.from - 1)):0;\n\t\t\t\t\tvar max = indexed?Math.min(run.data.length, Math.ceil(this._vScaler.bounds.to)):run.data.length;\n\t\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\t\tif(!this.isNullValue(value)){\n\t\t\t\t\t\t\tvar val = this.getValue(value, j, i, indexed),\n\t\t\t\t\t\t\t\tw = extractedValues[i][j], finalTheme, sshape;\n\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof value != \"number\"){\n\t\t\t\t\t\t\t\tvar tMixin = typeof value != \"number\" ? [value] : [];\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(value));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfinalTheme = t.addMixin(theme, \"bar\", tMixin, true);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinalTheme = t.post(theme, \"bar\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w && bar.height >= 1){\n\t\t\t\t\t\t\t\tvar rect = {\n\t\t\t\t\t\t\t\t\tx: offsets.l + baselineWidth + Math.min(w, 0),\n\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(val.x + 1.5) + bar.gap + bar.thickness * (actualLength - z - 1),\n\t\t\t\t\t\t\t\t\twidth: Math.abs(w),\n\t\t\t\t\t\t\t\t\theight: bar.height\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif(finalTheme.series.shadow){\n\t\t\t\t\t\t\t\t\tvar srect = lang.clone(rect);\n\t\t\t\t\t\t\t\t\tsrect.x += finalTheme.series.shadow.dx;\n\t\t\t\t\t\t\t\t\tsrect.y += finalTheme.series.shadow.dy;\n\t\t\t\t\t\t\t\t\tsshape = this.createRect(run, s, srect).setFill(finalTheme.series.shadow.color).setStroke(finalTheme.series.shadow);\n\t\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\t\tthis._animateBar(sshape, offsets.l + baselineWidth, -w);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar specialFill = this._plotFill(finalTheme.series.fill, dim, offsets);\n\t\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, rect);\n\t\t\t\t\t\t\t\tvar shape = this.createRect(run, s, rect).setFill(specialFill).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\t\tif(shape.setFilter && finalTheme.series.filter){\n\t\t\t\t\t\t\t\t\tshape.setFilter(finalTheme.series.filter);\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\trun.dyn.fill   = shape.getFill();\n\t\t\t\t\t\t\t\trun.dyn.stroke = shape.getStroke();\n\t\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\t\telement: \"bar\",\n\t\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\t\t\t\tshadow:\t sshape,\n\t\t\t\t\t\t\t\t\t\tcx:      val.y,\n\t\t\t\t\t\t\t\t\t\tcy:      val.x + 1.5,\n\t\t\t\t\t\t\t\t\t\tx:\t     indexed?j:run.data[j].x,\n\t\t\t\t\t\t\t\t\t\ty:\t \t indexed?run.data[j]:run.data[j].y\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!isNaN(val.py) && val.py > baseline){\n\t\t\t\t\t\t\t\t\trect.x += ht(val.py);\n\t\t\t\t\t\t\t\t\trect.width -= ht(val.py);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.createLabel(s, value, rect, finalTheme);\n\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\tthis._animateBar(shape, offsets.l + baselineWidth, -Math.abs(w));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Bars\n\t\t\t},\n\t\t\tgetValue: function(value, j, seriesIndex, indexed){\n\t\t\t\tvar y, x;\n\t\t\t\tif(indexed){\n\t\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\t\ty = value;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ty = value.y;\n\t\t\t\t\t}\n\t\t\t\t\tx = j;\n\t\t\t\t}else{\n\t\t\t\t\ty = value.y;\n\t\t\t\t\tx = value.x -1;\n\t\t\t\t}\n\t\t\t\treturn {y:y, x:x};\n\t\t\t},\n\t\t\textractValues: function(scaler){\n\t\t\t\tvar extracted = [];\n\t\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t\t// data point to save time\n\t\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tmin = indexed ? Math.max(0, Math.floor(scaler.bounds.from - 1)) : 0,\n\t\t\t\t\t\tmax = indexed ? Math.min(run.data.length, Math.ceil(scaler.bounds.to)) : run.data.length,\n\t\t\t\t\t\textractedSet = extracted[i] = [];\n\t\t\t\t\textractedSet.min = min;\n\t\t\t\t\textractedSet.max = max;\n\t\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 :\n\t\t\t\t\t\t\t(typeof value == \"number\" ? value : value.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn extracted;\n\t\t\t},\n\t\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t\t// transform to pixels\n\t\t\t\tfor(var i = 0, n = values.length; i < n; ++i){\n\t\t\t\t\tvar extractedSet = values[i];\n\t\t\t\t\tif(extractedSet){\n\t\t\t\t\t\tfor(var j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\t\tvar value = extractedSet[j];\n\t\t\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 : transform(value) - baseline;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t},\n\t\t\tisNullValue: function(value){\n\t\t\t\tif(value === null || typeof value == \"undefined\"){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar h = this._hAxis ? this._hAxis.isNullValue : alwaysFalse,\n\t\t\t\t\tv = this._vAxis ? this._vAxis.isNullValue : alwaysFalse;\n\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\treturn v(0.5) || h(value);\n\t\t\t\t}\n\t\t\t\treturn v(isNaN(value.x) ? 0.5 : value.x + 0.5) || value.y === null || h(value.y);\n\t\t\t},\t\t\n\t\t\tgetBarProperties: function(){\n\t\t\t\tvar f = dc.calculateBarSize(this._vScaler.bounds.scale, this.opt);\n\t\t\t\treturn {gap: f.gap, height: f.size, thickness: 0};\n\t\t\t},\n\t\t\t_animateBar: function(shape, hoffset, hsize){\n\t\t\t\tif(hsize==0){\n\t\t\t\t\thsize = 1;\n\t\t\t\t}\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: [hoffset - (hoffset/hsize), 0], end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: [1/hsize, 1], end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 217 */\n/*!***********************************************!*\\\n  !*** ../dojox/charting/plot2d/StackedBars.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! ./Bars */ 216), __webpack_require__(/*! ./commonStacked */ 190)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, lang, Bars, commonStacked){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.StackedBars\", Bars, {\n\t\t\t// summary:\n\t\t\t//\t\tThe plot object representing a stacked bar chart (horizontal bars).\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = commonStacked.collectStats(this.series, lang.hitch(this, \"isNullValue\")), t;\n\t\t\t\tstats.hmin -= 0.5;\n\t\t\t\tstats.hmax += 0.5;\n\t\t\t\tt = stats.hmin, stats.hmin = stats.vmin, stats.vmin = t;\n\t\t\t\tt = stats.hmax, stats.hmax = stats.vmax, stats.vmax = t;\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t\treturn commonStacked.rearrangeValues.call(this, values, transform, baseline);\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 218 */\n/*!*************************************************!*\\\n  !*** ../dojox/charting/plot2d/ClusteredBars.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! ./Bars */ 216), __webpack_require__(/*! ./common */ 165)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, array, Bars, dc){\n\t\n\t\treturn declare(\"dojox.charting.plot2d.ClusteredBars\", Bars, {\n\t\t\t// summary:\n\t\t\t//\t\tA plot representing grouped or clustered bars (horizontal bars)\n\t\t\tgetBarProperties: function(){\n\t\t\t\tvar length = this.series.length;\n\t\t\t\tarray.forEach(this.series, function(serie){if(serie.hidden){length--;}});\n\t\t\t\tvar f = dc.calculateBarSize(this._vScaler.bounds.scale, this.opt, length);\n\t\t\t\treturn {gap: f.gap, height: f.size, thickness: f.size};\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 219 */\n/*!****************************************!*\\\n  !*** ../dojox/charting/plot2d/Grid.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/sniff */ 10),\n\t\t\t__webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./common */ 165), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, arr, has, CartesianBase, dc, du, fx){\n\t\n\t\tvar sortTicks = function(a,b){return a.value - b.value};\n\t\n\t\t/*=====\n\t\tdeclare(\"dojox.charting.plot2d.__GridCtorArgs\", dojox.charting.plot2d.__CartesianCtorArgs, {\n\t\t\t// summary:\n\t\t\t//\t\tA special keyword arguments object that is specific to a grid \"plot\".\n\t\n\t\t\t// majorHLine: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional dojox.gfx.Stroke for a major horizontal line. By default major lines use major tick stroke.\n\t\t\tmajorHLine:undefined,\n\t\n\t\t\t// minorHLine: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional dojox.gfx.Stroke for a minor horizontal line. By default minor lines use minor tick stroke.\n\t\t\tminorHLine:undefined,\n\t\n\t\t\t// majorVLine: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional dojox.gfx.Stroke for a major vertical line. By default major lines use major tick stroke.\n\t\t\tmajorVLine:undefined,\n\t\n\t\t\t// minorVLine: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional dojox.gfx.Stroke for a minor vertical line. By default major lines use major tick stroke.\n\t\t\tminorVLine:undefined,\n\t\n\t\t\t// hFill: dojox.gfx.Fill?\n\t\t\t//\t\tAn optional dojox.gfx.Fill used to fill every other horizontal stripe created by grid lines.\n\t\t\thFill: undefined,\n\t\n\t\t\t// hAlternateFill: dojox.gfx.Fill?\n\t\t\t//\t\tAn optional dojox.gfx.Fill used to fill alternating horizontal stripe created by grid lines not filled by `hFill`.\n\t\t\thAlternateFill: undefined,\n\t\n\t\t\t// vFill: dojox.gfx.Fill?\n\t\t\t//\t\tAn optional dojox.gfx.Fill used to fill every other vertical stripe created by grid lines.\n\t\t\tvFill: undefined,\n\t\n\t\t\t// vAlternateFill: dojox.gfx.Fill?\n\t\t\t//\t\tAn optional dojox.gfx.Fill used to fill alternating vertical stripe created by grid lines not filled by `vFill`.\n\t\t\tvAlternateFill: undefined,\n\t\n\t\t\t// hMajorLines: Boolean?\n\t\t\t//\t\tWhether to show lines at the major ticks along the horizontal axis. Default is true.\n\t\t\thMajorLines: true,\n\t\n\t\t\t// hMinorLines: Boolean?\n\t\t\t//\t\tWhether to show lines at the minor ticks along the horizontal axis. Default is false.\n\t\t\thMinorLines: false,\n\t\n\t\t\t// vMajorLines: Boolean?\n\t\t\t//\t\tWhether to show lines at the major ticks along the vertical axis. Default is true.\n\t\t\tvMajorLines: true,\n\t\n\t\t\t// vMinorLines: Boolean?\n\t\t\t//\t\tWhether to show lines at the major ticks along the vertical axis. Default is false.\n\t\t\tvMinorLines: false,\n\t\n\t\t\t// hStripes: Boolean?\n\t\t\t//\t\tWhether to show horizontal stripes. Default is false.\n\t\t\thStripes: false,\n\t\n\t\t\t// vStripes: Boolean?\n\t\t\t//\t\tWhether to show vertical stripes. Default is false.\n\t\t\tvStripes: false,\n\t\n\t\t\t// enableCache: Boolean?\n\t\t\t//\t\tWhether the grid lines are cached from one rendering to another. This improves the rendering performance of\n\t\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\n\t\t\tenableCache: false,\n\t\n\t\t\t// renderOnAxis: Boolean?\n\t\t\t//\t\tWhether or not the grid is rendered when drawn at horizontal or vertical axis position. Default is true.\n\t\t\trenderOnAxis: true\n\t\t});\n\t\t=====*/\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Grid\", CartesianBase, {\n\t\t\t// summary:\n\t\t\t//\t\tA \"faux\" plot that can be placed behind other plots to represent\n\t\t\t//\t\ta grid against which other plots can be easily measured.\n\t\t\tdefaultParams: {\n\t\t\t\thMajorLines: true,\t// draw horizontal major lines\n\t\t\t\thMinorLines: false,\t// draw horizontal minor lines\n\t\t\t\tvMajorLines: true,\t// draw vertical major lines\n\t\t\t\tvMinorLines: false,\t// draw vertical minor lines\n\t\t\t\thStripes: false,\t// draw vertical stripes\n\t\t\t\tvStripes: false,\t// draw vertical stripes\n\t\t\t\tanimate: null,   // animate bars into place\n\t\t\t\tenableCache: false,\n\t\t\t\trenderOnAxis: true\n\t\t\t},\n\t\n\t\t\toptionalParams: {\n\t\t\t\tmajorHLine: {},\n\t\t\t\tminorHLine: {},\n\t\t\t\tmajorVLine: {},\n\t\t\t\tminorVLine: {},\n\t\t\t\thFill: {},\n\t\t\t\tvFill: {},\n\t\t\t\thAlternateFill: {},\n\t\t\t\tvAlternateFill: {}\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate the faux Grid plot.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__GridCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define the parameters of the underlying grid.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\tthis._lineFreePool = [];\n\t\t\t\t\tthis._lineUsePool = [];\n\t\t\t\t\tthis._rectFreePool = [];\n\t\t\t\t\tthis._rectUsePool = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\taddSeries: function(run){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tIgnored but included as a dummy method.\n\t\t\t\t// returns: dojox/charting/plot2d/Grid\n\t\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Grid\n\t\t\t},\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns default stats (irrelevant for this type of plot).\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\treturn lang.delegate(dc.defaultStats); // Object\n\t\t\t},\n\t\t\tcleanGroup: function(){\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\tthis._lineFreePool = this._lineFreePool.concat(this._lineUsePool);\n\t\t\t\t\tthis._lineUsePool = [];\n\t\t\t\t\tthis._rectFreePool = this._rectFreePool.concat(this._rectUsePool);\n\t\t\t\t\tthis._rectUsePool = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tcreateLine: function(creator, params){\n\t\t\t\tvar line;\n\t\t\t\tif(this.opt.enableCache && this._lineFreePool.length > 0){\n\t\t\t\t\tline = this._lineFreePool.pop();\n\t\t\t\t\tline.setShape(params);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(line);\n\t\t\t\t}else{\n\t\t\t\t\tline = creator.createLine(params);\n\t\t\t\t}\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\tthis._lineUsePool.push(line);\n\t\t\t\t}\n\t\t\t\treturn line;\n\t\t\t},\n\t\t\tcreateRect: function(creator, params){\n\t\t\t\tvar rect;\n\t\t\t\tif(this.opt.enableCache && this._rectFreePool.length > 0){\n\t\t\t\t\trect = this._rectFreePool.pop();\n\t\t\t\t\trect.setShape(params);\n\t\t\t\t\t// was cleared, add it back\n\t\t\t\t\tcreator.add(rect);\n\t\t\t\t}else{\n\t\t\t\t\trect = creator.createRect(params);\n\t\t\t\t}\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\tthis._rectUsePool.push(rect);\n\t\t\t\t}\n\t\t\t\treturn rect;\n\t\t\t},\n\t\t\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender the plot on the chart.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\t// returns: dojox/charting/plot2d/Grid\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this.zoom){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tif(!this.dirty){ return this; }\n\t\t\t\tthis.cleanGroup();\n\t\t\t\tvar s = this.getGroup(), ta = this.chart.theme, lineStroke, ticks;\n\t\t\t\tif((has(\"ios\") && has(\"ios\") < 6) || has(\"android\") || (has(\"safari\") && !has(\"ios\"))){\n\t\t\t\t\t// clipping seems buggy in some mobile Webkit browser and Safari desktop\n\t\t\t\t\t// it does not clip correctly if only lines are present => create a invisible rectangle...\n\t\t\t\t\tvar w = Math.max(0, dim.width  - offsets.l - offsets.r),\n\t\t\t\t\t\th = Math.max(0, dim.height - offsets.t - offsets.b);\n\t\t\t\t\ts.createRect({ x: offsets.l, y: offsets.t, width: w, height: h});\n\t\t\t\t}\n\t\t\t\tif(this._vAxis){\n\t\t\t\t\t// draw horizontal stripes and lines\n\t\t\t\t\tticks = this._vAxis.getTicks();\n\t\t\t\t\tvar vScaler = this._vAxis.getScaler();\n\t\t\t\t\tif(ticks != null && vScaler != null){\n\t\t\t\t\t\tvar vt = vScaler.scaler.getTransformerFromModel(vScaler);\n\t\t\t\t\t\tif(this.opt.hStripes){\n\t\t\t\t\t\t\tthis._renderHRect(ticks, ta.grid, dim, offsets, vScaler, vt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.hMinorLines){\n\t\t\t\t\t\t\tlineStroke = this.opt.minorHLine || (ta.grid && ta.grid.minorLine) || ta.axis.minorTick;\n\t\t\t\t\t\t\tthis._renderHLines(ticks.minor, lineStroke, dim, offsets, vScaler, vt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.hMajorLines){\n\t\t\t\t\t\t\tlineStroke = this.opt.majorHLine || (ta.grid && ta.grid.majorLine) || ta.axis.majorTick;\n\t\t\t\t\t\t\tthis._renderHLines(ticks.major, lineStroke, dim, offsets, vScaler, vt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(this._hAxis){\n\t\t\t\t\t// draw vertical stripes and lines\n\t\t\t\t\tticks = this._hAxis.getTicks();\n\t\t\t\t\tvar hScaler = this._hAxis.getScaler();\n\t\t\t\t\tif(ticks != null && hScaler != null){\n\t\t\t\t\t\tvar ht = hScaler.scaler.getTransformerFromModel(hScaler);\n\t\t\t\t\t\tif(this.opt.vStripes){\n\t\t\t\t\t\t\tthis._renderVRect(ticks, ta.grid, dim, offsets, hScaler, ht);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ticks && this.opt.vMinorLines){\n\t\t\t\t\t\t\tlineStroke = this.opt.minorVLine || (ta.grid && ta.grid.minorLine) || ta.axis.minorTick;\n\t\t\t\t\t\t\tthis._renderVLines(ticks.minor, lineStroke, dim, offsets, hScaler, ht);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ticks && this.opt.vMajorLines){\n\t\t\t\t\t\t\tlineStroke = this.opt.majorVLine || (ta.grid && ta.grid.majorLine) || ta.axis.majorTick;\n\t\t\t\t\t\t\tthis._renderVLines(ticks.major, lineStroke, dim, offsets, hScaler, ht);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Grid\n\t\t\t},\n\t\t\t_renderHLines: function(ticks, lineStroke, dim, offsets, vScaler, vt){\n\t\t\t\tvar s = this.getGroup();\n\t\t\t\tarr.forEach(ticks, function(tick){\n\t\t\t\t\tif(!this.opt.renderOnAxis && tick.value == (this._vAxis.opt.leftBottom?vScaler.bounds.from:vScaler.bounds.to)){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar y = dim.height - offsets.b - vt(tick.value);\n\t\t\t\t\tvar hLine = this.createLine(s, {\n\t\t\t\t\t\tx1: offsets.l,\n\t\t\t\t\t\ty1: y,\n\t\t\t\t\t\tx2: dim.width - offsets.r,\n\t\t\t\t\t\ty2: y\n\t\t\t\t\t}).setStroke(lineStroke);\n\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\tthis._animateGrid(hLine, \"h\", offsets.l, offsets.r + offsets.l - dim.width);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t},\n\t\t\t_renderVLines: function(ticks, lineStroke, dim, offsets, hScaler, ht){\n\t\t\t\tvar s = this.getGroup();\n\t\t\t\tarr.forEach(ticks, function(tick){\n\t\t\t\t\tif(!this.opt.renderOnAxis && tick.value == (this._hAxis.opt.leftBottom?hScaler.bounds.from:hScaler.bounds.to)){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar x = offsets.l + ht(tick.value);\n\t\t\t\t\tvar vLine = this.createLine(s, {\n\t\t\t\t\t\tx1: x,\n\t\t\t\t\t\ty1: offsets.t,\n\t\t\t\t\t\tx2: x,\n\t\t\t\t\t\ty2: dim.height - offsets.b\n\t\t\t\t\t}).setStroke(lineStroke);\n\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\tthis._animateGrid(vLine, \"v\", dim.height - offsets.b, dim.height - offsets.b - offsets.t);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t},\n\t\t\t_renderHRect: function(ticks, theme, dim, offsets, vScaler, vt){\n\t\t\t\tvar fill, tick, y, y2, hStripe;\n\t\t\t\tvar allTicks = ticks.major.concat(ticks.minor);\n\t\t\t\tallTicks.sort(sortTicks);\n\t\t\t\tif(allTicks[0].value > vScaler.bounds.from){\n\t\t\t\t\tallTicks.splice(0, 0, {value: vScaler.bounds.from});\n\t\t\t\t}\n\t\t\t\tif(allTicks[allTicks.length - 1].value < vScaler.bounds.to){\n\t\t\t\t\tallTicks.push({value: vScaler.bounds.to});\n\t\t\t\t}\n\t\t\t\tvar s = this.getGroup();\n\t\t\t\tfor(var j = 0; j < allTicks.length - 1; j++){\n\t\t\t\t\ttick = allTicks[j];\n\t\t\t\t\ty = dim.height - offsets.b - vt(tick.value);\n\t\t\t\t\ty2 = dim.height - offsets.b - vt(allTicks[j+1].value);\n\t\n\t\t\t\t\tfill = (j%2 == 0)?(this.opt.hAlternateFill ||(theme && theme.alternateFill)):\n\t\t\t\t\t\t(this.opt.hFill || (theme && theme.fill));\n\t\t\t\t\tif(fill){\n\t\t\t\t\t\thStripe = this.createRect(s, {\n\t\t\t\t\t\t\tx: offsets.l,\n\t\t\t\t\t\t\ty: y,\n\t\t\t\t\t\t\twidth: dim.width - offsets.r,\n\t\t\t\t\t\t\theight: y - y2\n\t\t\t\t\t\t}).setFill(fill);\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateGrid(hStripe, \"h\", offsets.l, offsets.r + offsets.l - dim.width);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_renderVRect: function(ticks, theme, dim, offsets, hScaler, ht){\n\t\t\t\tvar fill, tick, x, x2, vStripe;\n\t\t\t\tvar allTicks = ticks.major.concat(ticks.minor);\n\t\t\t\tallTicks.sort(sortTicks);\n\t\t\t\tif(allTicks[0].value > hScaler.bounds.from){\n\t\t\t\t\tallTicks.splice(0, 0, {value: hScaler.bounds.from});\n\t\t\t\t}\n\t\t\t\tif(allTicks[allTicks.length - 1].value < hScaler.bounds.to){\n\t\t\t\t\tallTicks.push({value: hScaler.bounds.to});\n\t\t\t\t}\n\t\t\t\tvar s = this.getGroup();\n\t\t\t\tfor(var j = 0; j < allTicks.length - 1; j++){\n\t\t\t\t\ttick = allTicks[j];\n\t\t\t\t\tx = offsets.l + ht(tick.value);\n\t\t\t\t\tx2 = offsets.l + ht(allTicks[j+1].value);\n\t\n\t\t\t\t\tfill = (j%2 == 0)?(this.opt.vAlternateFill ||(theme && theme.alternateFill)):\n\t\t\t\t\t\t(this.opt.vFill || (theme && theme.fill));\n\t\t\t\t\tif(fill){\n\t\t\t\t\t\tvStripe = this.createRect(s, {\n\t\t\t\t\t\t\tx: x,\n\t\t\t\t\t\t\ty: offsets.t,\n\t\t\t\t\t\t\twidth: x2 - x,\n\t\t\t\t\t\t\theight: dim.width - offsets.r\n\t\t\t\t\t\t}).setFill(fill);\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateGrid(vStripe, \"v\", dim.height - offsets.b, dim.height - offsets.b - offsets.t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_animateGrid: function(shape, type, offset, size){\n\t\t\t\tvar transStart = type == \"h\" ? [offset, 0] : [0, offset];\n\t\t\t\tvar scaleStart = type == \"h\" ? [1/size, 1] : [1, 1/size];\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: transStart, end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: scaleStart, end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 220 */\n/*!***************************************!*\\\n  !*** ../dojox/charting/plot2d/Pie.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13) ,__webpack_require__(/*! dojo/_base/declare */ 33), \n\t\t\t__webpack_require__(/*! ./Base */ 182), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165),\n\t\t\t__webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/gfx/matrix */ 170), __webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/utils */ 187),__webpack_require__(/*! dojo/has */ 5)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, Base, PlotEvents, dc, g, m, df, du, has){\n\t\n\t\t/*=====\n\t\tdeclare(\"dojox.charting.plot2d.__PieCtorArgs\", dojox.charting.plot2d.__DefaultCtorArgs, {\n\t\t\t// summary:\n\t\t\t//\t\tSpecialized keyword arguments object for use in defining parameters on a Pie chart.\n\t\t\n\t\t\t// labels: Boolean?\n\t\t\t//\t\tWhether or not to draw labels for each pie slice.  Default is true.\n\t\t\tlabels:\t\t\ttrue,\n\t\t\n\t\t\t// ticks: Boolean?\n\t\t\t//\t\tWhether or not to draw ticks to labels within each slice. Default is false.\n\t\t\tticks:\t\t\tfalse,\n\t\t\n\t\t\t// fixed: Boolean?\n\t\t\t//\t\tWhether a fixed precision must be applied to data values for display. Default is true.\n\t\t\tfixed:\t\t\ttrue,\n\t\t\n\t\t\t// precision: Number?\n\t\t\t//\t\tThe precision at which to round data values for display. Default is 0.\n\t\t\tprecision:\t\t1,\n\t\t\n\t\t\t// labelOffset: Number?\n\t\t\t//\t\tThe amount in pixels by which to offset labels.  Default is 20.\n\t\t\tlabelOffset:\t20,\n\t\t\n\t\t\t// labelStyle: String?\n\t\t\t//\t\tOptions as to where to draw labels.  Values include \"default\", and \"columns\".\tDefault is \"default\".\n\t\t\tlabelStyle:\t\t\"default\",\t// default/columns\n\t\t\t\n\t\t\t// omitLabels: Boolean?\n\t\t\t//\t\tWhether labels of slices small to the point of not being visible are omitted.\tDefault false.\n\t\t\tomitLabels: false,\n\t\t\t\n\t\t\t// htmlLabels: Boolean?\n\t\t\t//\t\tWhether or not to use HTML to render slice labels. Default is true.\n\t\t\thtmlLabels:\t\ttrue,\n\t\t\n\t\t\t// radGrad: String?\n\t\t\t//\t\tThe type of radial gradient to use in rendering.  Default is \"native\".\n\t\t\tradGrad:        \"native\",\n\t\t\n\t\t\t// fanSize: Number?\n\t\t\t//\t\tThe amount for a radial gradient.  Default is 5.\n\t\t\tfanSize:\t\t5,\n\t\t\n\t\t\t// startAngle: Number?\n\t\t\t//\t\tWhere to being rendering gradients in slices, in degrees.  Default is 0.\n\t\t\tstartAngle:     0,\n\t\t\n\t\t\t// radius: Number?\n\t\t\t//\t\tThe size of the radial gradient.  Default is 0.\n\t\t\tradius:\t\t0,\n\t\n\t\t\t// shadow: dojox.gfx.Stroke?\n\t\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\n\t\t\tshadow:\t\t{},\n\t\n\t\t\t// fill: dojox.gfx.Fill?\n\t\t\t//\t\tAny fill to be used for elements on the plot.\n\t\t\tfill:\t\t{},\n\t\n\t\t\t// filter: dojox.gfx.Filter?\n\t\t\t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\n\t\t\t//\t\tbe required for this to work.\n\t\t\tfilter:\t\t{},\n\t\n\t\t\t// styleFunc: Function?\n\t\t\t//\t\tA function that returns a styling object for the a given data item.\n\t\t\tstyleFunc:\tnull\n\t\t});\n\t\t=====*/\n\t\n\t\tvar FUDGE_FACTOR = 0.2; // use to overlap fans\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Pie\", [Base, PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tThe plot that represents a typical pie chart.\n\t\t\tdefaultParams: {\n\t\t\t\tlabels:\t\t\ttrue,\n\t\t\t\tticks:\t\t\tfalse,\n\t\t\t\tfixed:\t\t\ttrue,\n\t\t\t\tprecision:\t\t1,\n\t\t\t\tlabelOffset:\t20,\n\t\t\t\tlabelStyle:\t\t\"default\",\t// default/columns\n\t\t\t\thtmlLabels:\t\ttrue,\t\t// use HTML to draw labels\n\t\t\t\tradGrad:        \"native\",\t// or \"linear\", or \"fan\"\n\t\t\t\tfanSize:\t\t5,\t\t\t// maximum fan size in degrees\n\t\t\t\tstartAngle:     0\t\t\t// start angle for slices in degrees\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tradius:\t\t0,\n\t\t\t\tomitLabels: false,\n\t\t\t\t// theme components\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfilter:     {},\n\t\t\t\tstyleFunc:\tnull,\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\",\n\t\t\t\tlabelWiring: {}\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate a pie plot.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.axes = [];\n\t\t\t\tthis.run = null;\n\t\t\t\tthis.dyn = [];\n\t\t\t\tthis.runFilter = []; \n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tthis.dyn = [];\n\t\t\t\tthis.run = null;\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t\t},\n\t\t\tsetAxis: function(axis){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tDummy method, since axes are irrelevant with a Pie chart.\n\t\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t\t},\n\t\t\taddSeries: function(run){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAdd a series of data to this plot.\n\t\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\t\t\tthis.run = run;\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t\t},\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturns default stats (irrelevant for this type of plot).\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\treturn lang.delegate(dc.defaultStats); // Object\n\t\t\t},\n\t\t\tgetRequiredColors: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tReturn the number of colors needed to draw this plot.\n\t\t\t\treturn this.run ? this.run.data.length : 0;\n\t\t\t},\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender the plot on the chart.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(!this.dirty){ return this; }\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\tvar s = this.group, t = this.chart.theme;\n\t\n\t\t\t\tif(!this.run || !this.run.data.length){\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\n\t\t\t\t// calculate the geometry\n\t\t\t\tvar rx = (dim.width  - offsets.l - offsets.r) / 2,\n\t\t\t\t\try = (dim.height - offsets.t - offsets.b) / 2,\n\t\t\t\t\tr  = Math.min(rx, ry),\n\t\t\t\t\tlabelFont = \"font\" in this.opt ? this.opt.font : t.series.font,\n\t\t\t\t\tsize,\n\t\t\t\t\tstartAngle = m._degToRad(this.opt.startAngle),\n\t\t\t\t\tstart = startAngle, filteredRun, slices, labels, shift, labelR,\n\t\t\t\t\tevents = this.events();\n\t\n\t\t\t\tvar run = arr.map(this.run.data, function(item, i){\n\t\t\t\t\tif(typeof item != \"number\" && item.hidden){ \n\t\t\t\t\t\tthis.runFilter.push(i); \n\t\t\t\t\t\titem.hidden = false; \n\t\t\t\t\t} \n\t\t\t\t\tif(arr.some(this.runFilter, function(filter){return filter == i;})){ \n\t\t\t\t\t\tif(typeof item == \"number\"){ \n\t\t\t\t\t\t\treturn 0; \n\t\t\t\t\t\t}else{ \n\t\t\t\t\t\t\treturn {y: 0, text: item.text}; \n\t\t\t\t\t\t} \n\t\t\t\t\t}else{ \n\t\t\t\t\t\treturn item; \n\t\t\t\t\t} \n\t\t\t\t}, this);\n\t\n\t\t\t\tthis.dyn = [];\n\t\n\t\t\t\tif(\"radius\" in this.opt){\n\t\t\t\t\tr = this.opt.radius;\n\t\t\t\t\tlabelR = r - this.opt.labelOffset;\n\t\t\t\t}\n\t\t\t\tvar\tcircle = {\n\t\t\t\t\tcx: offsets.l + rx,\n\t\t\t\t\tcy: offsets.t + ry,\n\t\t\t\t\tr:  r\n\t\t\t\t};\n\t\n\t\t\t\t// draw shadow\n\t\t\t\tif(this.opt.shadow || t.shadow){\n\t\t\t\t\tvar shadow = this.opt.shadow || t.shadow;\n\t\t\t\t\tvar scircle = lang.clone(circle);\n\t\t\t\t\tscircle.cx += shadow.dx;\n\t\t\t\t\tscircle.cy += shadow.dy;\n\t\t\t\t\ts.createCircle(scircle).setFill(shadow.color).setStroke(shadow);\n\t\t\t\t}\n\t\t\t\tif(s.setFilter && (this.opt.filter || t.filter)){\n\t\t\t\t\ts.createCircle(circle).setFill(t.series.stroke).setFilter(this.opt.filter || t.filter);\n\t\t\t\t}\n\t\n\t\t\t\tif(typeof run[0] == \"number\"){\n\t\t\t\t\tfilteredRun = df.map(run, \"x ? Math.max(x, 0) : 0\");\n\t\t\t\t\tif(df.every(filteredRun, \"<= 0\")){\n\t\t\t\t\t\ts.createCircle(circle).setStroke(t.series.stroke);\n\t\t\t\t\t\tthis.dyn = arr.map(filteredRun, function(){\n\t\t\t\t\t\t\treturn {  };\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tslices = df.map(filteredRun, \"/this\", df.foldl(filteredRun, \"+\", 0));\n\t\t\t\t\t \tif(this.opt.labels){\n\t\t\t\t\t \t\tlabels = arr.map(slices, function(x){\n\t\t\t\t\t\t\t\treturn x > 0 ? this._getLabel(x * 100) + \"%\" : \"\";\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfilteredRun = df.map(run, \"x ? Math.max(x.y, 0) : 0\");\n\t\t\t\t\tif(df.every(filteredRun, \"<= 0\")){\n\t\t\t\t\t\ts.createCircle(circle).setStroke(t.series.stroke);\n\t\t\t\t\t\tthis.dyn = arr.map(filteredRun, function(){\n\t\t\t\t\t\t\treturn {  };\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tslices = df.map(filteredRun, \"/this\", df.foldl(filteredRun, \"+\", 0));\n\t\t\t\t\t\tif(this.opt.labels){\n\t\t\t\t\t\t\tlabels = arr.map(slices, function(x, i){\n\t\t\t\t\t\t\t\tif(x < 0){ return \"\"; }\n\t\t\t\t\t\t\t\tvar v = run[i];\n\t\t\t\t\t\t\t\treturn \"text\" in v ? v.text : this._getLabel(x * 100) + \"%\";\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar themes = df.map(run, function(v, i){\n\t\t\t\t\tvar tMixin = [this.opt, this.run];\n\t\t\t\t\tif(v !== null && typeof v != \"number\"){\n\t\t\t\t\t\ttMixin.push(v);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(v));\n\t\t\t\t\t}\n\t\t\t\t\treturn t.next(\"slice\", tMixin, true);\n\t\t\t\t}, this);\n\t\n\t\t\t\tif(this.opt.labels){\n\t\t\t\t\tsize = labelFont ? g.normalizedLength(g.splitFontString(labelFont).size) : 0;\n\t\t\t\t\tshift = df.foldl1(df.map(labels, function(label, i){\n\t\t\t\t\t\tvar font = themes[i].series.font;\n\t\t\t\t\t\treturn g._base._getTextBox(label, {font: font}).w;\n\t\t\t\t\t}, this), \"Math.max(a, b)\") / 2;\n\t\t\t\t\tif(this.opt.labelOffset < 0){\n\t\t\t\t\t\tr = Math.min(rx - 2 * shift, ry - size) + this.opt.labelOffset;\n\t\t\t\t\t}\n\t\t\t\t\tlabelR = r - this.opt.labelOffset;\n\t\t\t\t}\n\t\n\t\t\t\t// draw slices\n\t\t\t\tvar eventSeries = new Array(slices.length);\n\t\t\t\tarr.some(slices, function(slice, i){\n\t\t\t\t\tif(slice < 0){\n\t\t\t\t\t\t// degenerated slice\n\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t}\n\t\t\t\t\tvar v = run[i], theme = themes[i], specialFill, o;\n\t\t\t\t\tif(slice == 0){\n\t\t\t\t\t\tthis.dyn.push({fill: theme.series.fill, stroke: theme.series.stroke});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(slice >= 1){\n\t\t\t\t\t\t// whole pie\n\t\t\t\t\t\tspecialFill = this._plotFill(theme.series.fill, dim, offsets);\n\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx: circle.cx - circle.r, y: circle.cy - circle.r,\n\t\t\t\t\t\t\t\twidth: 2 * circle.r, height: 2 * circle.r\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tspecialFill = this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, circle.r);\n\t\t\t\t\t\tvar shape = s.createCircle(circle).setFill(specialFill).setStroke(theme.series.stroke);\n\t\t\t\t\t\tthis.dyn.push({fill: specialFill, stroke: theme.series.stroke});\n\t\n\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\to = {\n\t\t\t\t\t\t\t\telement: \"slice\",\n\t\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\t\trun:     this.run,\n\t\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\t\tx:       i,\n\t\t\t\t\t\t\t\ty:       typeof v == \"number\" ? v : v.y,\n\t\t\t\t\t\t\t\tcx:      circle.cx,\n\t\t\t\t\t\t\t\tcy:      circle.cy,\n\t\t\t\t\t\t\t\tcr:      r\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn false;\t// we continue because we want to collect null data points for legend\n\t\t\t\t\t}\n\t\t\t\t\t// calculate the geometry of the slice\n\t\t\t\t\tvar end = start + slice * 2 * Math.PI;\n\t\t\t\t\tif(i + 1 == slices.length){\n\t\t\t\t\t\tend = startAngle + 2 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t\tvar\tstep = end - start,\n\t\t\t\t\t\tx1 = circle.cx + r * Math.cos(start),\n\t\t\t\t\t\ty1 = circle.cy + r * Math.sin(start),\n\t\t\t\t\t\tx2 = circle.cx + r * Math.cos(end),\n\t\t\t\t\t\ty2 = circle.cy + r * Math.sin(end);\n\t\t\t\t\t// draw the slice\n\t\t\t\t\tvar fanSize = m._degToRad(this.opt.fanSize);\n\t\t\t\t\tif(theme.series.fill && theme.series.fill.type === \"radial\" && this.opt.radGrad === \"fan\" && step > fanSize){\n\t\t\t\t\t\tvar group = s.createGroup(), nfans = Math.ceil(step / fanSize), delta = step / nfans;\n\t\t\t\t\t\tspecialFill = this._shapeFill(theme.series.fill,\n\t\t\t\t\t\t\t{x: circle.cx - circle.r, y: circle.cy - circle.r, width: 2 * circle.r, height: 2 * circle.r});\n\t\t\t\t\t\tfor(var j = 0; j < nfans; ++j){\n\t\t\t\t\t\t\tvar fansx = j == 0 ? x1 : circle.cx + r * Math.cos(start + (j - FUDGE_FACTOR) * delta),\n\t\t\t\t\t\t\t\tfansy = j == 0 ? y1 : circle.cy + r * Math.sin(start + (j - FUDGE_FACTOR) * delta),\n\t\t\t\t\t\t\t\tfanex = j == nfans - 1 ? x2 : circle.cx + r * Math.cos(start + (j + 1 + FUDGE_FACTOR) * delta),\n\t\t\t\t\t\t\t\tfaney = j == nfans - 1 ? y2 : circle.cy + r * Math.sin(start + (j + 1 + FUDGE_FACTOR) * delta);\n\t\t\t\t\t\t\tgroup.createPath().\n\t\t\t\t\t\t\t\t\tmoveTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\t\t\tlineTo(fansx, fansy).\n\t\t\t\t\t\t\t\t\tarcTo(r, r, 0, delta > Math.PI, true, fanex, faney).\n\t\t\t\t\t\t\t\t\tlineTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\t\t\tclosePath().\n\t\t\t\t\t\t\t\t\tsetFill(this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, r, start + (j + 0.5) * delta, start + (j + 0.5) * delta));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.createPath().\n\t\t\t\t\t\t\tmoveTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\tlineTo(x1, y1).\n\t\t\t\t\t\t\tarcTo(r, r, 0, step > Math.PI, true, x2, y2).\n\t\t\t\t\t\t\tlineTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\tclosePath().\n\t\t\t\t\t\t\tsetStroke(theme.series.stroke);\n\t\t\t\t\t\tshape = group;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tshape = s.createPath().\n\t\t\t\t\t\t\tmoveTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\tlineTo(x1, y1).\n\t\t\t\t\t\t\tarcTo(r, r, 0, step > Math.PI, true, x2, y2).\n\t\t\t\t\t\t\tlineTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\tclosePath().\n\t\t\t\t\t\t\tsetStroke(theme.series.stroke);\n\t\t\t\t\t\tspecialFill = theme.series.fill;\n\t\t\t\t\t\tif(specialFill && specialFill.type === \"radial\"){\n\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, {x: circle.cx - circle.r, y: circle.cy - circle.r, width: 2 * circle.r, height: 2 * circle.r});\n\t\t\t\t\t\t\tif(this.opt.radGrad === \"linear\"){\n\t\t\t\t\t\t\t\tspecialFill = this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, r, start, end);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(specialFill && specialFill.type === \"linear\"){\n\t\t\t\t\t\t\tspecialFill = this._plotFill(specialFill, dim, offsets);\n\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, shape.getBoundingBox());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tshape.setFill(specialFill);\n\t\t\t\t\t}\n\t\t\t\t\tthis.dyn.push({fill: specialFill, stroke: theme.series.stroke});\n\t\n\t\t\t\t\tif(events){\n\t\t\t\t\t\to = {\n\t\t\t\t\t\t\telement: \"slice\",\n\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\trun:     this.run,\n\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\tx:       i,\n\t\t\t\t\t\t\ty:       typeof v == \"number\" ? v : v.y,\n\t\t\t\t\t\t\tcx:      circle.cx,\n\t\t\t\t\t\t\tcy:      circle.cy,\n\t\t\t\t\t\t\tcr:      r\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstart = end;\n\t\n\t\t\t\t\treturn false;\t// continue\n\t\t\t\t}, this);\n\t\t\t\t// draw labels\n\t\t\t\tif(this.opt.labels){\n\t\t\t\t\tvar isRtl = has(\"dojo-bidi\") && this.chart.isRightToLeft(); \n\t\t\t\t\tif(this.opt.labelStyle == \"default\"){ // inside or outside based on labelOffset\n\t\t\t\t\t\tstart = startAngle;\n\t\t\t\t\t\tarr.some(slices, function(slice, i){\n\t\t\t\t\t\t\tif(slice <= 0){\n\t\t\t\t\t\t\t\t// degenerated slice\n\t\t\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar theme = themes[i];\n\t\t\t\t\t\t\tif(slice >= 1){\n\t\t\t\t\t\t\t\t// whole pie\n\t\t\t\t\t\t\t\tthis.renderLabel(s, circle.cx, circle.cy + size / 2, labels[i], theme, this.opt.labelOffset > 0);\n\t\t\t\t\t\t\t\treturn true;\t// stop iteration\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// calculate the geometry of the slice\n\t\t\t\t\t\t\tvar end = start + slice * 2 * Math.PI;\n\t\t\t\t\t\t\tif(i + 1 == slices.length){\n\t\t\t\t\t\t\t\tend = startAngle + 2 * Math.PI;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.opt.omitLabels && end-start < 0.001){\n\t\t\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar\tlabelAngle = (start + end) / 2,\n\t\t\t\t\t\t\t\tx = circle.cx + labelR * Math.cos(labelAngle),\n\t\t\t\t\t\t\t\ty = circle.cy + labelR * Math.sin(labelAngle) + size / 2;\n\t\t\t\t\t\t\t// draw the label\n\t\t\t\t\t\t\tthis.renderLabel(s, isRtl ? dim.width - x : x, y, labels[i], theme, this.opt.labelOffset > 0);\n\t\t\t\t\t\t\tstart = end;\n\t\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}else if(this.opt.labelStyle == \"columns\"){\n\t\t\t\t\t\tstart = startAngle;\n\t\t\t\t\t\tvar omitLabels = this.opt.omitLabels;\n\t\t\t\t\t\t//calculate label angles\n\t\t\t\t\t\tvar labeledSlices = [];\n\t\t\t\t\t\tarr.forEach(slices, function(slice, i){\n\t\t\t\t\t\t\tvar end = start + slice * 2 * Math.PI;\n\t\t\t\t\t\t\tif(i + 1 == slices.length){\n\t\t\t\t\t\t\t\tend = startAngle + 2 * Math.PI;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar labelAngle = (start + end) / 2;\n\t\t\t\t\t\t\tlabeledSlices.push({\n\t\t\t\t\t\t\t\tangle: labelAngle,\n\t\t\t\t\t\t\t\tleft: Math.cos(labelAngle) < 0,\n\t\t\t\t\t\t\t\ttheme: themes[i],\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tomit: omitLabels?end - start < 0.001:false\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tstart = end;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//calculate label radius to each slice\n\t\t\t\t\t\tvar labelHeight = g._base._getTextBox(\"a\",{ font: labelFont }).h;\n\t\t\t\t\t\tthis._getProperLabelRadius(labeledSlices, labelHeight, circle.r * 1.1);\n\t\t\t\t\t\t//draw label and wiring\n\t\t\t\t\t\tarr.forEach(labeledSlices, function(slice, i){\n\t\t\t\t\t\t\tif(!slice.omit){\n\t\t\t\t\t\t\t\tvar leftColumn = circle.cx - circle.r * 2,\n\t\t\t\t\t\t\t\t\trightColumn = circle.cx + circle.r * 2,\n\t\t\t\t\t\t\t\t\tlabelWidth = g._base._getTextBox(labels[i], {font: slice.theme.series.font}).w,\n\t\t\t\t\t\t\t\t\tx = circle.cx + slice.labelR * Math.cos(slice.angle),\n\t\t\t\t\t\t\t\t\ty = circle.cy + slice.labelR * Math.sin(slice.angle),\n\t\t\t\t\t\t\t\t\tjointX = (slice.left) ? (leftColumn + labelWidth) : (rightColumn - labelWidth),\n\t\t\t\t\t\t\t\t\tlabelX = (slice.left) ? leftColumn : jointX;\n\t\t\t\t\t\t\t\tvar wiring = s.createPath().moveTo(circle.cx + circle.r * Math.cos(slice.angle), circle.cy + circle.r * Math.sin(slice.angle));\n\t\t\t\t\t\t\t\tif(Math.abs(slice.labelR * Math.cos(slice.angle)) < circle.r * 2 - labelWidth){\n\t\t\t\t\t\t\t\t\twiring.lineTo(x, y);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twiring.lineTo(jointX, y).setStroke(slice.theme.series.labelWiring);\n\t\t\t\t\t\t\t\tthis.renderLabel(s, isRtl ? dim.width - labelWidth - labelX : labelX, y, labels[i], slice.theme, false, \"left\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// post-process events to restore the original indexing\n\t\t\t\tvar esi = 0;\n\t\t\t\tthis._eventSeries[this.run.name] = df.map(run, function(v){\n\t\t\t\t\treturn v <= 0 ? null : eventSeries[esi++];\n\t\t\t\t});\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t\t},\n\t\t\t_getProperLabelRadius: function(slices, labelHeight, minRidius){\n\t\t\t\tvar leftCenterSlice, rightCenterSlice,\n\t\t\t\t\tleftMinSIN = 1, rightMinSIN = 1;\n\t\t\t\tif(slices.length == 1){\n\t\t\t\t\tslices[0].labelR = minRidius;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor(var i = 0; i < slices.length; i++){\n\t\t\t\t\tvar tempSIN = Math.abs(Math.sin(slices[i].angle));\n\t\t\t\t\tif(slices[i].left){\n\t\t\t\t\t\tif(leftMinSIN >= tempSIN){\n\t\t\t\t\t\t\tleftMinSIN = tempSIN;\n\t\t\t\t\t\t\tleftCenterSlice = slices[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(rightMinSIN >= tempSIN){\n\t\t\t\t\t\t\trightMinSIN = tempSIN;\n\t\t\t\t\t\t\trightCenterSlice = slices[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tleftCenterSlice.labelR = rightCenterSlice.labelR = minRidius;\n\t\t\t\tthis._calculateLabelR(leftCenterSlice, slices, labelHeight);\n\t\t\t\tthis._calculateLabelR(rightCenterSlice, slices, labelHeight);\n\t\t\t},\n\t\t\t_calculateLabelR: function(firstSlice, slices, labelHeight){\n\t\t\t\tvar i = firstSlice.index,length = slices.length,\n\t\t\t\t\tcurrentLabelR = firstSlice.labelR, nextLabelR;\n\t\t\t\twhile(!(slices[i%length].left ^ slices[(i+1)%length].left)){\n\t\t\t\t\tif(!slices[(i + 1) % length].omit){\n\t\t\t\t\t\tnextLabelR = (Math.sin(slices[i % length].angle) * currentLabelR + ((slices[i % length].left) ? (-labelHeight) : labelHeight)) /\n\t\t\t\t\t\tMath.sin(slices[(i + 1) % length].angle);\n\t\t\t\t\t\tcurrentLabelR = (nextLabelR < firstSlice.labelR) ? firstSlice.labelR : nextLabelR;\n\t\t\t\t\t\tslices[(i + 1) % length].labelR = currentLabelR;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ti = firstSlice.index;\n\t\t\t\tvar j = (i == 0)?length-1 : i - 1;\n\t\t\t\twhile(!(slices[i].left ^ slices[j].left)){\n\t\t\t\t\tif(!slices[j].omit){\n\t\t\t\t\t\tnextLabelR = (Math.sin(slices[i].angle) * currentLabelR + ((slices[i].left) ? labelHeight : (-labelHeight))) /\n\t\t\t\t\t\tMath.sin(slices[j].angle);\n\t\t\t\t\t\tcurrentLabelR = (nextLabelR < firstSlice.labelR) ? firstSlice.labelR : nextLabelR;\n\t\t\t\t\t\tslices[j].labelR = currentLabelR;\n\t\t\t\t\t}\n\t\t\t\t\ti--;j--;\n\t\t\t\t\ti = (i < 0)?i+slices.length:i;\n\t\t\t\t\tj = (j < 0)?j+slices.length:j;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 221 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/plot2d/Bubble.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/has */ 5), \n\t\t\t__webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165), __webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189),\n\t\t\t__webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\t\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\t\treturn declare(\"dojox.charting.plot2d.Bubble\", [CartesianBase, _PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tA plot representing bubbles.  Note that data for Bubbles requires 3 parameters,\n\t\t\t//\t\tin the form of:  { x, y, size }, where size determines the size of the bubble.\n\t\t\tdefaultParams: {\n\t\t\t\tanimate: null   // animate bars into place\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\t// theme component\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfilter:     {},\n\t\t\t\tstyleFunc:\tnull,\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\",\n\t\t\t\tlabelFunc: null\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate a plot of bubbles.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t\t//\t\tOptional keyword arguments object to help define plot parameters.\n\t\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tif(!this.opt.labelFunc){\n\t\t\t\t\tthis.opt.labelFunc = function(value, fixed, precision){\n\t\t\t\t\t\treturn this._getLabel(value.size, fixed, precision);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t},\n\t\n\t\t\t//\toverride the render so that we are plotting only circles.\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t\t// returns: dojox/charting/plot2d/Bubble\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tvar s;\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\ts = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\n\t\t\t\tvar t = this.chart.theme,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\tevents = this.events();\n\t\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tif(!run.data.length){\n\t\t\t\t\t\trun.dirty = false;\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif(typeof run.data[0] == \"number\"){\n\t\t\t\t\t\tconsole.warn(\"dojox.charting.plot2d.Bubble: the data in the following series cannot be rendered as a bubble chart; \", run);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar theme = t.next(\"circle\", [this.opt, run]),\n\t\t\t\t\t\tpoints = arr.map(run.data, function(v){\n\t\t\t\t\t\t\treturn v ? {\n\t\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y),\n\t\t\t\t\t\t\t\tradius: this._vScaler.bounds.scale * (v.size / 2)\n\t\t\t\t\t\t\t} : null;\n\t\t\t\t\t\t}, this);\n\t\n\t\t\t\t\tif(run.hidden){\n\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\t\trun.dyn.stroke =  theme.series.stroke;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ts = run.group;\n\t                \n\t\t\t\t\tvar frontCircles = null, outlineCircles = null, shadowCircles = null, styleFunc = this.opt.styleFunc;\n\t\n\t\t\t\t\tvar getFinalTheme = function(item){\n\t\t\t\t\t\tif(styleFunc){\n\t\t\t\t\t\t\treturn t.addMixin(theme, \"circle\", [item, styleFunc(item)], true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn t.addMixin(theme, \"circle\", item, true);\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// make shadows if needed\n\t\t\t\t\tif(theme.series.shadow){\n\t\t\t\t\t\tshadowCircles = arr.map(points, function(item, i){\n\t\t\t\t\t\t\tif(!this.isNullValue(item)){\n\t\t\t\t\t\t\t\tvar finalTheme = getFinalTheme(run.data[i]),\n\t\t\t\t\t\t\t\t\tshadow = finalTheme.series.shadow;\n\t\t\t\t\t\t\t\tvar shape = s.createCircle({\n\t\t\t\t\t\t\t\t\tcx: item.x + shadow.dx, cy: item.y + shadow.dy, r: item.radius\n\t\t\t\t\t\t\t\t}).setStroke(shadow).setFill(shadow.color);\n\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\tthis._animateBubble(shape, dim.height - offsets.b, item.radius);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\tif(shadowCircles.length){\n\t\t\t\t\t\t\trun.dyn.shadow = shadowCircles[shadowCircles.length - 1].getStroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// make outlines if needed\n\t\t\t\t\tif(theme.series.outline){\n\t\t\t\t\t\toutlineCircles = arr.map(points, function(item, i){\n\t\t\t\t\t\t\tif(!this.isNullValue(item)){\n\t\t\t\t\t\t\t\tvar finalTheme = getFinalTheme(run.data[i]),\n\t\t\t\t\t\t\t\t\toutline = dc.makeStroke(finalTheme.series.outline);\n\t\t\t\t\t\t\t\toutline.width = 2 * outline.width + (theme.series.stroke && theme.series.stroke.width || 0);\n\t\t\t\t\t\t\t\tvar shape = s.createCircle({\n\t\t\t\t\t\t\t\t\tcx: item.x, cy: item.y, r: item.radius\n\t\t\t\t\t\t\t\t}).setStroke(outline);\n\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\tthis._animateBubble(shape, dim.height - offsets.b, item.radius);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\tif(outlineCircles.length){\n\t\t\t\t\t\t\trun.dyn.outline = outlineCircles[outlineCircles.length - 1].getStroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//\trun through the data and add the circles.\n\t\t\t\t\tfrontCircles = arr.map(points, function(item, i){\n\t\t\t\t\t\tif(!this.isNullValue(item)){\n\t\t\t\t\t\t\tvar finalTheme = getFinalTheme(run.data[i]),\n\t\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\t\tx: item.x - item.radius,\n\t\t\t\t\t\t\t\t\ty: item.y - item.radius,\n\t\t\t\t\t\t\t\t\twidth:  2 * item.radius,\n\t\t\t\t\t\t\t\t\theight: 2 * item.radius\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tvar specialFill = this._plotFill(finalTheme.series.fill, dim, offsets);\n\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, rect);\n\t\t\t\t\t\t\tvar shape = s.createCircle({\n\t\t\t\t\t\t\t\tcx: item.x, cy: item.y, r: item.radius\n\t\t\t\t\t\t\t}).setFill(specialFill).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\tif(shape.setFilter && finalTheme.series.filter){\n\t\t\t\t\t\t\t\tshape.setFilter(finalTheme.series.filter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateBubble(shape, dim.height - offsets.b, item.radius);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.createLabel(s, run.data[i], rect, finalTheme);\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}, this);\n\t\t\t\t\tif(frontCircles.length){\n\t\t\t\t\t\trun.dyn.fill   = frontCircles[frontCircles.length - 1].getFill();\n\t\t\t\t\t\trun.dyn.stroke = frontCircles[frontCircles.length - 1].getStroke();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif(events){\n\t\t\t\t\t\tvar eventSeries = new Array(frontCircles.length);\n\t\t\t\t\t\tarr.forEach(frontCircles, function(s, i){\n\t\t\t\t\t\t\tif(s !== null){\n\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\telement: \"circle\",\n\t\t\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\tshape:   s,\n\t\t\t\t\t\t\t\t\toutline: outlineCircles && outlineCircles[i] || null,\n\t\t\t\t\t\t\t\t\tshadow:  shadowCircles && shadowCircles[i] || null,\n\t\t\t\t\t\t\t\t\tx:       run.data[i].x,\n\t\t\t\t\t\t\t\t\ty:       run.data[i].y,\n\t\t\t\t\t\t\t\t\tr:       run.data[i].size / 2,\n\t\t\t\t\t\t\t\t\tcx:      points[i].x,\n\t\t\t\t\t\t\t\t\tcy:      points[i].y,\n\t\t\t\t\t\t\t\t\tcr:      points[i].radius\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdelete this._eventSeries[run.name];\n\t\t\t\t\t}\n\t\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Bubble\n\t\t\t},\n\t\t\t_animateBubble: function(shape, offset, size){\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: [0, offset], end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: [0, 1/size], end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 222 */\n/*!************************************************!*\\\n  !*** ../dojox/charting/plot2d/Candlesticks.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/has */ 5), __webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165),\n\t\t\t__webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\t\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\t\t//\tCandlesticks are based on the Bars plot type; we expect the following passed\n\t\t//\tas values in a series:\n\t\t//\t{ x?, open, close, high, low, mid? }\n\t\t//\tif x is not provided, the array index is used.\n\t\t//\tfailing to provide the OHLC values will throw an error.\n\t\treturn declare(\"dojox.charting.plot2d.Candlesticks\", [CartesianBase, _PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tA plot that represents typical candlesticks (financial reporting, primarily).\n\t\t\t//\t\tUnlike most charts, the Candlestick expects data points to be represented by\n\t\t\t//\t\tan object of the form { x?, open, close, high, low, mid? }, where both\n\t\t\t//\t\tx and mid are optional parameters.  If x is not provided, the index of the\n\t\t\t//\t\tdata array is used.\n\t\t\tdefaultParams: {\n\t\t\t\tgap:\t2,\t\t// gap between columns in pixels\n\t\t\t\tanimate: null   // animate bars into place\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tminBarSize:\t1,\t// minimal candle width in pixels\n\t\t\t\tmaxBarSize:\t1,\t// maximal candle width in pixels\n\t\t\t\t// theme component\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\"\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for a candlestick chart.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t},\n\t\n\t\t\tcollectStats: function(series){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCollect all statistics for drawing this chart.  Since the common\n\t\t\t\t//\t\tfunctionality only assumes x and y, Candlesticks must create it's own\n\t\t\t\t//\t\tstats (since data has no y value, but open/close/high/low instead).\n\t\t\t\t// series: dojox.charting.Series[]\n\t\t\t\t//\t\tThe data series array to be drawn on this plot.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tReturns an object in the form of { hmin, hmax, vmin, vmax }.\n\t\n\t\t\t\t//\twe have to roll our own, since we need to use all four passed\n\t\t\t\t//\tvalues to figure out our stats, and common only assumes x and y.\n\t\t\t\tvar stats = lang.delegate(dc.defaultStats);\n\t\t\t\tfor(var i=0; i<series.length; i++){\n\t\t\t\t\tvar run = series[i];\n\t\t\t\t\tif(!run.data.length){ continue; }\n\t\t\t\t\tvar old_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\t\tif(!(\"ymin\" in run) || !(\"ymax\" in run)){\n\t\t\t\t\t\tarr.forEach(run.data, function(val, idx){\n\t\t\t\t\t\t\tif(!this.isNullValue(val)){\n\t\t\t\t\t\t\t\tvar x = val.x || idx + 1;\n\t\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t\t}\n\t\t\t\treturn stats;\t//\tObject\n\t\t\t},\n\t\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = this.collectStats(this.series);\n\t\t\t\tstats.hmin -= 0.5;\n\t\t\t\tstats.hmax += 0.5;\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t\t// returns: dojox/charting/plot2d/Candlesticks\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tvar s;\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\ts = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\t\t\tvar t = this.chart.theme, f, gap, width,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\tevents = this.events();\n\t\t\t\tf = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt);\n\t\t\t\tgap = f.gap;\n\t\t\t\twidth = f.size;\n\t\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tvar theme = t.next(\"candlestick\", [this.opt, run]),\n\t\t\t\t\t\teventSeries = new Array(run.data.length);\n\t\n\t\t\t\t\tif(run.hidden){\n\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\t\trun.dyn.stroke =  theme.series.stroke;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ts = run.group;\n\t                \n\t\t\t\t\tfor(var j = 0; j < run.data.length; ++j){\n\t\t\t\t\t\tvar v = run.data[j];\n\t\t\t\t\t\tif(!this.isNullValue(v)){\n\t\t\t\t\t\t\tvar finalTheme = t.addMixin(theme, \"candlestick\", v, true);\n\t\n\t\t\t\t\t\t\t//\tcalculate the points we need for OHLC\n\t\t\t\t\t\t\tvar x = ht(v.x || (j+0.5)) + offsets.l + gap,\n\t\t\t\t\t\t\t\ty = dim.height - offsets.b,\n\t\t\t\t\t\t\t\topen = vt(v.open),\n\t\t\t\t\t\t\t\tclose = vt(v.close),\n\t\t\t\t\t\t\t\thigh = vt(v.high),\n\t\t\t\t\t\t\t\tlow = vt(v.low);\n\t\t\t\t\t\t\tif(\"mid\" in v){\n\t\t\t\t\t\t\t\tvar mid = vt(v.mid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(low > high){\n\t\t\t\t\t\t\t\tvar tmp = high;\n\t\t\t\t\t\t\t\thigh = low;\n\t\t\t\t\t\t\t\tlow = tmp;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif(width >= 1){\n\t\t\t\t\t\t\t\t//\tdraw the line and rect, set up as a group and pass that to the events.\n\t\t\t\t\t\t\t\tvar doFill = open > close;\n\t\t\t\t\t\t\t\tvar line = { x1: width/2, x2: width/2, y1: y - high, y2: y - low },\n\t\t\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\t\t\tx: 0, y: y-Math.max(open, close),\n\t\t\t\t\t\t\t\t\t\twidth: width, height: Math.max(doFill ? open-close : close-open, 1)\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tvar shape = s.createGroup();\n\t\t\t\t\t\t\t\tshape.setTransform({dx: x, dy: 0 });\n\t\t\t\t\t\t\t\tvar inner = shape.createGroup();\n\t\t\t\t\t\t\t\tinner.createLine(line).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\t\tinner.createRect(rect).setStroke(finalTheme.series.stroke).\n\t\t\t\t\t\t\t\t\tsetFill(doFill ? finalTheme.series.fill : \"white\");\n\t\t\t\t\t\t\t\tif(\"mid\" in v){\n\t\t\t\t\t\t\t\t\t//\tadd the mid line.\n\t\t\t\t\t\t\t\t\tinner.createLine({\n\t\t\t\t\t\t\t\t\t\t\tx1: (finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1), x2: width - (finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1),\n\t\t\t\t\t\t\t\t\t\ty1: y - mid, y2: y - mid\n\t\t\t\t\t\t\t\t\t}).setStroke(doFill ? \"white\" : finalTheme.series.stroke);\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// TODO: double check this.\n\t\t\t\t\t\t\t\trun.dyn.fill   = finalTheme.series.fill;\n\t\t\t\t\t\t\t\trun.dyn.stroke = finalTheme.series.stroke;\n\t\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\t\telement: \"candlestick\",\n\t\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\t\tshape:   inner,\n\t\t\t\t\t\t\t\t\t\tx:       x,\n\t\t\t\t\t\t\t\t\t\ty:       y-Math.max(open, close),\n\t\t\t\t\t\t\t\t\t\tcx:\t\t width/2,\n\t\t\t\t\t\t\t\t\t\tcy:\t\t (y-Math.max(open, close)) + (Math.max(doFill ? open-close : close-open, 1)/2),\n\t\t\t\t\t\t\t\t\t\twidth:\t width,\n\t\t\t\t\t\t\t\t\t\theight:  Math.max(doFill ? open-close : close-open, 1),\n\t\t\t\t\t\t\t\t\t\tdata:\t v\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateCandlesticks(shape, y - low, high - low);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Candlesticks\n\t\t\t},\n\t\n\t\t\ttooltipFunc: function(o){\n\t\t\t\treturn '<table cellpadding=\"1\" cellspacing=\"0\" border=\"0\" style=\"font-size:0.9em;\">'\n\t\t\t\t\t\t\t+ '<tr><td>Open:</td><td align=\"right\"><strong>' + o.data.open + '</strong></td></tr>'\n\t\t\t\t\t\t\t+ '<tr><td>High:</td><td align=\"right\"><strong>' + o.data.high + '</strong></td></tr>'\n\t\t\t\t\t\t\t+ '<tr><td>Low:</td><td align=\"right\"><strong>' + o.data.low + '</strong></td></tr>'\n\t\t\t\t\t\t\t+ '<tr><td>Close:</td><td align=\"right\"><strong>' + o.data.close + '</strong></td></tr>'\n\t\t\t\t\t\t\t+ (o.data.mid !== undefined ? '<tr><td>Mid:</td><td align=\"right\"><strong>' + o.data.mid + '</strong></td></tr>' : '')\n\t\t\t\t\t\t\t+ '</table>';\n\t\t\t},\n\t\n\t\t\t_animateCandlesticks: function(shape, voffset, vsize){\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: [0, voffset - (voffset/vsize)], end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: [1, 1/vsize], end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 223 */\n/*!****************************************!*\\\n  !*** ../dojox/charting/plot2d/OHLC.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/array */ 13), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/has */ 5), __webpack_require__(/*! ./CartesianBase */ 181), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165),\n\t\t__webpack_require__(/*! dojox/lang/functional */ 175), __webpack_require__(/*! dojox/lang/functional/reversed */ 189), __webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojox/gfx/fx */ 186)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\t\n\t\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\t\t//\tCandlesticks are based on the Bars plot type; we expect the following passed\n\t\t//\tas values in a series:\n\t\t//\t{ x?, open, close, high, low }\n\t\t//\tif x is not provided, the array index is used.\n\t\t//\tfailing to provide the OHLC values will throw an error.\n\t\treturn declare(\"dojox.charting.plot2d.OHLC\", [CartesianBase, _PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tA plot that represents typical open/high/low/close (financial reporting, primarily).\n\t\t\t//\t\tUnlike most charts, the Candlestick expects data points to be represented by\n\t\t\t//\t\tan object of the form { x?, open, close, high, low, mid? }, where both\n\t\t\t//\t\tx and mid are optional parameters.  If x is not provided, the index of the\n\t\t\t//\t\tdata array is used.\n\t\t\tdefaultParams: {\n\t\t\t\tgap:\t2,\t\t// gap between columns in pixels\n\t\t\t\tanimate: null\t// animate chart to place\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tminBarSize: 1,\t// minimal bar size in pixels\n\t\t\t\tmaxBarSize: 1,\t// maximal bar size in pixels\n\t\t\t\t// theme component\n\t\t\t\tstroke:\t\t{},\n\t\t\t\toutline:\t{},\n\t\t\t\tshadow:\t\t{},\n\t\t\t\tfill:\t\t{},\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\"\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThe constructor for a candlestick chart.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.animate = this.opt.animate;\n\t\t\t},\n\t\n\t\t\tcollectStats: function(series){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCollect all statistics for drawing this chart.  Since the common\n\t\t\t\t//\t\tfunctionality only assumes x and y, OHLC must create it's own\n\t\t\t\t//\t\tstats (since data has no y value, but open/close/high/low instead).\n\t\t\t\t// series: dojox/charting/Series[]\n\t\t\t\t//\t\tThe data series array to be drawn on this plot.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\tReturns an object in the form of { hmin, hmax, vmin, vmax }.\n\t\n\t\t\t\t//\twe have to roll our own, since we need to use all four passed\n\t\t\t\t//\tvalues to figure out our stats, and common only assumes x and y.\n\t\t\t\tvar stats = lang.delegate(dc.defaultStats);\n\t\t\t\tfor(var i=0; i<series.length; i++){\n\t\t\t\t\tvar run = series[i];\n\t\t\t\t\tif(!run.data.length){ continue; }\n\t\t\t\t\tvar old_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\t\tif(!(\"ymin\" in run) || !(\"ymax\" in run)){\n\t\t\t\t\t\tarr.forEach(run.data, function(val, idx){\n\t\t\t\t\t\t\tif(!this.isNullValue(val)){\n\t\t\t\t\t\t\t\tvar x = val.x || idx + 1;\n\t\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t\t}\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\tvar stats = this.collectStats(this.series);\n\t\t\t\tstats.hmin -= 0.5;\n\t\t\t\tstats.hmax += 0.5;\n\t\t\t\treturn stats; // Object\n\t\t\t},\n\t\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t\t// returns: dojox/charting/plot2d/OHLC\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t\t}\n\t\t\t\tthis.resetEvents();\n\t\t\t\tthis.dirty = this.isDirty();\n\t\t\t\tif(this.dirty){\n\t\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\t\tthis._eventSeries = {};\n\t\t\t\t\tthis.cleanGroup();\n\t\t\t\t\tvar s = this.getGroup();\n\t\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t\t}\n\t\t\t\tvar t = this.chart.theme, f, gap, width,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\tevents = this.events();\n\t\t\t\tf = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt);\n\t\t\t\tgap = f.gap;\n\t\t\t\twidth = f.size;\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tvar run = this.series[i];\n\t\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trun.cleanGroup();\n\t\t\t\t\tvar theme = t.next(\"candlestick\", [this.opt, run]), s = run.group,\n\t\t\t\t\t\teventSeries = new Array(run.data.length);\n\t\t\t\t\tfor(var j = 0; j < run.data.length; ++j){\n\t\t\t\t\t\tvar v = run.data[j];\n\t\t\t\t\t\tif(!this.isNullValue(v)){\n\t\t\t\t\t\t\tvar finalTheme = t.addMixin(theme, \"candlestick\", v, true);\n\t\n\t\t\t\t\t\t\t//\tcalculate the points we need for OHLC\n\t\t\t\t\t\t\tvar x = ht(v.x || (j+0.5)) + offsets.l + gap,\n\t\t\t\t\t\t\t\ty = dim.height - offsets.b,\n\t\t\t\t\t\t\t\topen = vt(v.open),\n\t\t\t\t\t\t\t\tclose = vt(v.close),\n\t\t\t\t\t\t\t\thigh = vt(v.high),\n\t\t\t\t\t\t\t\tlow = vt(v.low);\n\t\t\t\t\t\t\tif(low > high){\n\t\t\t\t\t\t\t\tvar tmp = high;\n\t\t\t\t\t\t\t\thigh = low;\n\t\t\t\t\t\t\t\tlow = tmp;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif(width >= 1){\n\t\t\t\t\t\t\t\tvar hl = {x1: width/2, x2: width/2, y1: y - high, y2: y - low},\n\t\t\t\t\t\t\t\t\top = {x1: 0, x2: ((width/2) + ((finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1)/2)), y1: y-open, y2: y-open},\n\t\t\t\t\t\t\t\t\tcl = {x1: ((width/2) - ((finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1)/2)), x2: width, y1: y-close, y2: y-close};\n\t\t\t\t\t\t\t\tvar shape = s.createGroup();\n\t\t\t\t\t\t\t\tshape.setTransform({dx: x, dy: 0});\n\t\t\t\t\t\t\t\tvar inner = shape.createGroup();\n\t\t\t\t\t\t\t\tinner.createLine(hl).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\t\tinner.createLine(op).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\t\tinner.createLine(cl).setStroke(finalTheme.series.stroke);\n\t\n\t\t\t\t\t\t\t\t// TODO: double check this.\n\t\t\t\t\t\t\t\trun.dyn.stroke = finalTheme.series.stroke;\n\t\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\t\telement: \"candlestick\",\n\t\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\t\tshape:\t inner,\n\t\t\t\t\t\t\t\t\t\tx:       x,\n\t\t\t\t\t\t\t\t\t\ty:       y-Math.max(open, close),\n\t\t\t\t\t\t\t\t\t\tcx:\t\t width/2,\n\t\t\t\t\t\t\t\t\t\tcy:\t\t (y-Math.max(open, close)) + (Math.max(open > close ? open-close : close-open, 1)/2),\n\t\t\t\t\t\t\t\t\t\twidth:\t width,\n\t\t\t\t\t\t\t\t\t\theight:  Math.max(open > close ? open-close : close-open, 1),\n\t\t\t\t\t\t\t\t\t\tdata:\t v\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateOHLC(shape, y - low, high - low);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.dirty = false;\n\t\t\t\t// chart mirroring starts\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t\t}\n\t\t\t\t// chart mirroring ends\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/OHLC\n\t\t\t},\n\t\t\t_animateOHLC: function(shape, voffset, vsize){\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform: [\n\t\t\t\t\t\t{name: \"translate\", start: [0, voffset - (voffset/vsize)], end: [0, 0]},\n\t\t\t\t\t\t{name: \"scale\", start: [1, 1/vsize], end: [1, 1]},\n\t\t\t\t\t\t{name: \"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t});\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 224 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/plot2d/Spider.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9), __webpack_require__(/*! dojo/_base/declare */ 33), __webpack_require__(/*! dojo/_base/connect */ 42), __webpack_require__(/*! dojo/_base/array */ 13),\n\t\t__webpack_require__(/*! dojo/dom-geometry */ 36), __webpack_require__(/*! dojo/_base/fx */ 119), __webpack_require__(/*! dojo/fx */ 225), __webpack_require__(/*! dojo/sniff */ 10),\n\t\t__webpack_require__(/*! ./Base */ 182), __webpack_require__(/*! ./_PlotEvents */ 188), __webpack_require__(/*! ./common */ 165), __webpack_require__(/*! ../axis2d/common */ 184),\n\t\t__webpack_require__(/*! dojox/gfx */ 166), __webpack_require__(/*! dojox/gfx/matrix */ 170), __webpack_require__(/*! dojox/gfx/fx */ 186), __webpack_require__(/*! dojox/lang/functional */ 175),\n\t\t__webpack_require__(/*! dojox/lang/utils */ 187), __webpack_require__(/*! dojo/fx/easing */ 226)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, declare, hub, arr, domGeom, baseFx, coreFx, has,\n\t\t\t\tBase, PlotEvents, dc, da, g, m, gfxfx, df, du, easing){\n\t\n\t\tvar FUDGE_FACTOR = 0.2; // use to overlap fans\n\t\n\t\tvar Spider = declare(\"dojox.charting.plot2d.Spider\", [Base, PlotEvents], {\n\t\t\t// summary:\n\t\t\t//\t\tThe plot that represents a typical Spider chart.\n\t\t\tdefaultParams: {\n\t\t\t\tlabels:\t\t\ttrue,\n\t\t\t\tticks:\t\t\tfalse,\n\t\t\t\tfixed:\t\t\ttrue,\n\t\t\t\tprecision:\t\t1,\n\t\t\t\tlabelOffset:\t-10,\n\t\t\t\tlabelStyle:\t\t\"default\",\t// default/rows/auto\n\t\t\t\thtmlLabels:\t\ttrue,\t\t// use HTML to draw labels\n\t\t\t\tstartAngle:\t\t-90,\t\t// start angle for slices in degrees\n\t\t\t\tdivisions:\t\t 3,\t\t\t// radius tick count\n\t\t\t\taxisColor:\t\t \"\",\t\t// spider axis color\n\t\t\t\taxisWidth:\t\t 0,\t\t\t// spider axis stroke width\n\t\t\t\tspiderColor:\t \"\",\t\t// spider web color\n\t\t\t\tspiderWidth:\t 0,\t\t\t// spider web stroke width\n\t\t\t\tseriesWidth:\t 0,\t\t\t// plot border with\n\t\t\t\tseriesFillAlpha: 0.2,\t\t// plot fill alpha\n\t\t\t\tspiderOrigin:\t 0.16,\n\t\t\t\tmarkerSize:\t\t 3,\t\t\t// radius of plot vertex (px)\n\t\t\t\tspiderType:\t\t \"polygon\", //\"circle\"\n\t\t\t\tanimationType:\t easing.backOut,\n\t\t\t\tanimate: null,\n\t\t\t\taxisTickFont:\t\t\"\",\n\t\t\t\taxisTickFontColor:\t\"\",\n\t\t\t\taxisFont:\t\t\t\"\",\n\t\t\t\taxisFontColor:\t\t\"\"\n\t\t\t},\n\t\t\toptionalParams: {\n\t\t\t\tradius:\t\t0,\n\t\t\t\tfont:\t\t\"\",\n\t\t\t\tfontColor:\t\"\"\n\t\t\t},\n\t\n\t\t\tconstructor: function(chart, kwArgs){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCreate a Spider plot.\n\t\t\t\t// chart: dojox/charting/Chart\n\t\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t\t//\t\tAn optional keyword arguments object to help define this plot's parameters.\n\t\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t\tthis.dyn = [];\n\t\t\t\tthis.datas = {};\n\t\t\t\tthis.labelKey = [];\n\t\t\t\tthis.oldSeriePoints = {};\n\t\t\t\tthis.animate = this.opt.animate === null ? {} : this.opt.animate;\n\t\t\t\tthis.animations = {};\n\t\t\t},\n\t\t\tclear: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t\t// returns: dojox/charting/plot2d/Spider\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.inherited(arguments);\n\t\t\t\tthis.dyn = [];\n\t\t\t\tthis.axes = [];\n\t\t\t\tthis.datas = {};\n\t\t\t\tthis.labelKey = [];\n\t\t\t\tthis.oldSeriePoints = {};\n\t\t\t\tthis.animations = {};\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Spider\n\t\t\t},\n\t\t\tsetAxis: function(axis){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tOptionally set axis min and max property.\n\t\t\t\t// returns: dojox/charting/plot2d/Spider\n\t\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\n\t\t\t\t// override the computed min/max with provided values if any\n\t\t\t\tif(axis){\n\t\t\t\t\tif(axis.opt.min != undefined){\n\t\t\t\t\t\tthis.datas[axis.name].min = axis.opt.min;\n\t\t\t\t\t}\n\t\t\t\t\tif(axis.opt.max != undefined){\n\t\t\t\t\t\tthis.datas[axis.name].max = axis.opt.max;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Spider\n\t\t\t},\n\t\t\taddSeries: function(run){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tAdd a data series to this plot.\n\t\t\t\t// run: dojox.charting.Series\n\t\t\t\t//\t\tThe series to be added.\n\t\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tthis.series.push(run);\n\t\t\t\tvar key;\n\t\t\t\tfor(key in run.data){\n\t\t\t\t\tvar val = run.data[key],\n\t\t\t\t\t\tdata = this.datas[key];\n\t\t\t\t\tif(data){\n\t\t\t\t\t\tdata.vlist.push(val);\n\t\t\t\t\t\tdata.min = Math.min(data.min, val);\n\t\t\t\t\t\tdata.max = Math.max(data.max, val);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar axisKey = \"__\"+key;\n\t\t\t\t\t\tthis.axes.push(axisKey);\n\t\t\t\t\t\tthis[axisKey] = key;\n\t\t\t\t\t\tthis.datas[key] = {min: val, max: val, vlist: [val]};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.labelKey.length <= 0){\n\t\t\t\t\tfor(key in run.data){\n\t\t\t\t\t\tthis.labelKey.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox.charting.plot2d.Base\n\t\t\t},\n\t\t\tgetSeriesStats: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t\t// returns: Object\n\t\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\t\treturn dc.collectSimpleStats(this.series, function(v){ return v === null; }); // Object\n\t\t\t},\n\t\t\trender: function(dim, offsets){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tRender the plot on the chart.\n\t\t\t\t// dim: Object\n\t\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t\t// offsets: Object\n\t\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t\t// returns: dojox/charting/plot2d/Spider\n\t\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\t\tif(!this.dirty){ return this; }\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.cleanGroup();\n\t\t\t\tvar s = this.group, t = this.chart.theme;\n\t\t\t\tthis.resetEvents();\n\t\n\t\t\t\tif(!this.series || !this.series.length){\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\n\t\t\t\t// calculate the geometry\n\t\t\t\tvar o = this.opt, ta = t.axis,\n\t\t\t\t\trx = (dim.width\t - offsets.l - offsets.r) / 2,\n\t\t\t\t\try = (dim.height - offsets.t - offsets.b) / 2,\n\t\t\t\t\tr  = Math.min(rx, ry),\n\t\t\t\t\taxisTickFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font) || \"normal normal normal 7pt Tahoma\",\n\t\t\t\t\taxisFont = o.axisFont || (ta.tick && ta.tick.titleFont) || \"normal normal normal 11pt Tahoma\",\n\t\t\t\t\taxisTickFontColor = o.axisTickFontColor || (ta.majorTick && ta.majorTick.fontColor) || (ta.tick && ta.tick.fontColor) || \"silver\",\n\t\t\t\t\taxisFontColor = o.axisFontColor || (ta.tick && ta.tick.titleFontColor) || \"black\",\n\t\t\t\t\taxisColor = o.axisColor || (ta.tick && ta.tick.axisColor) || \"silver\",\n\t\t\t\t\tspiderColor = o.spiderColor || (ta.tick && ta.tick.spiderColor) || \"silver\",\n\t\t\t\t\taxisWidth = o.axisWidth || (ta.stroke && ta.stroke.width) || 2,\n\t\t\t\t\tspiderWidth = o.spiderWidth || (ta.stroke && ta.stroke.width) || 2,\n\t\t\t\t\tseriesWidth = o.seriesWidth || (ta.stroke && ta.stroke.width) || 2,\n\t\t\t\t\tasize = g.normalizedLength(g.splitFontString(axisFont).size),\n\t\t\t\t\tstartAngle = m._degToRad(o.startAngle),\n\t\t\t\t\tstart = startAngle, labels, shift, labelR,\n\t\t\t\t\touterPoints, innerPoints, divisionPoints, divisionRadius, labelPoints,\n\t\t\t\t\tro = o.spiderOrigin, dv = o.divisions >= 3 ? o.divisions : 3, ms = o.markerSize,\n\t\t\t\t\tspt = o.spiderType, at = o.animationType, lboffset = o.labelOffset < -10 ? o.labelOffset : -10,\n\t\t\t\t\taxisExtra = 0.2,\n\t\t\t\t\ti, j, point, len, fontWidth, render, serieEntry, run, data, min, max, distance;\n\t\t\t\t\n\t\t\t\tif(o.labels){\n\t\t\t\t\tlabels = arr.map(this.series, function(s){\n\t\t\t\t\t\treturn s.name;\n\t\t\t\t\t}, this);\n\t\t\t\t\tshift = df.foldl1(df.map(labels, function(label){\n\t\t\t\t\t\tvar font = t.series.font;\n\t\t\t\t\t\treturn g._base._getTextBox(label, {\n\t\t\t\t\t\t\tfont: font\n\t\t\t\t\t\t}).w;\n\t\t\t\t\t}, this), \"Math.max(a, b)\") / 2;\n\t\t\t\t\tr = Math.min(rx - 2 * shift, ry - asize) + lboffset;\n\t\t\t\t\tlabelR = r - lboffset;\n\t\t\t\t}\n\t\t\t\tif(\"radius\" in o){\n\t\t\t\t\tr = o.radius;\n\t\t\t\t\tlabelR = r - lboffset;\n\t\t\t\t}\n\t\t\t\tr /= (1+axisExtra);\n\t\t\t\tvar circle = {\n\t\t\t\t\tcx: offsets.l + rx,\n\t\t\t\t\tcy: offsets.t + ry,\n\t\t\t\t\tr: r\n\t\t\t\t};\n\t\n\t\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\t\tserieEntry = this.series[i];\n\t\t\t\t\tif(!this.dirty && !serieEntry.dirty){\n\t\t\t\t\t\tt.skip();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tserieEntry.cleanGroup();\n\t\t\t\t\trun = serieEntry.data;\n\t\t\t\t\tif(run !== null){\n\t\t\t\t\t\tlen = this._getObjectLength(run);\n\t\t\t\t\t\t//construct connect points\n\t\t\t\t\t\tif(!outerPoints || outerPoints.length <= 0){\n\t\t\t\t\t\t\touterPoints = [], innerPoints = [], labelPoints = [];\n\t\t\t\t\t\t\tthis._buildPoints(outerPoints, len, circle, r, start, true, dim);\n\t\t\t\t\t\t\tthis._buildPoints(innerPoints, len, circle, r*ro, start, true, dim);\n\t\t\t\t\t\t\tthis._buildPoints(labelPoints, len, circle, labelR, start, false, dim);\n\t\t\t\t\t\t\tif(dv > 2){\n\t\t\t\t\t\t\t\tdivisionPoints = [], divisionRadius = [];\n\t\t\t\t\t\t\t\tfor (j = 0; j < dv - 2; j++){\n\t\t\t\t\t\t\t\t\tdivisionPoints[j] = [];\n\t\t\t\t\t\t\t\t\tthis._buildPoints(divisionPoints[j], len, circle, r*(ro + (1-ro)*(j+1)/(dv-1)), start, true, dim);\n\t\t\t\t\t\t\t\t\tdivisionRadius[j] = r*(ro + (1-ro)*(j+1)/(dv-1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//draw Spider\n\t\t\t\t//axis\n\t\t\t\tvar axisGroup = s.createGroup(), axisStroke = {color: axisColor, width: axisWidth},\n\t\t\t\t\tspiderStroke = {color: spiderColor, width: spiderWidth};\n\t\t\t\tfor (j = outerPoints.length - 1; j >= 0; --j){\n\t\t\t\t\tpoint = outerPoints[j];\n\t\t\t\t\tvar st = {\n\t\t\t\t\t\t\tx: point.x + (point.x - circle.cx) * axisExtra,\n\t\t\t\t\t\t\ty: point.y + (point.y - circle.cy) * axisExtra\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnd = {\n\t\t\t\t\t\t\tx: point.x + (point.x - circle.cx) * axisExtra / 2,\n\t\t\t\t\t\t\ty: point.y + (point.y - circle.cy) * axisExtra / 2\n\t\t\t\t\t\t};\n\t\t\t\t\taxisGroup.createLine({\n\t\t\t\t\t\tx1: circle.cx,\n\t\t\t\t\t\ty1: circle.cy,\n\t\t\t\t\t\tx2: st.x,\n\t\t\t\t\t\ty2: st.y\n\t\t\t\t\t}).setStroke(axisStroke);\n\t\t\t\t\t//arrow\n\t\t\t\t\tthis._drawArrow(axisGroup, st, nd, axisStroke);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// draw the label\n\t\t\t\tvar labelGroup = s.createGroup();\n\t\t\t\tfor (j = labelPoints.length - 1; j >= 0; --j){\n\t\t\t\t\tpoint = labelPoints[j];\n\t\t\t\t\tfontWidth = g._base._getTextBox(this.labelKey[j], {font: axisFont}).w || 0;\n\t\t\t\t\trender = this.opt.htmlLabels && g.renderer != \"vml\" ? \"html\" : \"gfx\";\n\t\t\t\t\tvar elem = da.createText[render](this.chart, labelGroup, (!domGeom.isBodyLtr() && render == \"html\") ? (point.x + fontWidth - dim.width) : point.x, point.y,\n\t\t\t\t\t\t\t\t\"middle\", this.labelKey[j], axisFont, axisFontColor);\n\t\t\t\t\tif(this.opt.htmlLabels){\n\t\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//spider web: polygon or circle\n\t\t\t\tvar spiderGroup = s.createGroup();\n\t\t\t\tif(spt == \"polygon\"){\n\t\t\t\t\tspiderGroup.createPolyline(outerPoints).setStroke(spiderStroke);\n\t\t\t\t\tspiderGroup.createPolyline(innerPoints).setStroke(spiderStroke);\n\t\t\t\t\tif(divisionPoints.length > 0){\n\t\t\t\t\t\tfor (j = divisionPoints.length - 1; j >= 0; --j){\n\t\t\t\t\t\t\tspiderGroup.createPolyline(divisionPoints[j]).setStroke(spiderStroke);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{//circle\n\t\t\t\t\tspiderGroup.createCircle({cx: circle.cx, cy: circle.cy, r: r}).setStroke(spiderStroke);\n\t\t\t\t\tspiderGroup.createCircle({cx: circle.cx, cy: circle.cy, r: r*ro}).setStroke(spiderStroke);\n\t\t\t\t\tif(divisionRadius.length > 0){\n\t\t\t\t\t\tfor (j = divisionRadius.length - 1; j >= 0; --j){\n\t\t\t\t\t\t\tspiderGroup.createCircle({cx: circle.cx, cy: circle.cy, r: divisionRadius[j]}).setStroke(spiderStroke);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//text\n\t\t\t\tlen = this._getObjectLength(this.datas);\n\t\t\t\tvar textGroup = s.createGroup(), k = 0;\n\t\t\t\tfor(var key in this.datas){\n\t\t\t\t\tdata = this.datas[key];\n\t\t\t\t\tmin = data.min;\n\t\t\t\t\tmax = data.max;\n\t\t\t\t\tdistance = max - min;\n\t\t\t\t\t\tend = start + 2 * Math.PI * k / len;\n\t\t\t\t\tfor (i = 0; i < dv; i++){\n\t\t\t\t\t\tvar text = min + distance*i/(dv-1);\n\t\t\t\t\t\tpoint = this._getCoordinate(circle, r*(ro + (1-ro)*i/(dv-1)), end, dim);\n\t\t\t\t\t\ttext = this._getLabel(text);\n\t\t\t\t\t\tfontWidth = g._base._getTextBox(text, {font: axisTickFont}).w || 0;\n\t\t\t\t\t\t\trender = this.opt.htmlLabels && g.renderer != \"vml\" ? \"html\" : \"gfx\";\n\t\t\t\t\t\tif(this.opt.htmlLabels){\n\t\t\t\t\t\t\tthis.htmlElements.push(da.createText[render]\n\t\t\t\t\t\t\t\t(this.chart, textGroup, (!domGeom.isBodyLtr() && render == \"html\") ? (point.x + fontWidth - dim.width) : point.x, point.y,\n\t\t\t\t\t\t\t\t\t\"start\", text, axisTickFont, axisTickFontColor));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//draw series (animation)\n\t\t\t\tthis.chart.seriesShapes = {};\n\t\t\t\tfor (i = this.series.length - 1; i >= 0; i--){\n\t\t\t\t\tserieEntry = this.series[i];\n\t\t\t\t\trun = serieEntry.data;\n\t\t\t\t\tif(run !== null){\n\t\t\t\t\t\tvar theme = t.next(\"spider\", [o, serieEntry]),\n\t\t\t\t\t\t\tf = g.normalizeColor(theme.series.fill), \n\t\t\t\t\t\t\tsk = {color: theme.series.fill, width: seriesWidth};\n\t\t\t\t\t\tf.a = o.seriesFillAlpha;\n\t\t\t\t\t\tserieEntry.dyn = {fill: f, stroke: sk};\n\t\t\t\t\t\tif(serieEntry.hidden){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//series polygon\n\t\t\t\t\t\tvar seriePoints = [], tipData = [];\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tfor(key in run){\n\t\t\t\t\t\t\tdata = this.datas[key];\n\t\t\t\t\t\t\tmin = data.min;\n\t\t\t\t\t\t\tmax = data.max;\n\t\t\t\t\t\t\tdistance = max - min;\n\t\t\t\t\t\t\tvar entry = run[key], end = start + 2 * Math.PI * k / len;\n\t\t\t\t\t\t\t\tpoint = this._getCoordinate(circle, r*(ro + (1-ro)*(entry-min)/distance), end, dim);\n\t\t\t\t\t\t\tseriePoints.push(point);\n\t\t\t\t\t\t\ttipData.push({sname: serieEntry.name, key: key, data: entry});\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseriePoints[seriePoints.length] = seriePoints[0];\n\t\t\t\t\t\ttipData[tipData.length] = tipData[0];\n\t\t\t\t\t\tvar polygonBoundRect = this._getBoundary(seriePoints),\n\t\t\t\t\t\t\tts = serieEntry.group;\n\t\t\t\t         \n\t\t\t\t\t\t\n\t\t\t\t\t\tvar osps = this.oldSeriePoints[serieEntry.name];\n\t\t\t\t\t\tvar cs = this._createSeriesEntry(ts, (osps || innerPoints), seriePoints, f, sk, r, ro, ms, at);\n\t\t\t\t\t\tthis.chart.seriesShapes[serieEntry.name] = cs;\n\t\t\t\t\t\tthis.oldSeriePoints[serieEntry.name] = seriePoints;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar po = {\n\t\t\t\t\t\t\telement: \"spider_poly\",\n\t\t\t\t\t\t\tindex:\t i,\n\t\t\t\t\t\t\tid:\t\t \"spider_poly_\"+serieEntry.name,\n\t\t\t\t\t\t\trun:\t serieEntry,\n\t\t\t\t\t\t\tplot:\t this,\n\t\t\t\t\t\t\tshape:\t cs.poly,\n\t\t\t\t\t\t\tparent:\t ts,\n\t\t\t\t\t\t\tbrect:\t polygonBoundRect,\n\t\t\t\t\t\t\tcx:\t\t circle.cx,\n\t\t\t\t\t\t\tcy:\t\t circle.cy,\n\t\t\t\t\t\t\tcr:\t\t r,\n\t\t\t\t\t\t\tf:\t\t f,\n\t\t\t\t\t\t\ts:\t\t s\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._connectEvents(po);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar so = {\n\t\t\t\t\t\t\telement: \"spider_plot\",\n\t\t\t\t\t\t\tindex:\t i,\n\t\t\t\t\t\t\tid:\t\t \"spider_plot_\"+serieEntry.name,\n\t\t\t\t\t\t\trun:\t serieEntry,\n\t\t\t\t\t\t\tplot:\t this,\n\t\t\t\t\t\t\tshape:\t serieEntry.group\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._connectEvents(so);\n\t\t\t\t\t\t\n\t\t\t\t\t\tarr.forEach(cs.circles, function(c, i){\n\t\t\t\t\t\t\tvar co = {\n\t\t\t\t\t\t\t\t\telement: \"spider_circle\",\n\t\t\t\t\t\t\t\t\tindex:\t i,\n\t\t\t\t\t\t\t\t\tid:\t\t \"spider_circle_\"+serieEntry.name+i,\n\t\t\t\t\t\t\t\t\trun:\t serieEntry,\n\t\t\t\t\t\t\t\t\tplot:\t this,\n\t\t\t\t\t\t\t\t\tshape:\t c,\n\t\t\t\t\t\t\t\t\tparent:\t ts,\n\t\t\t\t\t\t\t\t\ttdata:\t tipData[i],\n\t\t\t\t\t\t\t\t\tcx:\t\t seriePoints[i].x,\n\t\t\t\t\t\t\t\t\tcy:\t\t seriePoints[i].y,\n\t\t\t\t\t\t\t\t\tf:\t\t f,\n\t\t\t\t\t\t\t\t\ts:\t\t s\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._connectEvents(co);\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\t//\tdojox/charting/plot2d/Spider\n\t\t\t},\n\t\t\t_createSeriesEntry: function(ts, osps, sps, f, sk, r, ro, ms, at){\n\t\t\t\t//polygon\n\t\t\t\tvar initpoints = this.animate?osps:sps;\n\t\t\t\tvar spoly = ts.createPolyline(initpoints).setFill(f).setStroke(sk), scircle = [];\n\t\t\t\tfor (var j = 0; j < initpoints.length; j++){\n\t\t\t\t\tvar point = initpoints[j], cr = ms;\n\t\t\t\t\tvar circle = ts.createCircle({cx: point.x, cy: point.y, r: cr}).setFill(f).setStroke(sk);\n\t\t\t\t\tscircle.push(circle);\n\t\t\t\t}\n\t\t\t\tif(this.animate) {\n\t\t\t\t\tvar anims = arr.map(sps, function (np, j) {\n\t\t\t\t\t\t// create animation\n\t\t\t\t\t\tvar sp = osps[j],\n\t\t\t\t\t\t\tanim = new baseFx.Animation(lang.delegate({\n\t\t\t\t\t\t\t\tduration: 1000,\n\t\t\t\t\t\t\t\teasing: at,\n\t\t\t\t\t\t\t\tcurve: [sp.y, np.y]\n\t\t\t\t\t\t\t}, this.animate));\n\t\t\t\t\t\tvar spl = spoly, sc = scircle[j];\n\t\t\t\t\t\thub.connect(anim, \"onAnimate\", function (y) {\n\t\t\t\t\t\t\t//apply poly\n\t\t\t\t\t\t\tvar pshape = spl.getShape();\n\t\t\t\t\t\t\tpshape.points[j].y = y;\n\t\t\t\t\t\t\tspl.setShape(pshape);\n\t\t\t\t\t\t\t//apply circle\n\t\t\t\t\t\t\tvar cshape = sc.getShape();\n\t\t\t\t\t\t\tcshape.cy = y;\n\t\t\t\t\t\t\tsc.setShape(cshape);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn anim;\n\t\t\t\t\t}, this);\n\t\n\t\t\t\t\tvar anims1 = arr.map(sps, function (np, j) {\n\t\t\t\t\t\t// create animation\n\t\t\t\t\t\tvar sp = osps[j],\n\t\t\t\t\t\t\tanim = new baseFx.Animation(lang.delegate({\n\t\t\t\t\t\t\t\tduration: 1000,\n\t\t\t\t\t\t\t\teasing: at,\n\t\t\t\t\t\t\t\tcurve: [sp.x, np.x]\n\t\t\t\t\t\t\t}, this.animate));\n\t\t\t\t\t\tvar spl = spoly, sc = scircle[j];\n\t\t\t\t\t\thub.connect(anim, \"onAnimate\", function (x) {\n\t\t\t\t\t\t\t//apply poly\n\t\t\t\t\t\t\tvar pshape = spl.getShape();\n\t\t\t\t\t\t\tpshape.points[j].x = x;\n\t\t\t\t\t\t\tspl.setShape(pshape);\n\t\t\t\t\t\t\t//apply circle\n\t\t\t\t\t\t\tvar cshape = sc.getShape();\n\t\t\t\t\t\t\tcshape.cx = x;\n\t\t\t\t\t\t\tsc.setShape(cshape);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn anim;\n\t\t\t\t\t}, this);\n\t\t\t\t\tvar masterAnimation = coreFx.combine(anims.concat(anims1)); //dojo.fx.chain(anims);\n\t\t\t\t\tmasterAnimation.play();\n\t\t\t\t}\n\t\t\t\treturn {group :ts, poly: spoly, circles: scircle};\n\t\t\t},\n\t\t\tplotEvent: function(o){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tStub function for use by specific plots.\n\t\t\t\t// o: Object\n\t\t\t\t//\t\tAn object intended to represent event parameters.\n\t\t\t\tif(o.element == \"spider_plot\"){\n\t\t\t\t\t//dojo gfx function \"moveToFront\" not work in IE\n\t\t\t\t\tif(o.type == \"onmouseover\" && !has(\"ie\")){\n\t\t\t\t\t\to.shape.moveToFront();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\ttooltipFunc: function(o){\n\t\t\t\tif(o.element == \"spider_circle\"){\n\t\t\t\t\treturn o.tdata.sname + \"<br/>\" + o.tdata.key + \"<br/>\" + o.tdata.data;\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_getBoundary: function(points){\n\t\t\t\tvar xmax = points[0].x,\n\t\t\t\t\txmin = points[0].x,\n\t\t\t\t\tymax = points[0].y,\n\t\t\t\t\tymin = points[0].y;\n\t\t\t\tfor(var i = 0; i < points.length; i++){\n\t\t\t\t\tvar point = points[i];\n\t\t\t\t\txmax = Math.max(point.x, xmax);\n\t\t\t\t\tymax = Math.max(point.y, ymax);\n\t\t\t\t\txmin = Math.min(point.x, xmin);\n\t\t\t\t\tymin = Math.min(point.y, ymin);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tx: xmin,\n\t\t\t\t\ty: ymin,\n\t\t\t\t\twidth: xmax - xmin,\n\t\t\t\t\theight: ymax - ymin\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t_drawArrow: function(s, start, end, stroke){\n\t\t\t\tvar len = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)),\n\t\t\t\t\tsin = (end.y - start.y)/len, cos = (end.x - start.x)/len,\n\t\t\t\t\tpoint2 = {x: end.x + (len/3)*(-sin), y: end.y + (len/3)*cos},\n\t\t\t\t\tpoint3 = {x: end.x + (len/3)*sin, y: end.y + (len/3)*(-cos)};\n\t\t\t\ts.createPolyline([start, point2, point3]).setFill(stroke.color).setStroke(stroke);\n\t\t\t},\n\t\t\t\n\t\t\t_buildPoints: function(points, count, circle, radius, angle, recursive, dim){\n\t\t\t\tfor(var i = 0; i < count; i++){\n\t\t\t\t\tvar end = angle + 2 * Math.PI * i / count;\n\t\t\t\t\tpoints.push(this._getCoordinate(circle, radius, end, dim));\n\t\t\t\t}\n\t\t\t\tif(recursive){\n\t\t\t\t\tpoints.push(this._getCoordinate(circle, radius, angle + 2 * Math.PI, dim));\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t_getCoordinate: function(circle, radius, angle, dim){\n\t\t\t\tvar x = circle.cx + radius * Math.cos(angle);\n\t\t\t\tif(has(\"dojo-bidi\") && this.chart.isRightToLeft() && dim){\n\t\t\t\t\tx = dim.width - x;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: circle.cy + radius * Math.sin(angle)\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t_getObjectLength: function(obj){\n\t\t\t\tvar count = 0;\n\t\t\t\tif(lang.isObject(obj)){\n\t\t\t\t\tfor(var key in obj){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t},\n\t\n\t\t\t// utilities\n\t\t\t_getLabel: function(number){\n\t\t\t\treturn dc.getLabel(number, this.opt.fixed, this.opt.precision);\n\t\t\t}\n\t\t});\n\t\n\t\treturn Spider; // dojox/plot2d/Spider\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 225 */\n/*!*********************!*\\\n  !*** ../dojo/fx.js ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t\t__webpack_require__(/*! ./_base/lang */ 9),\r\n\t\t__webpack_require__(/*! ./Evented */ 24),\r\n\t\t__webpack_require__(/*! ./_base/kernel */ 4),\r\n\t\t__webpack_require__(/*! ./_base/array */ 13),\r\n\t\t__webpack_require__(/*! ./aspect */ 12),\r\n\t\t__webpack_require__(/*! ./_base/fx */ 119),\r\n\t\t__webpack_require__(/*! ./dom */ 14),\r\n\t\t__webpack_require__(/*! ./dom-style */ 37),\r\n\t\t__webpack_require__(/*! ./dom-geometry */ 36),\r\n\t\t__webpack_require__(/*! ./ready */ 3),\r\n\t\t__webpack_require__.dj.c(/*! dojo/fx */ 225) // for context sensitive loading of Toggler\r\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, Evented, dojo, arrayUtil, aspect, baseFx, dom, domStyle, geom, ready, require){\r\n\t\r\n\t\t// module:\r\n\t\t//\t\tdojo/fx\r\n\t\t\r\n\t\t// For back-compat, remove in 2.0.\r\n\t\tif(!dojo.isAsync){\r\n\t\t\tready(0, function(){\r\n\t\t\t\tvar requires = [\"./fx/Toggler\"];\r\n\t\t\t\trequire(requires);\t// use indirection so modules not rolled into a build\r\n\t\t\t});\r\n\t\t}\r\n\t\r\n\t\tvar coreFx = dojo.fx = {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEffects library on top of Base animations\r\n\t\t};\r\n\t\r\n\t\tvar _baseObj = {\r\n\t\t\t\t_fire: function(evt, args){\r\n\t\t\t\t\tif(this[evt]){\r\n\t\t\t\t\t\tthis[evt].apply(this, args||[]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\tvar _chain = function(animations){\r\n\t\t\tthis._index = -1;\r\n\t\t\tthis._animations = animations||[];\r\n\t\t\tthis._current = this._onAnimateCtx = this._onEndCtx = null;\r\n\t\r\n\t\t\tthis.duration = 0;\r\n\t\t\tarrayUtil.forEach(this._animations, function(a){\r\n\t\t\t\tthis.duration += a.duration;\r\n\t\t\t\tif(a.delay){ this.duration += a.delay; }\r\n\t\t\t}, this);\r\n\t\t};\r\n\t\t_chain.prototype = new Evented();\r\n\t\tlang.extend(_chain, {\r\n\t\t\t_onAnimate: function(){\r\n\t\t\t\tthis._fire(\"onAnimate\", arguments);\r\n\t\t\t},\r\n\t\t\t_onEnd: function(){\r\n\t\t\t\tthis._onAnimateCtx.remove();\r\n\t\t\t\tthis._onEndCtx.remove();\r\n\t\t\t\tthis._onAnimateCtx = this._onEndCtx = null;\r\n\t\t\t\tif(this._index + 1 == this._animations.length){\r\n\t\t\t\t\tthis._fire(\"onEnd\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// switch animations\r\n\t\t\t\t\tthis._current = this._animations[++this._index];\r\n\t\t\t\t\tthis._onAnimateCtx = aspect.after(this._current, \"onAnimate\", lang.hitch(this, \"_onAnimate\"), true);\r\n\t\t\t\t\tthis._onEndCtx = aspect.after(this._current, \"onEnd\", lang.hitch(this, \"_onEnd\"), true);\r\n\t\t\t\t\tthis._current.play(0, true);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\r\n\t\t\t\tif(!this._current){ this._current = this._animations[this._index = 0]; }\r\n\t\t\t\tif(!gotoStart && this._current.status() == \"playing\"){ return this; }\r\n\t\t\t\tvar beforeBegin = aspect.after(this._current, \"beforeBegin\", lang.hitch(this, function(){\r\n\t\t\t\t\t\tthis._fire(\"beforeBegin\");\r\n\t\t\t\t\t}), true),\r\n\t\t\t\t\tonBegin = aspect.after(this._current, \"onBegin\", lang.hitch(this, function(arg){\r\n\t\t\t\t\t\tthis._fire(\"onBegin\", arguments);\r\n\t\t\t\t\t}), true),\r\n\t\t\t\t\tonPlay = aspect.after(this._current, \"onPlay\", lang.hitch(this, function(arg){\r\n\t\t\t\t\t\tthis._fire(\"onPlay\", arguments);\r\n\t\t\t\t\t\tbeforeBegin.remove();\r\n\t\t\t\t\t\tonBegin.remove();\r\n\t\t\t\t\t\tonPlay.remove();\r\n\t\t\t\t\t}));\r\n\t\t\t\tif(this._onAnimateCtx){\r\n\t\t\t\t\tthis._onAnimateCtx.remove();\r\n\t\t\t\t}\r\n\t\t\t\tthis._onAnimateCtx = aspect.after(this._current, \"onAnimate\", lang.hitch(this, \"_onAnimate\"), true);\r\n\t\t\t\tif(this._onEndCtx){\r\n\t\t\t\t\tthis._onEndCtx.remove();\r\n\t\t\t\t}\r\n\t\t\t\tthis._onEndCtx = aspect.after(this._current, \"onEnd\", lang.hitch(this, \"_onEnd\"), true);\r\n\t\t\t\tthis._current.play.apply(this._current, arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tpause: function(){\r\n\t\t\t\tif(this._current){\r\n\t\t\t\t\tvar e = aspect.after(this._current, \"onPause\", lang.hitch(this, function(arg){\r\n\t\t\t\t\t\t\tthis._fire(\"onPause\", arguments);\r\n\t\t\t\t\t\t\te.remove();\r\n\t\t\t\t\t\t}), true);\r\n\t\t\t\t\tthis._current.pause();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tgotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){\r\n\t\t\t\tthis.pause();\r\n\t\t\t\tvar offset = this.duration * percent;\r\n\t\t\t\tthis._current = null;\r\n\t\r\n\t\t\t\tarrayUtil.some(this._animations, function(a, index){\r\n\t\t\t\t\tif(offset <= a.duration){\r\n\t\t\t\t\t\tthis._current = a;\r\n\t\t\t\t\t\tthis._index = index;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toffset -= a.duration;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}, this);\r\n\t\t\t\tif(this._current){\r\n\t\t\t\t\tthis._current.gotoPercent(offset / this._current.duration);\r\n\t\t\t\t}\r\n\t\t\t\tif (andPlay) { this.play(); }\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tstop: function(/*boolean?*/ gotoEnd){\r\n\t\t\t\tif(this._current){\r\n\t\t\t\t\tif(gotoEnd){\r\n\t\t\t\t\t\tfor(; this._index + 1 < this._animations.length; ++this._index){\r\n\t\t\t\t\t\t\tthis._animations[this._index].stop(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis._current = this._animations[this._index];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar e = aspect.after(this._current, \"onStop\", lang.hitch(this, function(arg){\r\n\t\t\t\t\t\t\tthis._fire(\"onStop\", arguments);\r\n\t\t\t\t\t\t\te.remove();\r\n\t\t\t\t\t\t}), true);\r\n\t\t\t\t\tthis._current.stop();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tstatus: function(){\r\n\t\t\t\treturn this._current ? this._current.status() : \"stopped\";\r\n\t\t\t},\r\n\t\t\tdestroy: function(){\r\n\t\t\t\tthis.stop();\r\n\t\t\t\tif(this._onAnimateCtx){ this._onAnimateCtx.remove(); }\r\n\t\t\t\tif(this._onEndCtx){ this._onEndCtx.remove(); }\r\n\t\t\t}\r\n\t\t});\r\n\t\tlang.extend(_chain, _baseObj);\r\n\t\r\n\t\tcoreFx.chain = function(/*dojo/_base/fx.Animation[]*/ animations){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChain a list of `dojo/_base/fx.Animation`s to run in sequence\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturn a `dojo/_base/fx.Animation` which will play all passed\r\n\t\t\t//\t\t`dojo/_base/fx.Animation` instances in sequence, firing its own\r\n\t\t\t//\t\tsynthesized events simulating a single animation. (eg:\r\n\t\t\t//\t\tonEnd of this animation means the end of the chain,\r\n\t\t\t//\t\tnot the individual animations within)\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tOnce `node` is faded out, fade in `otherNode`\r\n\t\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t\t//\t|\t\tfx.chain([\r\n\t\t\t//\t|\t\t\tfx.fadeIn({ node:node }),\r\n\t\t\t//\t|\t\t\tfx.fadeOut({ node:otherNode })\r\n\t\t\t//\t|\t\t]).play();\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\treturn new _chain(animations); // dojo/_base/fx.Animation\r\n\t\t};\r\n\t\r\n\t\tvar _combine = function(animations){\r\n\t\t\tthis._animations = animations||[];\r\n\t\t\tthis._connects = [];\r\n\t\t\tthis._finished = 0;\r\n\t\r\n\t\t\tthis.duration = 0;\r\n\t\t\tarrayUtil.forEach(animations, function(a){\r\n\t\t\t\tvar duration = a.duration;\r\n\t\t\t\tif(a.delay){ duration += a.delay; }\r\n\t\t\t\tif(this.duration < duration){ this.duration = duration; }\r\n\t\t\t\tthis._connects.push(aspect.after(a, \"onEnd\", lang.hitch(this, \"_onEnd\"), true));\r\n\t\t\t}, this);\r\n\t\r\n\t\t\tthis._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});\r\n\t\t\tvar self = this;\r\n\t\t\tarrayUtil.forEach([\"beforeBegin\", \"onBegin\", \"onPlay\", \"onAnimate\", \"onPause\", \"onStop\", \"onEnd\"],\r\n\t\t\t\tfunction(evt){\r\n\t\t\t\t\tself._connects.push(aspect.after(self._pseudoAnimation, evt,\r\n\t\t\t\t\t\tfunction(){ self._fire(evt, arguments); },\r\n\t\t\t\t\ttrue));\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t};\r\n\t\tlang.extend(_combine, {\r\n\t\t\t_doAction: function(action, args){\r\n\t\t\t\tarrayUtil.forEach(this._animations, function(a){\r\n\t\t\t\t\ta[action].apply(a, args);\r\n\t\t\t\t});\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t_onEnd: function(){\r\n\t\t\t\tif(++this._finished > this._animations.length){\r\n\t\t\t\t\tthis._fire(\"onEnd\");\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_call: function(action, args){\r\n\t\t\t\tvar t = this._pseudoAnimation;\r\n\t\t\t\tt[action].apply(t, args);\r\n\t\t\t},\r\n\t\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\r\n\t\t\t\tthis._finished = 0;\r\n\t\t\t\tthis._doAction(\"play\", arguments);\r\n\t\t\t\tthis._call(\"play\", arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tpause: function(){\r\n\t\t\t\tthis._doAction(\"pause\", arguments);\r\n\t\t\t\tthis._call(\"pause\", arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tgotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){\r\n\t\t\t\tvar ms = this.duration * percent;\r\n\t\t\t\tarrayUtil.forEach(this._animations, function(a){\r\n\t\t\t\t\ta.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);\r\n\t\t\t\t});\r\n\t\t\t\tthis._call(\"gotoPercent\", arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tstop: function(/*boolean?*/ gotoEnd){\r\n\t\t\t\tthis._doAction(\"stop\", arguments);\r\n\t\t\t\tthis._call(\"stop\", arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tstatus: function(){\r\n\t\t\t\treturn this._pseudoAnimation.status();\r\n\t\t\t},\r\n\t\t\tdestroy: function(){\r\n\t\t\t\tthis.stop();\r\n\t\t\t\tarrayUtil.forEach(this._connects, function(handle){\r\n\t\t\t\t\thandle.remove();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\tlang.extend(_combine, _baseObj);\r\n\t\r\n\t\tcoreFx.combine = function(/*dojo/_base/fx.Animation[]*/ animations){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCombine a list of `dojo/_base/fx.Animation`s to run in parallel\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tCombine an array of `dojo/_base/fx.Animation`s to run in parallel,\r\n\t\t\t//\t\tproviding a new `dojo/_base/fx.Animation` instance encompasing each\r\n\t\t\t//\t\tanimation, firing standard animation events.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tFade out `node` while fading in `otherNode` simultaneously\r\n\t\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t\t//\t|\t\tfx.combine([\r\n\t\t\t//\t|\t\t\tfx.fadeIn({ node:node }),\r\n\t\t\t//\t|\t\t\tfx.fadeOut({ node:otherNode })\r\n\t\t\t//\t|\t\t]).play();\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tWhen the longest animation ends, execute a function:\r\n\t\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t\t//\t|\t\tvar anim = fx.combine([\r\n\t\t\t//\t|\t\t\tfx.fadeIn({ node: n, duration:700 }),\r\n\t\t\t//\t|\t\t\tfx.fadeOut({ node: otherNode, duration: 300 })\r\n\t\t\t//\t|\t\t]);\r\n\t\t\t//\t|\t\taspect.after(anim, \"onEnd\", function(){\r\n\t\t\t//\t|\t\t\t// overall animation is done.\r\n\t\t\t//\t|\t\t}, true);\r\n\t\t\t//\t|\t\tanim.play(); // play the animation\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\treturn new _combine(animations); // dojo/_base/fx.Animation\r\n\t\t};\r\n\t\r\n\t\tcoreFx.wipeIn = function(/*Object*/ args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tExpand a node to it's natural height.\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns an animation that will expand the\r\n\t\t\t//\t\tnode defined in 'args' object from it's current height to\r\n\t\t\t//\t\tit's natural height (with no scrollbar).\r\n\t\t\t//\t\tNode must have no margin/border/padding.\r\n\t\t\t//\r\n\t\t\t// args: Object\r\n\t\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\r\n\t\t\t//\t\t(such as easing: node: duration: and so on)\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t\t//\t|\t\tfx.wipeIn({\r\n\t\t\t//\t|\t\t\tnode:\"someId\"\r\n\t\t\t//\t|\t\t}).play()\r\n\t\t\t//\t|\t});\r\n\t\r\n\t\t\tvar node = args.node = dom.byId(args.node), s = node.style, o;\r\n\t\r\n\t\t\tvar anim = baseFx.animateProperty(lang.mixin({\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\theight: {\r\n\t\t\t\t\t\t// wrapped in functions so we wait till the last second to query (in case value has changed)\r\n\t\t\t\t\t\tstart: function(){\r\n\t\t\t\t\t\t\t// start at current [computed] height, but use 1px rather than 0\r\n\t\t\t\t\t\t\t// because 0 causes IE to display the whole panel\r\n\t\t\t\t\t\t\to = s.overflow;\r\n\t\t\t\t\t\t\ts.overflow = \"hidden\";\r\n\t\t\t\t\t\t\tif(s.visibility == \"hidden\" || s.display == \"none\"){\r\n\t\t\t\t\t\t\t\ts.height = \"1px\";\r\n\t\t\t\t\t\t\t\ts.display = \"\";\r\n\t\t\t\t\t\t\t\ts.visibility = \"\";\r\n\t\t\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tvar height = domStyle.get(node, \"height\");\r\n\t\t\t\t\t\t\t\treturn Math.max(height, 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tend: function(){\r\n\t\t\t\t\t\t\treturn node.scrollHeight;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, args));\r\n\t\r\n\t\t\tvar fini = function(){\r\n\t\t\t\ts.height = \"auto\";\r\n\t\t\t\ts.overflow = o;\r\n\t\t\t};\r\n\t\t\taspect.after(anim, \"onStop\", fini, true);\r\n\t\t\taspect.after(anim, \"onEnd\", fini, true);\r\n\t\r\n\t\t\treturn anim; // dojo/_base/fx.Animation\r\n\t\t};\r\n\t\r\n\t\tcoreFx.wipeOut = function(/*Object*/ args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tShrink a node to nothing and hide it.\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns an animation that will shrink node defined in \"args\"\r\n\t\t\t//\t\tfrom it's current height to 1px, and then hide it.\r\n\t\t\t//\r\n\t\t\t// args: Object\r\n\t\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\r\n\t\t\t//\t\t(such as easing: node: duration: and so on)\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t\t//\t|\t\tfx.wipeOut({ node:\"someId\" }).play()\r\n\t\t\t//\t|\t});\r\n\t\r\n\t\t\tvar node = args.node = dom.byId(args.node), s = node.style, o;\r\n\t\r\n\t\t\tvar anim = baseFx.animateProperty(lang.mixin({\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\theight: {\r\n\t\t\t\t\t\tend: 1 // 0 causes IE to display the whole panel\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, args));\r\n\t\r\n\t\t\taspect.after(anim, \"beforeBegin\", function(){\r\n\t\t\t\to = s.overflow;\r\n\t\t\t\ts.overflow = \"hidden\";\r\n\t\t\t\ts.display = \"\";\r\n\t\t\t}, true);\r\n\t\t\tvar fini = function(){\r\n\t\t\t\ts.overflow = o;\r\n\t\t\t\ts.height = \"auto\";\r\n\t\t\t\ts.display = \"none\";\r\n\t\t\t};\r\n\t\t\taspect.after(anim, \"onStop\", fini, true);\r\n\t\t\taspect.after(anim, \"onEnd\", fini, true);\r\n\t\r\n\t\t\treturn anim; // dojo/_base/fx.Animation\r\n\t\t};\r\n\t\r\n\t\tcoreFx.slideTo = function(/*Object*/ args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSlide a node to a new top/left position\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns an animation that will slide \"node\"\r\n\t\t\t//\t\tdefined in args Object from its current position to\r\n\t\t\t//\t\tthe position defined by (args.left, args.top).\r\n\t\t\t//\r\n\t\t\t// args: Object\r\n\t\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\r\n\t\t\t//\t\t(such as easing: node: duration: and so on). Special args members\r\n\t\t\t//\t\tare `top` and `left`, which indicate the new position to slide to.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\t.slideTo({ node: node, left:\"40\", top:\"50\", units:\"px\" }).play()\r\n\t\r\n\t\t\tvar node = args.node = dom.byId(args.node),\r\n\t\t\t\ttop = null, left = null;\r\n\t\r\n\t\t\tvar init = (function(n){\r\n\t\t\t\treturn function(){\r\n\t\t\t\t\tvar cs = domStyle.getComputedStyle(n);\r\n\t\t\t\t\tvar pos = cs.position;\r\n\t\t\t\t\ttop = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);\r\n\t\t\t\t\tleft = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);\r\n\t\t\t\t\tif(pos != 'absolute' && pos != 'relative'){\r\n\t\t\t\t\t\tvar ret = geom.position(n, true);\r\n\t\t\t\t\t\ttop = ret.y;\r\n\t\t\t\t\t\tleft = ret.x;\r\n\t\t\t\t\t\tn.style.position=\"absolute\";\r\n\t\t\t\t\t\tn.style.top=top+\"px\";\r\n\t\t\t\t\t\tn.style.left=left+\"px\";\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t})(node);\r\n\t\t\tinit();\r\n\t\r\n\t\t\tvar anim = baseFx.animateProperty(lang.mixin({\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\ttop: args.top || 0,\r\n\t\t\t\t\tleft: args.left || 0\r\n\t\t\t\t}\r\n\t\t\t}, args));\r\n\t\t\taspect.after(anim, \"beforeBegin\", init, true);\r\n\t\r\n\t\t\treturn anim; // dojo/_base/fx.Animation\r\n\t\t};\r\n\t\r\n\t\treturn coreFx;\r\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ },\n/* 226 */\n/*!****************************!*\\\n  !*** ../dojo/fx/easing.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ 9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){\r\n\t\r\n\t// module:\r\n\t//\t\tdojo/fx/easing\r\n\t\r\n\tvar easingFuncs = {\r\n\t\t// summary:\r\n\t\t//\t\tCollection of easing functions to use beyond the default\r\n\t\t//\t\t`dojo._defaultEasing` function.\r\n\t\t// description:\r\n\t\t//\t\tEasing functions are used to manipulate the iteration through\r\n\t\t//\t\tan `dojo.Animation`s _Line. _Line being the properties of an Animation,\r\n\t\t//\t\tand the easing function progresses through that Line determining\r\n\t\t//\t\thow quickly (or slowly) it should go. Or more accurately: modify\r\n\t\t//\t\tthe value of the _Line based on the percentage of animation completed.\r\n\t\t//\r\n\t\t//\t\tAll functions follow a simple naming convention of \"ease type\" + \"when\".\r\n\t\t//\t\tIf the name of the function ends in Out, the easing described appears\r\n\t\t//\t\ttowards the end of the animation. \"In\" means during the beginning,\r\n\t\t//\t\tand InOut means both ranges of the Animation will applied, both\r\n\t\t//\t\tbeginning and end.\r\n\t\t//\r\n\t\t//\t\tOne does not call the easing function directly, it must be passed to\r\n\t\t//\t\tthe `easing` property of an animation.\r\n\t\t// example:\r\n\t\t//\t|\tdojo.require(\"dojo.fx.easing\");\r\n\t\t//\t|\tvar anim = dojo.fadeOut({\r\n\t\t//\t|\t\tnode: 'node',\r\n\t\t//\t|\t\tduration: 2000,\r\n\t\t//\t|\t\t//\tnote there is no ()\r\n\t\t//\t|\t\teasing: dojo.fx.easing.quadIn\r\n\t\t//\t|\t}).play();\r\n\t\t//\r\n\t\r\n\t\tlinear: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tA linear easing function\r\n\t\t\treturn n;\r\n\t\t},\r\n\t\r\n\t\tquadIn: function(/* Decimal? */n){\r\n\t\t\treturn Math.pow(n, 2);\r\n\t\t},\r\n\t\r\n\t\tquadOut: function(/* Decimal? */n){\r\n\t\t\treturn n * (n - 2) * -1;\r\n\t\t},\r\n\t\r\n\t\tquadInOut: function(/* Decimal? */n){\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return Math.pow(n, 2) / 2; }\r\n\t\t\treturn -1 * ((--n) * (n - 2) - 1) / 2;\r\n\t\t},\r\n\t\r\n\t\tcubicIn: function(/* Decimal? */n){\r\n\t\t\treturn Math.pow(n, 3);\r\n\t\t},\r\n\t\r\n\t\tcubicOut: function(/* Decimal? */n){\r\n\t\t\treturn Math.pow(n - 1, 3) + 1;\r\n\t\t},\r\n\t\r\n\t\tcubicInOut: function(/* Decimal? */n){\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return Math.pow(n, 3) / 2; }\r\n\t\t\tn -= 2;\r\n\t\t\treturn (Math.pow(n, 3) + 2) / 2;\r\n\t\t},\r\n\t\r\n\t\tquartIn: function(/* Decimal? */n){\r\n\t\t\treturn Math.pow(n, 4);\r\n\t\t},\r\n\t\r\n\t\tquartOut: function(/* Decimal? */n){\r\n\t\t\treturn -1 * (Math.pow(n - 1, 4) - 1);\r\n\t\t},\r\n\t\r\n\t\tquartInOut: function(/* Decimal? */n){\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return Math.pow(n, 4) / 2; }\r\n\t\t\tn -= 2;\r\n\t\t\treturn -1 / 2 * (Math.pow(n, 4) - 2);\r\n\t\t},\r\n\t\r\n\t\tquintIn: function(/* Decimal? */n){\r\n\t\t\treturn Math.pow(n, 5);\r\n\t\t},\r\n\t\r\n\t\tquintOut: function(/* Decimal? */n){\r\n\t\t\treturn Math.pow(n - 1, 5) + 1;\r\n\t\t},\r\n\t\r\n\t\tquintInOut: function(/* Decimal? */n){\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return Math.pow(n, 5) / 2; }\r\n\t\t\tn -= 2;\r\n\t\t\treturn (Math.pow(n, 5) + 2) / 2;\r\n\t\t},\r\n\t\r\n\t\tsineIn: function(/* Decimal? */n){\r\n\t\t\treturn -1 * Math.cos(n * (Math.PI / 2)) + 1;\r\n\t\t},\r\n\t\r\n\t\tsineOut: function(/* Decimal? */n){\r\n\t\t\treturn Math.sin(n * (Math.PI / 2));\r\n\t\t},\r\n\t\r\n\t\tsineInOut: function(/* Decimal? */n){\r\n\t\t\treturn -1 * (Math.cos(Math.PI * n) - 1) / 2;\r\n\t\t},\r\n\t\r\n\t\texpoIn: function(/* Decimal? */n){\r\n\t\t\treturn (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));\r\n\t\t},\r\n\t\r\n\t\texpoOut: function(/* Decimal? */n){\r\n\t\t\treturn (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);\r\n\t\t},\r\n\t\r\n\t\texpoInOut: function(/* Decimal? */n){\r\n\t\t\tif(n == 0){ return 0; }\r\n\t\t\tif(n == 1){ return 1; }\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }\r\n\t\t\t--n;\r\n\t\t\treturn (-1 * Math.pow(2, -10 * n) + 2) / 2;\r\n\t\t},\r\n\t\r\n\t\tcircIn: function(/* Decimal? */n){\r\n\t\t\treturn -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);\r\n\t\t},\r\n\t\r\n\t\tcircOut: function(/* Decimal? */n){\r\n\t\t\tn = n - 1;\r\n\t\t\treturn Math.sqrt(1 - Math.pow(n, 2));\r\n\t\t},\r\n\t\r\n\t\tcircInOut: function(/* Decimal? */n){\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }\r\n\t\t\tn -= 2;\r\n\t\t\treturn 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);\r\n\t\t},\r\n\t\r\n\t\tbackIn: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that starts away from the target,\r\n\t\t\t//\t\tand quickly accelerates towards the end value.\r\n\t\t\t//\r\n\t\t\t//\t\tUse caution when the easing will cause values to become\r\n\t\t\t//\t\tnegative as some properties cannot be set to negative values.\r\n\t\t\tvar s = 1.70158;\r\n\t\t\treturn Math.pow(n, 2) * ((s + 1) * n - s);\r\n\t\t},\r\n\t\r\n\t\tbackOut: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that pops past the range briefly, and slowly comes back.\r\n\t\t\t// description:\r\n\t\t\t//\t\tAn easing function that pops past the range briefly, and slowly comes back.\r\n\t\t\t//\r\n\t\t\t//\t\tUse caution when the easing will cause values to become negative as some\r\n\t\t\t//\t\tproperties cannot be set to negative values.\r\n\t\r\n\t\t\tn = n - 1;\r\n\t\t\tvar s = 1.70158;\r\n\t\t\treturn Math.pow(n, 2) * ((s + 1) * n + s) + 1;\r\n\t\t},\r\n\t\r\n\t\tbackInOut: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function combining the effects of `backIn` and `backOut`\r\n\t\t\t// description:\r\n\t\t\t//\t\tAn easing function combining the effects of `backIn` and `backOut`.\r\n\t\t\t//\t\tUse caution when the easing will cause values to become negative\r\n\t\t\t//\t\tas some properties cannot be set to negative values.\r\n\t\t\tvar s = 1.70158 * 1.525;\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }\r\n\t\t\tn-=2;\r\n\t\t\treturn (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;\r\n\t\t},\r\n\t\r\n\t\telasticIn: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function the elastically snaps from the start value\r\n\t\t\t// description:\r\n\t\t\t//\t\tAn easing function the elastically snaps from the start value\r\n\t\t\t//\r\n\t\t\t//\t\tUse caution when the elasticity will cause values to become negative\r\n\t\t\t//\t\tas some properties cannot be set to negative values.\r\n\t\t\tif(n == 0 || n == 1){ return n; }\r\n\t\t\tvar p = .3;\r\n\t\t\tvar s = p / 4;\r\n\t\t\tn = n - 1;\r\n\t\t\treturn -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);\r\n\t\t},\r\n\t\r\n\t\telasticOut: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that elasticly snaps around the target value,\r\n\t\t\t//\t\tnear the end of the Animation\r\n\t\t\t// description:\r\n\t\t\t//\t\tAn easing function that elasticly snaps around the target value,\r\n\t\t\t//\t\tnear the end of the Animation\r\n\t\t\t//\r\n\t\t\t//\t\tUse caution when the elasticity will cause values to become\r\n\t\t\t//\t\tnegative as some properties cannot be set to negative values.\r\n\t\t\tif(n==0 || n == 1){ return n; }\r\n\t\t\tvar p = .3;\r\n\t\t\tvar s = p / 4;\r\n\t\t\treturn Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;\r\n\t\t},\r\n\t\r\n\t\telasticInOut: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that elasticly snaps around the value, near\r\n\t\t\t//\t\tthe beginning and end of the Animation.\r\n\t\t\t// description:\r\n\t\t\t//\t\tAn easing function that elasticly snaps around the value, near\r\n\t\t\t//\t\tthe beginning and end of the Animation.\r\n\t\t\t//\r\n\t\t\t//\t\tUse caution when the elasticity will cause values to become\r\n\t\t\t//\t\tnegative as some properties cannot be set to negative values.\r\n\t\t\tif(n == 0) return 0;\r\n\t\t\tn = n * 2;\r\n\t\t\tif(n == 2) return 1;\r\n\t\t\tvar p = .3 * 1.5;\r\n\t\t\tvar s = p / 4;\r\n\t\t\tif(n < 1){\r\n\t\t\t\tn -= 1;\r\n\t\t\t\treturn -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));\r\n\t\t\t}\r\n\t\t\tn -= 1;\r\n\t\t\treturn .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;\r\n\t\t},\r\n\t\r\n\t\tbounceIn: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that 'bounces' near the beginning of an Animation\r\n\t\t\treturn (1 - easingFuncs.bounceOut(1 - n)); // Decimal\r\n\t\t},\r\n\t\r\n\t\tbounceOut: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that 'bounces' near the end of an Animation\r\n\t\t\tvar s = 7.5625;\r\n\t\t\tvar p = 2.75;\r\n\t\t\tvar l;\r\n\t\t\tif(n < (1 / p)){\r\n\t\t\t\tl = s * Math.pow(n, 2);\r\n\t\t\t}else if(n < (2 / p)){\r\n\t\t\t\tn -= (1.5 / p);\r\n\t\t\t\tl = s * Math.pow(n, 2) + .75;\r\n\t\t\t}else if(n < (2.5 / p)){\r\n\t\t\t\tn -= (2.25 / p);\r\n\t\t\t\tl = s * Math.pow(n, 2) + .9375;\r\n\t\t\t}else{\r\n\t\t\t\tn -= (2.625 / p);\r\n\t\t\t\tl = s * Math.pow(n, 2) + .984375;\r\n\t\t\t}\r\n\t\t\treturn l;\r\n\t\t},\r\n\t\r\n\t\tbounceInOut: function(/* Decimal? */n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAn easing function that 'bounces' at the beginning and end of the Animation\r\n\t\t\tif(n < 0.5){ return easingFuncs.bounceIn(n * 2) / 2; }\r\n\t\t\treturn (easingFuncs.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal\r\n\t\t}\r\n\t};\r\n\t\r\n\tlang.setObject(\"dojo.fx.easing\", easingFuncs);\r\n\t\r\n\treturn easingFuncs;\r\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ },\n/* 227 */\n/*!*******************************************!*\\\n  !*** ../dojox/charting/themes/Wetland.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../SimpleTheme */ 192), __webpack_require__(/*! ./common */ 228)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SimpleTheme, themes){\n\t\tthemes.Wetland = new SimpleTheme({\n\t\t\tcolors: [\n\t\t\t\t\"#bfbc64\",\n\t\t\t\t\"#737130\",\n\t\t\t\t\"#73373b\",\n\t\t\t\t\"#7dafca\",\n\t\t\t\t\"#8d3c42\"\n\t\t\t]\n\t\t});\n\t\treturn themes.Wetland;\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 228 */\n/*!******************************************!*\\\n  !*** ../dojox/charting/themes/common.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ 9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){\n\t\treturn lang.getObject(\"dojox.charting.themes\", true);\n\t}.apply(null, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }\n]));\n\n\n// WEBPACK FOOTER //\n// 4.bundle.js","define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"..\", \"./Chart\",\n\t\"./axis2d/Default\", \"./axis2d/Invisible\", \"./plot2d/Default\", \"./plot2d/Lines\", \"./plot2d/Areas\",\n\t\"./plot2d/Markers\", \"./plot2d/MarkersOnly\", \"./plot2d/Scatter\", \"./plot2d/Stacked\", \"./plot2d/StackedLines\",\n\t\"./plot2d/StackedAreas\", \"./plot2d/Columns\", \"./plot2d/StackedColumns\", \"./plot2d/ClusteredColumns\",\n\t\"./plot2d/Bars\", \"./plot2d/StackedBars\", \"./plot2d/ClusteredBars\", \"./plot2d/Grid\", \"./plot2d/Pie\",\n\t\"./plot2d/Bubble\", \"./plot2d/Candlesticks\", \"./plot2d/OHLC\", \"./plot2d/Spider\"], \n\t  function(kernel, lang, dojox, Chart){\n\tkernel.deprecated(\"dojox.charting.Chart2D\", \"Use dojox.charting.Chart instead and require all other components explicitly\", \"2.0\");\n\t// module:\n\t//\t\tdojox/charting/Chart2D\n\t// summary:\n\t//\t\tThis is a compatibility module which loads all charting modules that used to be automatically\n\t//\t\tloaded in versions prior to 1.6.  It is highly recommended for performance reasons that\n\t//\t\tthis module no longer be referenced by applications.  Instead, use dojox/charting/Chart.\n\treturn lang.setObject(\"dojox.charting.Chart2D\", Chart);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/Chart2D.js\n// module id = 161\n// module chunks = 4","define([\"dojo/_base/declare\", \"./Stacked\"], function(declare, Stacked){\n\n\treturn declare(\"dojox.charting.plot2d.StackedAreas\", Stacked, {\n\t\t// summary:\n\t\t//\t\tA convenience object to set up a stacked area plot.\n\t\tconstructor: function(){\n\t\t\t// summary:\n\t\t\t//\t\tForce our Stacked plotter to include both lines and areas.\n\t\t\tthis.opt.lines = true;\n\t\t\tthis.opt.areas = true;\n\t\t}\n\t});\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/StackedAreas.js\n// module id = 162\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"./Default\", \"./commonStacked\"], \n\tfunction(declare, lang, Default, commonStacked){\n\n\treturn declare(\"dojox.charting.plot2d.Stacked\", Default, {\n\t\t// summary:\n\t\t//\t\tLike the default plot, Stacked sets up lines, areas and markers\n\t\t//\t\tin a stacked fashion (values on the y axis added to each other)\n\t\t//\t\tas opposed to a direct one.\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = commonStacked.collectStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\treturn stats; // Object\n\t\t},\n\t\t\n\t\tbuildSegments: function(i, indexed){\n\t\t\tvar run = this.series[i],\n\t\t\t\tmin = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0,\n\t\t\t\tmax = indexed?Math.min(run.data.length-1, Math.ceil(this._hScaler.bounds.to)):run.data.length-1,\n\t\t\t\trseg = null, segments = [], isNullValue = lang.hitch(this, \"isNullValue\");\n\t\t\t// split the run data into dense segments (each containing no nulls)\n\t\t\t// except if interpolates is false in which case ignore null between valid data\n\t\t\tfor(var j = min; j <= max; j++){\n\t\t\t\tvar value = indexed ? commonStacked.getIndexValue(this.series, i, j, isNullValue) : commonStacked.getValue(this.series, i, run.data[j] ?run.data[j].x: null, isNullValue);\n\t\t\t\tif(!isNullValue(value[0]) && (indexed || value[0].y != null)){\n\t\t\t\t\tif(!rseg){\n\t\t\t\t\t\trseg = [];\n\t\t\t\t\t\tsegments.push({index: j, rseg: rseg});\n\t\t\t\t\t}\n\t\t\t\t\trseg.push(value[0]);\n\t\t\t\t}else{\n\t\t\t\t\tif(!this.opt.interpolate || indexed){\n\t\t\t\t\t\t// we break the line only if not interpolating or if we have indexed data\n\t\t\t\t\t\trseg = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn segments;\n\t\t}\n\t\t\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Stacked.js\n// module id = 163\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/has\",\n\t\t\"./CartesianBase\", \"./_PlotEvents\", \"./common\", \"dojox/lang/functional\", \"dojox/lang/functional/reversed\", \"dojox/lang/utils\", \"dojox/gfx/fx\"],\n\tfunction(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\n\t/*=====\n\tdeclare(\"dojox.charting.plot2d.__DefaultCtorArgs\", dojox.charting.plot2d.__CartesianCtorArgs, {\n\t\t// summary:\n\t\t//\t\tThe arguments used for any/most plots.\n\n\t\t// lines: Boolean?\n\t\t//\t\tWhether or not to draw lines on this plot.  Defaults to true.\n\t\tlines:   true,\n\n\t\t// areas: Boolean?\n\t\t//\t\tWhether or not to draw areas on this plot. Defaults to false.\n\t\tareas:   false,\n\n\t\t// markers: Boolean?\n\t\t//\t\tWhether or not to draw markers at data points on this plot. Default is false.\n\t\tmarkers: false,\n\n\t\t// tension: Number|String?\n\t\t//\t\tWhether or not to apply 'tensioning' to the lines on this chart.\n\t\t//\t\tOptions include a number, \"X\", \"x\", or \"S\"; if a number is used, the\n\t\t//\t\tsimpler bezier curve calculations are used to draw the lines.  If X, x or S\n\t\t//\t\tis used, the more accurate smoothing algorithm is used.\n\t\ttension: \"\",\n\n\t\t// animate: Boolean?|Number?\n\t\t//\t\tWhether or not to animate the chart to place. When a Number it specifies the duration of the animation.\n\t\t//\t\tDefault is false.\n\t\tanimate: false,\n\n\t\t// stroke: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke to use for any series on the plot.\n\t\tstroke:\t\t{},\n\n\t\t// outline: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke used to outline any series on the plot.\n\t\toutline:\t{},\n\n\t\t// shadow: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\n\t\tshadow:\t\t{},\n\n\t\t// fill: dojox.gfx.Fill?\n\t\t//\t\tAny fill to be used for elements on the plot (such as areas).\n\t\tfill:\t\t{},\n\n\t\t// filter: dojox.gfx.Filter?\n\t\t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\n\t\t//\t\tbe required for this to work.\n\t\tfilter:\t\t{},\n\n\t\t// styleFunc: Function?\n\t\t//\t\tA function that returns a styling object for the a given data item.\n\t\tstyleFunc:\tnull,\n\n\t\t// font: String?\n\t\t//\t\tA font definition to be used for labels and other text-based elements on the plot.\n\t\tfont:\t\t\"\",\n\n\t\t// fontColor: String|dojo.Color?\n\t\t//\t\tThe color to be used for any text-based elements on the plot.\n\t\tfontColor:\t\"\",\n\n\t\t// markerStroke: dojo.gfx.Stroke?\n\t\t//\t\tAn optional stroke to use for any markers on the plot.\n\t\tmarkerStroke:\t\t{},\n\n\t\t// markerOutline: dojo.gfx.Stroke?\n\t\t//\t\tAn optional outline to use for any markers on the plot.\n\t\tmarkerOutline:\t\t{},\n\n\t\t// markerShadow: dojo.gfx.Stroke?\n\t\t//\t\tAn optional shadow to use for any markers on the plot.\n\t\tmarkerShadow:\t\t{},\n\n\t\t// markerFill: dojo.gfx.Fill?\n\t\t//\t\tAn optional fill to use for any markers on the plot.\n\t\tmarkerFill:\t\t\t{},\n\n\t\t// markerFont: String?\n\t\t//\t\tAn optional font definition to use for any markers on the plot.\n\t\tmarkerFont:\t\t\t\"\",\n\n\t\t// markerFontColor: String|dojo.Color?\n\t\t//\t\tAn optional color to use for any marker text on the plot.\n\t\tmarkerFontColor:\t\"\",\n\n\t\t// enableCache: Boolean?\n\t\t//\t\tWhether the markers are cached from one rendering to another. This improves the rendering performance of\n\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\n\t\tenableCache: false,\n\n\t\t// interpolate: Boolean?\n\t\t//\t\tWhether when there is a null data point in the data the plot interpolates it or if the lines is split at that\n\t\t//\t\tpoint.\tDefault false.\n\t\tinterpolate: false,\n\n\t\t// zeroLine: Number?\n\t\t//\t\tZero line for an area fill. Should be a numeric value in user coordinates.\n\t\t//\t\tDefault: the lowest value on a vertical axis.\n\t\tzeroLine: 0\n\t});\n=====*/\n\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\n\tvar DEFAULT_ANIMATION_LENGTH = 1200;\t// in ms\n\n\treturn declare(\"dojox.charting.plot2d.Default\", [CartesianBase, _PlotEvents], {\n\n\t\t// defaultParams:\n\t\t//\t\tThe default parameters of this plot.\n\t\tdefaultParams: {\n\t\t\tlines:   true,\t// draw lines\n\t\t\tareas:   false,\t// draw areas\n\t\t\tmarkers: false,\t// draw markers\n\t\t\ttension: \"\",\t// draw curved lines (tension is \"X\", \"x\", or \"S\")\n\t\t\tanimate: false, // animate chart to place\n\t\t\tenableCache: false,\n\t\t\tinterpolate: false\n\t\t},\n\n\t\t// optionalParams:\n\t\t//\t\tThe optional parameters of this plot.\n\t\toptionalParams: {\n\t\t\t// theme component\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfilter:     {},\n\t\t\tstyleFunc: null,\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\",\n\t\t\tmarker:             \"\",\n\t\t\tmarkerStroke:\t\t{},\n\t\t\tmarkerOutline:\t\t{},\n\t\t\tmarkerShadow:\t\t{},\n\t\t\tmarkerFill:\t\t\t{},\n\t\t\tmarkerFont:\t\t\t\"\",\n\t\t\tmarkerFontColor:\t\"\",\n\t\t\tzeroLine:           0\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tReturn a new plot.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t//\t\tAn optional arguments object to help define this plot.\n\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\t// animation properties\n\t\t\tthis.animate = this.opt.animate;\n\t\t},\n\n\t\tcreatePath: function(run, creator, params){\n\t\t\tvar path;\n\t\t\tif(this.opt.enableCache && run._pathFreePool.length > 0){\n\t\t\t\tpath = run._pathFreePool.pop();\n\t\t\t\tpath.setShape(params);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(path);\n\t\t\t}else{\n\t\t\t\tpath = creator.createPath(params);\n\t\t\t}\n\t\t\tif(this.opt.enableCache){\n\t\t\t\trun._pathUsePool.push(path);\n\t\t\t}\n\t\t\treturn path;\n\t\t},\n\n\t\tbuildSegments: function(i, indexed){\n\t\t\tvar run = this.series[i],\n\t\t\t\tmin = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0,\n\t\t\t\tmax = indexed?Math.min(run.data.length, Math.ceil(this._hScaler.bounds.to)):run.data.length,\n\t\t\t\trseg = null, segments = [];\n\n\t\t\t// split the run data into dense segments (each containing no nulls)\n\t\t\t// except if interpolates is false in which case ignore null between valid data\n\t\t\tfor(var j = min; j < max; j++){\n\t\t\t\tif(!this.isNullValue(run.data[j])){\n\t\t\t\t\tif(!rseg){\n\t\t\t\t\t\trseg = [];\n\t\t\t\t\t\tsegments.push({index: j, rseg: rseg});\n\t\t\t\t\t}\n\t\t\t\t\trseg.push((indexed && run.data[j].hasOwnProperty(\"y\"))?run.data[j].y:run.data[j]);\n\t\t\t\t}else{\n\t\t\t\t\tif(!this.opt.interpolate || indexed){\n\t\t\t\t\t\t// we break the line only if not interpolating or if we have indexed data\n\t\t\t\t\t\trseg = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn segments;\n\t\t},\n\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRender/draw everything on this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }\n\t\t\t// returns: dojox/charting/plot2d/Default\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\n\t\t\t// make sure all the series is not modified\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tvar s;\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\tthis.getGroup().setTransform(null);\n\t\t\t\ts = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\t\t\tvar t = this.chart.theme, stroke, outline, events = this.events();\n\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\trun._pathFreePool = (run._pathFreePool?run._pathFreePool:[]).concat(run._pathUsePool?run._pathUsePool:[]);\n\t\t\t\t\trun._pathUsePool = [];\n\t\t\t\t}\n\t\t\t\tif(!run.data.length){\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t\tt.skip();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar theme = t.next(this.opt.areas ? \"area\" : \"line\", [this.opt, run], true),\n\t\t\t\t\tlpoly,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\t\teventSeries = this._eventSeries[run.name] = new Array(run.data.length);\n\n\t\t\t\ts = run.group;\n\t\t\t\tif(run.hidden){\n\t\t\t\t\tif(this.opt.lines){\n\t\t\t\t\t\trun.dyn.stroke = theme.series.stroke;\n\t\t\t\t\t}\n\t\t\t\t\tif (run.markers || (run.markers === undefined && this.opt.markers)) {\n\t\t\t\t\t\trun.dyn.markerFill = theme.marker.fill;\n\t\t\t\t\t\trun.dyn.markerStroke = theme.marker.stroke;\n\t\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.areas){\n\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// optim works only for index based case\n\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t});\n\n\t\t\t\tvar rsegments = this.buildSegments(i, indexed);\n\t\t\t\tfor(var seg = 0; seg < rsegments.length; seg++){\n\t\t\t\t\tvar rsegment = rsegments[seg];\n\t\t\t\t\tif(indexed){\n\t\t\t\t\t\tlpoly = arr.map(rsegment.rseg, function(v, i){\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tx: ht(i + rsegment.index + 1) + offsets.l,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v),\n\t\t\t\t\t\t\t\tdata: v\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlpoly = arr.map(rsegment.rseg, function(v){\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y),\n\t\t\t\t\t\t\t\tdata: v\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we are indexed & we interpolate we need to put all the segments as a single one now\n\t\t\t\t\tif(indexed && this.opt.interpolate){\n\t\t\t\t\t\twhile(seg < rsegments.length) {\n\t\t\t\t\t\t\tseg++;\n\t\t\t\t\t\t\trsegment = rsegments[seg];\n\t\t\t\t\t\t\tif(rsegment){\n\t\t\t\t\t\t\t\tlpoly = lpoly.concat(arr.map(rsegment.rseg, function(v, i){\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\tx: ht(i + rsegment.index + 1) + offsets.l,\n\t\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v),\n\t\t\t\t\t\t\t\t\t\tdata: v\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}, this));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar lpath = this.opt.tension ? dc.curve(lpoly, this.opt.tension) : \"\";\n\n\t\t\t\t\tif(this.opt.areas && lpoly.length > 1){\n\t\t\t\t\t\tvar fill = this._plotFill(theme.series.fill, dim, offsets), apoly = lang.clone(lpoly),\n\t\t\t\t\t\t\tzeroLine = dim.height - offsets.b;\n\t\t\t\t\t\tif(!isNaN(this.opt.zeroLine)){\n\t\t\t\t\t\t\tzeroLine = Math.max(offsets.t, Math.min(dim.height - offsets.b - vt(this.opt.zeroLine), zeroLine));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\tvar apath = \"L\" + apoly[apoly.length-1].x + \",\" + zeroLine +\n\t\t\t\t\t\t\t\t\" L\" + apoly[0].x + \",\" + zeroLine +\n\t\t\t\t\t\t\t\t\" L\" + apoly[0].x + \",\" + apoly[0].y;\n\t\t\t\t\t\t\trun.dyn.fill = s.createPath(lpath + \" \" + apath).setFill(fill).getFill();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tapoly.push({x: lpoly[lpoly.length - 1].x, y: zeroLine});\n\t\t\t\t\t\t\tapoly.push({x: lpoly[0].x, y: zeroLine});\n\t\t\t\t\t\t\tapoly.push(lpoly[0]);\n\t\t\t\t\t\t\trun.dyn.fill = s.createPolyline(apoly).setFill(fill).getFill();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.lines || this.opt.markers){\n\t\t\t\t\t\t// need a stroke\n\t\t\t\t\t\tstroke = theme.series.stroke;\n\t\t\t\t\t\tif(theme.series.outline){\n\t\t\t\t\t\t\toutline = run.dyn.outline = dc.makeStroke(theme.series.outline);\n\t\t\t\t\t\t\toutline.width = 2 * outline.width + (stroke && stroke.width || 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.markers){\n\t\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\t}\n\t\t\t\t\tvar frontMarkers = null, outlineMarkers = null, shadowMarkers = null;\n\t\t\t\t\tif(stroke && theme.series.shadow && lpoly.length > 1){\n\t\t\t\t\t\tvar shadow = theme.series.shadow,\n\t\t\t\t\t\t\tspoly = arr.map(lpoly, function(c){\n\t\t\t\t\t\t\t\treturn {x: c.x + shadow.dx, y: c.y + shadow.dy};\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tif(this.opt.lines){\n\t\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\t\trun.dyn.shadow = s.createPath(dc.curve(spoly, this.opt.tension)).setStroke(shadow).getStroke();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trun.dyn.shadow = s.createPolyline(spoly).setStroke(shadow).getStroke();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.markers && theme.marker.shadow){\n\t\t\t\t\t\t\tshadow = theme.marker.shadow;\n\t\t\t\t\t\t\tshadowMarkers = arr.map(spoly, function(c){\n\t\t\t\t\t\t\t\treturn this.createPath(run, s, \"M\" + c.x + \" \" + c.y + \" \" + theme.symbol).\n\t\t\t\t\t\t\t\t\tsetStroke(shadow).setFill(shadow.color);\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.lines && lpoly.length > 1){\n\t\t\t\t\t\tvar shape;\n\t\t\t\t\t\tif(outline){\n\t\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\t\trun.dyn.outline = s.createPath(lpath).setStroke(outline).getStroke();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trun.dyn.outline = s.createPolyline(lpoly).setStroke(outline).getStroke();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.tension){\n\t\t\t\t\t\t\trun.dyn.stroke = (shape = s.createPath(lpath)).setStroke(stroke).getStroke();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trun.dyn.stroke = (shape = s.createPolyline(lpoly)).setStroke(stroke).getStroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(shape.setFilter && theme.series.filter){\n\t\t\t\t\t\t\tshape.setFilter(theme.series.filter);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar markerBox = null;\n\t\t\t\t\tif(this.opt.markers){\n\t\t\t\t\t\tvar markerTheme = theme;\n\t\t\t\t\t\tfrontMarkers = new Array(lpoly.length);\n\t\t\t\t\t\toutlineMarkers = new Array(lpoly.length);\n\t\t\t\t\t\toutline = null;\n\t\t\t\t\t\tif(markerTheme.marker.outline){\n\t\t\t\t\t\t\toutline = dc.makeStroke(markerTheme.marker.outline);\n\t\t\t\t\t\t\toutline.width = 2 * outline.width + (markerTheme.marker.stroke ? markerTheme.marker.stroke.width : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarr.forEach(lpoly, function(c, i){\n\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof c.data != \"number\"){\n\t\t\t\t\t\t\t\tvar tMixin = typeof c.data != \"number\" ? [c.data] : [];\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(c.data));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmarkerTheme = t.addMixin(theme, \"marker\", tMixin, true);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmarkerTheme = t.post(theme, \"marker\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar path = \"M\" + c.x + \" \" + c.y + \" \" + markerTheme.symbol;\n\t\t\t\t\t\t\tif(outline){\n\t\t\t\t\t\t\t\toutlineMarkers[i] = this.createPath(run, s, path).setStroke(outline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfrontMarkers[i] = this.createPath(run, s, path).setStroke(markerTheme.marker.stroke).setFill(markerTheme.marker.fill);\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\trun.dyn.markerFill = markerTheme.marker.fill;\n\t\t\t\t\t\trun.dyn.markerStroke = markerTheme.marker.stroke;\n\t\t\t\t\t\tif(!markerBox && this.opt.labels){\n\t\t\t\t\t\t\tmarkerBox = frontMarkers[0].getBoundingBox();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\tarr.forEach(frontMarkers, function(s, i){\n\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\telement: \"marker\",\n\t\t\t\t\t\t\t\t\tindex:   i + rsegment.index,\n\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\tshape:   s,\n\t\t\t\t\t\t\t\t\toutline: outlineMarkers[i] || null,\n\t\t\t\t\t\t\t\t\tshadow:  shadowMarkers && shadowMarkers[i] || null,\n\t\t\t\t\t\t\t\t\tcx:      lpoly[i].x,\n\t\t\t\t\t\t\t\t\tcy:      lpoly[i].y\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif(indexed){\n\t\t\t\t\t\t\t\t\to.x = i + rsegment.index + 1;\n\t\t\t\t\t\t\t\t\to.y = run.data[i + rsegment.index];\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\to.x = rsegment.rseg[i].x;\n\t\t\t\t\t\t\t\t\to.y = run.data[i + rsegment.index].y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\teventSeries[i + rsegment.index] = o;\n\t\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdelete this._eventSeries[run.name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.labels){\n\t\t\t\t\t\tvar labelBoxW = markerBox?markerBox.width:2;\n\t\t\t\t\t\tvar labelBoxH = markerBox?markerBox.height:2;\n\t\t\t\t\t\tarr.forEach(lpoly, function(c, i){\n\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof c.data != \"number\"){\n\t\t\t\t\t\t\t\tvar tMixin = typeof c.data != \"number\" ? [c.data] : [];\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(c.data));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmarkerTheme = t.addMixin(theme, \"marker\", tMixin, true);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmarkerTheme = t.post(theme, \"marker\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.createLabel(s, rsegment.rseg[i], { x: c.x - labelBoxW / 2, y: c.y - labelBoxH / 2,\n\t\t\t\t\t\t\t\twidth: labelBoxW , height: labelBoxH }, markerTheme);\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\tif(this.animate){\n\t\t\t\t// grow from the bottom\n\t\t\t\tvar plotGroup = this.getGroup();\n\t\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: plotGroup,\n\t\t\t\t\tduration: DEFAULT_ANIMATION_LENGTH,\n\t\t\t\t\ttransform:[\n\t\t\t\t\t\t{name:\"translate\", start: [0, dim.height - offsets.b], end: [0, 0]},\n\t\t\t\t\t\t{name:\"scale\", start: [1, 0], end:[1, 1]},\n\t\t\t\t\t\t{name:\"original\"}\n\t\t\t\t\t]\n\t\t\t\t}, this.animate)).play();\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Default\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Default.js\n// module id = 164\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/Color\", \n\t\t\"dojox/gfx\", \"dojox/lang/functional\", \"../scaler/common\"], \n\tfunction(lang, arr, Color, g, df, sc){\n\t\n\tvar common = lang.getObject(\"dojox.charting.plot2d.common\", true);\n\t\n\treturn lang.mixin(common, {\t\n\t\tdoIfLoaded: sc.doIfLoaded,\n\t\tmakeStroke: function(stroke){\n\t\t\tif(!stroke){ return stroke; }\n\t\t\tif(typeof stroke == \"string\" || stroke instanceof Color){\n\t\t\t\tstroke = {color: stroke};\n\t\t\t}\n\t\t\treturn g.makeParameters(g.defaultStroke, stroke);\n\t\t},\n\t\taugmentColor: function(target, color){\n\t\t\tvar t = new Color(target),\n\t\t\t\tc = new Color(color);\n\t\t\tc.a = t.a;\n\t\t\treturn c;\n\t\t},\n\t\taugmentStroke: function(stroke, color){\n\t\t\tvar s = common.makeStroke(stroke);\n\t\t\tif(s){\n\t\t\t\ts.color = common.augmentColor(s.color, color);\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\taugmentFill: function(fill, color){\n\t\t\tvar fc, c = new Color(color);\n\t\t\tif(typeof fill == \"string\" || fill instanceof Color){\n\t\t\t\treturn common.augmentColor(fill, color);\n\t\t\t}\n\t\t\treturn fill;\n\t\t},\n\n\t\tdefaultStats: {\n\t\t\tvmin: Number.POSITIVE_INFINITY, vmax: Number.NEGATIVE_INFINITY,\n\t\t\thmin: Number.POSITIVE_INFINITY, hmax: Number.NEGATIVE_INFINITY\n\t\t},\n\n\t\tcollectSimpleStats: function(series, isNullValue){\n\t\t\tvar stats = lang.delegate(common.defaultStats);\n\t\t\tfor(var i = 0; i < series.length; ++i){\n\t\t\t\tvar run = series[i];\n\t\t\t\tfor(var j = 0; j < run.data.length; j++){\n\t\t\t\t\tif(!isNullValue(run.data[j])){\n\t\t\t\t\t\tif(typeof run.data[j] == \"number\"){\n\t\t\t\t\t\t\t// 1D case\n\t\t\t\t\t\t\tvar old_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\t\t\t\tarr.forEach(run.data, function(val, i){\n\t\t\t\t\t\t\t\tif(!isNullValue(val)){\n\t\t\t\t\t\t\t\t\tvar x = i + 1, y = val;\n\t\t\t\t\t\t\t\t\tif(isNaN(y)){ y = 0; }\n\t\t\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, y);\n\t\t\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, y);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// 2D case\n\t\t\t\t\t\t\tvar old_hmin = stats.hmin, old_hmax = stats.hmax,\n\t\t\t\t\t\t\t\told_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\t\t\t\tif(!(\"xmin\" in run) || !(\"xmax\" in run) || !(\"ymin\" in run) || !(\"ymax\" in run)){\n\t\t\t\t\t\t\t\tarr.forEach(run.data, function(val, i){\n\t\t\t\t\t\t\t\t\tif(!isNullValue(val)){\n\t\t\t\t\t\t\t\t\t\tvar x = \"x\" in val ? val.x : i + 1, y = val.y;\n\t\t\t\t\t\t\t\t\t\tif(isNaN(x)){ x = 0; }\n\t\t\t\t\t\t\t\t\t\tif(isNaN(y)){ y = 0; }\n\t\t\t\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, y);\n\t\t\t\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(\"xmin\" in run){ stats.hmin = Math.min(old_hmin, run.xmin); }\n\t\t\t\t\t\t\tif(\"xmax\" in run){ stats.hmax = Math.max(old_hmax, run.xmax); }\n\t\t\t\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stats;\n\t\t},\n\n\t\tcalculateBarSize: function(/* Number */ availableSize, /* Object */ opt, /* Number? */ clusterSize){\n\t\t\tif(!clusterSize){\n\t\t\t\tclusterSize = 1;\n\t\t\t}\n\t\t\tvar gap = opt.gap, size = (availableSize - 2 * gap) / clusterSize;\n\t\t\tif(\"minBarSize\" in opt){\n\t\t\t\tsize = Math.max(size, opt.minBarSize);\n\t\t\t}\n\t\t\tif(\"maxBarSize\" in opt){\n\t\t\t\tsize = Math.min(size, opt.maxBarSize);\n\t\t\t}\n\t\t\tsize = Math.max(size, 1);\n\t\t\tgap = (availableSize - size * clusterSize) / 2;\n\t\t\treturn {size: size, gap: gap};\t// Object\n\t\t},\n\n\t\tcollectStackedStats: function(series){\n\t\t\t// collect statistics\n\t\t\tvar stats = lang.clone(common.defaultStats);\n\t\t\tif(series.length){\n\t\t\t\t// 1st pass: find the maximal length of runs\n\t\t\t\tstats.hmin = Math.min(stats.hmin, 1);\n\t\t\t\tstats.hmax = df.foldl(series, \"seed, run -> Math.max(seed, run.data.length)\", stats.hmax);\n\t\t\t\t// 2nd pass: stack values\n\t\t\t\tfor(var i = 0; i < stats.hmax; ++i){\n\t\t\t\t\tvar v = series[0].data[i];\n\t\t\t\t\tv = v && (typeof v == \"number\" ? v : v.y);\n\t\t\t\t\tif(isNaN(v)){ v = 0; }\n\t\t\t\t\tstats.vmin = Math.min(stats.vmin, v);\n\t\t\t\t\tfor(var j = 1; j < series.length; ++j){\n\t\t\t\t\t\tvar t = series[j].data[i];\n\t\t\t\t\t\tt = t && (typeof t == \"number\" ? t : t.y);\n\t\t\t\t\t\tif(isNaN(t)){ t = 0; }\n\t\t\t\t\t\tv += t;\n\t\t\t\t\t}\n\t\t\t\t\tstats.vmax = Math.max(stats.vmax, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stats;\n\t\t},\n\n\t\tcurve: function(/* Number[] */a, /* Number|String */tension){\n\t\t\t//\tFIX for #7235, submitted by Enzo Michelangeli.\n\t\t\t//\tEmulates the smoothing algorithms used in a famous, unnamed spreadsheet\n\t\t\t//\t\tprogram ;)\n\t\t\tvar array = a.slice(0);\n\t\t\tif(tension == \"x\") {\n\t\t\t\tarray[array.length] = array[0];   // add a last element equal to the first, closing the loop\n\t\t\t}\n\t\t\tvar p=arr.map(array, function(item, i){\n\t\t\t\tif(i==0){ return \"M\" + item.x + \",\" + item.y; }\n\t\t\t\tif(!isNaN(tension)) { // use standard Dojo smoothing in tension is numeric\n\t\t\t\t\tvar dx=item.x-array[i-1].x, dy=array[i-1].y;\n\t\t\t\t\treturn \"C\"+(item.x-(tension-1)*(dx/tension))+\",\"+dy+\" \"+(item.x-(dx/tension))+\",\"+item.y+\" \"+item.x+\",\"+item.y;\n\t\t\t\t} else if(tension == \"X\" || tension == \"x\" || tension == \"S\") {\n\t\t\t\t\t// use Excel \"line smoothing\" algorithm (http://xlrotor.com/resources/files.shtml)\n\t\t\t\t\tvar p0, p1 = array[i-1], p2 = array[i], p3;\n\t\t\t\t\tvar bz1x, bz1y, bz2x, bz2y;\n\t\t\t\t\tvar f = 1/6;\n\t\t\t\t\tif(i==1) {\n\t\t\t\t\t\tif(tension == \"x\") {\n\t\t\t\t\t\t\tp0 = array[array.length-2];\n\t\t\t\t\t\t} else { // \"tension == X || tension == \"S\"\n\t\t\t\t\t\t\tp0 = p1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = 1/3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp0 = array[i-2];\n\t\t\t\t\t}\n\t\t\t\t\tif(i==(array.length-1)) {\n\t\t\t\t\t\tif(tension == \"x\") {\n\t\t\t\t\t\t\tp3 = array[1];\n\t\t\t\t\t\t} else { // \"tension == X || tension == \"S\"\n\t\t\t\t\t\t\tp3 = p2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = 1/3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp3 = array[i+1];\n\t\t\t\t\t}\n\t\t\t\t\tvar p1p2 = Math.sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));\n\t\t\t\t\tvar p0p2 = Math.sqrt((p2.x-p0.x)*(p2.x-p0.x)+(p2.y-p0.y)*(p2.y-p0.y));\n\t\t\t\t\tvar p1p3 = Math.sqrt((p3.x-p1.x)*(p3.x-p1.x)+(p3.y-p1.y)*(p3.y-p1.y));\n\n\t\t\t\t\tvar p0p2f = p0p2 * f;\n\t\t\t\t\tvar p1p3f = p1p3 * f;\n\n\t\t\t\t\tif(p0p2f > p1p2/2 && p1p3f > p1p2/2) {\n\t\t\t\t\t\tp0p2f = p1p2/2;\n\t\t\t\t\t\tp1p3f = p1p2/2;\n\t\t\t\t\t} else if(p0p2f > p1p2/2) {\n\t\t\t\t\t\tp0p2f = p1p2/2;\n\t\t\t\t\t\tp1p3f = p1p2/2 * p1p3/p0p2;\n\t\t\t\t\t} else if(p1p3f > p1p2/2) {\n\t\t\t\t\t\tp1p3f = p1p2/2;\n\t\t\t\t\t\tp0p2f = p1p2/2 * p0p2/p1p3;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tension == \"S\") {\n\t\t\t\t\t\tif(p0 == p1) { p0p2f = 0; }\n\t\t\t\t\t\tif(p2 == p3) { p1p3f = 0; }\n\t\t\t\t\t}\n\n\t\t\t\t\tbz1x = p1.x + p0p2f*(p2.x - p0.x)/p0p2;\n\t\t\t\t\tbz1y = p1.y + p0p2f*(p2.y - p0.y)/p0p2;\n\t\t\t\t\tbz2x = p2.x - p1p3f*(p3.x - p1.x)/p1p3;\n\t\t\t\t\tbz2y = p2.y - p1p3f*(p3.y - p1.y)/p1p3;\n\t\t\t\t}\n\t\t\t\treturn \"C\"+(bz1x+\",\"+bz1y+\" \"+bz2x+\",\"+bz2y+\" \"+p2.x+\",\"+p2.y);\n\t\t\t});\n\t\t\treturn p.join(\" \");\n\t\t},\n\t\t\n\t\tgetLabel: function(/*Number*/number, /*Boolean*/fixed, /*Number*/precision){\n\t\t\treturn sc.doIfLoaded(\"dojo/number\", function(numberLib){\n\t\t\t\treturn (fixed ? numberLib.format(number, {places : precision}) :\n\t\t\t\t\tnumberLib.format(number)) || \"\";\n\t\t\t}, function(){\n\t\t\t\treturn fixed ? number.toFixed(precision) : number.toString();\n\t\t\t});\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/common.js\n// module id = 165\n// module chunks = 4","define([\"dojo/_base/lang\", \"./gfx/_base\", \"./gfx/renderer!\"], \n  function(lang, gfxBase, renderer){\n\t// module:\n\t//\t\tdojox/gfx\n\t// summary:\n\t//\t\tThis the root of the Dojo Graphics package\n\tgfxBase.switchTo(renderer);\n\treturn gfxBase;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx.js\n// module id = 166\n// module chunks = 4","define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"dojo/_base/Color\", \"dojo/_base/sniff\", \"dojo/_base/window\",\n\t    \"dojo/_base/array\",\"dojo/dom\", \"dojo/dom-construct\",\"dojo/dom-geometry\"],\nfunction(kernel, lang, Color, has, win, arr, dom, domConstruct, domGeom){\n\t// module:\n\t//\t\tdojox/gfx\n\t// summary:\n\t//\t\tThis module contains common core Graphics API used by different graphics renderers.\n\n\tvar g = lang.getObject(\"dojox.gfx\", true),\n\t\tb = g._base = {};\n\t\n\t// candidates for dojox.style (work on VML and SVG nodes)\n\tg._hasClass = function(/*DomNode*/node, /*String*/classStr){\n\t\t// summary:\n\t\t//\t\tReturns whether or not the specified classes are a portion of the\n\t\t//\t\tclass list currently applied to the node.\n\t\t\n\t\t// return (new RegExp('(^|\\\\s+)'+classStr+'(\\\\s+|$)')).test(node.className)\t// Boolean\n\t\tvar cls = node.getAttribute(\"className\");\n\t\treturn cls && (\" \" + cls + \" \").indexOf(\" \" + classStr + \" \") >= 0;  // Boolean\n\t};\n\tg._addClass = function(/*DomNode*/node, /*String*/classStr){\n\t\t// summary:\n\t\t//\t\tAdds the specified classes to the end of the class list on the\n\t\t//\t\tpassed node.\n\t\tvar cls = node.getAttribute(\"className\") || \"\";\n\t\tif(!cls || (\" \" + cls + \" \").indexOf(\" \" + classStr + \" \") < 0){\n\t\t\tnode.setAttribute(\"className\", cls + (cls ? \" \" : \"\") + classStr);\n\t\t}\n\t};\n\tg._removeClass = function(/*DomNode*/node, /*String*/classStr){\n\t\t// summary:\n\t\t//\t\tRemoves classes from node.\n\t\tvar cls = node.getAttribute(\"className\");\n\t\tif(cls){\n\t\t\tnode.setAttribute(\n\t\t\t\t\"className\",\n\t\t\t\tcls.replace(new RegExp('(^|\\\\s+)' + classStr + '(\\\\s+|$)'), \"$1$2\")\n\t\t\t);\n\t\t}\n\t};\n\n\t// candidate for dojox.html.metrics (dynamic font resize handler is not implemented here)\n\n\t//\t\tderived from Morris John's emResized measurer\n\tb._getFontMeasurements = function(){\n\t\t// summary:\n\t\t//\t\tReturns an object that has pixel equivilents of standard font\n\t\t//\t\tsize values.\n\t\tvar heights = {\n\t\t\t'1em': 0, '1ex': 0, '100%': 0, '12pt': 0, '16px': 0, 'xx-small': 0,\n\t\t\t'x-small': 0, 'small': 0, 'medium': 0, 'large': 0, 'x-large': 0,\n\t\t\t'xx-large': 0\n\t\t};\n\t\tvar p, oldStyle;\t\n\t\tif(has(\"ie\")){\n\t\t\t//\tWe do a font-size fix if and only if one isn't applied already.\n\t\t\t// NOTE: If someone set the fontSize on the HTML Element, this will kill it.\n\t\t\toldStyle = win.doc.documentElement.style.fontSize || \"\";\n\t\t\tif(!oldStyle){\n\t\t\t\twin.doc.documentElement.style.fontSize=\"100%\";\n\t\t\t}\n\t\t}\n\n\t\t//\t\tset up the measuring node.\n\t\tvar div = domConstruct.create(\"div\", {style: {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\tleft: \"0\",\n\t\t\t\ttop: \"-100px\",\n\t\t\t\twidth: \"30px\",\n\t\t\t\theight: \"1000em\",\n\t\t\t\tborderWidth: \"0\",\n\t\t\t\tmargin: \"0\",\n\t\t\t\tpadding: \"0\",\n\t\t\t\toutline: \"none\",\n\t\t\t\tlineHeight: \"1\",\n\t\t\t\toverflow: \"hidden\"\n\t\t\t}}, win.body());\n\n\t\t//\t\tdo the measurements.\n\t\tfor(p in heights){\n\t\t\tdiv.style.fontSize = p;\n\t\t\theights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;\n\t\t}\n\n\t\tif(has(\"ie\")){\n\t\t\t// Restore the font to its old style.\n\t\t\twin.doc.documentElement.style.fontSize = oldStyle;\n\t\t}\n\t\twin.body().removeChild(div);\n\t\treturn heights; //object\n\t};\n\n\tvar fontMeasurements = null;\n\n\tb._getCachedFontMeasurements = function(recalculate){\n\t\tif(recalculate || !fontMeasurements){\n\t\t\tfontMeasurements = b._getFontMeasurements();\n\t\t}\n\t\treturn fontMeasurements;\n\t};\n\n\t// candidate for dojox.html.metrics\n\n\tvar measuringNode = null, empty = {};\n\tb._getTextBox = function(\t/*String*/ text,\n\t\t\t\t\t\t\t\t/*Object*/ style,\n\t\t\t\t\t\t\t\t/*String?*/ className){\n\t\tvar m, s, al = arguments.length;\n\t\tvar i, box;\n\t\tif(!measuringNode){\n\t\t\tmeasuringNode = domConstruct.create(\"div\", {style: {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"-10000px\",\n\t\t\t\tleft: \"0\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t}}, win.body());\n\t\t}\n\t\tm = measuringNode;\n\t\t// reset styles\n\t\tm.className = \"\";\n\t\ts = m.style;\n\t\ts.borderWidth = \"0\";\n\t\ts.margin = \"0\";\n\t\ts.padding = \"0\";\n\t\ts.outline = \"0\";\n\t\t// set new style\n\t\tif(al > 1 && style){\n\t\t\tfor(i in style){\n\t\t\t\tif(i in empty){ continue; }\n\t\t\t\ts[i] = style[i];\n\t\t\t}\n\t\t}\n\t\t// set classes\n\t\tif(al > 2 && className){\n\t\t\tm.className = className;\n\t\t}\n\t\t// take a measure\n\t\tm.innerHTML = text;\n\n\t\tif(m.getBoundingClientRect){\n\t\t\tvar bcr = m.getBoundingClientRect();\n\t\t\tbox = {l: bcr.left, t: bcr.top, w: bcr.width || (bcr.right - bcr.left), h: bcr.height || (bcr.bottom - bcr.top)};\n\t\t}else{\n\t\t\tbox = domGeom.getMarginBox(m);\n\t\t}\n\t\tm.innerHTML = \"\";\n\t\treturn box;\n\t};\n\n\tb._computeTextLocation = function(/*g.defaultTextShape*/textShape, /*Number*/width, /*Number*/height, /*Boolean*/fixHeight) {\n\t\tvar loc = {}, align = textShape.align;\n\t\tswitch (align) {\n\t\t\tcase 'end':\n\t\t\t\tloc.x = textShape.x - width;\n\t\t\t\tbreak;\n\t\t\tcase 'middle':\n\t\t\t\tloc.x = textShape.x - width / 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tloc.x = textShape.x;\n\t\t\t\tbreak;\n\t\t}\n\t\tvar c = fixHeight ? 0.75 : 1;\n\t\tloc.y = textShape.y - height*c; // **rough** approximation of the ascent...\n\t\treturn loc;\n\t};\n\tb._computeTextBoundingBox = function(/*shape.Text*/s){\n\t\t// summary:\n\t\t//\t\tCompute the bbox of the given shape.Text instance. Note that this method returns an\n\t\t//\t\tapproximation of the bbox, and should be used when the underlying renderer cannot provide precise metrics.\n\t\tif(!g._base._isRendered(s)){\n\t\t\treturn {x:0, y:0, width:0, height:0};\n\t\t}\n\t\tvar loc, textShape = s.getShape(),\n\t\t\tfont = s.getFont() || g.defaultFont,\n\t\t\tw = s.getTextWidth(),\n\t\t\th = g.normalizedLength(font.size);\n\t\tloc = b._computeTextLocation(textShape, w, h, true);\n\t\treturn {\n\t\t\tx: loc.x,\n\t\t\ty: loc.y,\n\t\t\twidth: w,\n\t\t\theight: h\n\t\t};\n\t};\n\tb._isRendered = function(/*Shape*/s){\n\t\tvar p = s.parent;\n\t\twhile(p && p.getParent){\n\t\t\tp = p.parent;\n\t\t}\n\t\treturn p !== null;\n\t};\n\n\t// candidate for dojo.dom\n\n\tvar uniqueId = 0;\n\tb._getUniqueId = function(){\n\t\t// summary:\n\t\t//\t\treturns a unique string for use with any DOM element\n\t\tvar id;\n\t\tdo{\n\t\t\tid = kernel._scopeName + \"xUnique\" + (++uniqueId);\n\t\t}while(dom.byId(id));\n\t\treturn id;\n\t};\n\n\t// IE10\n\n\tvar touchActionProp = has(\"pointer-events\") ? \"touchAction\" : has(\"MSPointer\") ? \"msTouchAction\" : null;\n\tb._fixMsTouchAction = touchActionProp ? function(/*dojox/gfx/shape.Surface*/surface){\n\t\tsurface.rawNode.style[touchActionProp] = \"none\";\n\t} : function() {};\n\n\t/*=====\n\tg.Stroke = {\n\t\t// summary:\n\t\t//\t\tA stroke defines stylistic properties that are used when drawing a path.\n\n\t\t// color: String\n\t\t//\t\tThe color of the stroke, default value 'black'.\n\t\tcolor: \"black\",\n\n\t\t// style: String\n\t\t//\t\tThe style of the stroke, one of 'solid', ... . Default value 'solid'.\n\t\tstyle: \"solid\",\n\n\t\t// width: Number\n\t\t//\t\tThe width of a stroke, default value 1.\n\t\twidth: 1,\n\n\t\t// cap: String\n\t\t//\t\tThe endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.\n\t\tcap: \"butt\",\n\n\t\t// join: Number\n\t\t//\t\tThe join style to use when combining path segments. Default value 4.\n\t\tjoin: 4\n\t};\n\t\n\tg.Fill = {\n\t\t// summary:\n\t\t//\t\tDefines how to fill a shape. Four types of fills can be used: solid, linear gradient, radial gradient and pattern.\n\t\t//\t\tSee dojox/gfx.LinearGradient, dojox/gfx.RadialGradient and dojox/gfx.Pattern respectively for more information about the properties supported by each type.\n\t\t\n\t\t// type: String?\n\t\t//\t\tThe type of fill. One of 'linear', 'radial', 'pattern' or undefined. If not specified, a solid fill is assumed.\n\t\ttype:\"\",\n\t\t\n\t\t// color: String|dojo/Color?\n\t\t//\t\tThe color of a solid fill type.\n\t\tcolor:null,\n\t\t\n\t};\n\t\n\tg.LinearGradient = {\n\t\t// summary:\n\t\t//\t\tAn object defining the default stylistic properties used for Linear Gradient fills.\n\t\t//\t\tLinear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.\n\n\t\t// type: String\n\t\t//\t\tSpecifies this object is a Linear Gradient, value 'linear'\n\t\ttype: \"linear\",\n\n\t\t// x1: Number\n\t\t//\t\tThe X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\tx1: 0,\n\n\t\t// y1: Number\n\t\t//\t\tThe Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\ty1: 0,\n\n\t\t// x2: Number\n\t\t//\t\tThe X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\tx2: 100,\n\n\t\t// y2: Number\n\t\t//\t\tThe Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\ty2: 100,\n\n\t\t// colors: Array\n\t\t//\t\tAn array of colors at given offsets (from the start of the line).  The start of the line is\n\t\t//\t\tdefined at offest 0 with the end of the line at offset 1.\n\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\tcolors: []\n\t};\n\t\n\tg.RadialGradient = {\n\t\t// summary:\n\t\t//\t\tSpecifies the properties for RadialGradients using in fills patterns.\n\n\t\t// type: String\n\t\t//\t\tSpecifies this is a RadialGradient, value 'radial'\n\t\ttype: \"radial\",\n\n\t\t// cx: Number\n\t\t//\t\tThe X coordinate of the center of the radial gradient, default value 0.\n\t\tcx: 0,\n\n\t\t// cy: Number\n\t\t//\t\tThe Y coordinate of the center of the radial gradient, default value 0.\n\t\tcy: 0,\n\n\t\t// r: Number\n\t\t//\t\tThe radius to the end of the radial gradient, default value 100.\n\t\tr: 100,\n\n\t\t// colors: Array\n\t\t//\t\tAn array of colors at given offsets (from the center of the radial gradient).\n\t\t//\t\tThe center is defined at offest 0 with the outer edge of the gradient at offset 1.\n\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\tcolors: []\n\t};\n\t\n\tg.Pattern = {\n\t\t// summary:\n\t\t//\t\tAn object specifying the default properties for a Pattern using in fill operations.\n\n\t\t// type: String\n\t\t//\t\tSpecifies this object is a Pattern, value 'pattern'.\n\t\ttype: \"pattern\",\n\n\t\t// x: Number\n\t\t//\t\tThe X coordinate of the position of the pattern, default value is 0.\n\t\tx: 0,\n\n\t\t// y: Number\n\t\t//\t\tThe Y coordinate of the position of the pattern, default value is 0.\n\t\ty: 0,\n\n\t\t// width: Number\n\t\t//\t\tThe width of the pattern image, default value is 0.\n\t\twidth: 0,\n\n\t\t// height: Number\n\t\t//\t\tThe height of the pattern image, default value is 0.\n\t\theight: 0,\n\n\t\t// src: String\n\t\t//\t\tA url specifying the image to use for the pattern.\n\t\tsrc: \"\"\n\t};\n\n\tg.Text = {\n\t\t//\tsummary:\n\t\t//\t\tA keyword argument object defining both the text to be rendered in a VectorText shape,\n\t\t//\t\tand specifying position, alignment, and fitting.\n\t\t//\ttext: String\n\t\t//\t\tThe text to be rendered.\n\t\t//\tx: Number?\n\t\t//\t\tThe left coordinate for the text's bounding box.\n\t\t//\ty: Number?\n\t\t//\t\tThe top coordinate for the text's bounding box.\n\t\t//\twidth: Number?\n\t\t//\t\tThe width of the text's bounding box.\n\t\t//\theight: Number?\n\t\t//\t\tThe height of the text's bounding box.\n\t\t//\talign: String?\n\t\t//\t\tThe alignment of the text, as defined in SVG. Can be \"start\", \"end\" or \"middle\".\n\t\t//\tfitting: Number?\n\t\t//\t\tHow the text is to be fitted to the bounding box. Can be 0 (no fitting), 1 (fitting based on\n\t\t//\t\tpassed width of the bounding box and the size of the font), or 2 (fit text to the bounding box,\n\t\t//\t\tand ignore any size parameters).\n\t\t//\tleading: Number?\n\t\t//\t\tThe leading to be used between lines in the text.\n\t\t//\tdecoration: String?\n\t\t//\t\tAny text decoration to be used.\n\t};\n\n\tg.Font = {\n\t\t// summary:\n\t\t//\t\tAn object specifying the properties for a Font used in text operations.\n\t\n\t\t// type: String\n\t\t//\t\tSpecifies this object is a Font, value 'font'.\n\t\ttype: \"font\",\n\t\n\t\t// style: String\n\t\t//\t\tThe font style, one of 'normal', 'bold', default value 'normal'.\n\t\tstyle: \"normal\",\n\t\n\t\t// variant: String\n\t\t//\t\tThe font variant, one of 'normal', ... , default value 'normal'.\n\t\tvariant: \"normal\",\n\t\n\t\t// weight: String\n\t\t//\t\tThe font weight, one of 'normal', ..., default value 'normal'.\n\t\tweight: \"normal\",\n\t\n\t\t// size: String\n\t\t//\t\tThe font size (including units), default value '10pt'.\n\t\tsize: \"10pt\",\n\t\n\t\t// family: String\n\t\t//\t\tThe font family, one of 'serif', 'sanserif', ..., default value 'serif'.\n\t\tfamily: \"serif\"\n\t};\n\n\t=====*/\n\n\tlang.mixin(g, {\n\t\t// summary:\n\t\t//\t\tdefines constants, prototypes, and utility functions for the core Graphics API\n\n\t\t// default shapes, which are used to fill in missing parameters\n\t\tdefaultPath: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default Path prototype object.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Path, default value 'path'.\n\t\t\ttype: \"path\", \n\n\t\t\t// path: String\n\t\t\t//\t\tThe path commands. See W32C SVG 1.0 specification.\n\t\t\t//\t\tDefaults to empty string value.\n\t\t\tpath: \"\"\n\t\t},\n\t\tdefaultPolyline: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default PolyLine prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a PolyLine, default value 'polyline'.\n\t\t\ttype: \"polyline\",\n\n\t\t\t// points: Array\n\t\t\t//\t\tAn array of point objects [{x:0,y:0},...] defining the default polyline's line segments. Value is an empty array [].\n\t\t\tpoints: []\n\t\t},\n\t\tdefaultRect: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default Rect prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this default object is a type of Rect. Value is 'rect'\n\t\t\ttype: \"rect\",\n\n\t\t\t// x: Number\n\t\t\t//\t\tThe X coordinate of the default rectangles position, value 0.\n\t\t\tx: 0,\n\n\t\t\t// y: Number\n\t\t\t//\t\tThe Y coordinate of the default rectangle's position, value 0.\n\t\t\ty: 0,\n\n\t\t\t// width: Number\n\t\t\t//\t\tThe width of the default rectangle, value 100.\n\t\t\twidth: 100,\n\n\t\t\t// height: Number\n\t\t\t//\t\tThe height of the default rectangle, value 100.\n\t\t\theight: 100,\n\n\t\t\t// r: Number\n\t\t\t//\t\tThe corner radius for the default rectangle, value 0.\n\t\t\tr: 0\n\t\t},\n\t\tdefaultEllipse: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default Ellipse prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies that this object is a type of Ellipse, value is 'ellipse'\n\t\t\ttype: \"ellipse\",\n\n\t\t\t// cx: Number\n\t\t\t//\t\tThe X coordinate of the center of the ellipse, default value 0.\n\t\t\tcx: 0,\n\n\t\t\t// cy: Number\n\t\t\t//\t\tThe Y coordinate of the center of the ellipse, default value 0.\n\t\t\tcy: 0,\n\n\t\t\t// rx: Number\n\t\t\t//\t\tThe radius of the ellipse in the X direction, default value 200.\n\t\t\trx: 200,\n\n\t\t\t// ry: Number\n\t\t\t//\t\tThe radius of the ellipse in the Y direction, default value 200.\n\t\t\try: 100\n\t\t},\n\t\tdefaultCircle: {\n\t\t\t// summary:\n\t\t\t//\t\tAn object defining the default Circle prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a circle, value 'circle'\n\t\t\ttype: \"circle\",\n\n\t\t\t// cx: Number\n\t\t\t//\t\tThe X coordinate of the center of the circle, default value 0.\n\t\t\tcx: 0,\n\t\t\t// cy: Number\n\t\t\t//\t\tThe Y coordinate of the center of the circle, default value 0.\n\t\t\tcy: 0,\n\n\t\t\t// r: Number\n\t\t\t//\t\tThe radius, default value 100.\n\t\t\tr: 100\n\t\t},\n\t\tdefaultLine: {\n\t\t\t// summary:\n\t\t\t//\t\tAn object defining the default Line prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this is a Line, value 'line'\n\t\t\ttype: \"line\",\n\n\t\t\t// x1: Number\n\t\t\t//\t\tThe X coordinate of the start of the line, default value 0.\n\t\t\tx1: 0,\n\n\t\t\t// y1: Number\n\t\t\t//\t\tThe Y coordinate of the start of the line, default value 0.\n\t\t\ty1: 0,\n\n\t\t\t// x2: Number\n\t\t\t//\t\tThe X coordinate of the end of the line, default value 100.\n\t\t\tx2: 100,\n\n\t\t\t// y2: Number\n\t\t\t//\t\tThe Y coordinate of the end of the line, default value 100.\n\t\t\ty2: 100\n\t\t},\n\t\tdefaultImage: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default Image prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is an image, value 'image'.\n\t\t\ttype: \"image\",\n\n\t\t\t// x: Number\n\t\t\t//\t\tThe X coordinate of the image's position, default value 0.\n\t\t\tx: 0,\n\n\t\t\t// y: Number\n\t\t\t//\t\tThe Y coordinate of the image's position, default value 0.\n\t\t\ty: 0,\n\n\t\t\t// width: Number\n\t\t\t//\t\tThe width of the image, default value 0.\n\t\t\twidth: 0,\n\n\t\t\t// height: Number\n\t\t\t//\t\tThe height of the image, default value 0.\n\t\t\theight: 0,\n\n\t\t\t// src: String\n\t\t\t//\t\tThe src url of the image, defaults to empty string.\n\t\t\tsrc: \"\"\n\t\t},\n\t\tdefaultText: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default Text prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this is a Text shape, value 'text'.\n\t\t\ttype: \"text\",\n\n\t\t\t// x: Number\n\t\t\t//\t\tThe X coordinate of the text position, default value 0.\n\t\t\tx: 0,\n\n\t\t\t// y: Number\n\t\t\t//\t\tThe Y coordinate of the text position, default value 0.\n\t\t\ty: 0,\n\n\t\t\t// text: String\n\t\t\t//\t\tThe text to be displayed, default value empty string.\n\t\t\ttext: \"\",\n\n\t\t\t// align:\tString\n\t\t\t//\t\tThe horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.\n\t\t\talign: \"start\",\n\n\t\t\t// decoration: String\n\t\t\t//\t\tThe text decoration , one of 'none', ... . Default value 'none'.\n\t\t\tdecoration: \"none\",\n\n\t\t\t// rotated: Boolean\n\t\t\t//\t\tWhether the text is rotated, boolean default value false.\n\t\t\trotated: false,\n\n\t\t\t// kerning: Boolean\n\t\t\t//\t\tWhether kerning is used on the text, boolean default value true.\n\t\t\tkerning: true\n\t\t},\n\t\tdefaultTextPath: {\n\t\t\t// summary:\n\t\t\t//\t\tDefines the default TextPath prototype.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this is a TextPath, value 'textpath'.\n\t\t\ttype: \"textpath\",\n\n\t\t\t// text: String\n\t\t\t//\t\tThe text to be displayed, default value empty string.\n\t\t\ttext: \"\",\n\n\t\t\t// align: String\n\t\t\t//\t\tThe horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.\n\t\t\talign: \"start\",\n\n\t\t\t// decoration: String\n\t\t\t//\t\tThe text decoration , one of 'none', ... . Default value 'none'.\n\t\t\tdecoration: \"none\",\n\n\t\t\t// rotated: Boolean\n\t\t\t//\t\tWhether the text is rotated, boolean default value false.\n\t\t\trotated: false,\n\n\t\t\t// kerning: Boolean\n\t\t\t//\t\tWhether kerning is used on the text, boolean default value true.\n\t\t\tkerning: true\n\t\t},\n\n\t\t// default stylistic attributes\n\t\tdefaultStroke: {\n\t\t\t// summary:\n\t\t\t//\t\tA stroke defines stylistic properties that are used when drawing a path.\n\t\t\t//\t\tThis object defines the default Stroke prototype.\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a type of Stroke, value 'stroke'.\n\t\t\ttype: \"stroke\",\n\n\t\t\t// color: String\n\t\t\t//\t\tThe color of the stroke, default value 'black'.\n\t\t\tcolor: \"black\",\n\n\t\t\t// style: String\n\t\t\t//\t\tThe style of the stroke, one of 'solid', ... . Default value 'solid'.\n\t\t\tstyle: \"solid\",\n\n\t\t\t// width: Number\n\t\t\t//\t\tThe width of a stroke, default value 1.\n\t\t\twidth: 1,\n\n\t\t\t// cap: String\n\t\t\t//\t\tThe endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.\n\t\t\tcap: \"butt\",\n\n\t\t\t// join: Number\n\t\t\t//\t\tThe join style to use when combining path segments. Default value 4.\n\t\t\tjoin: 4\n\t\t},\n\t\tdefaultLinearGradient: {\n\t\t\t// summary:\n\t\t\t//\t\tAn object defining the default stylistic properties used for Linear Gradient fills.\n\t\t\t//\t\tLinear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Linear Gradient, value 'linear'\n\t\t\ttype: \"linear\",\n\n\t\t\t// x1: Number\n\t\t\t//\t\tThe X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\t\tx1: 0,\n\n\t\t\t// y1: Number\n\t\t\t//\t\tThe Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.\n\t\t\ty1: 0,\n\n\t\t\t// x2: Number\n\t\t\t//\t\tThe X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\t\tx2: 100,\n\n\t\t\t// y2: Number\n\t\t\t//\t\tThe Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.\n\t\t\ty2: 100,\n\n\t\t\t// colors: Array\n\t\t\t//\t\tAn array of colors at given offsets (from the start of the line).  The start of the line is\n\t\t\t//\t\tdefined at offest 0 with the end of the line at offset 1.\n\t\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\t\tcolors: [\n\t\t\t\t{ offset: 0, color: \"black\" }, { offset: 1, color: \"white\" }\n\t\t\t]\n\t\t},\n\t\tdefaultRadialGradient: {\n\t\t\t// summary:\n\t\t\t//\t\tAn object specifying the default properties for RadialGradients using in fills patterns.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this is a RadialGradient, value 'radial'\n\t\t\ttype: \"radial\",\n\n\t\t\t// cx: Number\n\t\t\t//\t\tThe X coordinate of the center of the radial gradient, default value 0.\n\t\t\tcx: 0,\n\n\t\t\t// cy: Number\n\t\t\t//\t\tThe Y coordinate of the center of the radial gradient, default value 0.\n\t\t\tcy: 0,\n\n\t\t\t// r: Number\n\t\t\t//\t\tThe radius to the end of the radial gradient, default value 100.\n\t\t\tr: 100,\n\n\t\t\t// colors: Array\n\t\t\t//\t\tAn array of colors at given offsets (from the center of the radial gradient).\n\t\t\t//\t\tThe center is defined at offest 0 with the outer edge of the gradient at offset 1.\n\t\t\t//\t\tDefault value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.\n\t\t\tcolors: [\n\t\t\t\t{ offset: 0, color: \"black\" }, { offset: 1, color: \"white\" }\n\t\t\t]\n\t\t},\n\t\tdefaultPattern: {\n\t\t\t// summary:\n\t\t\t//\t\tAn object specifying the default properties for a Pattern using in fill operations.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Pattern, value 'pattern'.\n\t\t\ttype: \"pattern\",\n\n\t\t\t// x: Number\n\t\t\t//\t\tThe X coordinate of the position of the pattern, default value is 0.\n\t\t\tx: 0,\n\n\t\t\t// y: Number\n\t\t\t//\t\tThe Y coordinate of the position of the pattern, default value is 0.\n\t\t\ty: 0,\n\n\t\t\t// width: Number\n\t\t\t//\t\tThe width of the pattern image, default value is 0.\n\t\t\twidth: 0,\n\n\t\t\t// height: Number\n\t\t\t//\t\tThe height of the pattern image, default value is 0.\n\t\t\theight: 0,\n\n\t\t\t// src: String\n\t\t\t//\t\tA url specifying the image to use for the pattern.\n\t\t\tsrc: \"\"\n\t\t},\n\t\tdefaultFont: {\n\t\t\t// summary:\n\t\t\t//\t\tAn object specifying the default properties for a Font used in text operations.\n\n\t\t\t// type: String\n\t\t\t//\t\tSpecifies this object is a Font, value 'font'.\n\t\t\ttype: \"font\",\n\n\t\t\t// style: String\n\t\t\t//\t\tThe font style, one of 'normal', 'bold', default value 'normal'.\n\t\t\tstyle: \"normal\",\n\n\t\t\t// variant: String\n\t\t\t//\t\tThe font variant, one of 'normal', ... , default value 'normal'.\n\t\t\tvariant: \"normal\",\n\n\t\t\t// weight: String\n\t\t\t//\t\tThe font weight, one of 'normal', ..., default value 'normal'.\n\t\t\tweight: \"normal\",\n\n\t\t\t// size: String\n\t\t\t//\t\tThe font size (including units), default value '10pt'.\n\t\t\tsize: \"10pt\",\n\n\t\t\t// family: String\n\t\t\t//\t\tThe font family, one of 'serif', 'sanserif', ..., default value 'serif'.\n\t\t\tfamily: \"serif\"\n\t\t},\n\n\t\tgetDefault: (function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a function used to access default memoized prototype objects (see them defined above).\n\t\t\tvar typeCtorCache = {};\n\t\t\t// a memoized delegate()\n\t\t\treturn function(/*String*/ type){\n\t\t\t\tvar t = typeCtorCache[type];\n\t\t\t\tif(t){\n\t\t\t\t\treturn new t();\n\t\t\t\t}\n\t\t\t\tt = typeCtorCache[type] = new Function();\n\t\t\t\tt.prototype = g[ \"default\" + type ];\n\t\t\t\treturn new t();\n\t\t\t}\n\t\t})(),\n\n\t\tnormalizeColor: function(/*dojo/Color|Array|string|Object*/ color){\n\t\t\t// summary:\n\t\t\t//\t\tconverts any legal color representation to normalized\n\t\t\t//\t\tdojo/Color object\n\t\t\t// color:\n\t\t\t//\t\tA color representation.\n\t\t\treturn (color instanceof Color) ? color : new Color(color); // dojo/Color\n\t\t},\n\t\tnormalizeParameters: function(existed, update){\n\t\t\t// summary:\n\t\t\t//\t\tupdates an existing object with properties from an 'update'\n\t\t\t//\t\tobject\n\t\t\t// existed: Object\n\t\t\t//\t\tthe target object to be updated\n\t\t\t// update: Object\n\t\t\t//\t\tthe 'update' object, whose properties will be used to update\n\t\t\t//\t\tthe existed object\n\t\t\tvar x;\n\t\t\tif(update){\n\t\t\t\tvar empty = {};\n\t\t\t\tfor(x in existed){\n\t\t\t\t\tif(x in update && !(x in empty)){\n\t\t\t\t\t\texisted[x] = update[x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn existed;\t// Object\n\t\t},\n\t\tmakeParameters: function(defaults, update){\n\t\t\t// summary:\n\t\t\t//\t\tcopies the original object, and all copied properties from the\n\t\t\t//\t\t'update' object\n\t\t\t// defaults: Object\n\t\t\t//\t\tthe object to be cloned before updating\n\t\t\t// update: Object\n\t\t\t//\t\tthe object, which properties are to be cloned during updating\n\t\t\t// returns: Object\n\t\t\t//      new object with new and default properties\n\t\t\tvar i = null;\n\t\t\tif(!update){\n\t\t\t\t// return dojo.clone(defaults);\n\t\t\t\treturn lang.delegate(defaults);\n\t\t\t}\n\t\t\tvar result = {};\n\t\t\tfor(i in defaults){\n\t\t\t\tif(!(i in result)){\n\t\t\t\t\tresult[i] = lang.clone((i in update) ? update[i] : defaults[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result; // Object\n\t\t},\n\t\tformatNumber: function(x, addSpace){\n\t\t\t// summary:\n\t\t\t//\t\tconverts a number to a string using a fixed notation\n\t\t\t// x: Number\n\t\t\t//\t\tnumber to be converted\n\t\t\t// addSpace: Boolean\n\t\t\t//\t\twhether to add a space before a positive number\n\t\t\t// returns: String\n\t\t\t//      the formatted value\n\t\t\tvar val = x.toString();\n\t\t\tif(val.indexOf(\"e\") >= 0){\n\t\t\t\tval = x.toFixed(4);\n\t\t\t}else{\n\t\t\t\tvar point = val.indexOf(\".\");\n\t\t\t\tif(point >= 0 && val.length - point > 5){\n\t\t\t\t\tval = x.toFixed(4);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x < 0){\n\t\t\t\treturn val; // String\n\t\t\t}\n\t\t\treturn addSpace ? \" \" + val : val; // String\n\t\t},\n\t\t// font operations\n\t\tmakeFontString: function(font){\n\t\t\t// summary:\n\t\t\t//\t\tconverts a font object to a CSS font string\n\t\t\t// font: Object\n\t\t\t//\t\tfont object (see dojox/gfx.defaultFont)\n\t\t\treturn font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \" \" + font.family; // Object\n\t\t},\n\t\tsplitFontString: function(str){\n\t\t\t// summary:\n\t\t\t//\t\tconverts a CSS font string to a font object\n\t\t\t// description:\n\t\t\t//\t\tConverts a CSS font string to a gfx font object. The CSS font\n\t\t\t//\t\tstring components should follow the W3C specified order\n\t\t\t//\t\t(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):\n\t\t\t//\t\tstyle, variant, weight, size, optional line height (will be\n\t\t\t//\t\tignored), and family. Note that the Font.size attribute is limited to numeric CSS length.\n\t\t\t// str: String\n\t\t\t//\t\ta CSS font string.\n\t\t\t// returns: Object\n\t\t\t//      object in dojox/gfx.defaultFont format\n\t\t\tvar font = g.getDefault(\"Font\");\n\t\t\tvar t = str.split(/\\s+/);\n\t\t\tdo{\n\t\t\t\tif(t.length < 5){ break; }\n\t\t\t\tfont.style   = t[0];\n\t\t\t\tfont.variant = t[1];\n\t\t\t\tfont.weight  = t[2];\n\t\t\t\tvar i = t[3].indexOf(\"/\");\n\t\t\t\tfont.size = i < 0 ? t[3] : t[3].substring(0, i);\n\t\t\t\tvar j = 4;\n\t\t\t\tif(i < 0){\n\t\t\t\t\tif(t[4] == \"/\"){\n\t\t\t\t\t\tj = 6;\n\t\t\t\t\t}else if(t[4].charAt(0) == \"/\"){\n\t\t\t\t\t\tj = 5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j < t.length){\n\t\t\t\t\tfont.family = t.slice(j).join(\" \");\n\t\t\t\t}\n\t\t\t}while(false);\n\t\t\treturn font;\t// Object\n\t\t},\n\t\t// length operations\n\n\t\t// cm_in_pt: Number\n\t\t//\t\tpoints per centimeter (constant)\n\t\tcm_in_pt: 72 / 2.54,\n\n\t\t// mm_in_pt: Number\n\t\t//\t\tpoints per millimeter (constant)\n\t\tmm_in_pt: 7.2 / 2.54,\n\n\t\tpx_in_pt: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the current number of pixels per point.\n\t\t\treturn g._base._getCachedFontMeasurements()[\"12pt\"] / 12;\t// Number\n\t\t},\n\n\t\tpt2px: function(len){\n\t\t\t// summary:\n\t\t\t//\t\tconverts points to pixels\n\t\t\t// len: Number\n\t\t\t//\t\ta value in points\n\t\t\treturn len * g.px_in_pt();\t// Number\n\t\t},\n\n\t\tpx2pt: function(len){\n\t\t\t// summary:\n\t\t\t//\t\tconverts pixels to points\n\t\t\t// len: Number\n\t\t\t//\t\ta value in pixels\n\t\t\treturn len / g.px_in_pt();\t// Number\n\t\t},\n\n\t\tnormalizedLength: function(len) {\n\t\t\t// summary:\n\t\t\t//\t\tconverts any length value to pixels\n\t\t\t// len: String\n\t\t\t//\t\ta length, e.g., '12pc'\n\t\t\t// returns: Number\n\t\t\t//      pixels\n\t\t\tif(len.length === 0){ return 0; }\n\t\t\tif(len.length > 2){\n\t\t\t\tvar px_in_pt = g.px_in_pt();\n\t\t\t\tvar val = parseFloat(len);\n\t\t\t\tswitch(len.slice(-2)){\n\t\t\t\t\tcase \"px\": return val;\n\t\t\t\t\tcase \"pt\": return val * px_in_pt;\n\t\t\t\t\tcase \"in\": return val * 72 * px_in_pt;\n\t\t\t\t\tcase \"pc\": return val * 12 * px_in_pt;\n\t\t\t\t\tcase \"mm\": return val * g.mm_in_pt * px_in_pt;\n\t\t\t\t\tcase \"cm\": return val * g.cm_in_pt * px_in_pt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parseFloat(len);\t// Number\n\t\t},\n\n\t\t// pathVmlRegExp: RegExp\n\t\t//\t\ta constant regular expression used to split a SVG/VML path into primitive components\n\t\t// tags:\n\t\t//\t\tprivate\n\t\tpathVmlRegExp: /([A-Za-z]+)|(\\d+(\\.\\d+)?)|(\\.\\d+)|(-\\d+(\\.\\d+)?)|(-\\.\\d+)/g,\n\n\t\t// pathVmlRegExp: RegExp\n\t\t//\t\ta constant regular expression used to split a SVG/VML path into primitive components\n\t\t// tags:\n\t\t//\t\tprivate\n\t\tpathSvgRegExp: /([A-DF-Za-df-z])|([-+]?\\d*[.]?\\d+(?:[eE][-+]?\\d+)?)/g,\n\n\t\tequalSources: function(a, b){\n\t\t\t// summary:\n\t\t\t//\t\tcompares event sources, returns true if they are equal\n\t\t\t// a: Object\n\t\t\t//\t\tfirst event source\n\t\t\t// b: Object\n\t\t\t//\t\tevent source to compare against a\n\t\t\t// returns: Boolean\n\t\t\t//      true, if objects are truthy and the same\n\t\t\treturn a && b && a === b;\n\t\t},\n\n\t\tswitchTo: function(/*String|Object*/ renderer){\n\t\t\t// summary:\n\t\t\t//\t\tswitch the graphics implementation to the specified renderer.\n\t\t\t// renderer:\n\t\t\t//\t\tEither the string name of a renderer (eg. 'canvas', 'svg, ...) or the renderer\n\t\t\t//\t\tobject to switch to.\n\t\t\tvar ns = typeof renderer == \"string\" ? g[renderer] : renderer;\n\t\t\tif(ns){\n\t\t\t\t// If more options are added, update the docblock at the end of shape.js!\n\t\t\t\tarr.forEach([\"Group\", \"Rect\", \"Ellipse\", \"Circle\", \"Line\",\n\t\t\t\t\t\t\"Polyline\", \"Image\", \"Text\", \"Path\", \"TextPath\",\n\t\t\t\t\t\t\"Surface\", \"createSurface\", \"fixTarget\"], function(name){\n\t\t\t\t\tg[name] = ns[name];\n\t\t\t\t});\n\t\t\t\tif(typeof renderer == \"string\"){\n\t\t\t\t\tg.renderer = renderer;\n\t\t\t\t}else{\n\t\t\t\t\tarr.some([\"svg\",\"vml\",\"canvas\",\"canvasWithEvents\",\"silverlight\"], function(r){\n\t\t\t\t\t\treturn (g.renderer = g[r] && g[r].Surface === g.Surface ? r : null);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\t/*=====\n\t\tg.createSurface = function(parentNode, width, height){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a surface\n\t\t\t// parentNode: Node\n\t\t\t//\t\ta parent node\n\t\t\t// width: String|Number\n\t\t\t//\t\twidth of surface, e.g., \"100px\" or 100\n\t\t\t// height: String|Number\n\t\t\t//\t\theight of surface, e.g., \"100px\" or 100\n\t\t\t// returns: dojox/gfx.Surface\n\t\t\t//     newly created surface\n\t\t};\n\t\tg.fixTarget = function(){\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t};\n\t=====*/\n\t\n\treturn g; // defaults object api\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/_base.js\n// module id = 167\n// module chunks = 4","define([\"./_base\", \"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/declare\", \"dojo/_base/window\", \"dojo/dom-geometry\",\n\t\t\"dojo/dom\", \"./shape\", \"./path\", \"./arc\", \"./matrix\", \"./decompose\", \"./bezierutils\"],\nfunction(g, lang, arr, declare, win, domGeom, dom, gs, pathLib, ga, m, decompose, bezierUtils ){\n\tvar canvas = g.canvas = {\n\t\t// summary:\n\t\t//\t\tThis the graphics rendering bridge for W3C Canvas compliant browsers.\n\t\t//\t\tSince Canvas is an immediate mode graphics api, with no object graph or\n\t\t//\t\teventing capabilities, use of this module alone will only add in drawing support.\n\t\t//\t\tThe additional module, canvasWithEvents extends this module with additional support\n\t\t//\t\tfor handling events on Canvas.  By default, the support for events is now included\n\t\t//\t\thowever, if only drawing capabilities are needed, canvas event module can be disabled\n\t\t//\t\tusing the dojoConfig option, canvasEvents:true|false.\n\t\t//\t\tThe id of the Canvas renderer is 'canvas'.  This id can be used when switch Dojo's\n\t\t//\t\tgraphics context between renderer implementations.  See dojox/gfx/_base.switchRenderer\n\t\t//\t\tAPI.\n\t};\n\tvar pattrnbuffer = null,\n\t\tmp = m.multiplyPoint,\n\t\tpi = Math.PI,\n\t\ttwoPI = 2 * pi,\n\t\thalfPI = pi /2,\n\t\textend = lang.extend;\n\n\tif(win.global.CanvasRenderingContext2D){\n\t\tvar ctx2d = win.doc.createElement(\"canvas\").getContext(\"2d\");\n\t\tvar hasNativeDash = typeof ctx2d.setLineDash == \"function\";\n\t\tvar hasFillText = typeof ctx2d.fillText == \"function\";\n\t}\n\n\tvar dasharray = {\n\t\tsolid:\t\t\t\t\"none\",\n\t\tshortdash:\t\t\t[4, 1],\n\t\tshortdot:\t\t\t[1, 1],\n\t\tshortdashdot:\t\t[4, 1, 1, 1],\n\t\tshortdashdotdot:\t[4, 1, 1, 1, 1, 1],\n\t\tdot:\t\t\t\t[1, 3],\n\t\tdash:\t\t\t\t[4, 3],\n\t\tlongdash:\t\t\t[8, 3],\n\t\tdashdot:\t\t\t[4, 3, 1, 3],\n\t\tlongdashdot:\t\t[8, 3, 1, 3],\n\t\tlongdashdotdot:\t\t[8, 3, 1, 3, 1, 3]\n\t};\n\n\tfunction drawDashedArc(/*CanvasRenderingContext2D*/ctx, /*Number[]*/dash,  /*int*/cx,  /*int*/cy,  /*int*/r, /*Number*/sa, /*Number*/ea, /*Boolean*/ccw, /*Boolean?*/apply, prevResidue){\n\t\tvar residue, angle, l = dash.length, i= 0;\n\t\t// if there's a previous dash residue from the previous arc, start with it.\n\t\tif(prevResidue){\n\t\t\tangle = prevResidue.l/r;\n\t\t\ti = prevResidue.i;\n\t\t}else{\n\t\t\tangle = dash[0]/r;\n\t\t}\n\t\twhile(sa < ea){\n\t\t\t// if the dash segment length is longer than what remains to stroke, keep it for next arc. (aka residue)\n\t\t\tif(sa+angle > ea){\n\t\t\t\tresidue = {l: (sa+angle-ea)*r, i: i};\n\t\t\t\tangle = ea-sa;\n\t\t\t}\n\t\t\tif(!(i%2)){\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(cx, cy, r, sa, sa+angle, ccw);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t}\n\t\t\tsa += angle;\n\t\t\t++i;\n\t\t\tangle = dash[i%l]/r;\n\t\t}\n\t\treturn residue;\n\t}\n\n\tfunction splitToDashedBezier(/*Number[]*/points, /*Number[]*/dashArray, /*Number[]*/newPoints, /*Object*/prevResidue){\n\t\tvar residue = 0, t = 0, dash, i = 0;\n\t\tif(prevResidue){\n\t\t\tdash = prevResidue.l;\n\t\t\ti = prevResidue.i;\n\t\t}else{\n\t\t\tdash = dashArray[0];\n\t\t}\n\t\twhile(t<1){\n\t\t\t// get the 't' corresponding to the given dash value.\n\t\t\tt = bezierUtils.tAtLength(points, dash);\n\t\t\tif(t==1){\n\t\t\t\tvar rl = bezierUtils.computeLength(points);\n\t\t\t\tresidue = {l: dash-rl, i: i};\n\t\t\t}\n\t\t\t// split bezier at t: left part is the \"dash\" curve, right part is the remaining bezier points\n\t\t\tvar curves = bezierUtils.splitBezierAtT(points, t);\n\t\t\tif(!(i%2)){\n\t\t\t\t// only keep the \"dash\" curve\n\t\t\t\tnewPoints.push(curves[0]);\n\t\t\t}\n\t\t\tpoints = curves[1];\n\t\t\t++i;\n\t\t\tdash = dashArray[i%dashArray.length];\n\t\t}\n\t\treturn residue;\n\t}\n\n\tfunction toDashedCurveTo(/*Array||CanvasRenderingContext2D*/ctx, /*shape.Path*/shape, /*Number[]*/points, /*Object*/prevResidue){\n\t\t// summary:\n\t\t//\t\tBuilds a set of bezier (cubic || quadratic)curveTo' canvas instructions that represents a dashed stroke of the specified bezier geometry.\n\n\t\tvar pts = [shape.last.x, shape.last.y].concat(points),\n\t\t\tquadratic = points.length === 4, ctx2d = !(ctx instanceof Array),\n\t\t\tapi = quadratic ? \"quadraticCurveTo\" : \"bezierCurveTo\",\n\t\t\tcurves = [];\n\t\tvar residue = splitToDashedBezier(pts, shape.canvasDash, curves, prevResidue);\n\t\tfor(var c=0; c<curves.length;++c){\n\t\t\tvar curve = curves[c];\n\t\t\tif(ctx2d){\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\t\tctx[api].apply(ctx, curve.slice(2));\n\t\t\t}else{\n\t\t\t\tctx.push(\"moveTo\", [curve[0], curve[1]]);\n\t\t\t\tctx.push(api, curve.slice(2));\n\t\t\t}\n\t\t}\n\t\treturn residue;\n\t}\n\n\tfunction toDashedLineTo(/*Array||CanvasRenderingContext2D*/ctx, /*shape.Shape*/shape, /*int*/x1, /*int*/y1, /*int*/x2, /*int*/y2, /*Object*/prevResidue){\n\t\t// summary:\n\t\t//\t\tBuilds a set of moveTo/lineTo' canvas instructions that represents a dashed stroke of the specified line geometry.\n\n\t\tvar residue = 0, r = 0, dal = 0, tlength = bezierUtils.distance(x1, y1, x2, y2), i = 0, dash = shape.canvasDash,\n\t\t\tprevx = x1, prevy = y1, x, y, ctx2d = !(ctx instanceof Array);\n\t\tif(prevResidue){\n\t\t\tdal=prevResidue.l;\n\t\t\ti = prevResidue.i;\n\t\t}else{\n\t\t\tdal += dash[0];\n\t\t}\n\t\twhile(Math.abs(1-r)>0.01){\n\t\t\tif(dal>tlength){\n\t\t\t\tresidue = {l:dal-tlength,i:i};\n\t\t\t\tdal=tlength;\n\t\t\t}\n\t\t\tr = dal/tlength;\n\t\t\tx = x1 + (x2-x1)*r;\n\t\t\ty = y1 + (y2-y1)*r;\n\t\t\tif(!(i++%2)){\n\t\t\t\tif(ctx2d){\n\t\t\t\t\tctx.moveTo(prevx, prevy);\n\t\t\t\t\tctx.lineTo(x, y);\n\t\t\t\t}else{\n\t\t\t\t\tctx.push(\"moveTo\", [prevx, prevy]);\n\t\t\t\t\tctx.push(\"lineTo\", [x, y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevx = x;\n\t\t\tprevy = y;\n\t\t\tdal += dash[i%dash.length];\n\t\t}\n\t\treturn residue;\n\t}\n\n\tcanvas.Shape = declare(\"dojox.gfx.canvas.Shape\", gs.Shape, {\n\t\t_render: function(/* Object */ ctx){\n\t\t\t// summary:\n\t\t\t//\t\trender the shape\n\t\t\tctx.save();\n\t\t\tthis._renderTransform(ctx);\n\t\t\tthis._renderClip(ctx);\n\t\t\tthis._renderShape(ctx);\n\t\t\tthis._renderFill(ctx, true);\n\t\t\tthis._renderStroke(ctx, true);\n\t\t\tctx.restore();\n\t\t},\n\t\t_renderClip: function(ctx){\n\t\t\tif (this.canvasClip){\n\t\t\t\tthis.canvasClip.render(ctx);\n\t\t\t\tctx.clip();\n\t\t\t}\n\t\t},\n\t\t_renderTransform: function(/* Object */ ctx){\n\t\t\tif(\"canvasTransform\" in this){\n\t\t\t\tvar t = this.canvasTransform;\n\t\t\t\tctx.translate(t.dx, t.dy);\n\t\t\t\tctx.rotate(t.angle2);\n\t\t\t\tctx.scale(t.sx, t.sy);\n\t\t\t\tctx.rotate(t.angle1);\n\t\t\t\t// The future implementation when vendors catch up with the spec:\n\t\t\t\t// var t = this.matrix;\n\t\t\t\t// ctx.transform(t.xx, t.yx, t.xy, t.yy, t.dx, t.dy);\n\t\t\t}\n\t\t},\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\t// nothing\n\t\t},\n\t\t_renderFill: function(/* Object */ ctx, /* Boolean */ apply){\n\t\t\tif(\"canvasFill\" in this){\n\t\t\t\tvar fs = this.fillStyle;\n\t\t\t\tif(\"canvasFillImage\" in this){\n\t\t\t\t\tvar w = fs.width, h = fs.height,\n\t\t\t\t\t\tiw = this.canvasFillImage.width, ih = this.canvasFillImage.height,\n\t\t\t\t\t\t// let's match the svg default behavior wrt. aspect ratio: xMidYMid meet\n\t\t\t\t\t\tsx = w == iw ? 1 : w / iw,\n\t\t\t\t\t\tsy = h == ih ? 1 : h / ih,\n\t\t\t\t\t\ts = Math.min(sx,sy), //meet->math.min , slice->math.max\n\t\t\t\t\t\tdx = (w - s * iw)/2,\n\t\t\t\t\t\tdy = (h - s * ih)/2;\n\t\t\t\t\t// the buffer used to scaled the image\n\t\t\t\t\tpattrnbuffer.width = w; pattrnbuffer.height = h;\n\t\t\t\t\tvar copyctx = pattrnbuffer.getContext(\"2d\");\n\t\t\t\t\tcopyctx.clearRect(0, 0, w, h);\n\t\t\t\t\tcopyctx.drawImage(this.canvasFillImage, 0, 0, iw, ih, dx, dy, s*iw, s*ih);\n\t\t\t\t\tthis.canvasFill = ctx.createPattern(pattrnbuffer, \"repeat\");\n\t\t\t\t\tdelete this.canvasFillImage;\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = this.canvasFill;\n\t\t\t\tif(apply){\n\t\t\t\t\t// offset the pattern\n\t\t\t\t\tif (fs.type===\"pattern\" && (fs.x !== 0 || fs.y !== 0)) {\n\t\t\t\t\t\tctx.translate(fs.x,fs.y);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tctx.fillStyle = \"rgba(0,0,0,0.0)\";\n\t\t\t}\n\t\t},\n\t\t_renderStroke: function(/* Object */ ctx, /* Boolean */ apply){\n\t\t\tvar s = this.strokeStyle;\n\t\t\tif(s){\n\t\t\t\tctx.strokeStyle = s.color.toString();\n\t\t\t\tctx.lineWidth = s.width;\n\t\t\t\tctx.lineCap = s.cap;\n\t\t\t\tif(typeof s.join == \"number\"){\n\t\t\t\t\tctx.lineJoin = \"miter\";\n\t\t\t\t\tctx.miterLimit = s.join;\n\t\t\t\t}else{\n\t\t\t\t\tctx.lineJoin = s.join;\n\t\t\t\t}\n\t\t\t\tif(this.canvasDash){\n\t\t\t\t\tif(hasNativeDash){\n\t\t\t\t\t\tctx.setLineDash(this.canvasDash);\n\t\t\t\t\t\tif(apply){ ctx.stroke(); }\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis._renderDashedStroke(ctx, apply);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(apply){ ctx.stroke(); }\n\t\t\t\t}\n\t\t\t}else if(!apply){\n\t\t\t\tctx.strokeStyle = \"rgba(0,0,0,0.0)\";\n\t\t\t}\n\t\t},\n\t\t_renderDashedStroke: function(ctx, apply){},\n\n\t\t// events are not implemented\n\t\tgetEventSource: function(){ return null; },\n\t\ton:\t\t\t\tfunction(){},\n\t\tconnect:\t\tfunction(){},\n\t\tdisconnect:\t\tfunction(){},\n\n\t\tcanvasClip:null,\n\t\tsetClip: function(/*Object*/clip){\n\t\t\tthis.inherited(arguments);\n\t\t\tvar clipType = clip ? \"width\" in clip ? \"rect\" :\n\t\t\t\t\t\t\t\"cx\" in clip ? \"ellipse\" :\n\t\t\t\t\t\t\t\"points\" in clip ? \"polyline\" : \"d\" in clip ? \"path\" : null : null;\n\t\t\tif(clip && !clipType){\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.canvasClip = clip ? makeClip(clipType, clip) : null;\n\t\t\tif(this.parent){this.parent._makeDirty();}\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tvar makeClip = function(clipType, geometry){\n\t\tswitch(clipType){\n\t\t\tcase \"ellipse\":\n\t\t\t\treturn {\n\t\t\t\t\tcanvasEllipse: makeEllipse({shape:geometry}),\n\t\t\t\t\trender: function(ctx){return canvas.Ellipse.prototype._renderShape.call(this, ctx);}\n\t\t\t\t};\n\t\t\tcase \"rect\":\n\t\t\t\treturn {\n\t\t\t\t\tshape: lang.delegate(geometry,{r:0}),\n\t\t\t\t\trender: function(ctx){return canvas.Rect.prototype._renderShape.call(this, ctx);}\n\t\t\t\t};\n\t\t\tcase \"path\":\n\t\t\t\treturn {\n\t\t\t\t\tcanvasPath: makeClipPath(geometry),\n\t\t\t\t\trender: function(ctx){this.canvasPath._renderShape(ctx);}\n\t\t\t\t};\n\t\t\tcase \"polyline\":\n\t\t\t\treturn {\n\t\t\t\t\tcanvasPolyline: geometry.points,\n\t\t\t\t\trender: function(ctx){return canvas.Polyline.prototype._renderShape.call(this, ctx);}\n\t\t\t\t};\n\t\t}\n\t\treturn null;\n\t};\n\n\tvar makeClipPath = function(geo){\n\t\tvar p = new dojox.gfx.canvas.Path();\n\t\tp.canvasPath = [];\n\t\tp._setPath(geo.d);\n\t\treturn p;\n\t};\n\n\tvar modifyMethod = function(shape, method, extra){\n\t\tvar old = shape.prototype[method];\n\t\tshape.prototype[method] = extra ?\n\t\t\tfunction(){\n\t\t\t\tif(this.parent){this.parent._makeDirty();}\n\t\t\t\told.apply(this, arguments);\n\t\t\t\textra.call(this);\n\t\t\t\treturn this;\n\t\t\t} :\n\t\t\tfunction(){\n\t\t\t\tif(this.parent){this.parent._makeDirty();}\n\t\t\t\treturn old.apply(this, arguments);\n\t\t\t};\n\t};\n\n\tmodifyMethod(canvas.Shape, \"setTransform\",\n\t\tfunction(){\n\t\t\t// prepare Canvas-specific structures\n\t\t\tif(this.matrix){\n\t\t\t\tthis.canvasTransform = g.decompose(this.matrix);\n\t\t\t}else{\n\t\t\t\tdelete this.canvasTransform;\n\t\t\t}\n\t\t});\n\n\tmodifyMethod(canvas.Shape, \"setFill\",\n\t\tfunction(){\n\t\t\t// prepare Canvas-specific structures\n\t\t\tvar fs = this.fillStyle, f;\n\t\t\tif(fs){\n\t\t\t\tif(typeof(fs) == \"object\" && \"type\" in fs){\n\t\t\t\t\tvar ctx = this.surface.rawNode.getContext(\"2d\");\n\t\t\t\t\tswitch(fs.type){\n\t\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\t\tf = fs.type == \"linear\" ?\n\t\t\t\t\t\t\t\tctx.createLinearGradient(fs.x1, fs.y1, fs.x2, fs.y2) :\n\t\t\t\t\t\t\t\tctx.createRadialGradient(fs.cx, fs.cy, 0, fs.cx, fs.cy, fs.r);\n\t\t\t\t\t\t\tarr.forEach(fs.colors, function(step){\n\t\t\t\t\t\t\t\tf.addColorStop(step.offset, g.normalizeColor(step.color).toString());\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\t\tif (!pattrnbuffer) {\n\t\t\t\t\t\t\t\tpattrnbuffer = document.createElement(\"canvas\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// no need to scale the image since the canvas.createPattern uses\n\t\t\t\t\t\t\t// the original image data and not the scaled ones (see spec.)\n\t\t\t\t\t\t\t// the scaling needs to be done at rendering time in a context buffer\n\t\t\t\t\t\t\tvar img =new Image();\n\t\t\t\t\t\t\tthis.surface.downloadImage(img, fs.src);\n\t\t\t\t\t\t\tthis.canvasFillImage = img;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// Set fill color using CSS RGBA func style\n\t\t\t\t\tf = fs.toString();\n\t\t\t\t}\n\t\t\t\tthis.canvasFill = f;\n\t\t\t}else{\n\t\t\t\tdelete this.canvasFill;\n\t\t\t}\n\t\t});\n\n\tmodifyMethod(canvas.Shape, \"setStroke\",\n\t\tfunction(){\n\t\t\tvar st = this.strokeStyle;\n\t\t\tif(st){\n\t\t\t\tvar da = this.strokeStyle.style.toLowerCase();\n\t\t\t\tif(da in dasharray){\n\t\t\t\t\tda = dasharray[da];\n\t\t\t\t}\n\t\t\t\tif(da instanceof Array){\n\t\t\t\t\tda = da.slice();\n\t\t\t\t\tthis.canvasDash = da;\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor(i = 0; i < da.length; ++i){\n\t\t\t\t\t\tda[i] *= st.width;\n\t\t\t\t\t}\n\t\t\t\t\tif(st.cap != \"butt\"){\n\t\t\t\t\t\tfor(i = 0; i < da.length; i += 2){\n\t\t\t\t\t\t\tda[i] -= st.width;\n\t\t\t\t\t\t\tif(da[i] < 1){ da[i] = 1; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(i = 1; i < da.length; i += 2){\n\t\t\t\t\t\t\tda[i] += st.width;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdelete this.canvasDash;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdelete this.canvasDash;\n\t\t\t}\n\t\t\tthis._needsDash = !hasNativeDash && !!this.canvasDash;\n\t\t});\n\n\tmodifyMethod(canvas.Shape, \"setShape\");\n\n\tcanvas.Group = declare(\"dojox.gfx.canvas.Group\", canvas.Shape, {\n\t\t// summary:\n\t\t//\t\ta group shape (Canvas), which can be used\n\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\n\t\tconstructor: function(){\n\t\t\tgs.Container._init.call(this);\n\t\t},\n\t\t_render: function(/* Object */ ctx){\n\t\t\t// summary:\n\t\t\t//\t\trender the group\n\t\t\tctx.save();\n\t\t\tthis._renderTransform(ctx);\n\t\t\tthis._renderClip(ctx);\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\tthis.children[i]._render(ctx);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t},\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReleases all internal resources owned by this shape. Once this method has been called,\n\t\t\t//\t\tthe instance is considered disposed and should not be used anymore.\n\n\t\t\t// don't call canvas impl to avoid makeDirty'\n\t\t\tgs.Container.clear.call(this, true);\n\t\t\t// avoid this.inherited\n\t\t\tcanvas.Shape.prototype.destroy.apply(this, arguments);\n\t\t}\n\t});\n\n\n\n\tcanvas.Rect = declare(\"dojox.gfx.canvas.Rect\", [canvas.Shape, gs.Rect], {\n\t\t// summary:\n\t\t//\t\ta rectangle shape (Canvas)\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar s = this.shape, r = Math.min(s.r, s.height / 2, s.width / 2),\n\t\t\t\txl = s.x, xr = xl + s.width, yt = s.y, yb = yt + s.height,\n\t\t\t\txl2 = xl + r, xr2 = xr - r, yt2 = yt + r, yb2 = yb - r;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(xl2, yt);\n\t\t\tif(r){\n\t\t\t\tctx.arc(xr2, yt2, r, -halfPI, 0, false);\n\t\t\t\tctx.arc(xr2, yb2, r, 0, halfPI, false);\n\t\t\t\tctx.arc(xl2, yb2, r, halfPI, pi, false);\n\t\t\t\tctx.arc(xl2, yt2, r, pi, pi + halfPI, false);\n\t\t\t}else{\n\t\t\t\tctx.lineTo(xr2, yt);\n\t\t\t\tctx.lineTo(xr, yb2);\n\t\t\t\tctx.lineTo(xl2, yb);\n\t\t\t\tctx.lineTo(xl, yt2);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t},\n\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\tvar s = this.shape, residue, r = Math.min(s.r, s.height / 2, s.width / 2),\n\t\t\t\txl = s.x, xr = xl + s.width, yt = s.y, yb = yt + s.height,\n\t\t\t\txl2 = xl + r, xr2 = xr - r, yt2 = yt + r, yb2 = yb - r;\n\t\t\tif(r){\n\t\t\t\tctx.beginPath();\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xl2, yt, xr2, yt);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\tresidue = drawDashedArc(ctx, this.canvasDash, xr2, yt2, r, -halfPI, 0, false, apply, residue);\n\t\t\t\tctx.beginPath();\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xr, yt2, xr, yb2, residue);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\tresidue = drawDashedArc(ctx, this.canvasDash, xr2, yb2, r, 0, halfPI, false, apply, residue);\n\t\t\t\tctx.beginPath();\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xr2, yb, xl2, yb, residue);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\tresidue = drawDashedArc(ctx, this.canvasDash, xl2, yb2, r, halfPI, pi, false, apply, residue);\n\t\t\t\tctx.beginPath();\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xl, yb2, xl, yt2,residue);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\tdrawDashedArc(ctx, this.canvasDash, xl2, yt2, r, pi, pi + halfPI, false, apply, residue);\n\t\t\t}else{\n\t\t\t\tctx.beginPath();\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xl2, yt, xr2, yt);\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xr2, yt, xr, yb2, residue);\n\t\t\t\tresidue = toDashedLineTo(ctx, this, xr, yb2, xl2, yb, residue);\n\t\t\t\ttoDashedLineTo(ctx, this, xl2, yb, xl, yt2, residue);\n\t\t\t\tif(apply) ctx.stroke();\n\t\t\t}\n\t\t}\n\t});\n\n\tvar bezierCircle = [];\n\t(function(){\n\t\tvar u = ga.curvePI4;\n\t\tbezierCircle.push(u.s, u.c1, u.c2, u.e);\n\t\tfor(var a = 45; a < 360; a += 45){\n\t\t\tvar r = m.rotateg(a);\n\t\t\tbezierCircle.push(mp(r, u.c1), mp(r, u.c2), mp(r, u.e));\n\t\t}\n\t})();\n\n\tvar makeEllipse = function(shape){\n\t\t// prepare Canvas-specific structures\n\t\tvar t, c1, c2, r = [], s = shape.shape,\n\t\t\tM = m.normalize([m.translate(s.cx, s.cy), m.scale(s.rx, s.ry)]);\n\t\tt = mp(M, bezierCircle[0]);\n\t\tr.push([t.x, t.y]);\n\t\tfor(var i = 1; i < bezierCircle.length; i += 3){\n\t\t\tc1 = mp(M, bezierCircle[i]);\n\t\t\tc2 = mp(M, bezierCircle[i + 1]);\n\t\t\tt  = mp(M, bezierCircle[i + 2]);\n\t\t\tr.push([c1.x, c1.y, c2.x, c2.y, t.x, t.y]);\n\t\t}\n\t\tif(shape._needsDash){\n\t\t\tvar points = [], p1 = r[0];\n\t\t\tfor(i = 1; i < r.length; ++i){\n\t\t\t\tvar curves = [];\n\t\t\t\tsplitToDashedBezier(p1.concat(r[i]), shape.canvasDash, curves);\n\t\t\t\tp1 = [r[i][4],r[i][5]];\n\t\t\t\tpoints.push(curves);\n\t\t\t}\n\t\t\tshape._dashedPoints = points;\n\t\t}\n\t\treturn r;\n\t};\n\n\tcanvas.Ellipse = declare(\"dojox.gfx.canvas.Ellipse\", [canvas.Shape, gs.Ellipse], {\n\t\t// summary:\n\t\t//\t\tan ellipse shape (Canvas)\n\t\tsetShape: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tthis.canvasEllipse = makeEllipse(this);\n\t\t\treturn this;\n\t\t},\n\t\tsetStroke: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tif(!hasNativeDash){\n\t\t\t\tthis.canvasEllipse = makeEllipse(this);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar r = this.canvasEllipse, i;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo.apply(ctx, r[0]);\n\t\t\tfor(i = 1; i < r.length; ++i){\n\t\t\t\tctx.bezierCurveTo.apply(ctx, r[i]);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t},\n\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\tvar r = this._dashedPoints;\n\t\t\tctx.beginPath();\n\t\t\tfor(var i = 0; i < r.length; ++i){\n\t\t\t\tvar curves = r[i];\n\t\t\t\tfor(var j=0;j<curves.length;++j){\n\t\t\t\t\tvar curve = curves[j];\n\t\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\t\t\tctx.bezierCurveTo(curve[2],curve[3],curve[4],curve[5],curve[6],curve[7]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(apply) ctx.stroke();\n\t\t}\n\t});\n\n\tcanvas.Circle = declare(\"dojox.gfx.canvas.Circle\", [canvas.Shape, gs.Circle], {\n\t\t// summary:\n\t\t//\t\ta circle shape (Canvas)\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar s = this.shape;\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(s.cx, s.cy, s.r, 0, twoPI, 1);\n\t\t},\n\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\tvar s = this.shape;\n\t\t\tvar startAngle = 0, angle, l = this.canvasDash.length; i=0;\n\t\t\twhile(startAngle < twoPI){\n\t\t\t\tangle = this.canvasDash[i%l]/s.r;\n\t\t\t\tif(!(i%2)){\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(s.cx, s.cy, s.r, startAngle, startAngle+angle, 0);\n\t\t\t\t\tif(apply) ctx.stroke();\n\t\t\t\t}\n\t\t\t\tstartAngle+=angle;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t});\n\n\tcanvas.Line = declare(\"dojox.gfx.canvas.Line\", [canvas.Shape, gs.Line], {\n\t\t// summary:\n\t\t//\t\ta line shape (Canvas)\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar s = this.shape;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(s.x1, s.y1);\n\t\t\tctx.lineTo(s.x2, s.y2);\n\t\t},\n\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\tvar s = this.shape;\n\t\t\tctx.beginPath();\n\t\t\ttoDashedLineTo(ctx, this, s.x1, s.y1, s.x2, s.y2);\n\t\t\tif(apply) ctx.stroke();\n\t\t}\n\t});\n\n\tcanvas.Polyline = declare(\"dojox.gfx.canvas.Polyline\", [canvas.Shape, gs.Polyline], {\n\t\t// summary:\n\t\t//\t\ta polyline/polygon shape (Canvas)\n\t\tsetShape: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tvar p = this.shape.points, f = p[0], r, c, i;\n\t\t\tthis.bbox = null;\n\t\t\t// normalize this.shape.points as array of points: [{x,y}, {x,y}, ...]\n\t\t\tthis._normalizePoints();\n\t\t\t// after _normalizePoints, if shape.points was [x1,y1,x2,y2,..], shape.points references a new array\n\t\t\t// and p references the original points array\n\t\t\t// prepare Canvas-specific structures, if needed\n\t\t\tif(p.length){\n\t\t\t\tif(typeof f == \"number\"){ // already in the canvas format [x1,y1,x2,y2,...]\n\t\t\t\t\tr = p;\n\t\t\t\t}else{ // convert into canvas-specific format\n\t\t\t\t\tr = [];\n\t\t\t\t\tfor(i=0; i < p.length; ++i){\n\t\t\t\t\t\tc = p[i];\n\t\t\t\t\t\tr.push(c.x, c.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tr = [];\n\t\t\t}\n\t\t\tthis.canvasPolyline = r;\n\t\t\treturn this;\n\t\t},\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar p = this.canvasPolyline;\n\t\t\tif(p.length){\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p[0], p[1]);\n\t\t\t\tfor(var i = 2; i < p.length; i += 2){\n\t\t\t\t\tctx.lineTo(p[i], p[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_renderDashedStroke: function(ctx, apply){\n\t\t\tvar p = this.canvasPolyline, residue = 0;\n\t\t\tctx.beginPath();\n\t\t\tfor(var i = 0; i < p.length; i += 2){\n\t\t\t\tresidue = toDashedLineTo(ctx, this, p[i], p[i + 1], p[i + 2], p[i + 3], residue);\n\t\t\t}\n\t\t\tif(apply) ctx.stroke();\n\t\t}\n\t});\n\n\tcanvas.Image = declare(\"dojox.gfx.canvas.Image\", [canvas.Shape, gs.Image], {\n\t\t// summary:\n\t\t//\t\tan image shape (Canvas)\n\t\tsetShape: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\t// prepare Canvas-specific structures\n\t\t\tvar img = new Image();\n\t\t\tthis.surface.downloadImage(img, this.shape.src);\n\t\t\tthis.canvasImage = img;\n\t\t\treturn this;\n\t\t},\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar s = this.shape;\n\t\t\tctx.drawImage(this.canvasImage, s.x, s.y, s.width, s.height);\n\t\t}\n\t});\n\n\tcanvas.Text = declare(\"dojox.gfx.canvas.Text\", [canvas.Shape, gs.Text], {\n\t\t_setFont:function(){\n\t\t\tif(this.fontStyle){\n\t\t\t\tthis.canvasFont = g.makeFontString(this.fontStyle);\n\t\t\t}else{\n\t\t\t\tdelete this.canvasFont;\n\t\t\t}\n\t\t},\n\n\t\tgetTextWidth: function(){\n\t\t\t// summary:\n\t\t\t//\t\tget the text width in pixels\n\t\t\tvar s = this.shape, w = 0, ctx;\n\t\t\tif(s.text){\n\t\t\t\tctx = this.surface.rawNode.getContext(\"2d\");\n\t\t\t\tctx.save();\n\t\t\t\tthis._renderTransform(ctx);\n\t\t\t\tthis._renderFill(ctx, false);\n\t\t\t\tthis._renderStroke(ctx, false);\n\t\t\t\tif (this.canvasFont)\n\t\t\t\t\tctx.font = this.canvasFont;\n\t\t\t\tw = ctx.measureText(s.text).width;\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t\treturn w;\n\t\t},\n\n\t\t// override to apply first fill and stroke (\n\t\t// the base implementation is for path-based shape that needs to first define the path then to fill/stroke it.\n\t\t// Here, we need the fillstyle or strokestyle to be set before calling fillText/strokeText.\n\t\t_render: function(/* Object */ctx){\n\t\t\t// summary:\n\t\t\t//\t\trender the shape\n\t\t\t// ctx: Object\n\t\t\t//\t\tthe drawing context.\n\t\t\tctx.save();\n\t\t\tthis._renderTransform(ctx);\n\t\t\tthis._renderFill(ctx, false);\n\t\t\tthis._renderStroke(ctx, false);\n\t\t\tthis._renderShape(ctx);\n\t\t\tctx.restore();\n\t\t},\n\n\t\t_renderShape: function(ctx){\n\t\t\t// summary:\n\t\t\t//\t\ta text shape (Canvas)\n\t\t\t// ctx: Object\n\t\t\t//\t\tthe drawing context.\n\t\t\tvar ta, s = this.shape;\n\t\t\tif(!s.text){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// text align\n\t\t\tta = s.align === 'middle' ? 'center' : s.align;\n\t\t\tctx.textAlign = ta;\n\t\t\tif(this.canvasFont){\n\t\t\t\tctx.font = this.canvasFont;\n\t\t\t}\n\t\t\tif(this.canvasFill){\n\t\t\t\tctx.fillText(s.text, s.x, s.y);\n\t\t\t}\n\t\t\tif(this.strokeStyle){\n\t\t\t\tctx.beginPath(); // fix bug in FF3.6. Fixed in FF4b8\n\t\t\t\tctx.strokeText(s.text, s.x, s.y);\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t}\n\t});\n\tmodifyMethod(canvas.Text, \"setFont\");\n\n\tif(!hasFillText){\n\t\tcanvas.Text.extend({\n\t\t\tgetTextWidth: function(){\n\t\t\t\treturn 0;\n\t\t\t},\n\t\t\tgetBoundingBox: function(){\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\t_renderShape: function(){\n\t\t\t}\n\t\t});\n\t}\n\n\tvar pathRenderers = {\n\t\t\tM: \"_moveToA\", m: \"_moveToR\",\n\t\t\tL: \"_lineToA\", l: \"_lineToR\",\n\t\t\tH: \"_hLineToA\", h: \"_hLineToR\",\n\t\t\tV: \"_vLineToA\", v: \"_vLineToR\",\n\t\t\tC: \"_curveToA\", c: \"_curveToR\",\n\t\t\tS: \"_smoothCurveToA\", s: \"_smoothCurveToR\",\n\t\t\tQ: \"_qCurveToA\", q: \"_qCurveToR\",\n\t\t\tT: \"_qSmoothCurveToA\", t: \"_qSmoothCurveToR\",\n\t\t\tA: \"_arcTo\", a: \"_arcTo\",\n\t\t\tZ: \"_closePath\", z: \"_closePath\"\n\t\t};\n\n\n\tcanvas.Path = declare(\"dojox.gfx.canvas.Path\", [canvas.Shape, pathLib.Path], {\n\t\t// summary:\n\t\t//\t\ta path shape (Canvas)\n\t\tconstructor: function(){\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\tsetShape: function(){\n\t\t\tthis.canvasPath = [];\n\t\t\tthis._dashedPath= [];\n\t\t\treturn this.inherited(arguments);\n\t\t},\n\t\tsetStroke:function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tif(!hasNativeDash){\n\t\t\t\tthis.segmented = false;\n\t\t\t\tthis._confirmSegmented();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t_setPath: function(){\n\t\t\tthis._dashResidue = null;\n\t\t\tthis.inherited(arguments);\n\t\t},\n\t\t_updateWithSegment: function(segment){\n\t\t\tvar last = lang.clone(this.last);\n\t\t\tthis[pathRenderers[segment.action]](this.canvasPath, segment.action, segment.args, this._needsDash ? this._dashedPath : null);\n\t\t\tthis.last = last;\n\t\t\tthis.inherited(arguments);\n\t\t},\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar r = this.canvasPath;\n\t\t\tctx.beginPath();\n\t\t\tfor(var i = 0; i < r.length; i += 2){\n\t\t\t\tctx[r[i]].apply(ctx, r[i + 1]);\n\t\t\t}\n\t\t},\n\t\t_renderDashedStroke: hasNativeDash ? function(){} : function(ctx, apply){\n\t\t\tvar r = this._dashedPath;\n\t\t\tctx.beginPath();\n\t\t\tfor(var i = 0; i < r.length; i += 2){\n\t\t\t\tctx[r[i]].apply(ctx, r[i + 1]);\n\t\t\t}\n\t\t\tif(apply) ctx.stroke();\n\t\t},\n\t\t_moveToA: function(result, action, args, doDash){\n\t\t\tresult.push(\"moveTo\", [args[0], args[1]]);\n\t\t\tif(doDash) doDash.push(\"moveTo\", [args[0], args[1]]);\n\t\t\tfor(var i = 2; i < args.length; i += 2){\n\t\t\t\tresult.push(\"lineTo\", [args[i], args[i + 1]]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, args[i - 2], args[i - 1], args[i], args[i + 1], this._dashResidue);\n\t\t\t}\n\t\t\tthis.last.x = args[args.length - 2];\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_moveToR: function(result, action, args, doDash){\n\t\t\tvar pts;\n\t\t\tif(\"x\" in this.last){\n\t\t\t\tpts = [this.last.x += args[0], this.last.y += args[1]];\n\t\t\t\tresult.push(\"moveTo\", pts);\n\t\t\t\tif(doDash) doDash.push(\"moveTo\", pts);\n\t\t\t}else{\n\t\t\t\tpts = [this.last.x = args[0], this.last.y = args[1]];\n\t\t\t\tresult.push(\"moveTo\", pts);\n\t\t\t\tif(doDash) doDash.push(\"moveTo\", pts);\n\t\t\t}\n\t\t\tfor(var i = 2; i < args.length; i += 2){\n\t\t\t\tresult.push(\"lineTo\", [this.last.x += args[i], this.last.y += args[i + 1]]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t}\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_lineToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, this.last.x, this.last.y, args[i], args[i + 1], this._dashResidue);\n\t\t\t\tresult.push(\"lineTo\", [args[i], args[i + 1]]);\n\t\t\t}\n\t\t\tthis.last.x = args[args.length - 2];\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_lineToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\tresult.push(\"lineTo\", [this.last.x += args[i], this.last.y += args[i + 1]]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t}\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_hLineToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\tresult.push(\"lineTo\", [args[i], this.last.y]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], args[i], this.last.y, this._dashResidue);\n\t\t\t}\n\t\t\tthis.last.x = args[args.length - 1];\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_hLineToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\tresult.push(\"lineTo\", [this.last.x += args[i], this.last.y]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t}\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_vLineToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\tresult.push(\"lineTo\", [this.last.x, args[i]]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, args[i], this._dashResidue);\n\t\t\t}\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_vLineToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\tresult.push(\"lineTo\", [this.last.x, this.last.y += args[i]]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, doDash[doDash.length - 1][0], doDash[doDash.length - 1][1], this.last.x, this.last.y, this._dashResidue);\n\t\t\t}\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_curveToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 6){\n\t\t\t\tresult.push(\"bezierCurveTo\", args.slice(i, i + 6));\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t}\n\t\t\tthis.last.x = args[args.length - 2];\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t\tthis.lastControl.x = args[args.length - 4];\n\t\t\tthis.lastControl.y = args[args.length - 3];\n\t\t\tthis.lastControl.type = \"C\";\n\t\t},\n\t\t_curveToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 6){\n\t\t\t\tresult.push(\"bezierCurveTo\", [\n\t\t\t\t\tthis.last.x + args[i],\n\t\t\t\t\tthis.last.y + args[i + 1],\n\t\t\t\t\tthis.lastControl.x = this.last.x + args[i + 2],\n\t\t\t\t\tthis.lastControl.y = this.last.y + args[i + 3],\n\t\t\t\t\tthis.last.x + args[i + 4],\n\t\t\t\t\tthis.last.y + args[i + 5]\n\t\t\t\t]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\tthis.last.x += args[i + 4];\n\t\t\t\tthis.last.y += args[i + 5];\n\t\t\t}\n\t\t\tthis.lastControl.type = \"C\";\n\t\t},\n\t\t_smoothCurveToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\tvar valid = this.lastControl.type == \"C\";\n\t\t\t\tresult.push(\"bezierCurveTo\", [\n\t\t\t\t\tvalid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\tvalid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\targs[i],\n\t\t\t\t\targs[i + 1],\n\t\t\t\t\targs[i + 2],\n\t\t\t\t\targs[i + 3]\n\t\t\t\t]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\tthis.lastControl.x = args[i];\n\t\t\t\tthis.lastControl.y = args[i + 1];\n\t\t\t\tthis.lastControl.type = \"C\";\n\t\t\t}\n\t\t\tthis.last.x = args[args.length - 2];\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t},\n\t\t_smoothCurveToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\tvar valid = this.lastControl.type == \"C\";\n\t\t\t\tresult.push(\"bezierCurveTo\", [\n\t\t\t\t\tvalid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\tvalid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\tthis.last.x + args[i],\n\t\t\t\t\tthis.last.y + args[i + 1],\n\t\t\t\t\tthis.last.x + args[i + 2],\n\t\t\t\t\tthis.last.y + args[i + 3]\n\t\t\t\t]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length-1], this._dashResidue);\n\t\t\t\tthis.lastControl.x = this.last.x + args[i];\n\t\t\t\tthis.lastControl.y = this.last.y + args[i + 1];\n\t\t\t\tthis.lastControl.type = \"C\";\n\t\t\t\tthis.last.x += args[i + 2];\n\t\t\t\tthis.last.y += args[i + 3];\n\t\t\t}\n\t\t},\n\t\t_qCurveToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\tresult.push(\"quadraticCurveTo\", args.slice(i, i + 4));\n\t\t\t}\n\t\t\tif(doDash)\n\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\tthis.last.x = args[args.length - 2];\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t\tthis.lastControl.x = args[args.length - 4];\n\t\t\tthis.lastControl.y = args[args.length - 3];\n\t\t\tthis.lastControl.type = \"Q\";\n\t\t},\n\t\t_qCurveToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 4){\n\t\t\t\tresult.push(\"quadraticCurveTo\", [\n\t\t\t\t\tthis.lastControl.x = this.last.x + args[i],\n\t\t\t\t\tthis.lastControl.y = this.last.y + args[i + 1],\n\t\t\t\t\tthis.last.x + args[i + 2],\n\t\t\t\t\tthis.last.y + args[i + 3]\n\t\t\t\t]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\tthis.last.x += args[i + 2];\n\t\t\t\tthis.last.y += args[i + 3];\n\t\t\t}\n\t\t\tthis.lastControl.type = \"Q\";\n\t\t},\n\t\t_qSmoothCurveToA: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\tvar valid = this.lastControl.type == \"Q\";\n\t\t\t\tresult.push(\"quadraticCurveTo\", [\n\t\t\t\t\tthis.lastControl.x = valid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\tthis.lastControl.y = valid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\targs[i],\n\t\t\t\t\targs[i + 1]\n\t\t\t\t]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\tthis.lastControl.type = \"Q\";\n\t\t\t}\n\t\t\tthis.last.x = args[args.length - 2];\n\t\t\tthis.last.y = args[args.length - 1];\n\t\t},\n\t\t_qSmoothCurveToR: function(result, action, args, doDash){\n\t\t\tfor(var i = 0; i < args.length; i += 2){\n\t\t\t\tvar valid = this.lastControl.type == \"Q\";\n\t\t\t\tresult.push(\"quadraticCurveTo\", [\n\t\t\t\t\tthis.lastControl.x = valid ? 2 * this.last.x - this.lastControl.x : this.last.x,\n\t\t\t\t\tthis.lastControl.y = valid ? 2 * this.last.y - this.lastControl.y : this.last.y,\n\t\t\t\t\tthis.last.x + args[i],\n\t\t\t\t\tthis.last.y + args[i + 1]\n\t\t\t\t]);\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, result[result.length - 1], this._dashResidue);\n\t\t\t\tthis.lastControl.type = \"Q\";\n\t\t\t\tthis.last.x += args[i];\n\t\t\t\tthis.last.y += args[i + 1];\n\t\t\t}\n\t\t},\n\t\t_arcTo: function(result, action, args, doDash){\n\t\t\tvar relative = action == \"a\";\n\t\t\tfor(var i = 0; i < args.length; i += 7){\n\t\t\t\tvar x1 = args[i + 5], y1 = args[i + 6];\n\t\t\t\tif(relative){\n\t\t\t\t\tx1 += this.last.x;\n\t\t\t\t\ty1 += this.last.y;\n\t\t\t\t}\n\t\t\t\tvar arcs = ga.arcAsBezier(\n\t\t\t\t\tthis.last, args[i], args[i + 1], args[i + 2],\n\t\t\t\t\targs[i + 3] ? 1 : 0, args[i + 4] ? 1 : 0,\n\t\t\t\t\tx1, y1\n\t\t\t\t);\n\t\t\t\tarr.forEach(arcs, function(p){\n\t\t\t\t\tresult.push(\"bezierCurveTo\", p);\n\t\t\t\t});\n\t\t\t\tif(doDash)\n\t\t\t\t\tthis._dashResidue = toDashedCurveTo(doDash, this, p, this._dashResidue);\n\t\t\t\tthis.last.x = x1;\n\t\t\t\tthis.last.y = y1;\n\t\t\t}\n\t\t\tthis.lastControl = {};\n\t\t},\n\t\t_closePath: function(result, action, args, doDash){\n\t\t\tresult.push(\"closePath\", []);\n\t\t\tif(doDash)\n\t\t\t\tthis._dashResidue = toDashedLineTo(doDash, this, this.last.x, this.last.y, doDash[1][0], doDash[1][1], this._dashResidue);\n\t\t\tthis.lastControl = {};\n\t\t}\n\t});\n\tarr.forEach([\"moveTo\", \"lineTo\", \"hLineTo\", \"vLineTo\", \"curveTo\",\n\t\t\"smoothCurveTo\", \"qCurveTo\", \"qSmoothCurveTo\", \"arcTo\", \"closePath\"],\n\t\tfunction(method){ modifyMethod(canvas.Path, method); }\n\t);\n\n\tcanvas.TextPath = declare(\"dojox.gfx.canvas.TextPath\", [canvas.Shape, pathLib.TextPath], {\n\t\t// summary:\n\t\t//\t\ta text shape (Canvas)\n\t\t_renderShape: function(/* Object */ ctx){\n\t\t\tvar s = this.shape;\n\t\t\t// nothing for the moment\n\t\t},\n\t\t_setText: function(){\n\t\t\t// not implemented\n\t\t},\n\t\t_setFont: function(){\n\t\t\t// not implemented\n\t\t}\n\t});\n\n\tcanvas.Surface = declare(\"dojox.gfx.canvas.Surface\", gs.Surface, {\n\t\t// summary:\n\t\t//\t\ta surface object to be used for drawings (Canvas)\n\t\tconstructor: function(){\n\t\t\tgs.Container._init.call(this);\n\t\t\tthis.pendingImageCount = 0;\n\t\t\tthis.makeDirty();\n\t\t},\n\t\tdestroy: function(){\n\t\t\tgs.Container.clear.call(this, true); // avoid makeDirty() from canvas.Container.clear impl.\n\t\t\tthis.inherited(arguments);\n\t\t},\n\t\tsetDimensions: function(width, height){\n\t\t\t// summary:\n\t\t\t//\t\tsets the width and height of the rawNode\n\t\t\t// width: String\n\t\t\t//\t\twidth of surface, e.g., \"100px\"\n\t\t\t// height: String\n\t\t\t//\t\theight of surface, e.g., \"100px\"\n\t\t\tthis.width  = g.normalizedLength(width);\t// in pixels\n\t\t\tthis.height = g.normalizedLength(height);\t// in pixels\n\t\t\tif(!this.rawNode) return this;\n\t\t\tvar dirty = false;\n\t\t\tif (this.rawNode.width != this.width){\n\t\t\t\tthis.rawNode.width = this.width;\n\t\t\t\tdirty = true;\n\t\t\t}\n\t\t\tif (this.rawNode.height != this.height){\n\t\t\t\tthis.rawNode.height = this.height;\n\t\t\t\tdirty = true;\n\t\t\t}\n\t\t\tif (dirty)\n\t\t\t\tthis.makeDirty();\n\t\t\treturn this;\t// self\n\t\t},\n\t\tgetDimensions: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns an object with properties \"width\" and \"height\"\n\t\t\treturn this.rawNode ? {width:  this.rawNode.width, height: this.rawNode.height} : null;\t// Object\n\t\t},\n\t\t_render: function(force){\n\t\t\t// summary:\n\t\t\t//\t\trender the all shapes\n\t\t\tif(!this.rawNode || (!force && this.pendingImageCount)){ return; }\n\t\t\tvar ctx = this.rawNode.getContext(\"2d\");\n\t\t\tctx.clearRect(0, 0, this.rawNode.width, this.rawNode.height);\n\t\t\tthis.render(ctx);\n\t\t\tif(\"pendingRender\" in this){\n\t\t\t\tclearTimeout(this.pendingRender);\n\t\t\t\tdelete this.pendingRender;\n\t\t\t}\n\t\t},\n\t\trender: function(ctx){\n\t\t\t// summary:\n\t\t\t//\t\tRenders the gfx scene.\n\t\t\t// description:\n\t\t\t//\t\tthis method is called to render the gfx scene to the specified context.\n\t\t\t//\t\tThis method should not be invoked directly but should be used instead\n\t\t\t//\t\tas an extension point on which user can connect to with aspect.before/aspect.after\n\t\t\t//\t\tto implement pre- or post- image processing jobs on the drawing surface.\n\t\t\t// ctx: CanvasRenderingContext2D\n\t\t\t//\t\tThe surface Canvas rendering context.\n\t\t\tctx.save();\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\tthis.children[i]._render(ctx);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t},\n\t\tmakeDirty: function(){\n\t\t\t// summary:\n\t\t\t//\t\tinternal method, which is called when we may need to redraw\n\t\t\tif(!this.pendingImagesCount && !(\"pendingRender\" in this) && !this._batch){\n\t\t\t\tthis.pendingRender = setTimeout(lang.hitch(this, this._render), 0);\n\t\t\t}\n\t\t},\n\t\tdownloadImage: function(img, url){\n\t\t\t// summary:\n\t\t\t//\t\tinternal method, which starts an image download and renders, when it is ready\n\t\t\t// img: Image\n\t\t\t//\t\tthe image object\n\t\t\t// url: String\n\t\t\t//\t\tthe url of the image\n\t\t\tvar handler = lang.hitch(this, this.onImageLoad);\n\t\t\tif(!this.pendingImageCount++ && \"pendingRender\" in this){\n\t\t\t\tclearTimeout(this.pendingRender);\n\t\t\t\tdelete this.pendingRender;\n\t\t\t}\n\t\t\timg.onload  = handler;\n\t\t\timg.onerror = handler;\n\t\t\timg.onabort = handler;\n\t\t\timg.src = url;\n\t\t},\n\t\tonImageLoad: function(){\n\t\t\tif(!--this.pendingImageCount){\n\t\t\t\tthis.onImagesLoaded();\n\t\t\t\tthis._render();\n\t\t\t}\n\t\t},\n\t\tonImagesLoaded: function(){\n\t\t\t// summary:\n\t\t\t//\t\tAn extension point called when all pending images downloads have been completed.\n\t\t\t// description:\n\t\t\t//\t\tThis method is invoked when all pending images downloads have been completed, just before\n\t\t\t//\t\tthe gfx scene is redrawn. User can connect to this method to get notified when a\n\t\t\t//\t\tgfx scene containing images is fully resolved.\n\t\t},\n\n\t\t// events are not implemented\n\t\tgetEventSource: function(){ return null; },\n\t\tconnect:\t\tfunction(){},\n\t\tdisconnect:\t\tfunction(){},\n\t\ton:\t\t\t\tfunction(){}\n\t});\n\n\tcanvas.createSurface = function(parentNode, width, height){\n\t\t// summary:\n\t\t//\t\tcreates a surface (Canvas)\n\t\t// parentNode: Node\n\t\t//\t\ta parent node\n\t\t// width: String\n\t\t//\t\twidth of surface, e.g., \"100px\"\n\t\t// height: String\n\t\t//\t\theight of surface, e.g., \"100px\"\n\n\t\tif(!width && !height){\n\t\t\tvar pos = domGeom.position(parentNode);\n\t\t\twidth  = width  || pos.w;\n\t\t\theight = height || pos.h;\n\t\t}\n\t\tif(typeof width == \"number\"){\n\t\t\twidth = width + \"px\";\n\t\t}\n\t\tif(typeof height == \"number\"){\n\t\t\theight = height + \"px\";\n\t\t}\n\n\t\tvar s = new canvas.Surface(),\n\t\t\tp = dom.byId(parentNode),\n\t\t\tc = p.ownerDocument.createElement(\"canvas\");\n\n\t\tc.width  = g.normalizedLength(width);\t// in pixels\n\t\tc.height = g.normalizedLength(height);\t// in pixels\n\n\t\tp.appendChild(c);\n\t\ts.rawNode = c;\n\t\ts._parent = p;\n\t\ts.surface = s;\n\t\treturn s;\t// dojox/gfx.Surface\n\t};\n\n\t// Extenders\n\n\tvar C = gs.Container, Container = {\n\t\topenBatch: function() {\n\t\t\t// summary:\n\t\t\t//\t\tstarts a new batch, subsequent new child shapes will be held in\n\t\t\t//\t\tthe batch instead of appending to the container directly.\n\t\t\t// description:\n\t\t\t//\t\tBecause the canvas renderer has no DOM hierarchy, the canvas implementation differs\n\t\t\t//\t\tsuch that it suspends the repaint requests for this container until the current batch is closed by a call to closeBatch().\n\t\t\t++this._batch;\n\t\t\treturn this;\n\t\t},\n\t\tcloseBatch: function() {\n\t\t\t// summary:\n\t\t\t//\t\tsubmits the current batch.\n\t\t\t// description:\n\t\t\t//\t\tOn canvas, this method flushes the pending redraws queue.\n\t\t\tthis._batch = this._batch > 0 ? --this._batch : 0;\n\t\t\tthis._makeDirty();\n\t\t\treturn this;\n\t\t},\n\t\t_makeDirty: function(){\n\t\t\tif(!this._batch){\n\t\t\t\tthis.surface.makeDirty();\n\t\t\t}\n\t\t},\n\t\tadd: function(shape){\n\t\t\tthis._makeDirty();\n\t\t\treturn C.add.apply(this, arguments);\n\t\t},\n\t\tremove: function(shape, silently){\n\t\t\tthis._makeDirty();\n\t\t\treturn C.remove.apply(this, arguments);\n\t\t},\n\t\tclear: function(){\n\t\t\tthis._makeDirty();\n\t\t\treturn C.clear.apply(this, arguments);\n\t\t},\n\t\tgetBoundingBox: C.getBoundingBox,\n\t\t_moveChildToFront: function(shape){\n\t\t\tthis._makeDirty();\n\t\t\treturn C._moveChildToFront.apply(this, arguments);\n\t\t},\n\t\t_moveChildToBack: function(shape){\n\t\t\tthis._makeDirty();\n\t\t\treturn C._moveChildToBack.apply(this, arguments);\n\t\t}\n\t};\n\n\tvar Creator = {\n\t\t// summary:\n\t\t//\t\tCanvas shape creators\n\t\tcreateObject: function(shapeType, rawShape) {\n\t\t\t// summary:\n\t\t\t//\t\tcreates an instance of the passed shapeType class\n\t\t\t// shapeType: Function\n\t\t\t//\t\ta class constructor to create an instance of\n\t\t\t// rawShape: Object\n\t\t\t//\t\tproperties to be passed in to the classes \"setShape\" method\n\t\t\t// overrideSize: Boolean\n\t\t\t//\t\tset the size explicitly, if true\n\t\t\tvar shape = new shapeType();\n\t\t\tshape.surface = this.surface;\n\t\t\tshape.setShape(rawShape);\n\t\t\tthis.add(shape);\n\t\t\treturn shape;\t// dojox/gfx/shape.Shape\n\t\t}\n\t};\n\n\textend(canvas.Group, Container);\n\textend(canvas.Group, gs.Creator);\n\textend(canvas.Group, Creator);\n\n\textend(canvas.Surface, Container);\n\textend(canvas.Surface, gs.Creator);\n\textend(canvas.Surface, Creator);\n\n\t// no event support -> nothing to fix.\n\tcanvas.fixTarget = function(event, gfxElement){\n\t\t// tags:\n\t\t//\t\tprivate\n\t\treturn true;\n\t};\n\n\treturn canvas;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/canvas.js\n// module id = 168\n// module chunks = 4","define([\"./_base\", \"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/kernel\", \"dojo/_base/sniff\",\n\t\"dojo/on\", \"dojo/_base/array\", \"dojo/dom-construct\", \"dojo/_base/Color\", \"./matrix\" ],\n\tfunction(g, lang, declare, kernel, has, on, arr, domConstruct, Color, matrixLib){\n\n\tvar shape = g.shape = {\n\t\t// summary:\n\t\t//\t\tThis module contains the core graphics Shape API.\n\t\t//\t\tDifferent graphics renderer implementation modules (svg, canvas, vml, silverlight, etc.) extend this\n\t\t//\t\tbasic api to provide renderer-specific implementations for each shape.\n\t};\n\n\tshape.Shape = declare(\"dojox.gfx.shape.Shape\", null, {\n\t\t// summary:\n\t\t//\t\ta Shape object, which knows how to apply\n\t\t//\t\tgraphical attributes and transformations\n\t\n\t\tconstructor: function(){\n\t\t\t// rawNode: Node\n\t\t\t//\t\tunderlying graphics-renderer-specific implementation object (if applicable)\n\t\t\tthis.rawNode = null;\n\n\t\t\t// shape: Object\n\t\t\t//\t\tan abstract shape object\n\t\t\t//\t\t(see dojox/gfx.defaultPath,\n\t\t\t//\t\tdojox/gfx.defaultPolyline,\n\t\t\t//\t\tdojox/gfx.defaultRect,\n\t\t\t//\t\tdojox/gfx.defaultEllipse,\n\t\t\t//\t\tdojox/gfx.defaultCircle,\n\t\t\t//\t\tdojox/gfx.defaultLine,\n\t\t\t//\t\tor dojox/gfx.defaultImage)\n\t\t\tthis.shape = null;\n\t\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta transformation matrix\n\t\t\tthis.matrix = null;\n\t\n\t\t\t// fillStyle: dojox/gfx.Fill\n\t\t\t//\t\ta fill object\n\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\n\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\n\t\t\t//\t\tdojox/gfx.defaultPattern,\n\t\t\t//\t\tor dojo/Color)\n\t\t\tthis.fillStyle = null;\n\t\n\t\t\t// strokeStyle: dojox/gfx.Stroke\n\t\t\t//\t\ta stroke object\n\t\t\t//\t\t(see dojox/gfx.defaultStroke)\n\t\t\tthis.strokeStyle = null;\n\t\n\t\t\t// bbox: dojox/gfx.Rectangle\n\t\t\t//\t\ta bounding box of this shape\n\t\t\t//\t\t(see dojox/gfx.defaultRect)\n\t\t\tthis.bbox = null;\n\t\n\t\t\t// virtual group structure\n\t\n\t\t\t// parent: Object\n\t\t\t//\t\ta parent or null\n\t\t\t//\t\t(see dojox/gfx/shape.Surface,\n\t\t\t//\t\tor dojox/gfx.Group)\n\t\t\tthis.parent = null;\n\t\n\t\t\t// parentMatrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta transformation matrix inherited from the parent\n\t\t\tthis.parentMatrix = null;\n\n\t\t\tif(has(\"gfxRegistry\")){\n\t\t\t\tvar uid = shape.register(this);\n\t\t\t\tthis.getUID = function(){\n\t\t\t\t\treturn uid;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReleases all internal resources owned by this shape. Once this method has been called,\n\t\t\t//\t\tthe instance is considered destroyed and should not be used anymore.\n\t\t\tif(has(\"gfxRegistry\")){\n\t\t\t\tshape.dispose(this);\n\t\t\t}\n\t\t\tif(this.rawNode && \"__gfxObject__\" in this.rawNode){\n\t\t\t\tthis.rawNode.__gfxObject__ = null;\n\t\t\t}\n\t\t\tthis.rawNode = null;\n\t\t},\n\t\n\t\t// trivial getters\n\t\n\t\tgetNode: function(){\n\t\t\t// summary:\n\t\t\t//\t\tDifferent graphics rendering subsystems implement shapes in different ways.  This\n\t\t\t//\t\tmethod provides access to the underlying graphics subsystem object.  Clients calling this\n\t\t\t//\t\tmethod and using the return value must be careful not to try sharing or using the underlying node\n\t\t\t//\t\tin a general way across renderer implementation.\n\t\t\t//\t\tReturns the underlying graphics Node, or null if no underlying graphics node is used by this shape.\n\t\t\treturn this.rawNode; // Node\n\t\t},\n\t\tgetShape: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the current Shape object or null\n\t\t\t//\t\t(see dojox/gfx.defaultPath,\n\t\t\t//\t\tdojox/gfx.defaultPolyline,\n\t\t\t//\t\tdojox/gfx.defaultRect,\n\t\t\t//\t\tdojox/gfx.defaultEllipse,\n\t\t\t//\t\tdojox/gfx.defaultCircle,\n\t\t\t//\t\tdojox/gfx.defaultLine,\n\t\t\t//\t\tor dojox/gfx.defaultImage)\n\t\t\treturn this.shape; // Object\n\t\t},\n\t\tgetTransform: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the current transformation matrix applied to this Shape or null\n\t\t\treturn this.matrix;\t// dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tgetFill: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the current fill object or null\n\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\n\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\n\t\t\t//\t\tdojox/gfx.defaultPattern,\n\t\t\t//\t\tor dojo/Color)\n\t\t\treturn this.fillStyle;\t// Object\n\t\t},\n\t\tgetStroke: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the current stroke object or null\n\t\t\t//\t\t(see dojox/gfx.defaultStroke)\n\t\t\treturn this.strokeStyle;\t// Object\n\t\t},\n\t\tgetParent: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the parent Shape, Group or null if this Shape is unparented.\n\t\t\t//\t\t(see dojox/gfx/shape.Surface,\n\t\t\t//\t\tor dojox/gfx.Group)\n\t\t\treturn this.parent;\t// Object\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the bounding box Rectangle for this shape or null if a BoundingBox cannot be\n\t\t\t//\t\tcalculated for the shape on the current renderer or for shapes with no geometric area (points).\n\t\t\t//\t\tA bounding box is a rectangular geometric region\n\t\t\t//\t\tdefining the X and Y extent of the shape.\n\t\t\t//\t\t(see dojox/gfx.defaultRect)\n\t\t\t//\t\tNote that this method returns a direct reference to the attribute of this instance. Therefore you should\n\t\t\t//\t\tnot modify its value directly but clone it instead.\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t},\n\t\tgetTransformedBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns an array of four points or null\n\t\t\t//\t\tfour points represent four corners of the untransformed bounding box\n\t\t\tvar b = this.getBoundingBox();\n\t\t\tif(!b){\n\t\t\t\treturn null;\t// null\n\t\t\t}\n\t\t\tvar m = this._getRealMatrix(),\n\t\t\t\tgm = matrixLib;\n\t\t\treturn [\t// Array\n\t\t\t\t\tgm.multiplyPoint(m, b.x, b.y),\n\t\t\t\t\tgm.multiplyPoint(m, b.x + b.width, b.y),\n\t\t\t\t\tgm.multiplyPoint(m, b.x + b.width, b.y + b.height),\n\t\t\t\t\tgm.multiplyPoint(m, b.x, b.y + b.height)\n\t\t\t\t];\n\t\t},\n\t\tgetEventSource: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns a Node, which is used as\n\t\t\t//\t\ta source of events for this shape\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\treturn this.rawNode;\t// Node\n\t\t},\n\t\n\t\t// empty settings\n\t\t\n\t\tsetClip: function(clip){\n\t\t\t// summary:\n\t\t\t//\t\tsets the clipping area of this shape.\n\t\t\t// description:\n\t\t\t//\t\tThe clipping area defines the shape area that will be effectively visible. Everything that\n\t\t\t//\t\twould be drawn outside of the clipping area will not be rendered.\n\t\t\t//\t\tThe possible clipping area types are rectangle, ellipse, polyline and path, but all are not\n\t\t\t//\t\tsupported by all the renderers. vml only supports rectangle clipping, while the gfx silverlight renderer does not\n\t\t\t//\t\tsupport path clipping.\n\t\t\t//\t\tThe clip parameter defines the clipping area geometry, and should be an object with the following properties:\n\t\t\t//\n\t\t\t//\t\t- {x:Number, y:Number, width:Number, height:Number} for rectangular clip\n\t\t\t//\t\t- {cx:Number, cy:Number, rx:Number, ry:Number} for ellipse clip\n\t\t\t//\t\t- {points:Array} for polyline clip\n\t\t\t//\t\t- {d:String} for a path clip.\n\t\t\t//\n\t\t\t//\t\tThe clip geometry coordinates are expressed in the coordinate system used to draw the shape. In other\n\t\t\t//\t\twords, the clipping area is defined in the shape parent coordinate system and the shape transform is automatically applied.\n\t\t\t// example:\n\t\t\t//\t\tThe following example shows how to clip a gfx image with all the possible clip geometry: a rectangle,\n\t\t\t//\t\tan ellipse, a circle (using the ellipse geometry), a polyline and a path:\n\t\t\t//\n\t\t\t//\t|\tsurface.createImage({src:img, width:200,height:200}).setClip({x:10,y:10,width:50,height:50});\n\t\t\t//\t|\tsurface.createImage({src:img, x:100,y:50,width:200,height:200}).setClip({cx:200,cy:100,rx:20,ry:30});\n\t\t\t//\t|\tsurface.createImage({src:img, x:0,y:350,width:200,height:200}).setClip({cx:100,cy:425,rx:60,ry:60});\n\t\t\t//\t|\tsurface.createImage({src:img, x:300,y:0,width:200,height:200}).setClip({points:[350,0,450,50,380,130,300,110]});\n\t\t\t//\t|\tsurface.createImage({src:img, x:300,y:350,width:200,height:200}).setClip({d:\"M 350,350 C314,414 317,557 373,450.0000 z\"});\n\n\t\t\t// clip: Object\n\t\t\t//\t\tan object that defines the clipping geometry, or null to remove clip.\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\tthis.clip = clip;\n\t\t},\n\t\t\n\t\tgetClip: function(){\n\t\t\treturn this.clip;\n\t\t},\n\t\n\t\tsetShape: function(shape){\n\t\t\t// summary:\n\t\t\t//\t\tsets a shape object\n\t\t\t//\t\t(the default implementation simply ignores it)\n\t\t\t// shape: Object\n\t\t\t//\t\ta shape object\n\t\t\t//\t\t(see dojox/gfx.defaultPath,\n\t\t\t//\t\tdojox/gfx.defaultPolyline,\n\t\t\t//\t\tdojox/gfx.defaultRect,\n\t\t\t//\t\tdojox/gfx.defaultEllipse,\n\t\t\t//\t\tdojox/gfx.defaultCircle,\n\t\t\t//\t\tdojox/gfx.defaultLine,\n\t\t\t//\t\tor dojox/gfx.defaultImage)\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\tthis.shape = g.makeParameters(this.shape, shape);\n\t\t\tthis.bbox = null;\n\t\t\treturn this;\t// self\n\t\t},\n\t\tsetFill: function(fill){\n\t\t\t// summary:\n\t\t\t//\t\tsets a fill object\n\t\t\t//\t\t(the default implementation simply ignores it)\n\t\t\t// fill: Object\n\t\t\t//\t\ta fill object\n\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\n\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\n\t\t\t//\t\tdojox/gfx.defaultPattern,\n\t\t\t//\t\tor dojo/_base/Color)\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\tif(!fill){\n\t\t\t\t// don't fill\n\t\t\t\tthis.fillStyle = null;\n\t\t\t\treturn this;\t// self\n\t\t\t}\n\t\t\tvar f = null;\n\t\t\tif(typeof(fill) == \"object\" && \"type\" in fill){\n\t\t\t\t// gradient or pattern\n\t\t\t\tswitch(fill.type){\n\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\tf = g.makeParameters(g.defaultLinearGradient, fill);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"radial\":\n\t\t\t\t\t\tf = g.makeParameters(g.defaultRadialGradient, fill);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\tf = g.makeParameters(g.defaultPattern, fill);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// color object\n\t\t\t\tf = g.normalizeColor(fill);\n\t\t\t}\n\t\t\tthis.fillStyle = f;\n\t\t\treturn this;\t// self\n\t\t},\n\t\tsetStroke: function(stroke){\n\t\t\t// summary:\n\t\t\t//\t\tsets a stroke object\n\t\t\t//\t\t(the default implementation simply ignores it)\n\t\t\t// stroke: Object\n\t\t\t//\t\ta stroke object\n\t\t\t//\t\t(see dojox/gfx.defaultStroke)\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\tif(!stroke){\n\t\t\t\t// don't stroke\n\t\t\t\tthis.strokeStyle = null;\n\t\t\t\treturn this;\t// self\n\t\t\t}\n\t\t\t// normalize the stroke\n\t\t\tif(typeof stroke == \"string\" || lang.isArray(stroke) || stroke instanceof Color){\n\t\t\t\tstroke = {color: stroke};\n\t\t\t}\n\t\t\tvar s = this.strokeStyle = g.makeParameters(g.defaultStroke, stroke);\n\t\t\ts.color = g.normalizeColor(s.color);\n\t\t\treturn this;\t// self\n\t\t},\n\t\tsetTransform: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tsets a transformation matrix\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\tthis.matrix = matrixLib.clone(matrix ? matrixLib.normalize(matrix) : matrixLib.identity);\n\t\t\treturn this._applyTransform();\t// self\n\t\t},\n\t\n\t\t_applyTransform: function(){\n\t\t\t// summary:\n\t\t\t//\t\tphysically sets a matrix\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\treturn this;\t// self\n\t\t},\n\t\n\t\t// z-index\n\t\n\t\tmoveToFront: function(){\n\t\t\t// summary:\n\t\t\t//\t\tmoves a shape to front of its parent's list of shapes\n\t\t\tvar p = this.getParent();\n\t\t\tif(p){\n\t\t\t\tp._moveChildToFront(this);\n\t\t\t\tthis._moveToFront();\t// execute renderer-specific action\n\t\t\t}\n\t\t\treturn this;\t// self\n\t\t},\n\t\tmoveToBack: function(){\n\t\t\t// summary:\n\t\t\t//\t\tmoves a shape to back of its parent's list of shapes\n\t\t\tvar p = this.getParent();\n\t\t\tif(p){\n\t\t\t\tp._moveChildToBack(this);\n\t\t\t\tthis._moveToBack();\t// execute renderer-specific action\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t_moveToFront: function(){\n\t\t\t// summary:\n\t\t\t//\t\trenderer-specific hook, see dojox/gfx/shape.Shape.moveToFront()\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t},\n\t\t_moveToBack: function(){\n\t\t\t// summary:\n\t\t\t//\t\trenderer-specific hook, see dojox/gfx/shape.Shape.moveToFront()\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t},\n\t\n\t\t// apply left & right transformation\n\t\n\t\tapplyRightTransform: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tmultiplies the existing matrix with an argument on right side\n\t\t\t//\t\t(this.matrix * matrix)\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\n\t\t},\n\t\tapplyLeftTransform: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tmultiplies the existing matrix with an argument on left side\n\t\t\t//\t\t(matrix * this.matrix)\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\treturn matrix ? this.setTransform([matrix, this.matrix]) : this;\t// self\n\t\t},\n\t\tapplyTransform: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\ta shortcut for dojox/gfx/shape.Shape.applyRightTransform\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta matrix or a matrix-like object\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\n\t\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\n\t\t},\n\t\n\t\t// virtual group methods\n\t\n\t\tremoveShape: function(silently){\n\t\t\t// summary:\n\t\t\t//\t\tremoves the shape from its parent's list of shapes\n\t\t\t// silently: Boolean\n\t\t\t//\t\tif true, do not redraw a picture yet\n\t\t\tif(this.parent){\n\t\t\t\tthis.parent.remove(this, silently);\n\t\t\t}\n\t\t\treturn this;\t// self\n\t\t},\n\t\t_setParent: function(parent, matrix){\n\t\t\t// summary:\n\t\t\t//\t\tsets a parent\n\t\t\t// parent: Object\n\t\t\t//\t\ta parent or null\n\t\t\t//\t\t(see dojox/gfx/shape.Surface,\n\t\t\t//\t\tor dojox/gfx.Group)\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix or a matrix-like object\n\t\t\tthis.parent = parent;\n\t\t\treturn this._updateParentMatrix(matrix);\t// self\n\t\t},\n\t\t_updateParentMatrix: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tupdates the parent matrix with new matrix\n\t\t\t// matrix: dojox/gfx/Matrix2D\n\t\t\t//\t\ta 2D matrix or a matrix-like object\n\t\t\tthis.parentMatrix = matrix ? matrixLib.clone(matrix) : null;\n\t\t\treturn this._applyTransform();\t// self\n\t\t},\n\t\t_getRealMatrix: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the cumulative ('real') transformation matrix\n\t\t\t//\t\tby combining the shape's matrix with its parent's matrix\n\t\t\tvar m = this.matrix;\n\t\t\tvar p = this.parent;\n\t\t\twhile(p){\n\t\t\t\tif(p.matrix){\n\t\t\t\t\tm = matrixLib.multiply(p.matrix, m);\n\t\t\t\t}\n\t\t\t\tp = p.parent;\n\t\t\t}\n\t\t\treturn m;\t// dojox/gfx/matrix.Matrix2D\n\t\t}\n\t});\n\t\n\tshape._eventsProcessing = {\n\t\ton: function(type, listener){\n\t\t\t//\tsummary:\n\t\t\t//\t\tConnects an event to this shape.\n\n\t\t\treturn on(this.getEventSource(), type, shape.fixCallback(this, g.fixTarget, listener));\n\t\t},\n\n\t\tconnect: function(name, object, method){\n\t\t\t// summary:\n\t\t\t//\t\tconnects a handler to an event on this shape\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\t// redirect to fixCallback to normalize events and add the gfxTarget to the event. The latter\n\t\t\t// is done by dojox/gfx.fixTarget which is defined by each renderer\n\t\t\tif(name.substring(0, 2) == \"on\"){\n\t\t\t\tname = name.substring(2);\n\t\t\t}\n\t\t\treturn this.on(name, method ? lang.hitch(object, method) : object);\n\t\t},\n\n\t\tdisconnect: function(token){\n\t\t\t// summary:\n\t\t\t//\t\tconnects a handler by token from an event on this shape\n\t\t\t\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\n\t\t\treturn token.remove();\n\t\t}\n\t};\n\t\n\tshape.fixCallback = function(gfxElement, fixFunction, scope, method){\n\t\t// summary:\n\t\t//\t\tWraps the callback to allow for tests and event normalization\n\t\t//\t\tbefore it gets invoked. This is where 'fixTarget' is invoked.\n\t\t// tags:\n\t\t//      private\n\t\t// gfxElement: Object\n\t\t//\t\tThe GFX object that triggers the action (ex.:\n\t\t//\t\tdojox/gfx.Surface and dojox/gfx/shape.Shape). A new event property\n\t\t//\t\t'gfxTarget' is added to the event to reference this object.\n\t\t//\t\tfor easy manipulation of GFX objects by the event handlers.\n\t\t// fixFunction: Function\n\t\t//\t\tThe function that implements the logic to set the 'gfxTarget'\n\t\t//\t\tproperty to the event. It should be 'dojox/gfx.fixTarget' for\n\t\t//\t\tmost of the cases\n\t\t// scope: Object\n\t\t//\t\tOptional. The scope to be used when invoking 'method'. If\n\t\t//\t\tomitted, a global scope is used.\n\t\t// method: Function|String\n\t\t//\t\tThe original callback to be invoked.\n\t\tif(!method){\n\t\t\tmethod = scope;\n\t\t\tscope = null;\n\t\t}\n\t\tif(lang.isString(method)){\n\t\t\tscope = scope || kernel.global;\n\t\t\tif(!scope[method]){ throw(['dojox.gfx.shape.fixCallback: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\treturn function(e){  \n\t\t\t\treturn fixFunction(e,gfxElement) ? scope[method].apply(scope, arguments || []) : undefined; }; // Function\n\t\t}\n\t\treturn !scope \n\t\t\t? function(e){ \n\t\t\t\treturn fixFunction(e,gfxElement) ? method.apply(scope, arguments) : undefined; } \n\t\t\t: function(e){ \n\t\t\t\treturn fixFunction(e,gfxElement) ? method.apply(scope, arguments || []) : undefined; }; // Function\n\t};\n\tlang.extend(shape.Shape, shape._eventsProcessing);\n\t\n\tshape.Container = {\n\t\t// summary:\n\t\t//\t\ta container of shapes, which can be used\n\t\t//\t\tas a foundation for renderer-specific groups, or as a way\n\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\n\t\n\t\t_init: function() {\n\t\t\t// children: Array\n\t\t\t//\t\ta list of children\n\t\t\tthis.children = [];\n\t\t\tthis._batch = 0;\n\t\t},\n\t\n\t\t// group management\n\t\n\t\topenBatch: function() {\n\t\t\t// summary:\n\t\t\t//\t\tstarts a new batch, subsequent new child shapes will be held in\n\t\t\t//\t\tthe batch instead of appending to the container directly.\n\t\t\t// description:\n\t\t\t//\t\tBecause the canvas renderer has no DOM hierarchy, the canvas implementation differs\n\t\t\t//\t\tsuch that it suspends the repaint requests for this container until the current batch is closed by a call to closeBatch().\n\t\t\treturn this;\n\t\t},\n\t\tcloseBatch: function() {\n\t\t\t// summary:\n\t\t\t//\t\tsubmits the current batch, append all pending child shapes to DOM\n\t\t\t// description:\n\t\t\t//\t\tOn canvas, this method flushes the pending redraws queue.\n\t\t\treturn this;\n\t\t},\n\t\tadd: function(shape){\n\t\t\t// summary:\n\t\t\t//\t\tadds a shape to the list\n\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t//\t\tthe shape to add to the list\n\t\t\tvar oldParent = shape.getParent();\n\t\t\tif(oldParent){\n\t\t\t\toldParent.remove(shape, true);\n\t\t\t}\n\t\t\tthis.children.push(shape);\n\t\t\treturn shape._setParent(this, this._getRealMatrix());\t// self\n\t\t},\n\t\tremove: function(shape, silently){\n\t\t\t// summary:\n\t\t\t//\t\tremoves a shape from the list\n\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t//\t\tthe shape to remove\n\t\t\t// silently: Boolean\n\t\t\t//\t\tif true, do not redraw a picture yet\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\tif(this.children[i] == shape){\n\t\t\t\t\tif(silently){\n\t\t\t\t\t\t// skip for now\n\t\t\t\t\t}else{\n\t\t\t\t\t\tshape.parent = null;\n\t\t\t\t\t\tshape.parentMatrix = null;\n\t\t\t\t\t}\n\t\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t// self\n\t\t},\n\t\tclear: function(/*Boolean?*/ destroy){\n\t\t\t// summary:\n\t\t\t//\t\tremoves all shapes from a group/surface.\n\t\t\t// destroy: Boolean\n\t\t\t//\t\tIndicates whether the children should be destroyed. Optional.\n\t\t\tvar shape;\n\t\t\tfor(var i = 0; i < this.children.length;++i){\n\t\t\t\tshape = this.children[i];\n\t\t\t\tshape.parent = null;\n\t\t\t\tshape.parentMatrix = null;\n\t\t\t\tif(destroy){\n\t\t\t\t\tshape.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.children = [];\n\t\t\treturn this;\t// self\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the bounding box Rectangle for this shape.\n\t\t\tif(this.children){\n\t\t\t\t// if this is a composite shape, then sum up all the children\n\t\t\t\tvar result = null;\n\t\t\t\tarr.forEach(this.children, function(shape){\n\t\t\t\t\tvar bb = shape.getBoundingBox();\n\t\t\t\t\tif(bb){\n\t\t\t\t\t\tvar ct = shape.getTransform();\n\t\t\t\t\t\tif(ct){\n\t\t\t\t\t\t\tbb = matrixLib.multiplyRectangle(ct, bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(result){\n\t\t\t\t\t\t\t// merge two bbox \n\t\t\t\t\t\t\tresult.x = Math.min(result.x, bb.x);\n\t\t\t\t\t\t\tresult.y = Math.min(result.y, bb.y);\n\t\t\t\t\t\t\tresult.endX = Math.max(result.endX, bb.x + bb.width);\n\t\t\t\t\t\t\tresult.endY = Math.max(result.endY, bb.y + bb.height);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// first bbox \n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\tx: bb.x,\n\t\t\t\t\t\t\t\ty: bb.y,\n\t\t\t\t\t\t\t\tendX: bb.x + bb.width,\n\t\t\t\t\t\t\t\tendY: bb.y + bb.height\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(result){\n\t\t\t\t\tresult.width = result.endX - result.x;\n\t\t\t\t\tresult.height = result.endY - result.y;\n\t\t\t\t}\n\t\t\t\treturn result; // dojox/gfx.Rectangle\n\t\t\t}\n\t\t\t// unknown/empty bounding box, subclass shall override this impl \n\t\t\treturn null;\n\t\t},\n\t\t// moving child nodes\n\t\t_moveChildToFront: function(shape){\n\t\t\t// summary:\n\t\t\t//\t\tmoves a shape to front of the list of shapes\n\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t//\t\tone of the child shapes to move to the front\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\tif(this.children[i] == shape){\n\t\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\t\tthis.children.push(shape);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t// self\n\t\t},\n\t\t_moveChildToBack: function(shape){\n\t\t\t// summary:\n\t\t\t//\t\tmoves a shape to back of the list of shapes\n\t\t\t// shape: dojox/gfx/shape.Shape\n\t\t\t//\t\tone of the child shapes to move to the front\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\n\t\t\t\tif(this.children[i] == shape){\n\t\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\t\tthis.children.unshift(shape);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t// self\n\t\t}\n\t};\n\n\tshape.Surface = declare(\"dojox.gfx.shape.Surface\", null, {\n\t\t// summary:\n\t\t//\t\ta surface object to be used for drawings\n\t\tconstructor: function(){\n\t\t\t// underlying node\n\t\t\tthis.rawNode = null;\n\t\t\t// the parent node\n\t\t\tthis._parent = null;\n\t\t\t// the list of DOM nodes to be deleted in the case of destruction\n\t\t\tthis._nodes = [];\n\t\t\t// the list of events to be detached in the case of destruction\n\t\t\tthis._events = [];\n\t\t},\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tdestroy all relevant external resources and release all\n\t\t\t//\t\texternal references to make this object garbage-collectible\n\t\t\tarr.forEach(this._nodes, domConstruct.destroy);\n\t\t\tthis._nodes = [];\n\t\t\tarr.forEach(this._events, function(h){ if(h){ h.remove(); } });\n\t\t\tthis._events = [];\n\t\t\tthis.rawNode = null;\t// recycle it in _nodes, if it needs to be recycled\n\t\t\tif(has(\"ie\")){\n\t\t\t\twhile(this._parent.lastChild){\n\t\t\t\t\tdomConstruct.destroy(this._parent.lastChild);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tthis._parent.innerHTML = \"\";\n\t\t\t}\n\t\t\tthis._parent = null;\n\t\t},\n\t\tgetEventSource: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns a node, which can be used to attach event listeners\n\t\t\treturn this.rawNode; // Node\n\t\t},\n\t\t_getRealMatrix: function(){\n\t\t\t// summary:\n\t\t\t//\t\talways returns the identity matrix\n\t\t\treturn null;\t// dojox/gfx/Matrix2D\n\t\t},\n\t\t/*=====\n\t\t setDimensions: function(width, height){\n\t\t\t // summary:\n\t\t\t //\t\tsets the width and height of the rawNode\n\t\t\t // width: String\n\t\t\t //\t\twidth of surface, e.g., \"100px\"\n\t\t\t // height: String\n\t\t\t //\t\theight of surface, e.g., \"100px\"\n\t\t\t return this;\t// self\n\t\t },\n\t\t getDimensions: function(){\n\t\t\t // summary:\n\t\t\t //     gets current width and height in pixels\n\t\t\t // returns: Object\n\t\t\t //     object with properties \"width\" and \"height\"\n\t\t },\n\t\t =====*/\n\t\tisLoaded: true,\n\t\tonLoad: function(/*dojox/gfx/shape.Surface*/ surface){\n\t\t\t// summary:\n\t\t\t//\t\tlocal event, fired once when the surface is created\n\t\t\t//\t\tasynchronously, used only when isLoaded is false, required\n\t\t\t//\t\tonly for Silverlight.\n\t\t},\n\t\twhenLoaded: function(/*Object|Null*/ context, /*Function|String*/ method){\n\t\t\tvar f = lang.hitch(context, method);\n\t\t\tif(this.isLoaded){\n\t\t\t\tf(this);\n\t\t\t}else{\n\t\t\t\ton.once(this, \"load\", function(surface){\n\t\t\t\t\tf(surface);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\tlang.extend(shape.Surface, shape._eventsProcessing);\n\n\t/*=====\n\tg.Point = declare(\"dojox/gfx.Point\", null, {\n\t\t// summary:\n\t\t//\t\t2D point for drawings - {x, y}\n\t\t// description:\n\t\t//\t\tDo not use this object directly!\n\t\t//\t\tUse the naked object instead: {x: 1, y: 2}.\n\t});\n\n\tg.Rectangle = declare(\"dojox.gfx.Rectangle\", null, {\n\t\t// summary:\n\t\t//\t\trectangle - {x, y, width, height}\n\t\t// description:\n\t\t//\t\tDo not use this object directly!\n\t\t//\t\tUse the naked object instead: {x: 1, y: 2, width: 100, height: 200}.\n\t});\n\t =====*/\n\n\n\tshape.Rect = declare(\"dojox.gfx.shape.Rect\", shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic rectangle\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\tThe underlying graphics system object (typically a DOM Node)\n\t\t\tthis.shape = g.getDefault(\"Rect\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box (its shape in this case)\n\t\t\treturn this.shape;\t// dojox/gfx.Rectangle\n\t\t}\n\t});\n\t\n\tshape.Ellipse = declare(\"dojox.gfx.shape.Ellipse\", shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic ellipse\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM Node\n\t\t\tthis.shape = g.getDefault(\"Ellipse\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box\n\t\t\tif(!this.bbox){\n\t\t\t\tvar shape = this.shape;\n\t\t\t\tthis.bbox = {x: shape.cx - shape.rx, y: shape.cy - shape.ry,\n\t\t\t\t\twidth: 2 * shape.rx, height: 2 * shape.ry};\n\t\t\t}\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t}\n\t});\n\t\n\tshape.Circle = declare(\"dojox.gfx.shape.Circle\", shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic circle\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM Node\n\t\t\tthis.shape = g.getDefault(\"Circle\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box\n\t\t\tif(!this.bbox){\n\t\t\t\tvar shape = this.shape;\n\t\t\t\tthis.bbox = {x: shape.cx - shape.r, y: shape.cy - shape.r,\n\t\t\t\t\twidth: 2 * shape.r, height: 2 * shape.r};\n\t\t\t}\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t}\n\t});\n\t\n\tshape.Line = declare(\"dojox.gfx.shape.Line\", shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic line (do not instantiate it directly)\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM Node\n\t\t\tthis.shape = g.getDefault(\"Line\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box\n\t\t\tif(!this.bbox){\n\t\t\t\tvar shape = this.shape;\n\t\t\t\tthis.bbox = {\n\t\t\t\t\tx:\t\tMath.min(shape.x1, shape.x2),\n\t\t\t\t\ty:\t\tMath.min(shape.y1, shape.y2),\n\t\t\t\t\twidth:\tMath.abs(shape.x2 - shape.x1),\n\t\t\t\t\theight:\tMath.abs(shape.y2 - shape.y1)\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t}\n\t});\n\t\n\tshape.Polyline = declare(\"dojox.gfx.shape.Polyline\", shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic polyline/polygon (do not instantiate it directly)\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM Node\n\t\t\tthis.shape = g.getDefault(\"Polyline\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tsetShape: function(points, closed){\n\t\t\t// summary:\n\t\t\t//\t\tsets a polyline/polygon shape object\n\t\t\t// points: Object|Array\n\t\t\t//\t\ta polyline/polygon shape object, or an array of points\n\t\t\t// closed: Boolean\n\t\t\t//\t\tclose the polyline to make a polygon\n\t\t\tif(points && points instanceof Array){\n\t\t\t\tthis.inherited(arguments, [{points: points}]);\n\t\t\t\tif(closed && this.shape.points.length){\n\t\t\t\t\tthis.shape.points.push(this.shape.points[0]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tthis.inherited(arguments, [points]);\n\t\t\t}\n\t\t\treturn this;\t// self\n\t\t},\n\t\t_normalizePoints: function(){\n\t\t\t// summary:\n\t\t\t//\t\tnormalize points to array of {x:number, y:number}\n\t\t\tvar p = this.shape.points, l = p && p.length;\n\t\t\tif(l && typeof p[0] == \"number\"){\n\t\t\t\tvar points = [];\n\t\t\t\tfor(var i = 0; i < l; i += 2){\n\t\t\t\t\tpoints.push({x: p[i], y: p[i + 1]});\n\t\t\t\t}\n\t\t\t\tthis.shape.points = points;\n\t\t\t}\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box\n\t\t\tif(!this.bbox && this.shape.points.length){\n\t\t\t\tvar p = this.shape.points;\n\t\t\t\tvar l = p.length;\n\t\t\t\tvar t = p[0];\n\t\t\t\tvar bbox = {l: t.x, t: t.y, r: t.x, b: t.y};\n\t\t\t\tfor(var i = 1; i < l; ++i){\n\t\t\t\t\tt = p[i];\n\t\t\t\t\tif(bbox.l > t.x) bbox.l = t.x;\n\t\t\t\t\tif(bbox.r < t.x) bbox.r = t.x;\n\t\t\t\t\tif(bbox.t > t.y) bbox.t = t.y;\n\t\t\t\t\tif(bbox.b < t.y) bbox.b = t.y;\n\t\t\t\t}\n\t\t\t\tthis.bbox = {\n\t\t\t\t\tx:\t\tbbox.l,\n\t\t\t\t\ty:\t\tbbox.t,\n\t\t\t\t\twidth:\tbbox.r - bbox.l,\n\t\t\t\t\theight:\tbbox.b - bbox.t\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\n\t\t}\n\t});\n\t\n\tshape.Image = declare(\"dojox.gfx.shape.Image\", shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic image (do not instantiate it directly)\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM Node\n\t\t\tthis.shape = g.getDefault(\"Image\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box (its shape in this case)\n\t\t\treturn this.shape;\t// dojox/gfx.Rectangle\n\t\t},\n\t\tsetStroke: function(){\n\t\t\t// summary:\n\t\t\t//\t\tignore setting a stroke style\n\t\t\treturn this;\t// self\n\t\t},\n\t\tsetFill: function(){\n\t\t\t// summary:\n\t\t\t//\t\tignore setting a fill style\n\t\t\treturn this;\t// self\n\t\t}\n\t});\n\t\n\tshape.Text = declare(shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta generic text (do not instantiate it directly)\n\t\tconstructor: function(rawNode){\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM Node\n\t\t\tthis.fontStyle = null;\n\t\t\tthis.shape = g.getDefault(\"Text\");\n\t\t\tthis.rawNode = rawNode;\n\t\t},\n\t\tgetFont: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the current font object or null\n\t\t\treturn this.fontStyle;\t// Object\n\t\t},\n\t\tsetFont: function(newFont){\n\t\t\t// summary:\n\t\t\t//\t\tsets a font for text\n\t\t\t// newFont: Object\n\t\t\t//\t\ta font object (see dojox/gfx.defaultFont) or a font string\n\t\t\tthis.fontStyle = typeof newFont == \"string\" ? g.splitFontString(newFont) :\n\t\t\t\tg.makeParameters(g.defaultFont, newFont);\n\t\t\tthis._setFont();\n\t\t\treturn this;\t// self\n\t\t},\n\t\tgetBoundingBox: function(){\n\t\t\tvar bbox = null, s = this.getShape();\n\t\t\tif(s.text){\n\t\t\t\tbbox = g._base._computeTextBoundingBox(this);\n\t\t\t}\n\t\t\treturn bbox;\n\t\t}\n\t});\n\t\n\tshape.Creator = {\n\t\t// summary:\n\t\t//\t\tshape creators\n\t\tcreateShape: function(shape){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a shape object based on its type; it is meant to be used\n\t\t\t//\t\tby group-like objects\n\t\t\t// shape: Object\n\t\t\t//\t\ta shape descriptor object\n\t\t\t// returns: dojox/gfx/shape.Shape | Null\n\t\t\t//      a fully instantiated surface-specific Shape object\n\t\t\tswitch(shape.type){\n\t\t\t\tcase g.defaultPath.type:\t\treturn this.createPath(shape);\n\t\t\t\tcase g.defaultRect.type:\t\treturn this.createRect(shape);\n\t\t\t\tcase g.defaultCircle.type:\t    return this.createCircle(shape);\n\t\t\t\tcase g.defaultEllipse.type:\t    return this.createEllipse(shape);\n\t\t\t\tcase g.defaultLine.type:\t\treturn this.createLine(shape);\n\t\t\t\tcase g.defaultPolyline.type:\treturn this.createPolyline(shape);\n\t\t\t\tcase g.defaultImage.type:\t\treturn this.createImage(shape);\n\t\t\t\tcase g.defaultText.type:\t\treturn this.createText(shape);\n\t\t\t\tcase g.defaultTextPath.type:\treturn this.createTextPath(shape);\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tcreateGroup: function(){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a group shape\n\t\t\treturn this.createObject(g.Group);\t// dojox/gfx/Group\n\t\t},\n\t\tcreateRect: function(rect){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a rectangle shape\n\t\t\t// rect: Object\n\t\t\t//\t\ta path object (see dojox/gfx.defaultRect)\n\t\t\treturn this.createObject(g.Rect, rect);\t// dojox/gfx/shape.Rect\n\t\t},\n\t\tcreateEllipse: function(ellipse){\n\t\t\t// summary:\n\t\t\t//\t\tcreates an ellipse shape\n\t\t\t// ellipse: Object\n\t\t\t//\t\tan ellipse object (see dojox/gfx.defaultEllipse)\n\t\t\treturn this.createObject(g.Ellipse, ellipse);\t// dojox/gfx/shape.Ellipse\n\t\t},\n\t\tcreateCircle: function(circle){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a circle shape\n\t\t\t// circle: Object\n\t\t\t//\t\ta circle object (see dojox/gfx.defaultCircle)\n\t\t\treturn this.createObject(g.Circle, circle);\t// dojox/gfx/shape.Circle\n\t\t},\n\t\tcreateLine: function(line){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a line shape\n\t\t\t// line: Object\n\t\t\t//\t\ta line object (see dojox/gfx.defaultLine)\n\t\t\treturn this.createObject(g.Line, line);\t// dojox/gfx/shape.Line\n\t\t},\n\t\tcreatePolyline: function(points){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a polyline/polygon shape\n\t\t\t// points: Object\n\t\t\t//\t\ta points object (see dojox/gfx.defaultPolyline)\n\t\t\t//\t\tor an Array of points\n\t\t\treturn this.createObject(g.Polyline, points);\t// dojox/gfx/shape.Polyline\n\t\t},\n\t\tcreateImage: function(image){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a image shape\n\t\t\t// image: Object\n\t\t\t//\t\tan image object (see dojox/gfx.defaultImage)\n\t\t\treturn this.createObject(g.Image, image);\t// dojox/gfx/shape.Image\n\t\t},\n\t\tcreateText: function(text){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a text shape\n\t\t\t// text: Object\n\t\t\t//\t\ta text object (see dojox/gfx.defaultText)\n\t\t\treturn this.createObject(g.Text, text);\t// dojox/gfx/shape.Text\n\t\t},\n\t\tcreatePath: function(path){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a path shape\n\t\t\t// path: Object\n\t\t\t//\t\ta path object (see dojox/gfx.defaultPath)\n\t\t\treturn this.createObject(g.Path, path);\t// dojox/gfx/shape.Path\n\t\t},\n\t\tcreateTextPath: function(text){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a text shape\n\t\t\t// text: Object\n\t\t\t//\t\ta textpath object (see dojox/gfx.defaultTextPath)\n\t\t\treturn this.createObject(g.TextPath, {}).setText(text);\t// dojox/gfx/shape.TextPath\n\t\t},\n\t\tcreateObject: function(shapeType, rawShape){\n\t\t\t// summary:\n\t\t\t//\t\tcreates an instance of the passed shapeType class\n\t\t\t// shapeType: Function\n\t\t\t//\t\ta class constructor to create an instance of\n\t\t\t// rawShape: Object \n\t\t\t//\t\tproperties to be passed in to the classes 'setShape' method\n\t\n\t\t\t// SHOULD BE RE-IMPLEMENTED BY THE RENDERER!\n\t\t\treturn null;\t// dojox/gfx/shape.Shape\n\t\t}\n\t};\n\t\n\t/*=====\n\t lang.extend(shape.Surface, shape.Container);\n\t lang.extend(shape.Surface, shape.Creator);\n\n\t g.Group = declare(shape.Shape, {\n\t\t// summary:\n\t\t//\t\ta group shape, which can be used\n\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\n\t});\n\tlang.extend(g.Group, shape.Container);\n\tlang.extend(g.Group, shape.Creator);\n\n\tg.Rect     = shape.Rect;\n\tg.Circle   = shape.Circle;\n\tg.Ellipse  = shape.Ellipse;\n\tg.Line     = shape.Line;\n\tg.Polyline = shape.Polyline;\n\tg.Text     = shape.Text;\n\tg.Surface  = shape.Surface;\n\t=====*/\n\n\treturn shape;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/shape.js\n// module id = 169\n// module chunks = 4","define([\"./_base\",\"dojo/_base/lang\"], \n  function(g, lang){\n\tvar m = g.matrix = {};\n\n\t// candidates for dojox.math:\n\tvar _degToRadCache = {};\n\tm._degToRad = function(degree){\n\t\treturn _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));\n\t};\n\tm._radToDeg = function(radian){ return radian / Math.PI * 180; };\n\n\tm.Matrix2D = function(arg){\n\t\t// summary:\n\t\t//\t\ta 2D matrix object\n\t\t// description:\n\t\t//\t\tNormalizes a 2D matrix-like object. If arrays is passed,\n\t\t//\t\tall objects of the array are normalized and multiplied sequentially.\n\t\t// arg: Object\n\t\t//\t\ta 2D matrix-like object, a number, or an array of such objects\n\t\tif(arg){\n\t\t\tif(typeof arg == \"number\"){\n\t\t\t\tthis.xx = this.yy = arg;\n\t\t\t}else if(arg instanceof Array){\n\t\t\t\tif(arg.length > 0){\n\t\t\t\t\tvar matrix = m.normalize(arg[0]);\n\t\t\t\t\t// combine matrices\n\t\t\t\t\tfor(var i = 1; i < arg.length; ++i){\n\t\t\t\t\t\tvar l = matrix, r = m.normalize(arg[i]);\n\t\t\t\t\t\tmatrix = new m.Matrix2D();\n\t\t\t\t\t\tmatrix.xx = l.xx * r.xx + l.xy * r.yx;\n\t\t\t\t\t\tmatrix.xy = l.xx * r.xy + l.xy * r.yy;\n\t\t\t\t\t\tmatrix.yx = l.yx * r.xx + l.yy * r.yx;\n\t\t\t\t\t\tmatrix.yy = l.yx * r.xy + l.yy * r.yy;\n\t\t\t\t\t\tmatrix.dx = l.xx * r.dx + l.xy * r.dy + l.dx;\n\t\t\t\t\t\tmatrix.dy = l.yx * r.dx + l.yy * r.dy + l.dy;\n\t\t\t\t\t}\n\t\t\t\t\tlang.mixin(this, matrix);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlang.mixin(this, arg);\n\t\t\t}\n\t\t}\n\t};\n\n\t// the default (identity) matrix, which is used to fill in missing values\n\tlang.extend(m.Matrix2D, {xx: 1, xy: 0, yx: 0, yy: 1, dx: 0, dy: 0});\n\n\tlang.mixin(m, {\n\t\t// summary:\n\t\t//\t\tclass constants, and methods of dojox/gfx/matrix\n\n\t\t// matrix constants\n\n\t\t// identity: dojox/gfx/matrix.Matrix2D\n\t\t//\t\tan identity matrix constant: identity * (x, y) == (x, y)\n\t\tidentity: new m.Matrix2D(),\n\n\t\t// flipX: dojox/gfx/matrix.Matrix2D\n\t\t//\t\ta matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)\n\t\tflipX:    new m.Matrix2D({xx: -1}),\n\n\t\t// flipY: dojox/gfx/matrix.Matrix2D\n\t\t//\t\ta matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)\n\t\tflipY:    new m.Matrix2D({yy: -1}),\n\n\t\t// flipXY: dojox/gfx/matrix.Matrix2D\n\t\t//\t\ta matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)\n\t\tflipXY:   new m.Matrix2D({xx: -1, yy: -1}),\n\n\t\t// matrix creators\n\n\t\ttranslate: function(a, b){\n\t\t\t// summary:\n\t\t\t//\t\tforms a translation matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to translate (move) points by specified offsets.\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x coordinate value, or a point-like object, which specifies offsets for both dimensions\n\t\t\t// b: Number?\n\t\t\t//\t\ta y coordinate value\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 1){\n\t\t\t\treturn new m.Matrix2D({dx: a, dy: b}); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\t// branch\n\t\t\treturn new m.Matrix2D({dx: a.x, dy: a.y}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tscale: function(a, b){\n\t\t\t// summary:\n\t\t\t//\t\tforms a scaling matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to scale (magnify) points by specified offsets.\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\ta scaling factor used for the x coordinate, or\n\t\t\t//\t\ta uniform scaling factor used for the both coordinates, or\n\t\t\t//\t\ta point-like object, which specifies scale factors for both dimensions\n\t\t\t// b: Number?\n\t\t\t//\t\ta scaling factor used for the y coordinate\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 1){\n\t\t\t\treturn new m.Matrix2D({xx: a, yy: b}); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\tif(typeof a == \"number\"){\n\t\t\t\treturn new m.Matrix2D({xx: a, yy: a}); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn new m.Matrix2D({xx: a.x, yy: a.y}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\trotate: function(angle){\n\t\t\t// summary:\n\t\t\t//\t\tforms a rotating matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to rotate points\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\n\t\t\t// angle: Number\n\t\t\t//\t\tan angle of rotation in radians (>0 for CW)\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tvar c = Math.cos(angle);\n\t\t\tvar s = Math.sin(angle);\n\t\t\treturn new m.Matrix2D({xx: c, xy: -s, yx: s, yy: c}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\trotateg: function(degree){\n\t\t\t// summary:\n\t\t\t//\t\tforms a rotating matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to rotate points\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\n\t\t\t//\t\tSee dojox/gfx/matrix.rotate() for comparison.\n\t\t\t// degree: Number\n\t\t\t//\t\tan angle of rotation in degrees (>0 for CW)\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\treturn m.rotate(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewX: function(angle) {\n\t\t\t// summary:\n\t\t\t//\t\tforms an x skewing matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to skew points in the x dimension\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\n\t\t\t// angle: Number\n\t\t\t//\t\ta skewing angle in radians\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\treturn new m.Matrix2D({xy: Math.tan(angle)}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewXg: function(degree){\n\t\t\t// summary:\n\t\t\t//\t\tforms an x skewing matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to skew points in the x dimension\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\n\t\t\t//\t\tSee dojox/gfx/matrix.skewX() for comparison.\n\t\t\t// degree: Number\n\t\t\t//\t\ta skewing angle in degrees\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\treturn m.skewX(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewY: function(angle){\n\t\t\t// summary:\n\t\t\t//\t\tforms a y skewing matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to skew points in the y dimension\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\n\t\t\t// angle: Number\n\t\t\t//\t\ta skewing angle in radians\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\treturn new m.Matrix2D({yx: Math.tan(angle)}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewYg: function(degree){\n\t\t\t// summary:\n\t\t\t//\t\tforms a y skewing matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to skew points in the y dimension\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\n\t\t\t//\t\tSee dojox/gfx/matrix.skewY() for comparison.\n\t\t\t// degree: Number\n\t\t\t//\t\ta skewing angle in degrees\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\treturn m.skewY(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\treflect: function(a, b){\n\t\t\t// summary:\n\t\t\t//\t\tforms a reflection matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to reflect points around a vector,\n\t\t\t//\t\twhich goes through the origin.\n\t\t\t// a: dojox/gfx.Point|Number\n\t\t\t//\t\ta point-like object, which specifies a vector of reflection, or an X value\n\t\t\t// b: Number?\n\t\t\t//\t\ta Y value\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length == 1){\n\t\t\t\tb = a.y;\n\t\t\t\ta = a.x;\n\t\t\t}\n\t\t\t// make a unit vector\n\t\t\tvar a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = 2 * a * b / n2;\n\t\t\treturn new m.Matrix2D({xx: 2 * a2 / n2 - 1, xy: xy, yx: xy, yy: 2 * b2 / n2 - 1}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tproject: function(a, b){\n\t\t\t// summary:\n\t\t\t//\t\tforms an orthogonal projection matrix\n\t\t\t// description:\n\t\t\t//\t\tThe resulting matrix is used to project points orthogonally on a vector,\n\t\t\t//\t\twhich goes through the origin.\n\t\t\t// a: dojox/gfx.Point|Number\n\t\t\t//\t\ta point-like object, which specifies a vector of projection, or\n\t\t\t//\t\tan x coordinate value\n\t\t\t// b: Number?\n\t\t\t//\t\ta y coordinate value\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length == 1){\n\t\t\t\tb = a.y;\n\t\t\t\ta = a.x;\n\t\t\t}\n\t\t\t// make a unit vector\n\t\t\tvar a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = a * b / n2;\n\t\t\treturn new m.Matrix2D({xx: a2 / n2, xy: xy, yx: xy, yy: b2 / n2}); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\n\t\t// ensure matrix 2D conformance\n\t\tnormalize: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tconverts an object to a matrix, if necessary\n\t\t\t// description:\n\t\t\t//\t\tConverts any 2D matrix-like object or an array of\n\t\t\t//\t\tsuch objects to a valid dojox/gfx/matrix.Matrix2D object.\n\t\t\t// matrix: Object\n\t\t\t//\t\tan object, which is converted to a matrix, if necessary\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\treturn (matrix instanceof m.Matrix2D) ? matrix : new m.Matrix2D(matrix); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\n\t\t// common operations\n\n\t\tisIdentity: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\treturns whether the specified matrix is the identity.\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix object to be tested\n\t\t\t// returns: Boolean\n\t\t\treturn matrix.xx == 1 && matrix.xy == 0 && matrix.yx == 0 && matrix.yy == 1 && matrix.dx == 0 && matrix.dy == 0; // Boolean\n\t\t},\n\t\tclone: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a copy of a 2D matrix\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object to be cloned\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tvar obj = new m.Matrix2D();\n\t\t\tfor(var i in matrix){\n\t\t\t\tif(typeof(matrix[i]) == \"number\" && typeof(obj[i]) == \"number\" && obj[i] != matrix[i]) obj[i] = matrix[i];\n\t\t\t}\n\t\t\treturn obj; // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tinvert: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tinverts a 2D matrix\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object to be inverted\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tvar M = m.normalize(matrix),\n\t\t\t\tD = M.xx * M.yy - M.xy * M.yx;\n\t\t\t\tM = new m.Matrix2D({\n\t\t\t\t\txx: M.yy/D, xy: -M.xy/D,\n\t\t\t\t\tyx: -M.yx/D, yy: M.xx/D,\n\t\t\t\t\tdx: (M.xy * M.dy - M.yy * M.dx) / D,\n\t\t\t\t\tdy: (M.yx * M.dx - M.xx * M.dy) / D\n\t\t\t\t});\n\t\t\treturn M; // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\t_multiplyPoint: function(matrix, x, y){\n\t\t\t// summary:\n\t\t\t//\t\tapplies a matrix to a point\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix object to be applied\n\t\t\t// x: Number\n\t\t\t//\t\tan x coordinate of a point\n\t\t\t// y: Number\n\t\t\t//\t\ta y coordinate of a point\n\t\t\t// returns: dojox/gfx.Point\n\t\t\treturn {x: matrix.xx * x + matrix.xy * y + matrix.dx, y: matrix.yx * x + matrix.yy * y + matrix.dy}; // dojox/gfx.Point\n\t\t},\n\t\tmultiplyPoint: function(matrix, /* Number||Point */ a, /* Number? */ b){\n\t\t\t// summary:\n\t\t\t//\t\tapplies a matrix to a point\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix object to be applied\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x coordinate of a point, or a point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y coordinate of a point\n\t\t\t// returns: dojox/gfx.Point\n\t\t\tvar M = m.normalize(matrix);\n\t\t\tif(typeof a == \"number\" && typeof b == \"number\"){\n\t\t\t\treturn m._multiplyPoint(M, a, b); // dojox/gfx.Point\n\t\t\t}\n\t\t\treturn m._multiplyPoint(M, a.x, a.y); // dojox/gfx.Point\n\t\t},\n\t\tmultiplyRectangle: function(matrix, /*Rectangle*/ rect){\n\t\t\t// summary:\n\t\t\t//\t\tApplies a matrix to a rectangle.\n\t\t\t// description:\n\t\t\t//\t\tThe method applies the transformation on all corners of the\n\t\t\t//\t\trectangle and returns the smallest rectangle enclosing the 4 transformed\n\t\t\t//\t\tpoints.\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix object to be applied.\n\t\t\t// rect: Rectangle\n\t\t\t//\t\tthe rectangle to transform.\n\t\t\t// returns: dojox/gfx.Rectangle\n\t\t\tvar M = m.normalize(matrix);\n\t\t\trect = rect || {x:0, y:0, width:0, height:0}; \n\t\t\tif(m.isIdentity(M))\n\t\t\t\treturn {x: rect.x, y: rect.y, width: rect.width, height: rect.height}; // dojo/gfx.Rectangle\n\t\t\tvar p0 = m.multiplyPoint(M, rect.x, rect.y),\n\t\t\t\tp1 = m.multiplyPoint(M, rect.x, rect.y + rect.height),\n\t\t\t\tp2 = m.multiplyPoint(M, rect.x + rect.width, rect.y),\n\t\t\t\tp3 = m.multiplyPoint(M, rect.x + rect.width, rect.y + rect.height),\n\t\t\t\tminx = Math.min(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\tminy = Math.min(p0.y, p1.y, p2.y, p3.y),\n\t\t\t\tmaxx = Math.max(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\tmaxy = Math.max(p0.y, p1.y, p2.y, p3.y);\n\t\t\treturn{ // dojo/gfx.Rectangle\n\t\t\t\tx: minx,\n\t\t\t\ty: miny,\n\t\t\t\twidth: maxx - minx,\n\t\t\t\theight: maxy - miny\n\t\t\t};\n\t\t},\n\t\tmultiply: function(matrix){\n\t\t\t// summary:\n\t\t\t//\t\tcombines matrices by multiplying them sequentially in the given order\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object,\n\t\t\t//\t\tall subsequent arguments are matrix-like objects too\n\t\t\tvar M = m.normalize(matrix);\n\t\t\t// combine matrices\n\t\t\tfor(var i = 1; i < arguments.length; ++i){\n\t\t\t\tvar l = M, r = m.normalize(arguments[i]);\n\t\t\t\tM = new m.Matrix2D();\n\t\t\t\tM.xx = l.xx * r.xx + l.xy * r.yx;\n\t\t\t\tM.xy = l.xx * r.xy + l.xy * r.yy;\n\t\t\t\tM.yx = l.yx * r.xx + l.yy * r.yx;\n\t\t\t\tM.yy = l.yx * r.xy + l.yy * r.yy;\n\t\t\t\tM.dx = l.xx * r.dx + l.xy * r.dy + l.dx;\n\t\t\t\tM.dy = l.yx * r.dx + l.yy * r.dy + l.dy;\n\t\t\t}\n\t\t\treturn M; // dojox/gfx/matrix.Matrix2D\n\t\t},\n\n\t\t// high level operations\n\n\t\t_sandwich: function(matrix, x, y){\n\t\t\t// summary:\n\t\t\t//\t\tapplies a matrix at a central point\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t\t//\t\ta 2D matrix-like object, which is applied at a central point\n\t\t\t// x: Number\n\t\t\t//\t\tan x component of the central point\n\t\t\t// y: Number\n\t\t\t//\t\ta y component of the central point\n\t\t\treturn m.multiply(m.translate(x, y), matrix, m.translate(-x, -y)); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tscaleAt: function(a, b, c, d){\n\t\t\t// summary:\n\t\t\t//\t\tscales a picture using a specified point as a center of scaling\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.scale().\n\t\t\t// a: Number\n\t\t\t//\t\ta scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates\n\t\t\t// b: Number?\n\t\t\t//\t\ta scaling factor used for the y coordinate\n\t\t\t// c: Number|Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// d: Number\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tswitch(arguments.length){\n\t\t\t\tcase 4:\n\t\t\t\t\t// a and b are scale factor components, c and d are components of a point\n\t\t\t\t\treturn m._sandwich(m.scale(a, b), c, d); // dojox/gfx/matrix.Matrix2D\n\t\t\t\tcase 3:\n\t\t\t\t\tif(typeof c == \"number\"){\n\t\t\t\t\t\treturn m._sandwich(m.scale(a), b, c); // dojox/gfx/matrix.Matrix2D\n\t\t\t\t\t}\n\t\t\t\t\treturn m._sandwich(m.scale(a, b), c.x, c.y); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.scale(a), b.x, b.y); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\trotateAt: function(angle, a, b){\n\t\t\t// summary:\n\t\t\t//\t\trotates a picture using a specified point as a center of rotation\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.rotate().\n\t\t\t// angle: Number\n\t\t\t//\t\tan angle of rotation in radians (>0 for CW)\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn m._sandwich(m.rotate(angle), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.rotate(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\trotategAt: function(degree, a, b){\n\t\t\t// summary:\n\t\t\t//\t\trotates a picture using a specified point as a center of rotation\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.rotateg().\n\t\t\t// degree: Number\n\t\t\t//\t\tan angle of rotation in degrees (>0 for CW)\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn m._sandwich(m.rotateg(degree), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.rotateg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewXAt: function(angle, a, b){\n\t\t\t// summary:\n\t\t\t//\t\tskews a picture along the x axis using a specified point as a center of skewing\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.skewX().\n\t\t\t// angle: Number\n\t\t\t//\t\ta skewing angle in radians\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn m._sandwich(m.skewX(angle), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.skewX(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewXgAt: function(degree, a, b){\n\t\t\t// summary:\n\t\t\t//\t\tskews a picture along the x axis using a specified point as a center of skewing\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.skewXg().\n\t\t\t// degree: Number\n\t\t\t//\t\ta skewing angle in degrees\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn m._sandwich(m.skewXg(degree), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.skewXg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewYAt: function(angle, a, b){\n\t\t\t// summary:\n\t\t\t//\t\tskews a picture along the y axis using a specified point as a center of skewing\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.skewY().\n\t\t\t// angle: Number\n\t\t\t//\t\ta skewing angle in radians\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn m._sandwich(m.skewY(angle), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.skewY(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t},\n\t\tskewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){\n\t\t\t// summary:\n\t\t\t//\t\tskews a picture along the y axis using a specified point as a center of skewing\n\t\t\t// description:\n\t\t\t//\t\tCompare with dojox/gfx/matrix.skewYg().\n\t\t\t// degree: Number\n\t\t\t//\t\ta skewing angle in degrees\n\t\t\t// a: Number|dojox/gfx.Point\n\t\t\t//\t\tan x component of a central point, or a central point\n\t\t\t// b: Number?\n\t\t\t//\t\ta y component of a central point\n\t\t\t// returns: dojox/gfx/matrix.Matrix2D\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn m._sandwich(m.skewYg(degree), a, b); // dojox/gfx/matrix.Matrix2D\n\t\t\t}\n\t\t\treturn m._sandwich(m.skewYg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D\n\t\t}\n\n\t\t//TODO: rect-to-rect mapping, scale-to-fit (isotropic and anisotropic versions)\n\n\t});\n\t// propagate Matrix2D up\n\tg.Matrix2D = m.Matrix2D;\n\n\treturn m;\n});\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/matrix.js\n// module id = 170\n// module chunks = 4","define([\"./_base\", \"dojo/_base/lang\",\"dojo/_base/declare\", \"./matrix\", \"./shape\"],\n\tfunction(g, lang, declare, matrix, shapeLib){\n\n\t// module:\n\t//\t\tdojox/gfx/path\n\n\tvar Path = declare(\"dojox.gfx.path.Path\", shapeLib.Shape, {\n\t\t// summary:\n\t\t//\t\ta generalized path shape\n\n\t\tconstructor: function(rawNode){\n\t\t\t// summary:\n\t\t\t//\t\ta path constructor\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM node to be used by this path object\n\t\t\tthis.shape = lang.clone(g.defaultPath);\n\t\t\tthis.segments = [];\n\t\t\tthis.tbbox = null;\n\t\t\tthis.absolute = true;\n\t\t\tthis.last = {};\n\t\t\tthis.rawNode = rawNode;\n\t\t\tthis.segmented = false;\n\t\t},\n\n\t\t// mode manipulations\n\t\tsetAbsoluteMode: function(mode){\n\t\t\t// summary:\n\t\t\t//\t\tsets an absolute or relative mode for path points\n\t\t\t// mode: Boolean\n\t\t\t//\t\ttrue/false or \"absolute\"/\"relative\" to specify the mode\n\t\t\tthis._confirmSegmented();\n\t\t\tthis.absolute = typeof mode == \"string\" ? (mode == \"absolute\") : mode;\n\t\t\treturn this; // self\n\t\t},\n\t\tgetAbsoluteMode: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns a current value of the absolute mode\n\t\t\tthis._confirmSegmented();\n\t\t\treturn this.absolute; // Boolean\n\t\t},\n\n\t\tgetBoundingBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the bounding box {x, y, width, height} or null\n\t\t\tthis._confirmSegmented();\n\t\t\treturn (this.bbox && (\"l\" in this.bbox)) ? {x: this.bbox.l, y: this.bbox.t, width: this.bbox.r - this.bbox.l, height: this.bbox.b - this.bbox.t} : null; // dojox/gfx.Rectangle\n\t\t},\n\n\t\t_getRealBBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns an array of four points or null\n\t\t\t//\t\tfour points represent four corners of the untransformed bounding box\n\t\t\tthis._confirmSegmented();\n\t\t\tif(this.tbbox){\n\t\t\t\treturn this.tbbox;\t// Array\n\t\t\t}\n\t\t\tvar bbox = this.bbox, matrix = this._getRealMatrix();\n\t\t\tthis.bbox = null;\n\t\t\tfor(var i = 0, len = this.segments.length; i < len; ++i){\n\t\t\t\tthis._updateWithSegment(this.segments[i], matrix);\n\t\t\t}\n\t\t\tvar t = this.bbox;\n\t\t\tthis.bbox = bbox;\n\t\t\tthis.tbbox = t ? [\n\t\t\t\t{x: t.l, y: t.t},\n\t\t\t\t{x: t.r, y: t.t},\n\t\t\t\t{x: t.r, y: t.b},\n\t\t\t\t{x: t.l, y: t.b}\n\t\t\t] : null;\n\t\t\treturn this.tbbox;\t// Array\n\t\t},\n\n\t\tgetLastPosition: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the last point in the path, or null\n\t\t\tthis._confirmSegmented();\n\t\t\treturn \"x\" in this.last ? this.last : null; // Object\n\t\t},\n\n\t\t_applyTransform: function(){\n\t\t\tthis.tbbox = null;\n\t\t\treturn this.inherited(arguments);\n\t\t},\n\n\t\t// segment interpretation\n\t\t_updateBBox: function(x, y, m){\n\t\t\t// summary:\n\t\t\t//\t\tupdates the bounding box of path with new point\n\t\t\t// x: Number\n\t\t\t//\t\tan x coordinate\n\t\t\t// y: Number\n\t\t\t//\t\ta y coordinate\n\n\t\t\tif(m){\n\t\t\t\tvar t = matrix.multiplyPoint(m, x, y);\n\t\t\t\tx = t.x;\n\t\t\t\ty = t.y;\n\t\t\t}\n\n\t\t\t// we use {l, b, r, t} representation of a bbox\n\t\t\tif(this.bbox && (\"l\" in this.bbox)){\n\t\t\t\tif(this.bbox.l > x) this.bbox.l = x;\n\t\t\t\tif(this.bbox.r < x) this.bbox.r = x;\n\t\t\t\tif(this.bbox.t > y) this.bbox.t = y;\n\t\t\t\tif(this.bbox.b < y) this.bbox.b = y;\n\t\t\t}else{\n\t\t\t\tthis.bbox = {l: x, b: y, r: x, t: y};\n\t\t\t}\n\t\t},\n\t\t_updateWithSegment: function(segment, matrix){\n\t\t\t// summary:\n\t\t\t//\t\tupdates the bounding box of path with new segment\n\t\t\t// segment: Object\n\t\t\t//\t\ta segment\n\t\t\tvar n = segment.args, l = n.length, i;\n\t\t\t// update internal variables: bbox, absolute, last\n\t\t\tswitch(segment.action){\n\t\t\t\tcase \"M\":\n\t\t\t\tcase \"L\":\n\t\t\t\tcase \"C\":\n\t\t\t\tcase \"S\":\n\t\t\t\tcase \"Q\":\n\t\t\t\tcase \"T\":\n\t\t\t\t\tfor(i = 0; i < l; i += 2){\n\t\t\t\t\t\tthis._updateBBox(n[i], n[i + 1], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.last.x = n[l - 2];\n\t\t\t\t\tthis.last.y = n[l - 1];\n\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"H\":\n\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\tthis._updateBBox(n[i], this.last.y, matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.last.x = n[l - 1];\n\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"V\":\n\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\tthis._updateBBox(this.last.x, n[i], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.last.y = n[l - 1];\n\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"m\":\n\t\t\t\t\tvar start = 0;\n\t\t\t\t\tif(!(\"x\" in this.last)){\n\t\t\t\t\t\tthis._updateBBox(this.last.x = n[0], this.last.y = n[1], matrix);\n\t\t\t\t\t\tstart = 2;\n\t\t\t\t\t}\n\t\t\t\t\tfor(i = start; i < l; i += 2){\n\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i], this.last.y += n[i + 1], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"l\":\n\t\t\t\tcase \"t\":\n\t\t\t\t\tfor(i = 0; i < l; i += 2){\n\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i], this.last.y += n[i + 1], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"h\":\n\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i], this.last.y, matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\t\t\tthis._updateBBox(this.last.x, this.last.y += n[i], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"c\":\n\t\t\t\t\tfor(i = 0; i < l; i += 6){\n\t\t\t\t\t\tthis._updateBBox(this.last.x + n[i], this.last.y + n[i + 1], matrix);\n\t\t\t\t\t\tthis._updateBBox(this.last.x + n[i + 2], this.last.y + n[i + 3], matrix);\n\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i + 4], this.last.y += n[i + 5], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"s\":\n\t\t\t\tcase \"q\":\n\t\t\t\t\tfor(i = 0; i < l; i += 4){\n\t\t\t\t\t\tthis._updateBBox(this.last.x + n[i], this.last.y + n[i + 1], matrix);\n\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i + 2], this.last.y += n[i + 3], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"A\":\n\t\t\t\t\tfor(i = 0; i < l; i += 7){\n\t\t\t\t\t\tthis._updateBBox(n[i + 5], n[i + 6], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.last.x = n[l - 2];\n\t\t\t\t\tthis.last.y = n[l - 1];\n\t\t\t\t\tthis.absolute = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"a\":\n\t\t\t\t\tfor(i = 0; i < l; i += 7){\n\t\t\t\t\t\tthis._updateBBox(this.last.x += n[i + 5], this.last.y += n[i + 6], matrix);\n\t\t\t\t\t}\n\t\t\t\t\tthis.absolute = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// add an SVG path segment\n\t\t\tvar path = [segment.action];\n\t\t\tfor(i = 0; i < l; ++i){\n\t\t\t\tpath.push(g.formatNumber(n[i], true));\n\t\t\t}\n\t\t\tif(typeof this.shape.path == \"string\"){\n\t\t\t\tthis.shape.path += path.join(\"\");\n\t\t\t}else{\n\t\t\t\tfor(i = 0, l = path.length; i < l; ++i){\n\t\t\t\t\tthis.shape.path.push(path[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// a dictionary, which maps segment type codes to a number of their arguments\n\t\t_validSegments: {m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, z: 0},\n\n\t\t_pushSegment: function(action, args){\n\t\t\t// summary:\n\t\t\t//\t\tadds a segment\n\t\t\t// action: String\n\t\t\t//\t\tvalid SVG code for a segment's type\n\t\t\t// args: Array\n\t\t\t//\t\ta list of parameters for this segment\n\t\t\tthis.tbbox = null;\n\t\t\tvar group = this._validSegments[action.toLowerCase()], segment;\n\t\t\tif(typeof group == \"number\"){\n\t\t\t\tif(group){\n\t\t\t\t\tif(args.length >= group){\n\t\t\t\t\t\tsegment = {action: action, args: args.slice(0, args.length - args.length % group)};\n\t\t\t\t\t\tthis.segments.push(segment);\n\t\t\t\t\t\tthis._updateWithSegment(segment);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsegment = {action: action, args: []};\n\t\t\t\t\tthis.segments.push(segment);\n\t\t\t\t\tthis._updateWithSegment(segment);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_collectArgs: function(array, args){\n\t\t\t// summary:\n\t\t\t//\t\tconverts an array of arguments to plain numeric values\n\t\t\t// array: Array\n\t\t\t//\t\tan output argument (array of numbers)\n\t\t\t// args: Array\n\t\t\t//\t\tan input argument (can be values of Boolean, Number, dojox/gfx.Point, or an embedded array of them)\n\t\t\tfor(var i = 0; i < args.length; ++i){\n\t\t\t\tvar t = args[i];\n\t\t\t\tif(typeof t == \"boolean\"){\n\t\t\t\t\tarray.push(t ? 1 : 0);\n\t\t\t\t}else if(typeof t == \"number\"){\n\t\t\t\t\tarray.push(t);\n\t\t\t\t}else if(t instanceof Array){\n\t\t\t\t\tthis._collectArgs(array, t);\n\t\t\t\t}else if(\"x\" in t && \"y\" in t){\n\t\t\t\t\tarray.push(t.x, t.y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// segments\n\t\tmoveTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a move segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"M\" : \"m\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tlineTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a line segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"L\" : \"l\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\thLineTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a horizontal line segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"H\" : \"h\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tvLineTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a vertical line segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"V\" : \"v\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tcurveTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a curve segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"C\" : \"c\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tsmoothCurveTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a smooth curve segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"S\" : \"s\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tqCurveTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a quadratic curve segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"Q\" : \"q\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tqSmoothCurveTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms a quadratic smooth curve segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"T\" : \"t\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tarcTo: function(){\n\t\t\t// summary:\n\t\t\t//\t\tforms an elliptic arc segment\n\t\t\tthis._confirmSegmented();\n\t\t\tvar args = [];\n\t\t\tthis._collectArgs(args, arguments);\n\t\t\tthis._pushSegment(this.absolute ? \"A\" : \"a\", args);\n\t\t\treturn this; // self\n\t\t},\n\t\tclosePath: function(){\n\t\t\t// summary:\n\t\t\t//\t\tcloses a path\n\t\t\tthis._confirmSegmented();\n\t\t\tthis._pushSegment(\"Z\", []);\n\t\t\treturn this; // self\n\t\t},\n\n\t\t_confirmSegmented: function() {\n\t\t\tif (!this.segmented) {\n\t\t\t\tvar path = this.shape.path;\n\t\t\t\t// switch to non-updating version of path building\n\t\t\t\tthis.shape.path = [];\n\t\t\t\tthis._setPath(path);\n\t\t\t\t// switch back to the string path\n\t\t\t\tthis.shape.path = this.shape.path.join(\"\");\n\t\t\t\t// become segmented\n\t\t\t\tthis.segmented = true;\n\t\t\t}\n\t\t},\n\n\t\t// setShape\n\t\t_setPath: function(path){\n\t\t\t// summary:\n\t\t\t//\t\tforms a path using an SVG path string\n\t\t\t// path: String\n\t\t\t//\t\tan SVG path string\n\t\t\tvar p = lang.isArray(path) ? path : path.match(g.pathSvgRegExp);\n\t\t\tthis.segments = [];\n\t\t\tthis.absolute = true;\n\t\t\tthis.bbox = {};\n\t\t\tthis.last = {};\n\t\t\tif(!p) return;\n\t\t\t// create segments\n\t\t\tvar action = \"\",\t// current action\n\t\t\t\targs = [],\t\t// current arguments\n\t\t\t\tl = p.length;\n\t\t\tfor(var i = 0; i < l; ++i){\n\t\t\t\tvar t = p[i], x = parseFloat(t);\n\t\t\t\tif(isNaN(x)){\n\t\t\t\t\tif(action){\n\t\t\t\t\t\tthis._pushSegment(action, args);\n\t\t\t\t\t}\n\t\t\t\t\targs = [];\n\t\t\t\t\taction = t;\n\t\t\t\t}else{\n\t\t\t\t\targs.push(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._pushSegment(action, args);\n\t\t},\n\t\tsetShape: function(newShape){\n\t\t\t// summary:\n\t\t\t//\t\tforms a path using a shape\n\t\t\t// newShape: Object\n\t\t\t//\t\tan SVG path string or a path object (see dojox/gfx.defaultPath)\n\t\t\tthis.inherited(arguments, [typeof newShape == \"string\" ? {path: newShape} : newShape]);\n\n\t\t\tthis.segmented = false;\n\t\t\tthis.segments = [];\n\t\t\tif(!g.lazyPathSegmentation){\n\t\t\t\tthis._confirmSegmented();\n\t\t\t}\n\t\t\treturn this; // self\n\t\t},\n\n\t\t// useful constant for descendants\n\t\t_2PI: Math.PI * 2\n\t});\n\n\tvar TextPath = declare(\"dojox.gfx.path.TextPath\", Path, {\n\t\t// summary:\n\t\t//\t\ta generalized TextPath shape\n\n\t\tconstructor: function(rawNode){\n\t\t\t// summary:\n\t\t\t//\t\ta TextPath shape constructor\n\t\t\t// rawNode: Node\n\t\t\t//\t\ta DOM node to be used by this TextPath object\n\t\t\tif(!(\"text\" in this)){\n\t\t\t\tthis.text = lang.clone(g.defaultTextPath);\n\t\t\t}\n\t\t\tif(!(\"fontStyle\" in this)){\n\t\t\t\tthis.fontStyle = lang.clone(g.defaultFont);\n\t\t\t}\n\t\t},\n\t\tgetText: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the current text object or null\n\t\t\treturn this.text;\t// Object\n\t\t},\n\t\tsetText: function(newText){\n\t\t\t// summary:\n\t\t\t//\t\tsets a text to be drawn along the path\n\t\t\tthis.text = g.makeParameters(this.text,\n\t\t\t\ttypeof newText == \"string\" ? {text: newText} : newText);\n\t\t\tthis._setText();\n\t\t\treturn this;\t// self\n\t\t},\n\t\tgetFont: function(){\n\t\t\t// summary:\n\t\t\t//\t\treturns the current font object or null\n\t\t\treturn this.fontStyle;\t// Object\n\t\t},\n\t\tsetFont: function(newFont){\n\t\t\t// summary:\n\t\t\t//\t\tsets a font for text\n\t\t\tthis.fontStyle = typeof newFont == \"string\" ?\n\t\t\t\tg.splitFontString(newFont) :\n\t\t\t\tg.makeParameters(g.defaultFont, newFont);\n\t\t\tthis._setFont();\n\t\t\treturn this;\t// self\n\t\t}\n\t});\n\n\t/*=====\n\tg.Path = Path;\n\tg.TextPath = TextPath;\n\t=====*/\n\n\treturn g.path = {\n\t\t// summary:\n\t\t//\t\tThis module contains the core graphics Path API.\n\t\t//\t\tPath command format follows the W3C SVG 1.0 Path api.\n\n\t\tPath: Path,\n\t\tTextPath: TextPath\n\t};\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/path.js\n// module id = 171\n// module chunks = 4","define([\"./_base\", \"dojo/_base/lang\", \"./matrix\"], \n  function(g, lang, m){\n\tvar twoPI = 2 * Math.PI, pi4 = Math.PI / 4, pi8 = Math.PI / 8,\n\t\tpi48 = pi4 + pi8, curvePI4 = unitArcAsBezier(pi8);\n\n\tfunction unitArcAsBezier(alpha){\n\t\t// summary:\n\t\t//\t\treturn a start point, 1st and 2nd control points, and an end point of\n\t\t//\t\ta an arc, which is reflected on the x axis\n\t\t// alpha: Number\n\t\t//\t\tangle in radians, the arc will be 2 * angle size\n\t\tvar cosa  = Math.cos(alpha), sina  = Math.sin(alpha),\n\t\t\tp2 = {x: cosa + (4 / 3) * (1 - cosa), y: sina - (4 / 3) * cosa * (1 - cosa) / sina};\n\t\treturn {\t// Object\n\t\t\ts:  {x: cosa, y: -sina},\n\t\t\tc1: {x: p2.x, y: -p2.y},\n\t\t\tc2: p2,\n\t\t\te:  {x: cosa, y: sina}\n\t\t};\n\t}\n\n\tvar arc = g.arc = {\n\t\t// summary:\n\t\t//\t\tThis module contains the core graphics Arc functions.\n\t\t\n\t\tunitArcAsBezier: unitArcAsBezier,\n\t\t/*===== \n\t\tunitArcAsBezier: function(alpha) {\n\t\t\t// summary:\n\t\t\t//\t\treturn a start point, 1st and 2nd control points, and an end point of\n\t\t\t//\t\ta an arc, which is reflected on the x axis\n\t\t\t// alpha: Number\n\t\t\t//\t\tangle in radians, the arc will be 2 * angle size\n\t\t},\n\t\t=====*/\n\n\t\t// curvePI4: Object\n\t\t//\t\tan object with properties of an arc around a unit circle from 0 to pi/4\n\t\tcurvePI4: curvePI4,\n\n\t\tarcAsBezier: function(last, rx, ry, xRotg, large, sweep, x, y){\n\t\t\t// summary:\n\t\t\t//\t\tcalculates an arc as a series of Bezier curves\n\t\t\t//\t\tgiven the last point and a standard set of SVG arc parameters,\n\t\t\t//\t\tit returns an array of arrays of parameters to form a series of\n\t\t\t//\t\tabsolute Bezier curves.\n\t\t\t// last: Object\n\t\t\t//\t\ta point-like object as a start of the arc\n\t\t\t// rx: Number\n\t\t\t//\t\ta horizontal radius for the virtual ellipse\n\t\t\t// ry: Number\n\t\t\t//\t\ta vertical radius for the virtual ellipse\n\t\t\t// xRotg: Number\n\t\t\t//\t\ta rotation of an x axis of the virtual ellipse in degrees\n\t\t\t// large: Boolean\n\t\t\t//\t\twhich part of the ellipse will be used (the larger arc if true)\n\t\t\t// sweep: Boolean\n\t\t\t//\t\tdirection of the arc (CW if true)\n\t\t\t// x: Number\n\t\t\t//\t\tthe x coordinate of the end point of the arc\n\t\t\t// y: Number\n\t\t\t//\t\tthe y coordinate of the end point of the arc\n\n\t\t\t// calculate parameters\n\t\t\tlarge = Boolean(large);\n\t\t\tsweep = Boolean(sweep);\n\t\t\tvar xRot = m._degToRad(xRotg),\n\t\t\t\trx2 = rx * rx, ry2 = ry * ry,\n\t\t\t\tpa = m.multiplyPoint(\n\t\t\t\t\tm.rotate(-xRot),\n\t\t\t\t\t{x: (last.x - x) / 2, y: (last.y - y) / 2}\n\t\t\t\t),\n\t\t\t\tpax2 = pa.x * pa.x, pay2 = pa.y * pa.y,\n\t\t\t\tc1 = Math.sqrt((rx2 * ry2 - rx2 * pay2 - ry2 * pax2) / (rx2 * pay2 + ry2 * pax2));\n\t\t\tif(isNaN(c1)){ c1 = 0; }\n\t\t\tvar\tca = {\n\t\t\t\t\tx:  c1 * rx * pa.y / ry,\n\t\t\t\t\ty: -c1 * ry * pa.x / rx\n\t\t\t\t};\n\t\t\tif(large == sweep){\n\t\t\t\tca = {x: -ca.x, y: -ca.y};\n\t\t\t}\n\t\t\t// the center\n\t\t\tvar c = m.multiplyPoint(\n\t\t\t\t[\n\t\t\t\t\tm.translate(\n\t\t\t\t\t\t(last.x + x) / 2,\n\t\t\t\t\t\t(last.y + y) / 2\n\t\t\t\t\t),\n\t\t\t\t\tm.rotate(xRot)\n\t\t\t\t],\n\t\t\t\tca\n\t\t\t);\n\t\t\t// calculate the elliptic transformation\n\t\t\tvar elliptic_transform = m.normalize([\n\t\t\t\tm.translate(c.x, c.y),\n\t\t\t\tm.rotate(xRot),\n\t\t\t\tm.scale(rx, ry)\n\t\t\t]);\n\t\t\t// start, end, and size of our arc\n\t\t\tvar inversed = m.invert(elliptic_transform),\n\t\t\t\tsp = m.multiplyPoint(inversed, last),\n\t\t\t\tep = m.multiplyPoint(inversed, x, y),\n\t\t\t\tstartAngle = Math.atan2(sp.y, sp.x),\n\t\t\t\tendAngle   = Math.atan2(ep.y, ep.x),\n\t\t\t\ttheta = startAngle - endAngle;\t// size of our arc in radians\n\t\t\tif(sweep){ theta = -theta; }\n\t\t\tif(theta < 0){\n\t\t\t\ttheta += twoPI;\n\t\t\t}else if(theta > twoPI){\n\t\t\t\ttheta -= twoPI;\n\t\t\t}\n\n\t\t\t// draw curve chunks\n\t\t\tvar alpha = pi8, curve = curvePI4, step  = sweep ? alpha : -alpha,\n\t\t\t\tresult = [];\n\t\t\tfor(var angle = theta; angle > 0; angle -= pi4){\n\t\t\t\tif(angle < pi48){\n\t\t\t\t\talpha = angle / 2;\n\t\t\t\t\tcurve = unitArcAsBezier(alpha);\n\t\t\t\t\tstep  = sweep ? alpha : -alpha;\n\t\t\t\t\tangle = 0;\t// stop the loop\n\t\t\t\t}\n\t\t\t\tvar c2, e, M = m.normalize([elliptic_transform, m.rotate(startAngle + step)]);\n\t\t\t\tif(sweep){\n\t\t\t\t\tc1 = m.multiplyPoint(M, curve.c1);\n\t\t\t\t\tc2 = m.multiplyPoint(M, curve.c2);\n\t\t\t\t\te  = m.multiplyPoint(M, curve.e );\n\t\t\t\t}else{\n\t\t\t\t\tc1 = m.multiplyPoint(M, curve.c2);\n\t\t\t\t\tc2 = m.multiplyPoint(M, curve.c1);\n\t\t\t\t\te  = m.multiplyPoint(M, curve.s );\n\t\t\t\t}\n\t\t\t\t// draw the curve\n\t\t\t\tresult.push([c1.x, c1.y, c2.x, c2.y, e.x, e.y]);\n\t\t\t\tstartAngle += 2 * step;\n\t\t\t}\n\t\t\treturn result;\t// Array\n\t\t}\n\t};\n\t\n\treturn arc;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/arc.js\n// module id = 172\n// module chunks = 4","define([\"./_base\", \"dojo/_base/lang\", \"./matrix\"], \n  function (g, lang, m){\n\tfunction eq(/* Number */ a, /* Number */ b){\n\t\t// summary:\n\t\t//\t\tcompare two FP numbers for equality\n\t\treturn Math.abs(a - b) <= 1e-6 * (Math.abs(a) + Math.abs(b));\t// Boolean\n\t}\n\n\tfunction calcFromValues(/* Number */ r1, /* Number */ m1, /* Number */ r2, /* Number */ m2){\n\t\t// summary:\n\t\t//\t\tuses two close FP ration and their original magnitudes to approximate the result\n\t\tif(!isFinite(r1)){\n\t\t\treturn r2;\t// Number\n\t\t}else if(!isFinite(r2)){\n\t\t\treturn r1;\t// Number\n\t\t}\n\t\tm1 = Math.abs(m1); m2 = Math.abs(m2);\n\t\treturn (m1 * r1 + m2 * r2) / (m1 + m2);\t// Number\n\t}\n\n\tfunction transpose(matrix){\n\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t//\t\ta 2D matrix-like object\n\t\tvar M = new m.Matrix2D(matrix);\n\t\treturn lang.mixin(M, {dx: 0, dy: 0, xy: M.yx, yx: M.xy});\t// dojox/gfx/matrix.Matrix2D\n\t}\n\n\tfunction scaleSign(/* dojox/gfx/matrix.Matrix2D */ matrix){\n\t\treturn (matrix.xx * matrix.yy < 0 || matrix.xy * matrix.yx > 0) ? -1 : 1;\t// Number\n\t}\n\n\tfunction eigenvalueDecomposition(matrix){\n\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t//\t\ta 2D matrix-like object\n\t\tvar M = m.normalize(matrix),\n\t\t\tb = -M.xx - M.yy,\n\t\t\tc = M.xx * M.yy - M.xy * M.yx,\n\t\t\td = Math.sqrt(b * b - 4 * c),\n\t\t\tl1 = -(b + (b < 0 ? -d : d)) / 2,\n\t\t\tl2 = c / l1,\n\t\t\tvx1 = M.xy / (l1 - M.xx), vy1 = 1,\n\t\t\tvx2 = M.xy / (l2 - M.xx), vy2 = 1;\n\t\tif(eq(l1, l2)){\n\t\t\tvx1 = 1, vy1 = 0, vx2 = 0, vy2 = 1;\n\t\t}\n\t\tif(!isFinite(vx1)){\n\t\t\tvx1 = 1, vy1 = (l1 - M.xx) / M.xy;\n\t\t\tif(!isFinite(vy1)){\n\t\t\t\tvx1 = (l1 - M.yy) / M.yx, vy1 = 1;\n\t\t\t\tif(!isFinite(vx1)){\n\t\t\t\t\tvx1 = 1, vy1 = M.yx / (l1 - M.yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isFinite(vx2)){\n\t\t\tvx2 = 1, vy2 = (l2 - M.xx) / M.xy;\n\t\t\tif(!isFinite(vy2)){\n\t\t\t\tvx2 = (l2 - M.yy) / M.yx, vy2 = 1;\n\t\t\t\tif(!isFinite(vx2)){\n\t\t\t\t\tvx2 = 1, vy2 = M.yx / (l2 - M.yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar d1 = Math.sqrt(vx1 * vx1 + vy1 * vy1),\n\t\t\td2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);\n\t\tif(!isFinite(vx1 /= d1)){ vx1 = 0; }\n\t\tif(!isFinite(vy1 /= d1)){ vy1 = 0; }\n\t\tif(!isFinite(vx2 /= d2)){ vx2 = 0; }\n\t\tif(!isFinite(vy2 /= d2)){ vy2 = 0; }\n\t\treturn {\t// Object\n\t\t\tvalue1: l1,\n\t\t\tvalue2: l2,\n\t\t\tvector1: {x: vx1, y: vy1},\n\t\t\tvector2: {x: vx2, y: vy2}\n\t\t};\n\t}\n\n\tfunction decomposeSR(/* dojox/gfx/matrix.Matrix2D */ M, /* Object */ result){\n\t\t// summary:\n\t\t//\t\tdecomposes a matrix into [scale, rotate]; no checks are done.\n\t\tvar sign = scaleSign(M),\n\t\t\ta = result.angle1 = (Math.atan2(M.yx, M.yy) + Math.atan2(-sign * M.xy, sign * M.xx)) / 2,\n\t\t\tcos = Math.cos(a), sin = Math.sin(a);\n\t\tresult.sx = calcFromValues(M.xx / cos, cos, -M.xy / sin, sin);\n\t\tresult.sy = calcFromValues(M.yy / cos, cos,  M.yx / sin, sin);\n\t\treturn result;\t// Object\n\t}\n\n\tfunction decomposeRS(/* dojox/gfx/matrix.Matrix2D */ M, /* Object */ result){\n\t\t// summary:\n\t\t//\t\tdecomposes a matrix into [rotate, scale]; no checks are done\n\t\tvar sign = scaleSign(M),\n\t\t\ta = result.angle2 = (Math.atan2(sign * M.yx, sign * M.xx) + Math.atan2(-M.xy, M.yy)) / 2,\n\t\t\tcos = Math.cos(a), sin = Math.sin(a);\n\t\tresult.sx = calcFromValues(M.xx / cos, cos,  M.yx / sin, sin);\n\t\tresult.sy = calcFromValues(M.yy / cos, cos, -M.xy / sin, sin);\n\t\treturn result;\t// Object\n\t}\n\n\treturn g.decompose = function(matrix){\n\t\t// summary:\n\t\t//\t\tDecompose a 2D matrix into translation, scaling, and rotation components.\n\t\t// description:\n\t\t//\t\tThis function decompose a matrix into four logical components:\n\t\t//\t\ttranslation, rotation, scaling, and one more rotation using SVD.\n\t\t//\t\tThe components should be applied in following order:\n\t\t//\t| [translate, rotate(angle2), scale, rotate(angle1)]\n\t\t// matrix: dojox/gfx/matrix.Matrix2D\n\t\t//\t\ta 2D matrix-like object\n\t\tvar M = m.normalize(matrix),\n\t\t\tresult = {dx: M.dx, dy: M.dy, sx: 1, sy: 1, angle1: 0, angle2: 0};\n\t\t// detect case: [scale]\n\t\tif(eq(M.xy, 0) && eq(M.yx, 0)){\n\t\t\treturn lang.mixin(result, {sx: M.xx, sy: M.yy});\t// Object\n\t\t}\n\t\t// detect case: [scale, rotate]\n\t\tif(eq(M.xx * M.yx, -M.xy * M.yy)){\n\t\t\treturn decomposeSR(M, result);\t// Object\n\t\t}\n\t\t// detect case: [rotate, scale]\n\t\tif(eq(M.xx * M.xy, -M.yx * M.yy)){\n\t\t\treturn decomposeRS(M, result);\t// Object\n\t\t}\n\t\t// do SVD\n\t\tvar\tMT = transpose(M),\n\t\t\tu  = eigenvalueDecomposition([M, MT]),\n\t\t\tv  = eigenvalueDecomposition([MT, M]),\n\t\t\tU  = new m.Matrix2D({xx: u.vector1.x, xy: u.vector2.x, yx: u.vector1.y, yy: u.vector2.y}),\n\t\t\tVT = new m.Matrix2D({xx: v.vector1.x, xy: v.vector1.y, yx: v.vector2.x, yy: v.vector2.y}),\n\t\t\tS = new m.Matrix2D([m.invert(U), M, m.invert(VT)]);\n\t\tdecomposeSR(VT, result);\n\t\tS.xx *= result.sx;\n\t\tS.yy *= result.sy;\n\t\tdecomposeRS(U, result);\n\t\tS.xx *= result.sx;\n\t\tS.yy *= result.sy;\n\t\treturn lang.mixin(result, {sx: S.xx, sy: S.yy});\t// Object\n\t};\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/decompose.js\n// module id = 173\n// module chunks = 4","define([\n\t\"./_base\"\n], function(gfx){\n\n\tvar bu = gfx.bezierutils = {},\n\t\terror = 0.1;\n\n\tvar tAtLength = bu.tAtLength = function(points, length){\n\t\t// summary:\n\t\t//\t\tReturns the t corresponding to the given length for the specified bezier curve.\n\t\t// points: Number[]\n\t\t//\t\tThe bezier points. Should be [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y] for a cubic\n\t\t//\t\tbezier curve or [p1x, p1y, cx, cy, p2x, p2y] for a quadratic bezier curve.\n\t\t// length: Number\n\t\t//\t\tThe length.\n\t\tvar t = 0,\n\t\t\tquadratic = points.length == 6,\n\t\t\tcurrentLen = 0,\n\t\t\tsplitCount = 0,\n\t\t\tsplitFunc = quadratic ? splitQBezierAtT : splitBezierAtT;\n\t\tvar _compute = function(p, error){\n\t\t\t// control points polygon length\n\t\t\tvar pLen = 0;\n\t\t\tfor(var i = 0; i < p.length-2; i+=2)\n\t\t\t\tpLen += distance(p[i],p[i+1],p[i+2],p[i+3]);\n\t\t\t// chord length\n\t\t\tvar chord = quadratic ?\n\t\t\t\tdistance(points[0],points[1],points[4],points[5]) :\n\t\t\t\tdistance(points[0],points[1],points[6],points[7]);\n\t\t\t// if needs more approx. or if currentLen is greater than the target length,\n\t\t\t// split the curve one more time\n\t\t\tif(pLen - chord > error || currentLen + pLen > length + error){\n\t\t\t\t++splitCount;\n\t\t\t\tvar newbezier = splitFunc(p, .5);\n\t\t\t\t// check 1st subpath\n\t\t\t\t_compute(newbezier[0], error);\n\t\t\t\t// the 1st subcurve was the good one, we stop\n\t\t\t\tif(Math.abs(currentLen - length) <= error){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// need to continue with the 2nde subcurve\n\t\t\t\t_compute(newbezier[1], error);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tcurrentLen += pLen;\n\t\t\tt += 1.0 / (1 << splitCount);\n\t\t};\n\t\tif(length)\n\t\t\t_compute(points, 0.5);\n\t\treturn t;\n\t};\n\n\tvar computeLength = bu.computeLength = function(/*Array*/points){\n\t\t// summary:\n\t\t//\t\tReturns the length of the given bezier curve.\n\t\t// points: Number[]\n\t\t//\t\tThe bezier points. Should be [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y] for a cubic\n\t\t//\t\tbezier curve or [p1x, p1y, cx, cy, p2x, p2y] for a quadratic bezier curve.\n\n\t\tvar quadratic = points.length == 6, pLen=0;\n\t\t// control points polygon length\n\t\tfor(var i = 0; i < points.length-2; i+=2)\n\t\t\tpLen += distance(points[i],points[i+1],points[i+2],points[i+3]);\n\t\t// chord length\n\t\tvar chord = quadratic ?\n\t\t\tdistance(points[0],points[1],points[4],points[5]) :\n\t\t\tdistance(points[0],points[1],points[6],points[7]);\n\t\t// split polygons until the polygon and the chord are \"the same\"\n\t\tif(pLen-chord>error){\n\t\t\tvar newBeziers = quadratic ? splitQBezierAtT(points,.5) : splitCBezierAtT(points,.5);\n\t\t\tvar length = computeLength(newBeziers[0], quadratic);\n\t\t\tlength += computeLength(newBeziers[1], quadratic);\n\t\t\treturn length;\n\t\t}\n\t\t// pLen is close enough, done.\n\t\treturn pLen;\n\t};\n\n\tvar distance = bu.distance = function(x1, y1, x2, y2){\n\t\t// summary:\n\t\t//\t\tReturns the distance between the specified points.\n\t\treturn Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\t};\n\n\tvar splitQBezierAtT = function(points, t){\n\t\t// summary:\n\t\t//\t\tSplit a quadratic bezier curve into 2 sub-quadratic beziers at the specified t.\n\n\t\t// de Casteljau\n\t\tvar r = 1-t,\n\t\t\tr2 = r*r,\n\t\t\tt2 = t*t,\n\t\t\tp1x = points[0],\n\t\t\tp1y = points[1],\n\t\t\tcx = points[2],\n\t\t\tcy = points[3],\n\t\t\tp2x = points[4],\n\t\t\tp2y = points[5],\n\n\t\t\tax = r*p1x + t*cx,\n\t\t\tay = r*p1y + t*cy,\n\t\t\tbx = r*cx + t*p2x,\n\t\t\tby = r*cy + t*p2y,\n\t\t\tpx = r2*p1x + 2*r*t*cx + t2*p2x,\n\t\t\tpy = r2*p1y + 2*r*t*cy + t2*p2y;\n\n\t\treturn [\n\t\t\t[\n\t\t\t\tp1x, p1y,\n\t\t\t\tax, ay,\n\t\t\t\tpx, py\n\t\t\t],\n\t\t\t[\n\t\t\t\tpx, py,\n\t\t\t\tbx, by,\n\t\t\t\tp2x, p2y\n\t\t\t]\n\t\t];\n\t};\n\n\tvar splitCBezierAtT = function(points, t){\n\t\t// summary:\n\t\t//\t\tSplit a cubic bezier curve into 2 sub-cubic beziers at the specified t.\n\n\t\t// de Casteljau\n\t\tvar r = 1-t,\n\t\t\tr2 = r*r,\n\t\t\tr3 = r2*r,\n\t\t\tt2 = t*t,\n\t\t\tt3 = t2*t,\n\t\t\tp1x = points[0],\n\t\t\tp1y = points[1],\n\t\t\tc1x = points[2],\n\t\t\tc1y = points[3],\n\t\t\tc2x = points[4],\n\t\t\tc2y = points[5],\n\t\t\tp2x = points[6],\n\t\t\tp2y = points[7],\n\n\t\t\tax = r*p1x + t*c1x,\n\t\t\tay = r*p1y + t*c1y,\n\t\t\tcx = r*c2x + t*p2x,\n\t\t\tcy = r*c2y + t*p2y,\n\t\t\tmx = r2*p1x + 2*r*t*c1x + t2*c2x,\n\t\t\tmy = r2*p1y + 2*r*t*c1y + t2*c2y,\n\t\t\tnx = r2*c1x + 2*r*t*c2x + t2*p2x,\n\t\t\tny = r2*c1y + 2*r*t*c2y + t2*p2y,\n\t\t\tpx = r3*p1x + 3*r2*t*c1x + 3*r*t2*c2x+t3*p2x,\n\t\t\tpy = r3*p1y + 3*r2*t*c1y + 3*r*t2*c2y+t3*p2y;\n\n\t\treturn [\n\t\t\t[\n\t\t\t\tp1x, p1y,\n\t\t\t\tax, ay,\n\t\t\t\tmx, my,\n\t\t\t\tpx, py\n\t\t\t],\n\t\t\t[\n\t\t\t\tpx, py,\n\t\t\t\tnx, ny,\n\t\t\t\tcx, cy,\n\t\t\t\tp2x, p2y\n\t\t\t]\n\t\t];\n\t};\n\n\tvar splitBezierAtT = bu.splitBezierAtT = function(points, t){\n\t\treturn points.length == 6 ? splitQBezierAtT(points, t) : splitCBezierAtT(points, t);\n\t};\n\treturn bu;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/bezierutils.js\n// module id = 174\n// module chunks = 4","define([\"./functional/lambda\", \"./functional/array\", \"./functional/object\"], function(df){\n\treturn df;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/functional.js\n// module id = 175\n// module chunks = 4","define([\"../..\", \"dojo/_base/lang\", \"dojo/_base/array\"], function(dojox, lang, arr){\n\tvar df = lang.getObject(\"lang.functional\", true, dojox);\n\n// This module adds high-level functions and related constructs:\n//\t- anonymous functions built from the string\n\n// Acknowledgements:\n//\t- lambda() is based on work by Oliver Steele\n//\t\t(http://osteele.com/sources/javascript/functional/functional.js)\n//\t\twhich was published under MIT License\n\n// Notes:\n//\t- lambda() produces functions, which after the compilation step are\n//\t\tas fast as regular JS functions (at least theoretically).\n\n// Lambda input values:\n//\t- returns functions unchanged\n//\t- converts strings to functions\n//\t- converts arrays to a functional composition\n\n\tvar lcache = {};\n\n\t// split() is augmented on IE6 to ensure the uniform behavior\n\tvar split = \"ab\".split(/a*/).length > 1 ? String.prototype.split :\n\t\t\tfunction(sep){\n\t\t\t\t var r = this.split.call(this, sep),\n\t\t\t\t\t m = sep.exec(this);\n\t\t\t\t if(m && m.index == 0){ r.unshift(\"\"); }\n\t\t\t\t return r;\n\t\t\t};\n\t\t\t\n\tvar lambda = function(/*String*/ s){\n\t\tvar args = [], sects = split.call(s, /\\s*->\\s*/m);\n\t\tif(sects.length > 1){\n\t\t\twhile(sects.length){\n\t\t\t\ts = sects.pop();\n\t\t\t\targs = sects.pop().split(/\\s*,\\s*|\\s+/m);\n\t\t\t\tif(sects.length){ sects.push(\"(function(\" + args.join(\", \") + \"){ return (\" + s + \"); })\"); }\n\t\t\t}\n\t\t}else if(s.match(/\\b_\\b/)){\n\t\t\targs = [\"_\"];\n\t\t}else{\n\t\t\tvar l = s.match(/^\\s*(?:[+*\\/%&|\\^\\.=<>]|!=)/m),\n\t\t\t\tr = s.match(/[+\\-*\\/%&|\\^\\.=<>!]\\s*$/m);\n\t\t\tif(l || r){\n\t\t\t\tif(l){\n\t\t\t\t\targs.push(\"$1\");\n\t\t\t\t\ts = \"$1\" + s;\n\t\t\t\t}\n\t\t\t\tif(r){\n\t\t\t\t\targs.push(\"$2\");\n\t\t\t\t\ts = s + \"$2\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// the point of the long regex below is to exclude all well-known\n\t\t\t\t// lower-case words from the list of potential arguments\n\t\t\t\tvar vars = s.\n\t\t\t\t\treplace(/(?:\\b[A-Z]|\\.[a-zA-Z_$])[a-zA-Z_$\\d]*|[a-zA-Z_$][a-zA-Z_$\\d]*:|this|true|false|null|undefined|typeof|instanceof|in|delete|new|void|arguments|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape|dojo|dijit|dojox|window|document|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"/g, \"\").\n\t\t\t\t\tmatch(/([a-z_$][a-z_$\\d]*)/gi) || [], t = {};\n\t\t\t\tarr.forEach(vars, function(v){\n\t\t\t\t\tif(!t.hasOwnProperty(v)){\n\t\t\t\t\t\targs.push(v);\n\t\t\t\t\t\tt[v] = 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn {args: args, body: s};\t// Object\n\t};\n\n\tvar compose = function(/*Array*/ a){\n\t\treturn a.length ?\n\t\t\t\t\tfunction(){\n\t\t\t\t\t\tvar i = a.length - 1, x = df.lambda(a[i]).apply(this, arguments);\n\t\t\t\t\t\tfor(--i; i >= 0; --i){ x = df.lambda(a[i]).call(this, x); }\n\t\t\t\t\t\treturn x;\n\t\t\t\t\t}\n\t\t\t\t:\n\t\t\t\t\t// identity\n\t\t\t\t\tfunction(x){ return x; };\n\t};\n\n\tlang.mixin(df, {\n\t\t// lambda\n\t\trawLambda: function(/*String*/ s){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\n\t\t\t//\t\treturns an object describing the function; functions are\n\t\t\t//\t\tpassed through unmodified.\n\t\t\t// description:\n\t\t\t//\t\tThis method is to normalize a functional representation (a\n\t\t\t//\t\ttext snippet) to an object that contains an array of\n\t\t\t//\t\targuments, and a body , which is used to calculate the\n\t\t\t//\t\treturning value.\n\t\t\treturn lambda(s);\t// Object\n\t\t},\n\t\tbuildLambda: function(/*String*/ s){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds a function from a snippet, returns a string, which\n\t\t\t//\t\trepresents the function.\n\t\t\t// description:\n\t\t\t//\t\tThis method returns a textual representation of a function\n\t\t\t//\t\tbuilt from the snippet. It is meant to be evaled in the\n\t\t\t//\t\tproper context, so local variables can be pulled from the\n\t\t\t//\t\tenvironment.\n\t\t\tvar l = lambda(s);\n\t\t\treturn \"function(\" + l.args.join(\",\") + \"){return (\" + l.body + \");}\";\t// String\n\t\t},\n\t\tlambda: function(/*Function|String|Array*/ s){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\n\t\t\t//\t\treturns a function object; functions are passed through\n\t\t\t//\t\tunmodified.\n\t\t\t// description:\n\t\t\t//\t\tThis method is used to normalize a functional\n\t\t\t//\t\trepresentation (a text snippet, an array, or a function) to\n\t\t\t//\t\ta function object.\n\t\t\tif(typeof s == \"function\"){ return s; }\n\t\t\tif(s instanceof Array){ return compose(s); }\n\t\t\tif(lcache.hasOwnProperty(s)){ return lcache[s]; }\n\t\t\tvar l = lambda(s);\n\t\t\treturn lcache[s] = new Function(l.args, \"return (\" + l.body + \");\");\t// Function\n\t\t},\n\t\tclearLambdaCache: function(){\n\t\t\t// summary:\n\t\t\t//\t\tclears internal cache of lambdas\n\t\t\tlcache = {};\n\t\t}\n\t});\n\t\n\treturn df;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/functional/lambda.js\n// module id = 176\n// module chunks = 4","define([\"dojo/_base/kernel\"], function(dojo) {\n\t// module:\n\t//\t\tdojox/main\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tThe dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.\n\t\t//\t\tApps should require modules from the dojox packages directly, rather than loading this module.\n\t};\n\t=====*/\n\n\treturn dojo.dojox;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/main.js\n// module id = 177\n// module chunks = 4","define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"dojo/_base/array\", \"./lambda\"],\n\tfunction(kernel, lang, arr, df){\n\n// This module adds high-level functions and related constructs:\n//\t- array-processing functions similar to standard JS functions\n\n// Notes:\n//\t- this module provides JS standard methods similar to high-level functions in dojo/_base/array.js:\n//\t\tforEach, map, filter, every, some\n\n// Defined methods:\n//\t- take any valid lambda argument as the functional argument\n//\t- operate on dense arrays\n//\t- take a string as the array argument\n//\t- take an iterator objects as the array argument\n\n\tvar empty = {};\n\n\tlang.mixin(df, {\n\t\t// JS 1.6 standard array functions, which can take a lambda as a parameter.\n\t\t// Consider using dojo._base.array functions, if you don't need the lambda support.\n\t\tfilter: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a new array with all elements that pass the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t = [], v, i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tfor(i = 0, n = a.length; i < n; ++i){\n\t\t\t\t\tv = a[i];\n\t\t\t\t\tif(f.call(o, v, i, a)){ t.push(v); }\n\t\t\t\t}\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tfor(i = 0; a.hasNext();){\n\t\t\t\t\tv = a.next();\n\t\t\t\t\tif(f.call(o, v, i++, a)){ t.push(v); }\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tv = a[i];\n\t\t\t\t\t\tif(f.call(o, v, i, a)){ t.push(v); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\t// Array\n\t\t},\n\t\tforEach: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\texecutes a provided function once per array element.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tfor(i = 0, n = a.length; i < n; f.call(o, a[i], i, a), ++i);\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tfor(i = 0; a.hasNext(); f.call(o, a.next(), i++, a));\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tf.call(o, a[i], i, a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn o;\t// Object\n\t\t},\n\t\tmap: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a new array with the results of calling\n\t\t\t//\t\ta provided function on every element in this array.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t, n, i;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tt = new Array(n = a.length);\n\t\t\t\tfor(i = 0; i < n; t[i] = f.call(o, a[i], i, a), ++i);\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tt = [];\n\t\t\t\tfor(i = 0; a.hasNext(); t.push(f.call(o, a.next(), i++, a)));\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tt = [];\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tt.push(f.call(o, a[i], i, a));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\t// Array\n\t\t},\n\t\tevery: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\ttests whether all elements in the array pass the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tfor(i = 0, n = a.length; i < n; ++i){\n\t\t\t\t\tif(!f.call(o, a[i], i, a)){\n\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tfor(i = 0; a.hasNext();){\n\t\t\t\t\tif(!f.call(o, a.next(), i++, a)){\n\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tif(!f.call(o, a[i], i, a)){\n\t\t\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\t// Boolean\n\t\t},\n\t\tsome: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\ttests whether some element in the array passes the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tfor(i = 0, n = a.length; i < n; ++i){\n\t\t\t\t\tif(f.call(o, a[i], i, a)){\n\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tfor(i = 0; a.hasNext();){\n\t\t\t\t\tif(f.call(o, a.next(), i++, a)){\n\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tif(f.call(o, a[i], i, a)){\n\t\t\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\t// Boolean\n\t\t}\n\t});\n\t\n\treturn df;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/functional/array.js\n// module id = 178\n// module chunks = 4","define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"./lambda\"], function(kernel, lang, df){\n\n// This module adds high-level functions and related constructs:\n//\t- object/dictionary helpers\n\n// Defined methods:\n//\t- take any valid lambda argument as the functional argument\n//\t- skip all attributes that are present in the empty object\n//\t\t(IE and/or 3rd-party libraries).\n\n\tvar empty = {};\n\n\tlang.mixin(df, {\n\t\t// object helpers\n\t\tkeys: function(/*Object*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\treturns an array of all keys in the object\n\t\t\tvar t = [];\n\t\t\tfor(var i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tt.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\tt; // Array\n\t\t},\n\t\tvalues: function(/*Object*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\treturns an array of all values in the object\n\t\t\tvar t = [];\n\t\t\tfor(var i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tt.push(obj[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\tt; // Array\n\t\t},\n\t\tfilterIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates new object with all attributes that pass the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t = {}, v, i;\n\t\t\tfor(i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tv = obj[i];\n\t\t\t\t\tif(f.call(o, v, i, obj)){ t[i] = v; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\t// Object\n\t\t},\n\t\tforIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\titerates over all object attributes.\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tf.call(o, obj[i], i, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn o;\t// Object\n\t\t},\n\t\tmapIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates new object with the results of calling\n\t\t\t//\t\ta provided function on every attribute in this object.\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t = {}, i;\n\t\t\tfor(i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tt[i] = f.call(o, obj[i], i, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\t// Object\n\t\t}\n\t});\n\t\n\treturn df;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/functional/object.js\n// module id = 179\n// module chunks = 4","define([\"dojo/_base/lang\"], function(lang){\n\n\tvar eq = function(/*Number*/ a, /*Number*/ b){\n\t\t// summary:\n\t\t//\t\tcompare two FP numbers for equality\n\t\treturn Math.abs(a - b) <= 1e-6 * (Math.abs(a) + Math.abs(b));\t// Boolean\n\t};\n\n\tvar common = lang.getObject(\"dojox.charting.scaler.common\", true);\n\n\tvar testedModules = {};\n\n\treturn lang.mixin(common, {\n\t\tdoIfLoaded: function(moduleName, ifloaded, ifnotloaded){\n\t\t\tif(testedModules[moduleName] === undefined){\n\t\t\t\ttry{\n\t\t\t\t\ttestedModules[moduleName] = require(moduleName);\n\t\t\t\t}catch(e){\n\t\t\t\t\ttestedModules[moduleName] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(testedModules[moduleName]){\n\t\t\t\treturn ifloaded(testedModules[moduleName]);\n\t\t\t}else{\n\t\t\t\treturn ifnotloaded();\n\t\t\t}\n\t\t},\n\t\tgetNumericLabel: function(/*Number*/ number, /*Number*/ precision, /*Object*/ kwArgs){\n\t\t\tvar def = \"\";\n\t\t\tcommon.doIfLoaded(\"dojo/number\", function(numberLib){\n\t\t\t\tdef = (kwArgs.fixed ? numberLib.format(number, {places : precision < 0 ? -precision : 0}) :\n\t\t\t\t\tnumberLib.format(number)) || \"\";\n\t\t\t}, function(){\n\t\t\t\tdef = kwArgs.fixed ? number.toFixed(precision < 0 ? -precision : 0) : number.toString();\n\t\t\t});\n\t\t\tif(kwArgs.labelFunc){\n\t\t\t\tvar r = kwArgs.labelFunc(def, number, precision);\n\t\t\t\tif(r){ return r; }\n\t\t\t\t// else fall through to the regular labels search\n\t\t\t}\n\t\t\tif(kwArgs.labels){\n\t\t\t\t// classic binary search\n\t\t\t\t// TODO: working only if the array is sorted per value should be better documented or sorted automatically\n\t\t\t\tvar l = kwArgs.labels, lo = 0, hi = l.length;\n\t\t\t\twhile(lo < hi){\n\t\t\t\t\tvar mid = Math.floor((lo + hi) / 2), val = l[mid].value;\n\t\t\t\t\tif(val < number){\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\thi = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// lets take into account FP errors\n\t\t\t\tif(lo < l.length && eq(l[lo].value, number)){\n\t\t\t\t\treturn l[lo].text;\n\t\t\t\t}\n\t\t\t\t--lo;\n\t\t\t\tif(lo >= 0 && lo < l.length && eq(l[lo].value, number)){\n\t\t\t\t\treturn l[lo].text;\n\t\t\t\t}\n\t\t\t\tlo += 2;\n\t\t\t\tif(lo < l.length && eq(l[lo].value, number)){\n\t\t\t\t\treturn l[lo].text;\n\t\t\t\t}\n\t\t\t\t// otherwise we will produce a number\n\t\t\t}\n\t\t\treturn def;\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/scaler/common.js\n// module id = 180\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/connect\", \"dojo/has\",\n\t\t\"./Base\", \"../scaler/primitive\", \"dojox/gfx\", \"dojox/gfx/fx\", \"dojox/lang/utils\"], \n\tfunction(lang, declare, hub, has, Base, primitive, gfx, fx, du){\n\t/*=====\n\tdeclare(\"dojox.charting.plot2d.__CartesianCtorArgs\", dojox.charting.plot2d.__PlotCtorArgs, {\n\t\t// hAxis: String?\n\t\t//\t\tThe horizontal axis name.\n\t\thAxis: \"x\",\n\n\t\t// vAxis: String?\n\t\t//\t\tThe vertical axis name\n\t\tvAxis: \"y\",\n\n\t\t// labels: Boolean?\n\t\t//\t\tFor plots that support labels, whether or not to draw labels for each data item.  Default is false.\n\t\tlabels:\t\t\tfalse,\n\n\t\t// fixed: Boolean?\n        //\t\tWhether a fixed precision must be applied to data values for display. Default is true.\n\t\tfixed:\t\t\ttrue,\n\n\t\t// precision: Number?\n        //\t\tThe precision at which to round data values for display. Default is 0.\n\t\tprecision:\t\t1,\n\n\t\t// labelOffset: Number?\n\t\t//\t\tThe amount in pixels by which to offset labels when using \"outside\" labelStyle.  Default is 10.\n\t\tlabelOffset:\t10,\n\n\t\t// labelStyle: String?\n\t\t//\t\tOptions as to where to draw labels.  This must be either \"inside\" or \"outside\". By default\n\t\t//      the labels are drawn \"inside\" the shape representing the data point (a column rectangle for a Columns plot\n\t\t//      or a marker for a Line plot for instance). When \"outside\" is used the labels are drawn above the data point shape.\n\t\tlabelStyle:\t\t\"inside\",\n\n\t\t// htmlLabels: Boolean?\n\t\t//\t\tWhether or not to use HTML to render slice labels. Default is true.\n\t\thtmlLabels:\t\ttrue,\n\n\t\t// omitLabels: Boolean?\n\t\t//\t\tWhether labels that do not fit in an item render are omitted or not.\tThis applies only when labelStyle\n\t\t//\t\tis \"inside\".\tDefault is false.\n\t\tomitLabels: true,\n\n\t\t// labelFunc: Function?\n\t\t//\t\tAn optional function to use to compute label text. It takes precedence over\n\t\t//\t\tthe default text when available.\n\t\t//\t|\t\tfunction labelFunc(value, fixed, precision) {}\n\t\t//\t\t`value` is the data value to display\n\t\t//\t\t`fixed` is true if fixed precision must be applied.\n\t\t//\t\t`precision` is the requested precision to be applied.\n\t\tlabelFunc: null\n\t});\n\t=====*/\n\n\tvar alwaysFalse = function(){ return false; }\n\n\treturn declare(\"dojox.charting.plot2d.CartesianBase\", Base, {\n\t\tbaseParams: {\n\t\t\thAxis: \t\t\t\"x\",\n\t\t\tvAxis: \t\t\t\"y\",\n\t\t\tlabels:\t\t\tfalse,\n\t\t\tlabelOffset:    10,\n\t\t\tfixed:\t\t\ttrue,\n\t\t\tprecision:\t\t1,\n\t\t\tlabelStyle:\t\t\"inside\",\n\t\t\thtmlLabels:\t\ttrue,\t\t// use HTML to draw labels\n\t\t\tomitLabels:\t\ttrue,\n\t\t\tlabelFunc:\t\tnull\n        },\n\n\t\t// summary:\n\t\t//\t\tBase class for cartesian plot types.\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a cartesian base plot for cartesian charts.\n\t\t\t// chart: dojox/chart/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__CartesianCtorArgs?\n\t\t\t//\t\tAn optional arguments object to help define the plot.\n\t\t\tthis.axes = [\"hAxis\", \"vAxis\"];\n\t\t\tthis.zoom = null;\n\t\t\tthis.zoomQueue = [];\t// zooming action task queue\n\t\t\tthis.lastWindow = {vscale: 1, hscale: 1, xoffset: 0, yoffset: 0};\n\t\t\tthis.hAxis = (kwArgs && kwArgs.hAxis) || \"x\";\n\t\t\tthis.vAxis = (kwArgs && kwArgs.vAxis) || \"y\";\n\t\t\tthis.series = [];\n\t\t\tthis.opt = lang.clone(this.baseParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t},\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.inherited(arguments);\n\t\t\tthis._hAxis = null;\n\t\t\tthis._vAxis = null;\n\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t},\n\t\tcleanGroup: function(creator, noClip){\n\t\t\tthis.inherited(arguments);\n\t\t\tif(!noClip && this.chart._nativeClip){\n\t\t\t\tvar offsets = this.chart.offsets, dim = this.chart.dim;\n\t\t\t\tvar w = Math.max(0, dim.width  - offsets.l - offsets.r),\n\t\t\t\t\th = Math.max(0, dim.height - offsets.t - offsets.b);\n\t\t\t\tthis.group.setClip({ x: offsets.l, y: offsets.t, width: w, height: h });\n\t\t\t\tif(!this._clippedGroup){\n\t\t\t\t\tthis._clippedGroup = this.group.createGroup();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tpurgeGroup: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tthis._clippedGroup = null;\n\t\t},\n\t\tgetGroup: function(){\n\t\t\treturn this._clippedGroup || this.group;\n\t\t},\n\t\tsetAxis: function(axis){\n\t\t\t// summary:\n\t\t\t//\t\tSet an axis for this plot.\n\t\t\t// axis: dojox/charting/axis2d/Base\n\t\t\t//\t\tThe axis to set.\n\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(axis){\n\t\t\t\tthis[axis.vertical ? \"_vAxis\" : \"_hAxis\"] = axis;\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t},\n\t\ttoPage: function(coord){\n\t\t\t// summary:\n\t\t\t//\t\tCompute page coordinates from plot axis data coordinates.\n\t\t\t// coord: Object?\n\t\t\t//\t\tThe coordinates in plot axis data coordinate space. For cartesian charts that is of the following form:\n\t\t\t//\t\t`{ hAxisName: 50, vAxisName: 200 }`\n\t\t\t//\t\tIf not provided return the transform method instead of the result of the transformation.\n\t\t\t// returns: Object\n\t\t\t//\t\tThe resulting page pixel coordinates. That is of the following form:\n\t\t\t//\t\t`{ x: 50, y: 200 }`\n\t\t\tvar ah = this._hAxis, av = this._vAxis,\n\t\t\t\tsh = ah.getScaler(), sv = av.getScaler(),\n\t\t\t\tth = sh.scaler.getTransformerFromModel(sh),\n\t\t\t\ttv = sv.scaler.getTransformerFromModel(sv),\n\t\t\t\tc = this.chart.getCoords(),\n\t\t\t\to = this.chart.offsets, dim = this.chart.dim;\n\t\t\tvar t = function(coord){\n\t\t\t\tvar r = {};\n\t\t\t\tr.x = th(coord[ah.name]) + c.x + o.l;\n\t\t\t\tr.y = c.y + dim.height - o.b - tv(coord[av.name]);\n\t\t\t\treturn r;\n\t\t\t};\n\t\t\t// if no coord return the function so that we can capture the current transforms\n\t\t\t// and reuse them later on\n\t\t\treturn coord?t(coord):t; // Object\n\t\t},\n\t\ttoData: function(coord){\n\t\t\t// summary:\n\t\t\t//\t\tCompute plot axis data coordinates from page coordinates.\n\t\t\t// coord: Object\n\t\t\t//\t\tThe pixel coordinate in page coordinate space. That is of the following form:\n\t\t\t//\t\t`{ x: 50, y: 200 }`\n\t\t\t//\t\tIf not provided return the tranform method instead of the result of the transformation.\n\t\t\t// returns: Object\n\t\t\t//\t\tThe resulting plot axis data coordinates. For cartesian charts that is of the following form:\n\t\t\t//\t\t`{ hAxisName: 50, vAxisName: 200 }`\n\t\t\tvar ah = this._hAxis, av = this._vAxis,\n\t\t\t\tsh = ah.getScaler(), sv = av.getScaler(),\n\t\t\t\tth = sh.scaler.getTransformerFromPlot(sh),\n\t\t\t\ttv = sv.scaler.getTransformerFromPlot(sv),\n\t\t\t\tc = this.chart.getCoords(),\n\t\t\t\to = this.chart.offsets, dim = this.chart.dim;\n\t\t\tvar t = function(coord){\n\t\t\t\tvar r = {};\n\t\t\t\tr[ah.name] = th(coord.x - c.x - o.l);\n\t\t\t\tr[av.name] = tv(c.y + dim.height - coord.y  - o.b);\n\t\t\t\treturn r;\n\t\t\t};\n\t\t\t// if no coord return the function so that we can capture the current transforms\n\t\t\t// and reuse them later on\n\t\t\treturn coord?t(coord):t; // Object\n\t\t},\n\t\tisDirty: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns whether or not this plot needs to be rendered.\n\t\t\t// returns: Boolean\n\t\t\t//\t\tThe state of the plot.\n\t\t\treturn this.dirty || this._hAxis && this._hAxis.dirty || this._vAxis && this._vAxis.dirty;\t//\tBoolean\n\t\t},\n\t\tcreateLabel: function(group, value, bbox, theme){\n\t\t\tif(this.opt.labels){\n\t\t\t\tvar x, y, label = this.opt.labelFunc?this.opt.labelFunc.apply(this, [value, this.opt.fixed, this.opt.precision]):\n\t\t\t\t\tthis._getLabel(isNaN(value.y)?value:value.y);\n\t\t\t\tif(this.opt.labelStyle == \"inside\"){\n\t\t\t\t\tvar lbox = gfx._base._getTextBox(label, { font: theme.series.font } );\n\t\t\t\t\tx = bbox.x + bbox.width / 2;\n\t\t\t\t\ty = bbox.y + bbox.height / 2 + lbox.h / 4;\n\t\t\t\t\tif(lbox.w > bbox.width || lbox.h > bbox.height){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tx = bbox.x + bbox.width / 2;\n\t\t\t\t\ty = bbox.y - this.opt.labelOffset;\n\t\t\t\t}\n\t\t\t\tthis.renderLabel(group, x, y, label, theme, this.opt.labelStyle == \"inside\");\n\t\t\t}\n\t\t},\n\t\tperformZoom: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tCreate/alter any zooming windows on this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\n\t\t\t// get current zooming various\n\t\t\tvar vs = this._vAxis.scale || 1,\n\t\t\t\ths = this._hAxis.scale || 1,\n\t\t\t\tvOffset = dim.height - offsets.b,\n\t\t\t\thBounds = this._hScaler.bounds,\n\t\t\t\txOffset = (hBounds.from - hBounds.lower) * hBounds.scale,\n\t\t\t\tvBounds = this._vScaler.bounds,\n\t\t\t\tyOffset = (vBounds.from - vBounds.lower) * vBounds.scale,\n\t\t\t\t// get incremental zooming various\n\t\t\t\trVScale = vs / this.lastWindow.vscale,\n\t\t\t\trHScale = hs / this.lastWindow.hscale,\n\t\t\t\trXOffset = (this.lastWindow.xoffset - xOffset)/\n\t\t\t\t\t((this.lastWindow.hscale == 1)? hs : this.lastWindow.hscale),\n\t\t\t\trYOffset = (yOffset - this.lastWindow.yoffset)/\n\t\t\t\t\t((this.lastWindow.vscale == 1)? vs : this.lastWindow.vscale),\n\n\t\t\t\tshape = this.getGroup(),\n\t\t\t\tanim = fx.animateTransform(lang.delegate({\n\t\t\t\t\tshape: shape,\n\t\t\t\t\tduration: 1200,\n\t\t\t\t\ttransform:[\n\t\t\t\t\t\t{name:\"translate\", start:[0, 0], end: [offsets.l * (1 - rHScale), vOffset * (1 - rVScale)]},\n\t\t\t\t\t\t{name:\"scale\", start:[1, 1], end: [rHScale, rVScale]},\n\t\t\t\t\t\t{name:\"original\"},\n\t\t\t\t\t\t{name:\"translate\", start: [0, 0], end: [rXOffset, rYOffset]}\n\t\t\t\t\t]}, this.zoom));\n\n\t\t\tlang.mixin(this.lastWindow, {vscale: vs, hscale: hs, xoffset: xOffset, yoffset: yOffset});\n\t\t\t//add anim to zooming action queue,\n\t\t\t//in order to avoid several zooming action happened at the same time\n\t\t\tthis.zoomQueue.push(anim);\n\t\t\t//perform each anim one by one in zoomQueue\n\t\t\thub.connect(anim, \"onEnd\", this, function(){\n\t\t\t\tthis.zoom = null;\n\t\t\t\tthis.zoomQueue.shift();\n\t\t\t\tif(this.zoomQueue.length > 0){\n\t\t\t\t\tthis.zoomQueue[0].play();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(this.zoomQueue.length == 1){\n\t\t\t\tthis.zoomQueue[0].play();\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t},\n\t\tinitializeScalers: function(dim, stats){\n\t\t\t// summary:\n\t\t\t//\t\tInitializes scalers using attached axes.\n\t\t\t// dim: Object\n\t\t\t//\t\tSize of a plot area in pixels as {width, height}.\n\t\t\t// stats: Object\n\t\t\t//\t\tMin/max of data in both directions as {hmin, hmax, vmin, vmax}.\n\t\t\t// returns: dojox/charting/plot2d/CartesianBase\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this._hAxis){\n\t\t\t\tif(!this._hAxis.initialized()){\n\t\t\t\t\tthis._hAxis.calculate(stats.hmin, stats.hmax, dim.width);\n\t\t\t\t}\n\t\t\t\tthis._hScaler = this._hAxis.getScaler();\n\t\t\t}else{\n\t\t\t\tthis._hScaler = primitive.buildScaler(stats.hmin, stats.hmax, dim.width);\n\t\t\t}\n\t\t\tif(this._vAxis){\n\t\t\t\tif(!this._vAxis.initialized()){\n\t\t\t\t\tthis._vAxis.calculate(stats.vmin, stats.vmax, dim.height);\n\t\t\t\t}\n\t\t\t\tthis._vScaler = this._vAxis.getScaler();\n\t\t\t}else{\n\t\t\t\tthis._vScaler = primitive.buildScaler(stats.vmin, stats.vmax, dim.height);\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/plot2d/CartesianBase\n\t\t},\n\t\tisNullValue: function(value){\n\t\t\tif(value === null || typeof value == \"undefined\"){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar h = this._hAxis ? this._hAxis.isNullValue : alwaysFalse,\n\t\t\t\tv = this._vAxis ? this._vAxis.isNullValue : alwaysFalse;\n\t\t\tif(typeof value == \"number\"){\n\t\t\t\treturn h(1) || v(value);\n\t\t\t}\n\t\t\treturn h(isNaN(value.x) ? 1 : value.x) || value.y === null || v(value.y);\n\t\t}\t\t\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/CartesianBase.js\n// module id = 181\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/_base/lang\", \"dojox/gfx\",\n\t\t\"../Element\", \"./common\", \"../axis2d/common\", \"dojo/has\"],\n\tfunction(declare, arr, lang, gfx, Element, common, ac, has){\n/*=====\ndojox.charting.plot2d.__PlotCtorArgs = {\n\t// summary:\n\t//\t\tThe base keyword arguments object for plot constructors.\n\t//\t\tNote that the parameters for this may change based on the\n\t//\t\tspecific plot type (see the corresponding plot type for\n\t//\t\tdetails).\n\n\t// tooltipFunc: Function?\n\t//\t\tAn optional function used to compute tooltip text for this plot. It takes precedence over\n\t//\t\tthe default function when available.\n\t//\t|\t\tfunction tooltipFunc(o) { return \"text\"; }\n\t//\t\t`o`is the event object that triggered the tooltip.\n\ttooltipFunc: null\n};\n=====*/\n\tvar Base = declare(\"dojox.charting.plot2d.Base\", Element, {\n\t\t// summary:\n\t\t//\t\tBase class for all plot types.\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a base plot for charting.\n\t\t\t// chart: dojox/chart/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__PlotCtorArgs?\n\t\t\t//\t\tAn optional arguments object to help define the plot.\n\t\n\t\t\t// TODO does not work in markup\n\t\t\tif(kwArgs && kwArgs.tooltipFunc){\n\t\t\t\tthis.tooltipFunc = kwArgs.tooltipFunc;\n\t\t\t}\n\t\t},\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t// returns: dojox.charting.plot2d.Base\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.series = [];\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t},\n\t\tsetAxis: function(axis){\n\t\t\t// summary:\n\t\t\t//\t\tSet an axis for this plot.\n\t\t\t// axis: dojox.charting.axis2d.Base\n\t\t\t//\t\tThe axis to set.\n\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t},\n\t\tassignAxes: function(axes){\n\t\t\t// summary:\n\t\t\t//\t\tFrom an array of axes pick the ones that correspond to this plot and\n\t\t\t//\t\tassign them to the plot using setAxis method.\n\t\t\t// axes: Array\n\t\t\t//\t\tAn array of dojox/charting/axis2d/Base\n\t\t\t// tags:\n\t\t\t//\t\tprotected\n\t\t\tarr.forEach(this.axes, function(axis){\n\t\t\t\tif(this[axis]){\n\t\t\t\t\tthis.setAxis(axes[this[axis]]);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t},\n\t\taddSeries: function(run){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a data series to this plot.\n\t\t\t// run: dojox.charting.Series\n\t\t\t//\t\tThe series to be added.\n\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.series.push(run);\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t},\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\treturn common.collectSimpleStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t},\n\t\tcalculateAxes: function(dim){\n\t\t\t// summary:\n\t\t\t//\t\tStub function for running the axis calculations (deprecated).\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }\n\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.initializeScalers(dim, this.getSeriesStats());\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t},\n\t\tinitializeScalers: function(){\n\t\t\t// summary:\n\t\t\t//\t\tDoes nothing.\n\t\t\treturn this;\n\t\t},\n\t\tisDataDirty: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns whether or not any of this plot's data series need to be rendered.\n\t\t\t// returns: Boolean\n\t\t\t//\t\tFlag indicating if any of this plot's series are invalid and need rendering.\n\t\t\treturn arr.some(this.series, function(item){ return item.dirty; });\t//\tBoolean\n\t\t},\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRender the plot on the chart.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Base\n\t\t},\n\t\trenderLabel: function(group, x, y, label, theme, block, align){\n\t\t\tvar elem = ac.createText[this.opt.htmlLabels && gfx.renderer != \"vml\" ? \"html\" : \"gfx\"]\n\t\t\t\t(this.chart, group, x, y, align?align:\"middle\", label, theme.series.font, theme.series.fontColor);\n\t\t\t// if the label is inside we need to avoid catching events on it this would prevent action on\n\t\t\t// chart elements\n\t\t\tif(block){\n\t\t\t\t// TODO this won't work in IE neither in VML nor in HTML\n\t\t\t\t// a solution would be to catch the event on the label and refire it to the element\n\t\t\t\t// possibly using elementFromPoint or having it already available\n\t\t\t\tif(this.opt.htmlLabels && gfx.renderer != \"vml\"){\n\t\t\t\t\t// we have HTML labels, let's use pointEvents on the HTML node\n\t\t\t\t\telem.style.pointerEvents = \"none\";\n\t\t\t\t}else if(elem.rawNode){\n\t\t\t\t\t// we have SVG labels, let's use pointerEvents on the SVG or VML node\n\t\t\t\t\telem.rawNode.style.pointerEvents = \"none\";\n\t\t\t\t}\n\t\t\t\t// else we have Canvas, we need do nothing, as Canvas text won't catch events\n\t\t\t}\n\t\t\tif(this.opt.htmlLabels && gfx.renderer != \"vml\"){\n\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t}\n\n\t\t\treturn elem;\n\t\t},\n\t\tgetRequiredColors: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet how many data series we have, so we know how many colors to use.\n\t\t\t// returns: Number\n\t\t\t//\t\tThe number of colors needed.\n\t\t\treturn this.series.length;\t//\tNumber\n\t\t},\n\t\t_getLabel: function(number){\n\t\t\treturn common.getLabel(number, this.opt.fixed, this.opt.precision);\n\t\t}\n\t});\n\tif(has(\"dojo-bidi\")){\n\t\tBase.extend({\n\t\t\t_checkOrientation: function(group, dim, offsets){\n\t\t\t\tthis.chart.applyMirroring(this.group, dim, offsets);\n\t\t\t}\t\t\n\t\t});\n\t}\n\treturn Base;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Base.js\n// module id = 182\n// module chunks = 4","define([\"dojo/_base/array\", \"dojo/dom-construct\",\"dojo/_base/declare\", \"dojox/gfx\", \"dojox/gfx/shape\"],\n\tfunction(arr, domConstruct, declare, gfx, shape){\n\n\treturn declare(\"dojox.charting.Element\", null, {\n\t\t// summary:\n\t\t//\t\tA base class that is used to build other elements of a chart, such as\n\t\t//\t\ta series.\n\t\t// chart: dojox/charting/Chart\n\t\t//\t\tThe parent chart for this element.\n\t\t// group: dojox/gfx/shape.Group\n\t\t//\t\tThe visual GFX group representing this element.\n\t\t// htmlElement: Array\n\t\t//\t\tAny DOMNodes used as a part of this element (such as HTML-based labels).\n\t\t// dirty: Boolean\n\t\t//\t\tA flag indicating whether or not this element needs to be rendered.\n\n\t\tchart: null,\n\t\tgroup: null,\n\t\thtmlElements: null,\n\t\tdirty: true,\n\t\trenderingOptions: null,\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreates a new charting element.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart that this element belongs to.\n\t\t\tthis.chart = chart;\n\t\t\tthis.group = null;\n\t\t\tthis.htmlElements = [];\n\t\t\tthis.dirty = true;\n\t\t\tthis.trailingSymbol = \"...\";\n\t\t\tthis._events = [];\n\t\t\tif (kwArgs && kwArgs.renderingOptions) {\n\t\t\t\tthis.renderingOptions = kwArgs.renderingOptions;\n\t\t\t}\n\t\t},\n\t\tpurgeGroup: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear any elements out of our group, and destroy the group.\n\t\t\t// returns: dojox/charting/Element\n\t\t\t//\t\tA reference to this object for functional chaining.\n\t\t\tthis.destroyHtmlElements();\n\t\t\tif(this.group){\n\t\t\t\t// since 1.7.x we need dispose shape otherwise there is a memoryleak\n\t\t\t\tthis.getGroup().removeShape();\n\t\t\t\tvar children = this.getGroup().children;\n\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\tif(shape.dispose){\n\t\t\t\t\tfor(var i = 0; i < children.length;++i){\n\t\t\t\t\t\tshape.dispose(children[i], true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.getGroup().rawNode){\n\t\t\t\t\tdomConstruct.empty(this.getGroup().rawNode);\n\t\t\t\t}\n\t\t\t\tthis.getGroup().clear();\n\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\tif(shape.dispose){\n\t\t\t\t\tshape.dispose(this.getGroup(), true);\n\t\t\t\t}\n\t\t\t\tif(this.getGroup() != this.group){\n\t\t\t\t\t// we do have an intermediary clipping group (see CartesianBase)\n\t\t\t\t\tif(this.group.rawNode){\n\t\t\t\t\t\tdomConstruct.empty(this.group.rawNode);\n\t\t\t\t\t}\n\t\t\t\t\tthis.group.clear();\n\t\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\t\tif(shape.dispose){\n\t\t\t\t\t\tshape.dispose(this.group, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.group = null;\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t\tif(this._events.length){\n\t\t\t\tarr.forEach(this._events, function(item){\n\t\t\t\t\titem.shape.disconnect(item.handle);\n\t\t\t\t});\n\t\t\t\tthis._events = [];\n\t\t\t}\n\t\t\treturn this;\t//\tdojox.charting.Element\n\t\t},\n\t\tcleanGroup: function(creator){\n\t\t\t// summary:\n\t\t\t//\t\tClean any elements (HTML or GFX-based) out of our group, and create a new one.\n\t\t\t// creator: dojox/gfx/shape.Surface?\n\t\t\t//\t\tAn optional surface to work with.\n\t\t\t// returns: dojox/charting/Element\n\t\t\t//\t\tA reference to this object for functional chaining.\n\t\t\tthis.destroyHtmlElements();\n\t\t\tif(!creator){ creator = this.chart.surface; }\n\t\t\tif(this.group){\n\t\t\t\tvar bgnode;\n\t\t\t\tvar children = this.getGroup().children;\n\t\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\t\tif(shape.dispose){\n\t\t\t\t\tfor(var i = 0; i < children.length;++i){\n\t\t\t\t\t\tshape.dispose(children[i], true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.getGroup().rawNode){\n\t\t\t\t\tbgnode = this.getGroup().bgNode;\n\t\t\t\t\tdomConstruct.empty(this.getGroup().rawNode);\n\t\t\t\t}\n\t\t\t\tthis.getGroup().clear();\n\t\t\t\tif(bgnode){\n\t\t\t\t\tthis.getGroup().rawNode.appendChild(bgnode);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tthis.group = creator.createGroup();\n\t\t\t\t// in some cases we have a rawNode but this is not an actual DOM element (CanvasWithEvents) so check\n\t\t\t\t// the actual rawNode type.\n\t\t\t\tif (this.renderingOptions && this.group.rawNode &&\n\t\t\t\t\tthis.group.rawNode.namespaceURI == \"http://www.w3.org/2000/svg\") {\n\t\t\t\t\tfor (var key in this.renderingOptions) {\n\t\t\t\t\t\tthis.group.rawNode.setAttribute(key, this.renderingOptions[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox.charting.Element\n\t\t},\n\t\tgetGroup: function(){\n\t\t\treturn this.group;\n\t\t},\n\t\tdestroyHtmlElements: function(){\n\t\t\t// summary:\n\t\t\t//\t\tDestroy any DOMNodes that may have been created as a part of this element.\n\t\t\tif(this.htmlElements.length){\n\t\t\t\tarr.forEach(this.htmlElements, domConstruct.destroy);\n\t\t\t\tthis.htmlElements = [];\n\t\t\t}\n\t\t},\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tAPI addition to conform to the rest of the Dojo Toolkit's standard.\n\t\t\tthis.purgeGroup();\n\t\t},\n\t\toverrideShape: function(shape, params){\n\t\t\t// summary:\n\t\t\t//\t\tExtension point for overriding the charting shape\n\t\t},\n\t\t//text utilities\n\t\tgetTextWidth: function(s, font){\n\t\t\treturn gfx._base._getTextBox(s, {font: font}).w || 0;\n\t\t},\n\t\tgetTextWithLimitLength: function(s, font, limitWidth, truncated){\n\t\t\t// summary:\n\t\t\t//\t\tGet the truncated string based on the limited width in px(dichotomy algorithm)\n\t\t\t// s: String?\n\t\t\t//\t\tcandidate text.\n\t\t\t// font: String?\n\t\t\t//\t\ttext's font style.\n\t\t\t// limitWidth: Number?\n\t\t\t//\t\ttext limited width in px.\n\t\t\t// truncated: Boolean?\n\t\t\t//\t\twhether the input text(s) has already been truncated.\n\t\t\t// returns: Object\n\t\t\t// |\t{\n\t\t\t// |\t\ttext: processed text, maybe truncated or not,\n\t\t\t// |\t\ttruncated: whether text has been truncated\n\t\t\t// |\t}\n\t\t\tif(!s || s.length <= 0){\n\t\t\t\treturn {\n\t\t\t\t\ttext: \"\",\n\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif(!limitWidth || limitWidth <= 0){\n\t\t\t\treturn {\n\t\t\t\t\ttext: s,\n\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t};\n\t\t\t}\n\t\t\tvar delta = 2,\n\t\t\t\t//golden section for dichotomy algorithm\n\t\t\t\ttrucPercentage = 0.618,\n\t\t\t\tminStr = s.substring(0,1) + this.trailingSymbol,\n\t\t\t\tminWidth = this.getTextWidth(minStr, font);\n\t\t\tif(limitWidth <= minWidth){\n\t\t\t\treturn {\n\t\t\t\t\ttext: minStr,\n\t\t\t\t\ttruncated: true\n\t\t\t\t};\n\t\t\t}\n\t\t\tvar width = this.getTextWidth(s, font);\n\t\t\tif(width <= limitWidth){\n\t\t\t\treturn {\n\t\t\t\t\ttext: s,\n\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\tvar begin = 0,\n\t\t\t\t\tend = s.length;\n\t\t\t\twhile(begin < end){\n\t\t\t\t\tif(end - begin <= delta ){\n\t\t\t\t\t\twhile (this.getTextWidth(s.substring(0, begin) + this.trailingSymbol, font) > limitWidth) {\n\t\t\t\t\t\t\tbegin -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: (s.substring(0,begin) + this.trailingSymbol),\n\t\t\t\t\t\t\ttruncated: true\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tvar index = begin + Math.round((end - begin) * trucPercentage),\n\t\t\t\t\t\twidthIntercepted = this.getTextWidth(s.substring(0, index), font);\n\t\t\t\t\tif(widthIntercepted < limitWidth){\n\t\t\t\t\t\tbegin = index;\n\t\t\t\t\t\tend = end;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbegin = begin;\n\t\t\t\t\t\tend = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTextWithLimitCharCount: function(s, font, wcLimit, truncated){\n\t\t\t// summary:\n\t\t\t//\t\tGet the truncated string based on the limited character count(dichotomy algorithm)\n\t\t\t// s: String?\n\t\t\t//\t\tcandidate text.\n\t\t\t// font: String?\n\t\t\t//\t\ttext's font style.\n\t\t\t// wcLimit: Number?\n\t\t\t//\t\ttext limited character count.\n\t\t\t// truncated: Boolean?\n\t\t\t//\t\twhether the input text(s) has already been truncated.\n\t\t\t// returns: Object\n\t\t\t// |\t{\n\t\t\t// |\t\ttext: processed text, maybe truncated or not,\n\t\t\t// |\t\ttruncated: whether text has been truncated\n\t\t\t// |\t}\n\t\t\tif (!s || s.length <= 0) {\n\t\t\t\treturn {\n\t\t\t\t\ttext: \"\",\n\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif(!wcLimit || wcLimit <= 0 || s.length <= wcLimit){\n\t\t\t\treturn {\n\t\t\t\t\ttext: s,\n\t\t\t\t\ttruncated: truncated || false\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttext: s.substring(0, wcLimit) + this.trailingSymbol,\n\t\t\t\ttruncated: true\n\t\t\t};\n\t\t},\n\t\t// fill utilities\n\t\t_plotFill: function(fill, dim, offsets){\n\t\t\t// process a plot-wide fill\n\t\t\tif(!fill || !fill.type || !fill.space){\n\t\t\t\treturn fill;\n\t\t\t}\n\t\t\tvar space = fill.space, span;\n\t\t\tswitch(fill.type){\n\t\t\t\tcase \"linear\":\n\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultLinearGradient, fill);\n\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\tspan = dim.height - offsets.t - offsets.b;\n\t\t\t\t\t\t\tfill.y1 = offsets.t + span * fill.y1 / 100;\n\t\t\t\t\t\t\tfill.y2 = offsets.t + span * fill.y2 / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\tspan = dim.width - offsets.l - offsets.r;\n\t\t\t\t\t\t\tfill.x1 = offsets.l + span * fill.x1 / 100;\n\t\t\t\t\t\t\tfill.x2 = offsets.l + span * fill.x2 / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"radial\":\n\t\t\t\t\tif(space === \"plot\"){\n\t\t\t\t\t\t// this one is used exclusively for scatter charts\n\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultRadialGradient, fill);\n\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t// process both dimensions\n\t\t\t\t\t\tvar spanX = dim.width  - offsets.l - offsets.r,\n\t\t\t\t\t\t\tspanY = dim.height - offsets.t - offsets.b;\n\t\t\t\t\t\tfill.cx = offsets.l + spanX * fill.cx / 100;\n\t\t\t\t\t\tfill.cy = offsets.t + spanY * fill.cy / 100;\n\t\t\t\t\t\tfill.r  = fill.r * Math.sqrt(spanX * spanX + spanY * spanY) / 200;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pattern\":\n\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultPattern, fill);\n\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\tspan = dim.height - offsets.t - offsets.b;\n\t\t\t\t\t\t\tfill.y = offsets.t + span * fill.y / 100;\n\t\t\t\t\t\t\tfill.height = span * fill.height / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(space === \"plot\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\tspan = dim.width - offsets.l - offsets.r;\n\t\t\t\t\t\t\tfill.x = offsets.l + span * fill.x / 100;\n\t\t\t\t\t\t\tfill.width = span * fill.width / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn fill;\n\t\t},\n\t\t_shapeFill: function(fill, bbox){\n\t\t\t// process shape-specific fill\n\t\t\tif(!fill || !fill.space){\n\t\t\t\treturn fill;\n\t\t\t}\n\t\t\tvar space = fill.space, span;\n\t\t\tswitch(fill.type){\n\t\t\t\tcase \"linear\":\n\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultLinearGradient, fill);\n\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\tspan = bbox.width;\n\t\t\t\t\t\t\tfill.x1 = bbox.x + span * fill.x1 / 100;\n\t\t\t\t\t\t\tfill.x2 = bbox.x + span * fill.x2 / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\tspan = bbox.height;\n\t\t\t\t\t\t\tfill.y1 = bbox.y + span * fill.y1 / 100;\n\t\t\t\t\t\t\tfill.y2 = bbox.y + span * fill.y2 / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"radial\":\n\t\t\t\t\tif(space === \"shape\"){\n\t\t\t\t\t\t// this one is used exclusively for bubble charts and pie charts\n\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultRadialGradient, fill);\n\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t// process both dimensions\n\t\t\t\t\t\tfill.cx = bbox.x + bbox.width  / 2;\n\t\t\t\t\t\tfill.cy = bbox.y + bbox.height / 2;\n\t\t\t\t\t\tfill.r  = fill.r * bbox.width  / 200;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pattern\":\n\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\" || space === \"shapeY\"){\n\t\t\t\t\t\t// clone a fill so we can modify properly directly\n\t\t\t\t\t\tfill = gfx.makeParameters(gfx.defaultPattern, fill);\n\t\t\t\t\t\tfill.space = space;\n\t\t\t\t\t\t// process dimensions\n\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeX\"){\n\t\t\t\t\t\t\t// process X\n\t\t\t\t\t\t\tspan = bbox.width;\n\t\t\t\t\t\t\tfill.x = bbox.x + span * fill.x / 100;\n\t\t\t\t\t\t\tfill.width = span * fill.width / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(space === \"shape\" || space === \"shapeY\"){\n\t\t\t\t\t\t\t// process Y\n\t\t\t\t\t\t\tspan = bbox.height;\n\t\t\t\t\t\t\tfill.y = bbox.y + span * fill.y / 100;\n\t\t\t\t\t\t\tfill.height = span * fill.height / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn fill;\n\t\t},\n\t\t_pseudoRadialFill: function(fill, center, radius, start, end){\n\t\t\t// process pseudo-radial fills\n\t\t\tif(!fill || fill.type !== \"radial\" || fill.space !== \"shape\"){\n\t\t\t\treturn fill;\n\t\t\t}\n\t\t\t// clone and normalize fill\n\t\t\tvar space = fill.space;\n\t\t\tfill = gfx.makeParameters(gfx.defaultRadialGradient, fill);\n\t\t\tfill.space = space;\n\t\t\tif(arguments.length < 4){\n\t\t\t\t// process both dimensions\n\t\t\t\tfill.cx = center.x;\n\t\t\t\tfill.cy = center.y;\n\t\t\t\tfill.r  = fill.r * radius / 100;\n\t\t\t\treturn fill;\n\t\t\t}\n\t\t\t// convert to a linear gradient\n\t\t\tvar angle = arguments.length < 5 ? start : (end + start) / 2;\n\t\t\treturn {\n\t\t\t\ttype: \"linear\",\n\t\t\t\tx1: center.x,\n\t\t\t\ty1: center.y,\n\t\t\t\tx2: center.x + fill.r * radius * Math.cos(angle) / 100,\n\t\t\t\ty2: center.y + fill.r * radius * Math.sin(angle) / 100,\n\t\t\t\tcolors: fill.colors\n\t\t\t};\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/Element.js\n// module id = 183\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/window\", \"dojo/dom-geometry\", \"dojox/gfx\", \"dojo/has\"],\n\tfunction(lang, win, domGeom, g, has){\n\n\tvar common = lang.getObject(\"dojox.charting.axis2d.common\", true);\n\t\n\tvar clearNode = function(s){\n\t\ts.marginLeft   = \"0px\";\n\t\ts.marginTop    = \"0px\";\n\t\ts.marginRight  = \"0px\";\n\t\ts.marginBottom = \"0px\";\n\t\ts.paddingLeft   = \"0px\";\n\t\ts.paddingTop    = \"0px\";\n\t\ts.paddingRight  = \"0px\";\n\t\ts.paddingBottom = \"0px\";\n\t\ts.borderLeftWidth   = \"0px\";\n\t\ts.borderTopWidth    = \"0px\";\n\t\ts.borderRightWidth  = \"0px\";\n\t\ts.borderBottomWidth = \"0px\";\n\t};\n\n\tvar getBoxWidth = function(n){\n\t\t// marginBox is incredibly slow, so avoid it if we can\n\t\tif(n[\"getBoundingClientRect\"]){\n\t\t\tvar bcr = n.getBoundingClientRect();\n\t\t\treturn bcr.width || (bcr.right - bcr.left);\n\t\t}else{\n\t\t\treturn domGeom.getMarginBox(n).w;\n\t\t}\n\t};\n\n\treturn lang.mixin(common, {\n\t\t// summary:\n\t\t//\t\tCommon methods to be used by any axis.  This is considered \"static\".\n\t\tcreateText: {\n\t\t\tgfx: function(chart, creator, x, y, align, text, font, fontColor){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUse dojox.gfx to create any text.\n\t\t\t\t// chart: dojox.charting.Chart\n\t\t\t\t//\t\tThe chart to create the text into.\n\t\t\t\t// creator: dojox.gfx.Surface\n\t\t\t\t//\t\tThe graphics surface to use for creating the text.\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tWhere to create the text along the x axis (CSS left).\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tWhere to create the text along the y axis (CSS top).\n\t\t\t\t// align: String\n\t\t\t\t//\t\tHow to align the text.  Can be \"left\", \"right\", \"center\".\n\t\t\t\t// text: String\n\t\t\t\t//\t\tThe text to render.\n\t\t\t\t// font: String\n\t\t\t\t//\t\tThe font definition, a la CSS \"font\".\n\t\t\t\t// fontColor: String|dojo.Color\n\t\t\t\t//\t\tThe color of the resultant text.\n\t\t\t\t// returns: dojox.gfx.Text\n\t\t\t\t//\t\tThe resultant GFX object.\n\t\t\t\treturn creator.createText({\n\t\t\t\t\tx: x, y: y, text: text, align: align\n\t\t\t\t}).setFont(font).setFill(fontColor);\t//\tdojox.gfx.Text\n\t\t\t},\n\t\t\thtml: function(chart, creator, x, y, align, text, font, fontColor, labelWidth){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tUse the HTML DOM to create any text.\n\t\t\t\t// chart: dojox.charting.Chart\n\t\t\t\t//\t\tThe chart to create the text into.\n\t\t\t\t// creator: dojox.gfx.Surface\n\t\t\t\t//\t\tThe graphics surface to use for creating the text.\n\t\t\t\t// x: Number\n\t\t\t\t//\t\tWhere to create the text along the x axis (CSS left).\n\t\t\t\t// y: Number\n\t\t\t\t//\t\tWhere to create the text along the y axis (CSS top).\n\t\t\t\t// align: String\n\t\t\t\t//\t\tHow to align the text.  Can be \"left\", \"right\", \"center\".\n\t\t\t\t// text: String\n\t\t\t\t//\t\tThe text to render.\n\t\t\t\t// font: String\n\t\t\t\t//\t\tThe font definition, a la CSS \"font\".\n\t\t\t\t// fontColor: String|dojo.Color\n\t\t\t\t//\t\tThe color of the resultant text.\n\t\t\t\t// labelWidth: Number?\n\t\t\t\t//\t\tThe maximum width of the resultant DOM node.\n\t\t\t\t// returns: DOMNode\n\t\t\t\t//\t\tThe resultant DOMNode (a \"div\" element).\n\n\t\t\t\t// setup the text node\n\t\t\t\tvar p = win.doc.createElement(\"div\"), s = p.style, boxWidth;\n\t\t\t\t// bidi support, if this function exists the module was loaded \n\t\t\t\tif(chart.getTextDir){\n\t\t\t\t\tp.dir = chart.getTextDir(text);\n\t\t\t\t}\n\t\t\t\tclearNode(s);\n\t\t\t\ts.font = font;\n\t\t\t\tp.innerHTML = String(text).replace(/\\s/g, \"&nbsp;\");\n\t\t\t\ts.color = fontColor;\n\t\t\t\t// measure the size\n\t\t\t\ts.position = \"absolute\";\n\t\t\t\ts.left = \"-10000px\";\n\t\t\t\twin.body().appendChild(p);\n\t\t\t\tvar size = g.normalizedLength(g.splitFontString(font).size);\n\n\t\t\t\t// do we need to calculate the label width?\n\t\t\t\tif(!labelWidth){\n\t\t\t\t\tboxWidth = getBoxWidth(p);\n\t\t\t\t}\n\t\t\t\t// when the textDir is rtl, but the UI ltr needs\n\t\t\t\t// to recalculate the starting point\n\t\t\t\tif(p.dir == \"rtl\"){\n\t\t\t\t\tx += labelWidth ? labelWidth : boxWidth;\n\t\t\t\t}\n\n\t\t\t\t// new settings for the text node\n\t\t\t\twin.body().removeChild(p);\n\n\t\t\t\ts.position = \"relative\";\n\t\t\t\tif(labelWidth){\n\t\t\t\t\ts.width = labelWidth + \"px\";\n\t\t\t\t\t// s.border = \"1px dotted grey\";\n\t\t\t\t\tswitch(align){\n\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\ts.textAlign = \"center\";\n\t\t\t\t\t\t\ts.left = (x - labelWidth / 2) + \"px\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\ts.textAlign = \"right\";\n\t\t\t\t\t\t\ts.left = (x - labelWidth) + \"px\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ts.left = x + \"px\";\n\t\t\t\t\t\t\ts.textAlign = \"left\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(align){\n\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\ts.left = Math.floor(x - boxWidth / 2) + \"px\";\n\t\t\t\t\t\t\t// s.left = Math.floor(x - p.offsetWidth / 2) + \"px\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\ts.left = Math.floor(x - boxWidth) + \"px\";\n\t\t\t\t\t\t\t// s.left = Math.floor(x - p.offsetWidth) + \"px\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t//case \"start\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ts.left = Math.floor(x) + \"px\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.top = Math.floor(y - size) + \"px\";\n\t\t\t\ts.whiteSpace = \"nowrap\";\t// hack for WebKit\n\t\t\t\t// setup the wrapper node\n\t\t\t\tvar wrap = win.doc.createElement(\"div\"), w = wrap.style;\n\t\t\t\tclearNode(w);\n\t\t\t\tw.width = \"0px\";\n\t\t\t\tw.height = \"0px\";\n\t\t\t\t// insert nodes\n\t\t\t\twrap.appendChild(p);\n\t\t\t\tchart.node.insertBefore(wrap, chart.node.firstChild);\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tchart.htmlElementsRegistry.push([wrap, x, y, align, text, font, fontColor]);\n\t\t\t\t}\n\t\t\t\treturn wrap;\t//\tDOMNode\n\t\t\t}\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/axis2d/common.js\n// module id = 184\n// module chunks = 4","define([\"dojo/_base/lang\"], \n  function(lang){\n\tvar primitive = lang.getObject(\"dojox.charting.scaler.primitive\", true);\n\treturn lang.mixin(primitive, {\n\t\tbuildScaler: function(/*Number*/ min, /*Number*/ max, /*Number*/ span, /*Object*/ kwArgs){\n\t\t\tif(min == max){\n\t\t\t\t// artificially extend bounds\n\t\t\t\tmin -= 0.5;\n\t\t\t\tmax += 0.5;\n\t\t\t\t// now the line will be centered\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tbounds: {\n\t\t\t\t\tlower: min,\n\t\t\t\t\tupper: max,\n\t\t\t\t\tfrom:  min,\n\t\t\t\t\tto:    max,\n\t\t\t\t\tscale: span / (max - min),\n\t\t\t\t\tspan:  span\n\t\t\t\t},\n\t\t\t\tscaler: primitive\n\t\t\t};\n\t\t},\n\t\tbuildTicks: function(/*Object*/ scaler, /*Object*/ kwArgs){\n\t\t\treturn {major: [], minor: [], micro: []};\t// Object\n\t\t},\n\t\tgetTransformerFromModel: function(/*Object*/ scaler){\n\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\treturn function(x){ return (x - offset) * scale; };\t// Function\n\t\t},\n\t\tgetTransformerFromPlot: function(/*Object*/ scaler){\n\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\treturn function(x){ return x / scale + offset; };\t// Function\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/scaler/primitive.js\n// module id = 185\n// module chunks = 4","define([\"dojo/_base/lang\", \"./_base\", \"./matrix\", \"dojo/_base/Color\", \"dojo/_base/array\", \"dojo/_base/fx\", \"dojo/_base/connect\", \"dojo/sniff\"], \n  function(lang, g, m, Color, arr, fx, Hub, has){\n\tvar fxg = g.fx = {};\n\n\t// Generic interpolators. Should they be moved to dojox.fx?\n\n\tfunction InterpolNumber(start, end){\n\t\tthis.start = start, this.end = end;\n\t}\n\tInterpolNumber.prototype.getValue = function(r){\n\t\treturn (this.end - this.start) * r + this.start;\n\t};\n\n\tfunction InterpolUnit(start, end, units){\n\t\tthis.start = start, this.end = end;\n\t\tthis.units = units;\n\t}\n\tInterpolUnit.prototype.getValue = function(r){\n\t\treturn (this.end - this.start) * r + this.start + this.units;\n\t};\n\n\tfunction InterpolColor(start, end){\n\t\tthis.start = start, this.end = end;\n\t\tthis.temp = new Color();\n\t}\n\tInterpolColor.prototype.getValue = function(r){\n\t\treturn Color.blendColors(this.start, this.end, r, this.temp);\n\t};\n\n\tfunction InterpolValues(values){\n\t\tthis.values = values;\n\t\tthis.length = values.length;\n\t}\n\tInterpolValues.prototype.getValue = function(r){\n\t\treturn this.values[Math.min(Math.floor(r * this.length), this.length - 1)];\n\t};\n\n\tfunction InterpolObject(values, def){\n\t\tthis.values = values;\n\t\tthis.def = def ? def : {};\n\t}\n\tInterpolObject.prototype.getValue = function(r){\n\t\tvar ret = lang.clone(this.def);\n\t\tfor(var i in this.values){\n\t\t\tret[i] = this.values[i].getValue(r);\n\t\t}\n\t\treturn ret;\n\t};\n\n\tfunction InterpolTransform(stack, original){\n\t\tthis.stack = stack;\n\t\tthis.original = original;\n\t}\n\tInterpolTransform.prototype.getValue = function(r){\n\t\tvar ret = [];\n\t\tarr.forEach(this.stack, function(t){\n\t\t\tif(t instanceof m.Matrix2D){\n\t\t\t\tret.push(t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(t.name == \"original\" && this.original){\n\t\t\t\tret.push(this.original);\n\t\t\t\treturn;\n\t\t\t}\n \t\t\t// Adding support for custom matrices\n \t\t\tif(t.name == \"matrix\"){\n \t\t\t\tif((t.start instanceof m.Matrix2D) && (t.end instanceof m.Matrix2D)){\n \t\t\t\t\tvar transfMatrix = new m.Matrix2D();\n \t\t\t\t\tfor(var p in t.start) {\n \t\t\t\t\t\ttransfMatrix[p] = (t.end[p] - t.start[p])*r + t.start[p];\n \t\t\t\t\t}\n \t\t\t\t\tret.push(transfMatrix);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n\t\t\tif(!(t.name in m)){ return; }\n\t\t\tvar f = m[t.name];\n\t\t\tif(typeof f != \"function\"){\n\t\t\t\t// constant\n\t\t\t\tret.push(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar val = arr.map(t.start, function(v, i){\n\t\t\t\t\t\t\treturn (t.end[i] - v) * r + v;\n\t\t\t\t\t\t}),\n\t\t\t\tmatrix = f.apply(m, val);\n\t\t\tif(matrix instanceof m.Matrix2D){\n\t\t\t\tret.push(matrix);\n\t\t\t}\n\t\t}, this);\n\t\treturn ret;\n\t};\n\n\tvar transparent = new Color(0, 0, 0, 0);\n\n\tfunction getColorInterpol(prop, obj, name, def){\n\t\tif(prop.values){\n\t\t\treturn new InterpolValues(prop.values);\n\t\t}\n\t\tvar value, start, end;\n\t\tif(prop.start){\n\t\t\tstart = g.normalizeColor(prop.start);\n\t\t}else{\n\t\t\tstart = value = obj ? (name ? obj[name] : obj) : def;\n\t\t}\n\t\tif(prop.end){\n\t\t\tend = g.normalizeColor(prop.end);\n\t\t}else{\n\t\t\tif(!value){\n\t\t\t\tvalue = obj ? (name ? obj[name] : obj) : def;\n\t\t\t}\n\t\t\tend = value;\n\t\t}\n\t\treturn new InterpolColor(start, end);\n\t}\n\n\tfunction getNumberInterpol(prop, obj, name, def){\n\t\tif(prop.values){\n\t\t\treturn new InterpolValues(prop.values);\n\t\t}\n\t\tvar value, start, end;\n\t\tif(prop.start){\n\t\t\tstart = prop.start;\n\t\t}else{\n\t\t\tstart = value = obj ? obj[name] : def;\n\t\t}\n\t\tif(prop.end){\n\t\t\tend = prop.end;\n\t\t}else{\n\t\t\tif(typeof value != \"number\"){\n\t\t\t\tvalue = obj ? obj[name] : def;\n\t\t\t}\n\t\t\tend = value;\n\t\t}\n\t\treturn new InterpolNumber(start, end);\n\t}\n\n\tfxg.animateStroke = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation which will change stroke properties over time.\n\t\t// args:\n\t\t//\t\tan object defining the animation setting.\n\t\t// example:\n\t\t//\t|\tfxg.animateStroke{{\n\t\t//\t|\t\tshape: shape,\n\t\t//\t|\t\tduration: 500,\n\t\t//\t|\t\tcolor: {start: \"red\", end: \"green\"},\n\t\t//\t|\t\twidth: {end: 15},\n\t\t//\t|\t\tjoin:  {values: [\"miter\", \"bevel\", \"round\"]}\n\t\t//\t|\t}).play();\n\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\tvar anim = new fx.Animation(args), shape = args.shape, stroke;\n\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\tstroke = shape.getStroke();\n\t\t\tvar prop = args.color, values = {}, value, start, end;\n\t\t\tif(prop){\n\t\t\t\tvalues.color = getColorInterpol(prop, stroke, \"color\", transparent);\n\t\t\t}\n\t\t\tprop = args.style;\n\t\t\tif(prop && prop.values){\n\t\t\t\tvalues.style = new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tprop = args.width;\n\t\t\tif(prop){\n\t\t\t\tvalues.width = getNumberInterpol(prop, stroke, \"width\", 1);\n\t\t\t}\n\t\t\tprop = args.cap;\n\t\t\tif(prop && prop.values){\n\t\t\t\tvalues.cap = new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tprop = args.join;\n\t\t\tif(prop){\n\t\t\t\tif(prop.values){\n\t\t\t\t\tvalues.join = new InterpolValues(prop.values);\n\t\t\t\t}else{\n\t\t\t\t\tstart = prop.start ? prop.start : (stroke && stroke.join || 0);\n\t\t\t\t\tend = prop.end ? prop.end : (stroke && stroke.join || 0);\n\t\t\t\t\tif(typeof start == \"number\" && typeof end == \"number\"){\n\t\t\t\t\t\tvalues.join = new InterpolNumber(start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.curve = new InterpolObject(values, stroke);\n\t\t});\n\t\tHub.connect(anim, \"onAnimate\", shape, \"setStroke\");\n\t\treturn anim; // dojo.Animation\n\t};\n\n\tfxg.animateFill = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation which will change fill color over time.\n\t\t//\t\tOnly solid fill color is supported at the moment\n\t\t// args:\n\t\t//\t\tan object defining the animation setting.\n\t\t// example:\n\t\t//\t|\tgfx.animateFill{{\n\t\t//\t|\t\tshape: shape,\n\t\t//\t|\t\tduration: 500,\n\t\t//\t|\t\tcolor: {start: \"red\", end: \"green\"}\n\t\t//\t|\t}).play();\n\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\tvar anim = new fx.Animation(args), shape = args.shape, fill;\n\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\tfill = shape.getFill();\n\t\t\tvar prop = args.color, values = {};\n\t\t\tif(prop){\n\t\t\t\tthis.curve = getColorInterpol(prop, fill, \"\", transparent);\n\t\t\t}\n\t\t});\n\t\tHub.connect(anim, \"onAnimate\", shape, \"setFill\");\n\t\treturn anim; // dojo.Animation\n\t};\n\n\tfxg.animateFont = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation which will change font properties over time.\n\t\t// args:\n\t\t//\t\tan object defining the animation setting.\n\t\t// example:\n\t\t//\t|\tgfx.animateFont{{\n\t\t//\t|\t\tshape: shape,\n\t\t//\t|\t\tduration: 500,\n\t\t//\t|\t\tvariant: {values: [\"normal\", \"small-caps\"]},\n\t\t//\t|\t\tsize:  {end: 10, units: \"pt\"}\n\t\t//\t|\t}).play();\n\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\tvar anim = new fx.Animation(args), shape = args.shape, font;\n\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\tfont = shape.getFont();\n\t\t\tvar prop = args.style, values = {}, value, start, end;\n\t\t\tif(prop && prop.values){\n\t\t\t\tvalues.style = new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tprop = args.variant;\n\t\t\tif(prop && prop.values){\n\t\t\t\tvalues.variant = new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tprop = args.weight;\n\t\t\tif(prop && prop.values){\n\t\t\t\tvalues.weight = new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tprop = args.family;\n\t\t\tif(prop && prop.values){\n\t\t\t\tvalues.family = new InterpolValues(prop.values);\n\t\t\t}\n\t\t\tprop = args.size;\n\t\t\tif(prop && prop.units){\n\t\t\t\tstart = parseFloat(prop.start ? prop.start : (shape.font && shape.font.size || \"0\"));\n\t\t\t\tend = parseFloat(prop.end ? prop.end : (shape.font && shape.font.size || \"0\"));\n\t\t\t\tvalues.size = new InterpolUnit(start, end, prop.units);\n\t\t\t}\n\t\t\tthis.curve = new InterpolObject(values, font);\n\t\t});\n\t\tHub.connect(anim, \"onAnimate\", shape, \"setFont\");\n\t\treturn anim; // dojo.Animation\n\t};\n\n\tfxg.animateTransform = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation which will change transformation over time.\n\t\t// args:\n\t\t//\t\tan object defining the animation setting.\n\t\t// example:\n\t\t//\t|\tgfx.animateTransform{{\n\t\t//\t|\t\tshape: shape,\n\t\t//\t|\t\tduration: 500,\n\t\t//\t|\t\ttransform: [\n\t\t//\t|\t\t\t{name: \"translate\", start: [0, 0], end: [200, 200]},\n\t\t//\t|\t\t\t{name: \"original\"}\n\t\t//\t|\t\t]\n\t\t//\t|\t}).play();\n\t\tif(!args.easing){ args.easing = fx._defaultEasing; }\n\t\tvar anim = new fx.Animation(args), shape = args.shape, original;\n\t\tHub.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\toriginal = shape.getTransform();\n\t\t\tthis.curve = new InterpolTransform(args.transform, original);\n\t\t});\n\t\tHub.connect(anim, \"onAnimate\", shape, \"setTransform\");\n\t\tif(g.renderer === \"svg\" && (has(\"ie\") >= 9 || has(\"ff\"))){\n\t\t\t// fix http://bugs.dojotoolkit.org/ticket/16879\n\t\t\tvar handlers = [\n\t\t\t\t\tHub.connect(anim, \"onBegin\", anim, function(){\n\t\t\t\t\t\tvar parent = shape.getParent();\n\t\t\t\t\t\twhile(parent && parent.getParent){\n\t\t\t\t\t\t\tparent = parent.getParent();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(parent){\n\t\t\t\t\t\t\tshape.__svgContainer = parent.rawNode.parentNode;\n\t\t\t\t\t\t\tshape.__svgRoot = parent.rawNode;\n\t\t\t\t\t\t\tif(shape.__svgRoot && shape.__svgRoot.getAttribute){\n\t\t\t\t\t\t\t\tshape.__svgWidth = parseInt(shape.__svgRoot.getAttribute(\"width\"), 10);\n\t\t\t\t\t\t\t\tif(isNaN(shape.__svgWidth)){\n\t\t\t\t\t\t\t\t\tdelete shape.__svgWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tHub.connect(anim, \"onAnimate\", anim, function(){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tif(shape.__svgContainer){\n\t\t\t\t\t\t\t\tvar ov = shape.__svgContainer.style.visibility;\n\t\t\t\t\t\t\t\tshape.__svgContainer.style.visibility = \"visible\";\n\t\t\t\t\t\t\t\tvar pokeNode = shape.__svgContainer.offsetHeight;\n\t\t\t\t\t\t\t\tshape.__svgContainer.style.visibility = ov;\n\t\t\t\t\t\t\t\tvar width = shape.__svgWidth;\n\t\t\t\t\t\t\t\tif(!isNaN(width)){\n\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\tshape.__svgRoot.setAttribute(\"width\", width  - 0.000005);\n\t\t\t\t\t\t\t\t\t\tshape.__svgRoot.setAttribute(\"width\", width);\n\t\t\t\t\t\t\t\t\t}catch(ignore){}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t}),\n\t\t\t\t\tHub.connect(anim, \"onEnd\", anim, function(){\n\t\t\t\t\t\tarr.forEach(handlers, Hub.disconnect);\n\t\t\t\t\t\tif(shape.__svgContainer){\n\t\t\t\t\t\t\tvar sn = shape.__svgContainer;\n\t\t\t\t\t\t\tif(sn.getAttribute(\"__gotVis\") == null){\n\t\t\t\t\t\t\t\tsn.setAttribute(\"__gotVis\", true);\n\t\t\t\t\t\t\t\tvar ov = shape.__svgContainer.style.visibility;\n\t\t\t\t\t\t\t\tvar root = shape.__svgRoot;\n\t\t\t\t\t\t\t\tvar width = shape.__svgWidth;\n\t\t\t\t\t\t\t\tsn.style.visibility = \"visible\";\n\t\t\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\tsn.style.visibility = ov;\n\t\t\t\t\t\t\t\t\t\tsn.removeAttribute(\"__gotVis\");\n\t\t\t\t\t\t\t\t\t\tsn = null;\n\t\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\t\tif(!isNaN(width)){\n\t\t\t\t\t\t\t\t\t\t\t\troot.setAttribute(\"width\", width - 0.000005);\n\t\t\t\t\t\t\t\t\t\t\t\troot.setAttribute(\"width\", width);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}catch(ignore){}\n\t\t\t\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t\t\t\t},100);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete shape.__svgContainer;\n\t\t\t\t\t\tdelete shape.__svgRoot;\n\t\t\t\t\t\tdelete shape.__svgWidth;\n\t\t\t\t\t})\n\t\t\t\t];\n\t\t}\n\t\treturn anim; // dojo.Animation\n\t};\n\t\n\treturn fxg;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/fx.js\n// module id = 186\n// module chunks = 4","define([\"..\", \"dojo/_base/lang\"], \n  function(dojox, lang){\n\tvar du = lang.getObject(\"lang.utils\", true, dojox);\n\t\n\tvar empty = {}, opts = Object.prototype.toString;\n\n\tvar clone = function(o){\n\t\tif(o){\n\t\t\tswitch(opts.call(o)){\n\t\t\t\tcase \"[object Array]\":\n\t\t\t\t\treturn o.slice(0);\n\t\t\t\tcase \"[object Object]\":\n\t\t\t\t\treturn lang.delegate(o);\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\t\n\tlang.mixin(du, {\n\t\tcoerceType: function(target, source){\n\t\t\t// summary:\n\t\t\t//\t\tCoerces one object to the type of another.\n\t\t\t// target: Object\n\t\t\t//\t\tobject, which typeof result is used to coerce \"source\" object.\n\t\t\t// source: Object\n\t\t\t//\t\tobject, which will be forced to change type.\n\t\t\tswitch(typeof target){\n\t\t\t\tcase \"number\":\treturn Number(eval(\"(\" + source + \")\"));\n\t\t\t\tcase \"string\":\treturn String(source);\n\t\t\t\tcase \"boolean\":\treturn Boolean(eval(\"(\" + source + \")\"));\n\t\t\t}\n\t\t\treturn eval(\"(\" + source + \")\");\n\t\t},\n\t\t\n\t\tupdateWithObject: function(target, source, conv){\n\t\t\t// summary:\n\t\t\t//\t\tUpdates an existing object in place with properties from an \"source\" object.\n\t\t\t// target: Object\n\t\t\t//\t\tthe \"target\" object to be updated\n\t\t\t// source: Object\n\t\t\t//\t\tthe \"source\" object, whose properties will be used to source the existed object.\n\t\t\t// conv: Boolean?\n\t\t\t//\t\tforce conversion to the original type\n\t\t\tif(!source){ return target; }\n\t\t\tfor(var x in target){\n\t\t\t\tif(x in source && !(x in empty)){\n\t\t\t\t\tvar t = target[x];\n\t\t\t\t\tif(t && typeof t == \"object\"){\n\t\t\t\t\t\tdu.updateWithObject(t, source[x], conv);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttarget[x] = conv ? du.coerceType(t, source[x]) : clone(source[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\t// Object\n\t\t},\n\t\n\t\tupdateWithPattern: function(target, source, pattern, conv){\n\t\t\t// summary:\n\t\t\t//\t\tUpdates an existing object in place with properties from an \"source\" object.\n\t\t\t// target: Object\n\t\t\t//\t\tthe \"target\" object to be updated\n\t\t\t// source: Object\n\t\t\t//\t\tthe \"source\" object, whose properties will be used to source the existed object.\n\t\t\t// pattern: Object\n\t\t\t//\t\tobject, whose properties will be used to pull values from the \"source\"\n\t\t\t// conv: Boolean?\n\t\t\t//\t\tforce conversion to the original type\n\t\t\tif(!source || !pattern){ return target; }\n\t\t\tfor(var x in pattern){\n\t\t\t\tif(x in source && !(x in empty)){\n\t\t\t\t\ttarget[x] = conv ? du.coerceType(pattern[x], source[x]) : clone(source[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\t// Object\n\t\t},\n\t\t\n\t\tmerge: function(object, mixin){\n\t\t\t// summary:\n\t\t\t//\t\tMerge two objects structurally, mixin properties will override object's properties.\n\t\t\t// object: Object\n\t\t\t//\t\toriginal object.\n\t\t\t// mixin: Object\n\t\t\t//\t\tadditional object, which properties will override object's properties.\n\t\t\tif(mixin){\n\t\t\t\tvar otype = opts.call(object), mtype = opts.call(mixin), t, i, l, m;\n\t\t\t\tswitch(mtype){\n\t\t\t\t\tcase \"[object Array]\":\n\t\t\t\t\t\tif(mtype == otype){\n\t\t\t\t\t\t\tt = new Array(Math.max(object.length, mixin.length));\n\t\t\t\t\t\t\tfor(i = 0, l = t.length; i < l; ++i){\n\t\t\t\t\t\t\t\tt[i] = du.merge(object[i], mixin[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn mixin.slice(0);\n\t\t\t\t\tcase \"[object Object]\":\n\t\t\t\t\t\tif(mtype == otype && object){\n\t\t\t\t\t\t\tt = lang.delegate(object);\n\t\t\t\t\t\t\tfor(i in mixin){\n\t\t\t\t\t\t\t\tif(i in object){\n\t\t\t\t\t\t\t\t\tl = object[i];\n\t\t\t\t\t\t\t\t\tm = mixin[i];\n\t\t\t\t\t\t\t\t\tif(m !== l){\n\t\t\t\t\t\t\t\t\t\tt[i] = du.merge(l, m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tt[i] = lang.clone(mixin[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn lang.clone(mixin);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mixin;\n\t\t}\n\t});\n\t\n\treturn du;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/utils.js\n// module id = 187\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/declare\", \"dojo/_base/connect\"], \n\tfunction(lang, arr, declare, hub){\n\n\treturn declare(\"dojox.charting.plot2d._PlotEvents\", null, {\n\t\tconstructor: function(){\n\t\t\tthis._shapeEvents = [];\n\t\t\tthis._eventSeries = {};\n\t\t},\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tDestroy any internal elements and event handlers.\n\t\t\tthis.resetEvents();\n\t\t\tthis.inherited(arguments);\n\t\t},\n\t\tplotEvent: function(o){\n\t\t\t// summary:\n\t\t\t//\t\tStub function for use by specific plots.\n\t\t\t// o: Object\n\t\t\t//\t\tAn object intended to represent event parameters.\n\t\t},\n\t\traiseEvent: function(o){\n\t\t\t// summary:\n\t\t\t//\t\tRaises events in predefined order\n\t\t\t// o: Object\n\t\t\t//\t\tAn object intended to represent event parameters.\n\t\t\tthis.plotEvent(o);\n\t\t\tvar t = lang.delegate(o);\n\t\t\tt.originalEvent = o.type;\n\t\t\tt.originalPlot  = o.plot;\n\t\t\tt.type = \"onindirect\";\n\t\t\tarr.forEach(this.chart.stack, function(plot){\n\t\t\t\tif(plot !== this && plot.plotEvent){\n\t\t\t\t\tt.plot = plot;\n\t\t\t\t\tplot.plotEvent(t);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t},\n\t\tconnect: function(object, method){\n\t\t\t// summary:\n\t\t\t//\t\tHelper function to connect any object's method to our plotEvent.\n\t\t\t// object: Object\n\t\t\t//\t\tThe object to connect to.\n\t\t\t// method: String|Function\n\t\t\t//\t\tThe method to fire when our plotEvent is fired.\n\t\t\t// returns: Array\n\t\t\t//\t\tThe handle as returned from dojo.connect (see dojo.connect).\n\t\t\tthis.dirty = true;\n\t\t\treturn hub.connect(this, \"plotEvent\", object, method);\t//\tArray\n\t\t},\n\t\tevents: function(){\n\t\t\t// summary:\n\t\t\t//\t\tFind out if any event handlers have been connected to our plotEvent.\n\t\t\t// returns: Boolean\n\t\t\t//\t\tA flag indicating that there are handlers attached.\n\t\t\treturn !!this.plotEvent.after;\n\t\t},\n\t\tresetEvents: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReset all events attached to our plotEvent (i.e. disconnect).\n\t\t\tif(this._shapeEvents.length){\n\t\t\t\tarr.forEach(this._shapeEvents, function(item){\n\t\t\t\t\titem.shape.disconnect(item.handle);\n\t\t\t\t});\n\t\t\t\tthis._shapeEvents = [];\n\t\t\t}\n\t\t\tthis.raiseEvent({type: \"onplotreset\", plot: this});\n\t\t},\n\t\t_connectSingleEvent: function(o, eventName){\n\t\t\tthis._shapeEvents.push({\n\t\t\t\tshape:  o.eventMask,\n\t\t\t\thandle: o.eventMask.connect(eventName, this, function(e){\n\t\t\t\t\to.type  = eventName;\n\t\t\t\t\to.event = e;\n\t\t\t\t\tthis.raiseEvent(o);\n\t\t\t\t\to.event = null;\n\t\t\t\t})\n\t\t\t});\n\t\t},\n\t\t_connectEvents: function(o){\n\t\t\tif(o){\n\t\t\t\to.chart = this.chart;\n\t\t\t\to.plot  = this;\n\t\t\t\to.hAxis = this.hAxis || null;\n\t\t\t\to.vAxis = this.vAxis || null;\n\t\t\t\to.eventMask = o.eventMask || o.shape;\n\t\t\t\tthis._connectSingleEvent(o, \"onmouseover\");\n\t\t\t\tthis._connectSingleEvent(o, \"onmouseout\");\n\t\t\t\tthis._connectSingleEvent(o, \"onclick\");\n\t\t\t}\n\t\t},\n\t\t_reconnectEvents: function(seriesName){\n\t\t\tvar a = this._eventSeries[seriesName];\n\t\t\tif(a){\n\t\t\t\tarr.forEach(a, this._connectEvents, this);\n\t\t\t}\n\t\t},\n\t\tfireEvent: function(seriesName, eventName, index, eventObject){\n\t\t\t// summary:\n\t\t\t//\t\tEmulates firing an event for a given data value (specified by\n\t\t\t//\t\tan index) of a given series.\n\t\t\t// seriesName: String\n\t\t\t//\t\tSeries name.\n\t\t\t// eventName: String\n\t\t\t//\t\tEvent name to emulate.\n\t\t\t// index: Number\n\t\t\t//\t\tValid data value index used to raise an event.\n\t\t\t// eventObject: Object?\n\t\t\t//\t\tOptional event object. Especially useful for synthetic events.\n\t\t\t//\t\tDefault: null.\n\t\t\tvar s = this._eventSeries[seriesName];\n\t\t\tif(s && s.length && index < s.length){\n\t\t\t\tvar o = s[index];\n\t\t\t\to.type  = eventName;\n\t\t\t\to.event = eventObject || null;\n\t\t\t\tthis.raiseEvent(o);\n\t\t\t\to.event = null;\n\t\t\t}\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/_PlotEvents.js\n// module id = 188\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/kernel\" ,\"./lambda\"],\n\tfunction(lang, kernel, df){\n// This module adds high-level functions and related constructs:\n//\t- reversed versions of array-processing functions similar to standard JS functions\n\n// Notes:\n//\t- this module provides reversed versions of standard array-processing functions:\n//\t\tforEachRev, mapRev, filterRev\n\n// Defined methods:\n//\t- take any valid lambda argument as the functional argument\n//\t- operate on dense arrays\n//\t- take a string as the array argument\n\n\tlang.mixin(df, {\n\t\t// JS 1.6 standard array functions, which can take a lambda as a parameter.\n\t\t// Consider using dojo._base.array functions, if you don't need the lambda support.\n\t\tfilterRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a new array with all elements that pass the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t = [], v, i = a.length - 1;\n\t\t\tfor(; i >= 0; --i){\n\t\t\t\tv = a[i];\n\t\t\t\tif(f.call(o, v, i, a)){ t.push(v); }\n\t\t\t}\n\t\t\treturn t;\t// Array\n\t\t},\n\t\tforEachRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\texecutes a provided function once per array element.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i = a.length - 1; i >= 0; f.call(o, a[i], i, a), --i);\n\t\t},\n\t\tmapRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates a new array with the results of calling\n\t\t\t//\t\ta provided function on every element in this array.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar n = a.length, t = new Array(n), i = n - 1, j = 0;\n\t\t\tfor(; i >= 0; t[j++] = f.call(o, a[i], i, a), --i);\n\t\t\treturn t;\t// Array\n\t\t},\n\t\teveryRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\ttests whether all elements in the array pass the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i = a.length - 1; i >= 0; --i){\n\t\t\t\tif(!f.call(o, a[i], i, a)){\n\t\t\t\t\treturn false;\t// Boolean\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\t// Boolean\n\t\t},\n\t\tsomeRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\ttests whether some element in the array passes the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i = a.length - 1; i >= 0; --i){\n\t\t\t\tif(f.call(o, a[i], i, a)){\n\t\t\t\t\treturn true;\t// Boolean\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\t// Boolean\n\t\t}\n\t});\n\t\n\treturn df;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/functional/reversed.js\n// module id = 189\n// module chunks = 4","define([\n\t\"dojo/_base/lang\",\n\t\"dojox/lang/functional\",\n\t\"./common\"\n], function(lang, df, common){\n\t\n\tvar commonStacked = lang.getObject(\"dojox.charting.plot2d.commonStacked\", true);\n\treturn lang.mixin(commonStacked, {\n\t\tcollectStats: function(series, isNullValue){\n\t\t\tvar stats = lang.delegate(common.defaultStats);\n\t\t\tfor(var i = 0; i < series.length; ++i){\n\t\t\t\tvar run = series[i];\n\t\t\t\tfor(var j = 0; j < run.data.length; j++){\n\t\t\t\t\tvar x, y;\n\t\t\t\t\tif(run.data[j] !== null){\n\t\t\t\t\t\tif(typeof run.data[j] == \"number\" || !run.data[j].hasOwnProperty(\"x\")){\n\t\t\t\t\t\t\ty = commonStacked.getIndexValue(series, i, j, isNullValue)[0];\n\t\t\t\t\t\t\tx = j+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx = run.data[j].x;\n\t\t\t\t\t\t\tif(x !== null){\n\t\t\t\t\t\t\t\ty = commonStacked.getValue(series, i, x, isNullValue)[0];\n\t\t\t\t\t\t\t\ty = y != null && y.y ? y.y:null; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, y);\n\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stats;\n\t\t},\n\t\t\n\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t// collect references to non-empty sets\n\t\t\tvar sets = df.filter(values, \"x\"), n = sets.length;\n\t\t\tif(!n){\n\t\t\t\t// nothing to do at all\n\t\t\t\treturn values;\n\t\t\t}\n\n\t\t\t// stack values\n\t\t\tvar previousSet = {};\n\t\t\tfor(var i = 0; i < n; ++i){\n\t\t\t\tvar extractedSet = sets[i];\n\t\t\t\tfor(var j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\textractedSet[j] = (extractedSet[j] || 0) + (previousSet[j] || 0);\n\t\t\t\t}\n\t\t\t\tpreviousSet = extractedSet;\n\t\t\t}\n\n\t\t\t// transform to pixels\n\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\textractedSet = sets[i];\n\t\t\t\tfor(j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\textractedSet[j] = this.isNullValue(extractedSet[j]) ? 0 :\n\t\t\t\t\t\ttransform(extractedSet[j]) - baseline;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// correct the minimal width\n\t\t\tif(this.opt.minWidth){\n\t\t\t\tvar minWidth = this.opt.minWidth;\n\n\t\t\t\t// unstack\n\t\t\t\tfor(i = n - 1; i; --i){\n\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\tpreviousSet  = sets[i - 1];\n\t\t\t\t\tfor(j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\textractedSet[j] = extractedSet[j] - previousSet[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now let's go over all values and correct them, if needed\n\t\t\t\tvar min = extractedSet.min, max = extractedSet.max;\n\t\t\t\tfor(var j = min; j < max; ++j){\n\n\t\t\t\t\t// find a total length of stack\n\t\t\t\t\tvar sum = 0, counter = 0;\n\t\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\t\tvar value = sets[i][j];\n\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\tsum += value;\n\t\t\t\t\t\t\t++counter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum <= counter * minWidth){\n\t\t\t\t\t\t// the corner case: all values are very small\n\t\t\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\t\t\tvalue = sets[i][j];\n\t\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\t\tsets[i][j] = minWidth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\t// next stack\n\t\t\t\t\t}\n\n\t\t\t\t\t// distributing overflow up\n\t\t\t\t\tvar overflow = 0;\n\t\t\t\t\tfor(i = 0; i < n; ++i){\n\t\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\t\tvalue = extractedSet[j];\n\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\tif(value < minWidth){\n\t\t\t\t\t\t\t\toverflow += minWidth - value;\n\t\t\t\t\t\t\t\textractedSet[j] = minWidth;\n\t\t\t\t\t\t\t}else if(overflow > 0){\n\t\t\t\t\t\t\t\t// calculate available space\n\t\t\t\t\t\t\t\tvar available = extractedSet[j] - minWidth;\n\t\t\t\t\t\t\t\tif(available >= overflow){\n\t\t\t\t\t\t\t\t\textractedSet[j] -= overflow;\n\t\t\t\t\t\t\t\t\toverflow = 0;\n\t\t\t\t\t\t\t\t}else if(available > 0){\n\t\t\t\t\t\t\t\t\textractedSet[j] = minWidth;\n\t\t\t\t\t\t\t\t\toverflow -= available;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// distributing overflow down, if any\n\t\t\t\t\tif(overflow > 0){\n\t\t\t\t\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\t\t\tvalue = extractedSet[j];\n\t\t\t\t\t\t\tif(value > 0){\n\t\t\t\t\t\t\t\t// calculate available space\n\t\t\t\t\t\t\t\tavailable = extractedSet[j] - minWidth;\n\t\t\t\t\t\t\t\tif(available >= overflow){\n\t\t\t\t\t\t\t\t\textractedSet[j] -= overflow;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else if(available > 0){\n\t\t\t\t\t\t\t\t\textractedSet[j] = minWidth;\n\t\t\t\t\t\t\t\t\toverflow -= available;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// stack\n\t\t\t\tfor(i = 1; i < n; ++i){\n\t\t\t\t\textractedSet = sets[i];\n\t\t\t\t\tpreviousSet  = sets[i - 1];\n\t\t\t\t\tfor(j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\textractedSet[j] = extractedSet[j] + previousSet[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values;\n\t\t},\n\n\t\tgetIndexValue: function(series, i, index, isNullValue){\n\t\t\tvar value = 0, v, j;\n\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\tv = series[j].data[index];\n\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\tif(isNaN(v)){ v = v.y || 0; }\n\t\t\t\t\tvalue += v;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\t\tgetValue: function(series, i, x, isNullValue){\n\t\t\tvar value = null, j, z;\n\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\tfor(z = 0; z < series[j].data.length; z++){\n\t\t\t\t\tv = series[j].data[z];\n\t\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\t\tif(v.x == x){\n\t\t\t\t\t\t\tif(!value){\n\t\t\t\t\t\t\t\tvalue = {x: x};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(v.y != null){\n\t\t\t\t\t\t\t\tif(value.y == null){\n\t\t\t\t\t\t\t\t\tvalue.y = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalue.y += v.y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(v.x > x){break;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\t\n\t\tgetIndexValue: function(series, i, index, isNullValue){\n\t\t\tvar value = 0, v, j, pvalue;\n\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\tif(series[j].hidden){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpvalue = value;\n\t\t\t\tv = series[j].data[index];\n\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\tif(isNaN(v)){ v = v.y || 0; }\n\t\t\t\t\tvalue += v;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [value , pvalue];\n\t\t},\n\t\t\n\t\tgetValue: function(series, i, x, isNullValue){\n\t\t\tvar value = null, j, z, v, pvalue;\n\t\t\tfor(j = 0; j <= i; ++j){\n\t\t\t\tif(series[j].hidden){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(z = 0; z < series[j].data.length; z++){\n\t\t\t\t\tpvalue = value;\n\t\t\t\t\tv = series[j].data[z];\n\t\t\t\t\tif(!isNullValue(v)){\n\t\t\t\t\t\tif(v.x == x){\n\t\t\t\t\t\t\tif(!value){\n\t\t\t\t\t\t\t\tvalue = {x: x};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(v.y != null){\n\t\t\t\t\t\t\t\tif(value.y == null){\n\t\t\t\t\t\t\t\t\tvalue.y = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalue.y += v.y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(v.x > x){break;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [value, pvalue];\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/commonStacked.js\n// module id = 190\n// module chunks = 4","define([\"../main\", \"dojo/_base/lang\", \"dojo/_base/array\",\"dojo/_base/declare\", \"dojo/dom-style\",\n\t\"dojo/dom\", \"dojo/dom-geometry\", \"dojo/dom-construct\",\"dojo/_base/Color\", \"dojo/sniff\",\n\t\"./Element\", \"./SimpleTheme\", \"./Series\", \"./axis2d/common\", \"dojox/gfx/shape\",\n\t\"dojox/gfx\", \"dojo/has!dojo-bidi?./bidi/Chart\", \"dojox/lang/functional\", \"dojox/lang/functional/fold\", \"dojox/lang/functional/reversed\"],\n\tfunction(dojox, lang, arr, declare, domStyle,\n\t \t\t dom, domGeom, domConstruct, Color, has,\n\t \t\t Element, SimpleTheme, Series, common, shape,\n\t \t\t g, BidiChart, func){\n\t/*=====\n\tvar __ChartCtorArgs = {\n\t\t// summary:\n\t\t//\t\tThe keyword arguments that can be passed in a Chart constructor.\n\t\t// margins: Object?\n\t\t//\t\tOptional margins for the chart, in the form of { l, t, r, b}.\n\t\t// stroke: dojox.gfx.Stroke?\n\t\t//\t\tAn optional outline/stroke for the chart.\n\t\t// fill: dojox.gfx.Fill?\n\t\t//\t\tAn optional fill for the chart.\n\t\t// delayInMs: Number\n\t\t//\t\tDelay in ms for delayedRender(). Default: 200.\n\t};\n\t=====*/\n\n\t/*=====\n\tvar __SeriesCtorArgs = {\n\t\t// summary:\n\t\t//\t\tAn optional arguments object that can be used in the Series constructor.\n\t\t// plot: String?\n\t\t//\t\tThe plot (by name) that this series belongs to.\n\t};\n\t=====*/\n\n\t/*=====\n\tvar __BaseAxisCtorArgs = {\n\t\t// summary:\n\t\t//\t\tOptional arguments used in the definition of an invisible axis.\n\t\t// vertical: Boolean?\n\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t// min: Number?\n\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t// max: Number?\n\t\t//\t\tThe largest value on an axis. Default is 1.\n\t};\n\t=====*/\n\n\tvar dc = lang.getObject(\"charting\", true, dojox),\n\t\tclear = func.lambda(\"item.clear()\"),\n\t\tpurge = func.lambda(\"item.purgeGroup()\"),\n\t\tdestroy = func.lambda(\"item.destroy()\"),\n\t\tmakeClean = func.lambda(\"item.dirty = false\"),\n\t\tmakeDirty = func.lambda(\"item.dirty = true\"),\n\t\tgetName = func.lambda(\"item.name\"),\n\t\tdefaultMargins = {l: 10, t: 10, r: 10, b: 10};\n\n\tvar Chart = declare(has(\"dojo-bidi\")? \"dojox.charting.NonBidiChart\" : \"dojox.charting.Chart\", null, {\n\t\t// summary:\n\t\t//\t\tThe main chart object in dojox.charting.  This will create a two dimensional\n\t\t//\t\tchart based on dojox.gfx.\n\t\t//\n\t\t// description:\n\t\t//\t\tdojox.charting.Chart is the primary object used for any kind of charts.  It\n\t\t//\t\tis simple to create--just pass it a node reference, which is used as the\n\t\t//\t\tcontainer for the chart--and a set of optional keyword arguments and go.\n\t\t//\n\t\t//\t\tNote that like most of dojox.gfx, most of dojox.charting.Chart's methods are\n\t\t//\t\tdesigned to return a reference to the chart itself, to allow for functional\n\t\t//\t\tchaining.  This makes defining everything on a Chart very easy to do.\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate an area chart, with smoothing.\n\t\t//\t|\trequire([\"dojox/charting/Chart\", \"dojox/charting/themes/Shrooms\", \"dojox/charting/plot2d/Areas\", ...],\n\t\t// \t|\t\tfunction(Chart, Shrooms, Areas, ...){\n\t\t//\t|\t\tnew Chart(node)\n\t\t//\t|\t\t\t.addPlot(\"default\", { type: Areas, tension: \"X\" })\n\t\t//\t|\t\t\t.setTheme(Shrooms)\n\t\t//\t|\t\t\t.addSeries(\"Series A\", [1, 2, 0.5, 1.5, 1, 2.8, 0.4])\n\t\t//\t|\t\t\t.addSeries(\"Series B\", [2.6, 1.8, 2, 1, 1.4, 0.7, 2])\n\t\t//\t|\t\t\t.addSeries(\"Series C\", [6.3, 1.8, 3, 0.5, 4.4, 2.7, 2])\n\t\t//\t|\t\t\t.render();\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tThe form of data in a data series can take a number of forms: a simple array,\n\t\t//\t\tan array of objects {x,y}, or something custom (as determined by the plot).\n\t\t//\t\tHere's an example of a Candlestick chart, which expects an object of\n\t\t//\t\t{ open, high, low, close }.\n\t\t//\t|\trequire([\"dojox/charting/Chart\", \"dojox/charting/plot2d/Candlesticks\", ...],\n\t\t// \t|\t\tfunction(Chart, Candlesticks, ...){\n\t\t//\t|\t\tnew Chart(node)\n\t\t//\t|\t\t\t.addPlot(\"default\", {type: Candlesticks, gap: 1})\n\t\t//\t|\t\t\t.addAxis(\"x\", {fixLower: \"major\", fixUpper: \"major\", includeZero: true})\n\t\t//\t|\t\t\t.addAxis(\"y\", {vertical: true, fixLower: \"major\", fixUpper: \"major\", natural: true})\n\t\t//\t|\t\t\t.addSeries(\"Series A\", [\n\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 },\n\t\t//\t|\t\t\t\t\t{ open: 16, close: 22, high: 26, low: 6, mid: 18 },\n\t\t//\t|\t\t\t\t\t{ open: 22, close: 18, high: 22, low: 11, mid: 21 },\n\t\t//\t|\t\t\t\t\t{ open: 18, close: 29, high: 32, low: 14, mid: 27 },\n\t\t//\t|\t\t\t\t\t{ open: 29, close: 24, high: 29, low: 13, mid: 27 },\n\t\t//\t|\t\t\t\t\t{ open: 24, close: 8, high: 24, low: 5 },\n\t\t//\t|\t\t\t\t\t{ open: 8, close: 16, high: 22, low: 2 },\n\t\t//\t|\t\t\t\t\t{ open: 16, close: 12, high: 19, low: 7 },\n\t\t//\t|\t\t\t\t\t{ open: 12, close: 20, high: 22, low: 8 },\n\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 },\n\t\t//\t|\t\t\t\t\t{ open: 16, close: 22, high: 26, low: 6, mid: 18 },\n\t\t//\t|\t\t\t\t\t{ open: 22, close: 18, high: 22, low: 11, mid: 21 },\n\t\t//\t|\t\t\t\t\t{ open: 18, close: 29, high: 32, low: 14, mid: 27 },\n\t\t//\t|\t\t\t\t\t{ open: 29, close: 24, high: 29, low: 13, mid: 27 },\n\t\t//\t|\t\t\t\t\t{ open: 24, close: 8, high: 24, low: 5 },\n\t\t//\t|\t\t\t\t\t{ open: 8, close: 16, high: 22, low: 2 },\n\t\t//\t|\t\t\t\t\t{ open: 16, close: 12, high: 19, low: 7 },\n\t\t//\t|\t\t\t\t\t{ open: 12, close: 20, high: 22, low: 8 },\n\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 },\n\t\t//\t|\t\t\t\t\t{ open: 16, close: 22, high: 26, low: 6 },\n\t\t//\t|\t\t\t\t\t{ open: 22, close: 18, high: 22, low: 11 },\n\t\t//\t|\t\t\t\t\t{ open: 18, close: 29, high: 32, low: 14 },\n\t\t//\t|\t\t\t\t\t{ open: 29, close: 24, high: 29, low: 13 },\n\t\t//\t|\t\t\t\t\t{ open: 24, close: 8, high: 24, low: 5 },\n\t\t//\t|\t\t\t\t\t{ open: 8, close: 16, high: 22, low: 2 },\n\t\t//\t|\t\t\t\t\t{ open: 16, close: 12, high: 19, low: 7 },\n\t\t//\t|\t\t\t\t\t{ open: 12, close: 20, high: 22, low: 8 },\n\t\t//\t|\t\t\t\t\t{ open: 20, close: 16, high: 22, low: 8 }\n\t\t//\t|\t\t\t\t],\n\t\t//\t|\t\t\t\t{ stroke: { color: \"green\" }, fill: \"lightgreen\" }\n\t\t//\t|\t\t\t)\n\t\t//\t|\t\t\t.render();\n\t\t//\t|\t});\n\t\t\n\t\t// theme: dojox/charting/SimpleTheme?\n\t\t//\t\tAn optional theme to use for styling the chart.\n\t\t// axes: dojox/charting/axis2d/Base{}?\n\t\t//\t\tA map of axes for use in plotting a chart.\n\t\t// stack: dojox/charting/plot2d/Base[]\n\t\t//\t\tA stack of plotters.\n\t\t// plots: dojox/charting/plot2d/Base{}\n\t\t//\t\tA map of plotter indices\n\t\t// series: dojox/charting/Series[]\n\t\t//\t\tThe stack of data runs used to create plots.\n\t\t// runs: dojox/charting/Series{}\n\t\t//\t\tA map of series indices\n\t\t// margins: Object?\n\t\t//\t\tThe margins around the chart. Default is { l:10, t:10, r:10, b:10 }.\n\t\t// stroke: dojox.gfx.Stroke?\n\t\t//\t\tThe outline of the chart (stroke in vector graphics terms).\n\t\t// fill: dojox.gfx.Fill?\n\t\t//\t\tThe color for the chart.\n\t\t// node: DOMNode\n\t\t//\t\tThe container node passed to the constructor.\n\t\t// surface: dojox/gfx/shape.Surface\n\t\t//\t\tThe main graphics surface upon which a chart is drawn.\n\t\t// dirty: Boolean\n\t\t//\t\tA boolean flag indicating whether or not the chart needs to be updated/re-rendered.\n\t\t// htmlLabels: Boolean\n\t\t//\t\tA boolean flag indicating whether or not it should try to use HTML-based labels for the title or not.\n\t\t//\t\tThe default is true.  The only caveat is IE and Opera browsers will always use GFX-based labels.\n\n\t\tconstructor: function(/* DOMNode */node, /* __ChartCtorArgs? */kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for a new Chart.  Initializes all parameters used for a chart.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tThe newly created chart.\n\n\t\t\t// initialize parameters\n\t\t\tif(!kwArgs){ kwArgs = {}; }\n\t\t\tthis.margins = kwArgs.margins || defaultMargins;\n\t\t\tthis._customMargins = !!kwArgs.margins;\n\t\t\tthis.stroke    = kwArgs.stroke;\n\t\t\tthis.fill      = kwArgs.fill;\n\t\t\tthis.delayInMs = kwArgs.delayInMs || 200;\n\t\t\tthis.title     = kwArgs.title;\n\t\t\tthis.titleGap  = kwArgs.titleGap;\n\t\t\tthis.titlePos  = kwArgs.titlePos;\n\t\t\tthis.titleFont = kwArgs.titleFont;\n\t\t\tthis.titleFontColor = kwArgs.titleFontColor;\n\t\t\tthis.titleAlign = kwArgs.titleAlign; // This can be middle, left, right, or edge \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // edge is left or right aligned with chart plot edge depending on bidi.\n\t\t\tthis.chartTitle = null;\n\t\t\tthis.htmlLabels = true;\n\t\t\tif(\"htmlLabels\" in kwArgs){\n\t\t\t\tthis.htmlLabels = kwArgs.htmlLabels;\n\t\t\t}\n\n\t\t\t// default initialization\n\t\t\tthis.theme = null;\n\t\t\tthis.axes = {};\t\t// map of axes\n\t\t\tthis.stack = [];\t// stack of plotters\n\t\t\tthis.plots = {};\t// map of plotter indices\n\t\t\tthis.series = [];\t// stack of data runs\n\t\t\tthis.runs = {};\t\t// map of data run indices\n\t\t\tthis.dirty = true;\n\n\t\t\t// create a surface\n\t\t\tthis.node = dom.byId(node);\n\t\t\tvar box = domGeom.getMarginBox(node);\n\t\t\tthis.surface = g.createSurface(this.node, box.w || 400, box.h || 300);\n\t\t\tif(this.surface.declaredClass.indexOf(\"vml\") == -1){\n\t\t\t\t// except if vml use native clipping\n\t\t\t\tthis._nativeClip = true;\n\t\t\t}\n\t\t},\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCleanup when a chart is to be destroyed.\n\t\t\t// returns: void\n\t\t\tarr.forEach(this.series, destroy);\n\t\t\tarr.forEach(this.stack,  destroy);\n\t\t\tfunc.forIn(this.axes, destroy);\n\t\t\tthis.surface.destroy();\n\t\t\tif(this.chartTitle && this.chartTitle.tagName){\n\t\t\t\t// destroy title if it is a DOM node\n\t\t\t\tdomConstruct.destroy(this.chartTitle);\n\t\t\t}\n\t\t},\n\t\tgetCoords: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet the coordinates and dimensions of the containing DOMNode, as\n\t\t\t//\t\treturned by dojo.coords.\n\t\t\t// returns: Object\n\t\t\t//\t\tThe resulting coordinates of the chart.  See dojo.coords for details.\n\t\t\tvar node = this.node;\n\t\t\tvar s = domStyle.getComputedStyle(node), coords = domGeom.getMarginBox(node, s);\n\t\t\tvar abs = domGeom.position(node, true);\n\t\t\tcoords.x = abs.x;\n\t\t\tcoords.y = abs.y;\n\t\t\treturn coords;\t//\tObject\n\t\t},\n\t\tsetTheme: function(theme){\n\t\t\t// summary:\n\t\t\t//\t\tSet a theme of the chart.\n\t\t\t// theme: dojox/charting/SimpleTheme\n\t\t\t//\t\tThe theme to be used for visual rendering.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tthis.theme = theme.clone();\n\t\t\tif(!this._customMargins){\n\t\t\t\tthis.margins = this.theme.chart.margins || defaultMargins;\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\taddAxis: function(name, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tAdd an axis to the chart, for rendering.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the axis.\n\t\t\t// kwArgs: __BaseAxisCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object for use in defining details of an axis.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tvar axis, axisType = kwArgs && kwArgs.type || \"Default\";\n\t\t\tif(typeof axisType == \"string\"){\n\t\t\t\tif(!dc.axis2d || !dc.axis2d[axisType]){\n\t\t\t\t\tthrow Error(\"Can't find axis: \" + axisType + \" - Check \" + \"require() dependencies.\");\n\t\t\t\t}\n\t\t\t\taxis = new dc.axis2d[axisType](this, kwArgs);\n\t\t\t}else{\n\t\t\t\taxis = new axisType(this, kwArgs);\n\t\t\t}\n\t\t\taxis.name = name;\n\t\t\taxis.dirty = true;\n\t\t\tif(name in this.axes){\n\t\t\t\tthis.axes[name].destroy();\n\t\t\t}\n\t\t\tthis.axes[name] = axis;\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tgetAxis: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tGet the given axis, by name.\n\t\t\t// name: String\n\t\t\t//\t\tThe name the axis was defined by.\n\t\t\t// returns: dojox/charting/axis2d/Default\n\t\t\t//\t\tThe axis as stored in the chart's axis map.\n\t\t\treturn this.axes[name];\t//\tdojox/charting/axis2d/Default\n\t\t},\n\t\tremoveAxis: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tRemove the axis that was defined using name.\n\t\t\t// name: String\n\t\t\t//\t\tThe axis name, as defined in addAxis.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.axes){\n\t\t\t\t// destroy the axis\n\t\t\t\tthis.axes[name].destroy();\n\t\t\t\tdelete this.axes[name];\n\t\t\t\t// mark the chart as dirty\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\taddPlot: function(name, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a new plot to the chart, defined by name and using the optional keyword arguments object.\n\t\t\t//\t\tNote that dojox.charting assumes the main plot to be called \"default\"; if you do not have\n\t\t\t//\t\ta plot called \"default\" and attempt to add data series to the chart without specifying the\n\t\t\t//\t\tplot to be rendered on, you WILL get errors.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the plot to be added to the chart.  If you only plan on using one plot, call it \"default\".\n\t\t\t// kwArgs: dojox.charting.plot2d.__PlotCtorArgs\n\t\t\t//\t\tAn object with optional parameters for the plot in question.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tvar plot, plotType = kwArgs && kwArgs.type || \"Default\";\n\t\t\tif(typeof plotType == \"string\"){\n\t\t\t\tif(!dc.plot2d || !dc.plot2d[plotType]){\n\t\t\t\t\tthrow Error(\"Can't find plot: \" + plotType + \" - didn't you forget to dojo\" + \".require() it?\");\n\t\t\t\t}\n\t\t\t\tplot = new dc.plot2d[plotType](this, kwArgs);\n\t\t\t}else{\n\t\t\t\tplot = new plotType(this, kwArgs);\n\t\t\t}\n\t\t\tplot.name = name;\n\t\t\tplot.dirty = true;\n\t\t\tif(name in this.plots){\n\t\t\t\tthis.stack[this.plots[name]].destroy();\n\t\t\t\tthis.stack[this.plots[name]] = plot;\n\t\t\t}else{\n\t\t\t\tthis.plots[name] = this.stack.length;\n\t\t\t\tthis.stack.push(plot);\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tgetPlot: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tGet the given plot, by name.\n\t\t\t// name: String\n\t\t\t//\t\tThe name the plot was defined by.\n\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t//\t\tThe plot.\n\t\t\treturn this.stack[this.plots[name]];\n\t\t},\n\t\tremovePlot: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tRemove the plot defined using name from the chart's plot stack.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the plot as defined using addPlot.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.plots){\n\t\t\t\t// get the index and remove the name\n\t\t\t\tvar index = this.plots[name];\n\t\t\t\tdelete this.plots[name];\n\t\t\t\t// destroy the plot\n\t\t\t\tthis.stack[index].destroy();\n\t\t\t\t// remove the plot from the stack\n\t\t\t\tthis.stack.splice(index, 1);\n\t\t\t\t// update indices to reflect the shift\n\t\t\t\tfunc.forIn(this.plots, function(idx, name, plots){\n\t\t\t\t\tif(idx > index){\n\t\t\t\t\t\tplots[name] = idx - 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// remove all related series\n\t\t\t\tvar ns = arr.filter(this.series, function(run){ return run.plot != name; });\n\t\t\t\tif(ns.length < this.series.length){\n\t\t\t\t\t// kill all removed series\n\t\t\t\t\tarr.forEach(this.series, function(run){\n\t\t\t\t\t\tif(run.plot == name){\n\t\t\t\t\t\t\trun.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t// rebuild all necessary data structures\n\t\t\t\t\tthis.runs = {};\n\t\t\t\t\tarr.forEach(ns, function(run, index){\n\t\t\t\t\t\tthis.runs[run.plot] = index;\n\t\t\t\t\t}, this);\n\t\t\t\t\tthis.series = ns;\n\t\t\t\t}\n\t\t\t\t// mark the chart as dirty\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tgetPlotOrder: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an array of plot names in the current order\n\t\t\t//\t\t(the top-most plot is the first).\n\t\t\t// returns: Array\n\t\t\treturn func.map(this.stack, getName); // Array\n\t\t},\n\t\tsetPlotOrder: function(newOrder){\n\t\t\t// summary:\n\t\t\t//\t\tSets new order of plots. newOrder cannot add or remove\n\t\t\t//\t\tplots. Wrong names, or dups are ignored.\n\t\t\t// newOrder: Array\n\t\t\t//\t\tArray of plot names compatible with getPlotOrder().\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tvar names = {},\n\t\t\t\torder = func.filter(newOrder, function(name){\n\t\t\t\t\tif(!(name in this.plots) || (name in names)){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tnames[name] = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}, this);\n\t\t\tif(order.length < this.stack.length){\n\t\t\t\tfunc.forEach(this.stack, function(plot){\n\t\t\t\t\tvar name = plot.name;\n\t\t\t\t\tif(!(name in names)){\n\t\t\t\t\t\torder.push(name);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar newStack = func.map(order, function(name){\n\t\t\t\t\treturn this.stack[this.plots[name]];\n\t\t\t\t}, this);\n\t\t\tfunc.forEach(newStack, function(plot, i){\n\t\t\t\tthis.plots[plot.name] = i;\n\t\t\t}, this);\n\t\t\tthis.stack = newStack;\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tmovePlotToFront: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tMoves a given plot to front.\n\t\t\t// name: String\n\t\t\t//\t\tPlot's name to move.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.plots){\n\t\t\t\tvar index = this.plots[name];\n\t\t\t\tif(index){\n\t\t\t\t\tvar newOrder = this.getPlotOrder();\n\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\tnewOrder.unshift(name);\n\t\t\t\t\treturn this.setPlotOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tmovePlotToBack: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tMoves a given plot to back.\n\t\t\t// name: String\n\t\t\t//\t\tPlot's name to move.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.plots){\n\t\t\t\tvar index = this.plots[name];\n\t\t\t\tif(index < this.stack.length - 1){\n\t\t\t\t\tvar newOrder = this.getPlotOrder();\n\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\tnewOrder.push(name);\n\t\t\t\t\treturn this.setPlotOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\taddSeries: function(name, data, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a data series to the chart for rendering.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the data series to be plotted.\n\t\t\t// data: Array|Object\n\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t// kwArgs: __SeriesCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object that will be mixed into\n\t\t\t//\t\tthe resultant series object.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tvar run = new Series(this, data, kwArgs);\n\t\t\trun.name = name;\n\t\t\tif(name in this.runs){\n\t\t\t\tthis.series[this.runs[name]].destroy();\n\t\t\t\tthis.series[this.runs[name]] = run;\n\t\t\t}else{\n\t\t\t\tthis.runs[name] = this.series.length;\n\t\t\t\tthis.series.push(run);\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t\t// fix min/max\n\t\t\tif(!(\"ymin\" in run) && \"min\" in run){ run.ymin = run.min; }\n\t\t\tif(!(\"ymax\" in run) && \"max\" in run){ run.ymax = run.max; }\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tgetSeries: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tGet the given series, by name.\n\t\t\t// name: String\n\t\t\t//\t\tThe name the series was defined by.\n\t\t\t// returns: dojox/charting/Series\n\t\t\t//\t\tThe series.\n\t\t\treturn this.series[this.runs[name]];\n\t\t},\n\t\tremoveSeries: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tRemove the series defined by name from the chart.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the series as defined by addSeries.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.runs){\n\t\t\t\t// get the index and remove the name\n\t\t\t\tvar index = this.runs[name];\n\t\t\t\tdelete this.runs[name];\n\t\t\t\t// destroy the run\n\t\t\t\tthis.series[index].destroy();\n\t\t\t\t// remove the run from the stack of series\n\t\t\t\tthis.series.splice(index, 1);\n\t\t\t\t// update indices to reflect the shift\n\t\t\t\tfunc.forIn(this.runs, function(idx, name, runs){\n\t\t\t\t\tif(idx > index){\n\t\t\t\t\t\truns[name] = idx - 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tupdateSeries: function(name, data, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tUpdate the given series with a new set of data points.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the series as defined in addSeries.\n\t\t\t// data: Array|Object\n\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t// offsets: Boolean?\n\t\t\t//\t\tIf true recomputes the offsets of the chart based on the new\n\t\t\t//\t\tdata. This is useful if the range of data is drastically changing\n\t\t\t//\t\tand offsets need to be recomputed.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.runs){\n\t\t\t\tvar run = this.series[this.runs[name]];\n\t\t\t\trun.update(data);\n\t\t\t\tif(offsets){\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}else{\n\t\t\t\t\tthis._invalidateDependentPlots(run.plot, false);\n\t\t\t\t\tthis._invalidateDependentPlots(run.plot, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tgetSeriesOrder: function(plotName){\n\t\t\t// summary:\n\t\t\t//\t\tReturns an array of series names in the current order\n\t\t\t//\t\t(the top-most series is the first) within a plot.\n\t\t\t// plotName: String\n\t\t\t//\t\tPlot's name.\n\t\t\t// returns: Array\n\t\t\treturn func.map(func.filter(this.series, function(run){\n\t\t\t\t\treturn run.plot == plotName;\n\t\t\t\t}), getName);\n\t\t},\n\t\tsetSeriesOrder: function(newOrder){\n\t\t\t// summary:\n\t\t\t//\t\tSets new order of series within a plot. newOrder cannot add\n\t\t\t//\t\tor remove series. Wrong names, or dups are ignored.\n\t\t\t// newOrder: Array\n\t\t\t//\t\tArray of series names compatible with getPlotOrder(). All\n\t\t\t//\t\tseries should belong to the same plot.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tvar plotName, names = {},\n\t\t\t\torder = func.filter(newOrder, function(name){\n\t\t\t\t\tif(!(name in this.runs) || (name in names)){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar run = this.series[this.runs[name]];\n\t\t\t\t\tif(plotName){\n\t\t\t\t\t\tif(run.plot != plotName){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tplotName = run.plot;\n\t\t\t\t\t}\n\t\t\t\t\tnames[name] = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}, this);\n\t\t\tfunc.forEach(this.series, function(run){\n\t\t\t\tvar name = run.name;\n\t\t\t\tif(!(name in names) && run.plot == plotName){\n\t\t\t\t\torder.push(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar newSeries = func.map(order, function(name){\n\t\t\t\t\treturn this.series[this.runs[name]];\n\t\t\t\t}, this);\n\t\t\tthis.series = newSeries.concat(func.filter(this.series, function(run){\n\t\t\t\treturn run.plot != plotName;\n\t\t\t}));\n\t\t\tfunc.forEach(this.series, function(run, i){\n\t\t\t\tthis.runs[run.name] = i;\n\t\t\t}, this);\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tmoveSeriesToFront: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tMoves a given series to front of a plot.\n\t\t\t// name: String\n\t\t\t//\t\tSeries' name to move.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.runs){\n\t\t\t\tvar index = this.runs[name],\n\t\t\t\t\tnewOrder = this.getSeriesOrder(this.series[index].plot);\n\t\t\t\tif(name != newOrder[0]){\n\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\tnewOrder.unshift(name);\n\t\t\t\t\treturn this.setSeriesOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tmoveSeriesToBack: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tMoves a given series to back of a plot.\n\t\t\t// name: String\n\t\t\t//\t\tSeries' name to move.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(name in this.runs){\n\t\t\t\tvar index = this.runs[name],\n\t\t\t\t\tnewOrder = this.getSeriesOrder(this.series[index].plot);\n\t\t\t\tif(name != newOrder[newOrder.length - 1]){\n\t\t\t\t\tnewOrder.splice(index, 1);\n\t\t\t\t\tnewOrder.push(name);\n\t\t\t\t\treturn this.setSeriesOrder(newOrder);\t//\tdojox/charting/Chart\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tresize: function(width, height){\n\t\t\t// summary:\n\t\t\t//\t\tResize the chart to the dimensions of width and height.\n\t\t\t// description:\n\t\t\t//\t\tResize the chart and its surface to the width and height dimensions.\n\t\t\t//\t\tIf a single argument of the form {w: value1, h: value2} is provided take that argument as the dimensions to use.\n\t\t\t//\t\tFinally if no argument is provided, resize the surface to the marginBox of the chart.\n\t\t\t// width: Number|Object?\n\t\t\t//\t\tThe new width of the chart or the box definition.\n\t\t\t// height: Number?\n\t\t\t//\t\tThe new height of the chart.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tswitch(arguments.length){\n\t\t\t\t// case 0, do not resize the div, just the surface\n\t\t\t\tcase 1:\n\t\t\t\t\t// argument, override node box\n\t\t\t\t\tdomGeom.setMarginBox(this.node, width);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// argument, override node box\n\t\t\t\t\tdomGeom.setMarginBox(this.node, {w: width, h: height});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// in all cases take back the computed box\n\t\t\tvar box = domGeom.getMarginBox(this.node);\n\t\t\tvar d = this.surface.getDimensions();\n\t\t\tif(d.width != box.w || d.height != box.h){\n\t\t\t\t// and set it on the surface\n\t\t\t\tthis.surface.setDimensions(box.w, box.h);\n\t\t\t\tthis.dirty = true;\n\t\t\t\treturn this.render();\t//\tdojox/charting/Chart\n\t\t\t}else{\n\t\t\t\treturn this;\n\t\t\t}\n\t\t},\n\t\tgetGeometry: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a map of information about all axes in a chart and what they represent\n\t\t\t//\t\tin terms of scaling (see dojox.charting.axis2d.Default.getScaler).\n\t\t\t// returns: Object\n\t\t\t//\t\tAn map of geometry objects, a one-to-one mapping of axes.\n\t\t\tvar ret = {};\n\t\t\tfunc.forIn(this.axes, function(axis){\n\t\t\t\tif(axis.initialized()){\n\t\t\t\t\tret[axis.name] = {\n\t\t\t\t\t\tname:\t\taxis.name,\n\t\t\t\t\t\tvertical:\taxis.vertical,\n\t\t\t\t\t\tscaler:\t\taxis.scaler,\n\t\t\t\t\t\tticks:\t\taxis.ticks\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ret;\t//\tObject\n\t\t},\n\t\tsetAxisWindow: function(name, scale, offset, zoom){\n\t\t\t// summary:\n\t\t\t//\t\tZooms an axis and all dependent plots. Can be used to zoom in 1D.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the axis as defined by addAxis.\n\t\t\t// scale: Number\n\t\t\t//\t\tThe scale on the target axis.\n\t\t\t// offset: Number\n\t\t\t//\t\tAny offest, as measured by axis tick\n\t\t\t// zoom: Boolean|Object?\n\t\t\t//\t\tThe chart zooming animation trigger.  This is null by default,\n\t\t\t//\t\te.g. {duration: 1200}, or just set true.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tvar axis = this.axes[name];\n\t\t\tif(axis){\n\t\t\t\taxis.setWindow(scale, offset);\n\t\t\t\tarr.forEach(this.stack,function(plot){\n\t\t\t\t\tif(plot.hAxis == name || plot.vAxis == name){\n\t\t\t\t\t\tplot.zoom = zoom;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tsetWindow: function(sx, sy, dx, dy, zoom){\n\t\t\t// summary:\n\t\t\t//\t\tZooms in or out any plots in two dimensions.\n\t\t\t// sx: Number\n\t\t\t//\t\tThe scale for the x axis.\n\t\t\t// sy: Number\n\t\t\t//\t\tThe scale for the y axis.\n\t\t\t// dx: Number\n\t\t\t//\t\tThe pixel offset on the x axis.\n\t\t\t// dy: Number\n\t\t\t//\t\tThe pixel offset on the y axis.\n\t\t\t// zoom: Boolean|Object?\n\t\t\t//\t\tThe chart zooming animation trigger.  This is null by default,\n\t\t\t//\t\te.g. {duration: 1200}, or just set true.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(!(\"plotArea\" in this)){\n\t\t\t\tthis.calculateGeometry();\n\t\t\t}\n\t\t\tfunc.forIn(this.axes, function(axis){\n\t\t\t\tvar scale, offset, bounds = axis.getScaler().bounds,\n\t\t\t\t\ts = bounds.span / (bounds.upper - bounds.lower);\n\t\t\t\tif(axis.vertical){\n\t\t\t\t\tscale  = sy;\n\t\t\t\t\toffset = dy / s / scale;\n\t\t\t\t}else{\n\t\t\t\t\tscale  = sx;\n\t\t\t\t\toffset = dx / s / scale;\n\t\t\t\t}\n\t\t\t\taxis.setWindow(scale, offset);\n\t\t\t});\n\t\t\tarr.forEach(this.stack, function(plot){ plot.zoom = zoom; });\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tzoomIn:\tfunction(name, range, delayed){\n\t\t\t// summary:\n\t\t\t//\t\tZoom the chart to a specific range on one axis.  This calls render()\n\t\t\t//\t\tdirectly as a convenience method.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the axis as defined by addAxis.\n\t\t\t// range: Array\n\t\t\t//\t\tThe end points of the zoom range, measured in axis ticks.\n\t\t\tvar axis = this.axes[name];\n\t\t\tif(axis){\n\t\t\t\tvar scale, offset, bounds = axis.getScaler().bounds;\n\t\t\t\tvar lower = Math.min(range[0],range[1]);\n\t\t\t\tvar upper = Math.max(range[0],range[1]);\n\t\t\t\tlower = range[0] < bounds.lower ? bounds.lower : lower;\n\t\t\t\tupper = range[1] > bounds.upper ? bounds.upper : upper;\n\t\t\t\tscale = (bounds.upper - bounds.lower) / (upper - lower);\n\t\t\t\toffset = lower - bounds.lower;\n\t\t\t\tthis.setAxisWindow(name, scale, offset);\n\t\t\t\tif(delayed){\n\t\t\t\t\tthis.delayedRender();\n\t\t\t\t}else{\n\t\t\t\t\tthis.render();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcalculateGeometry: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the geometry of the chart based on the defined axes of\n\t\t\t//\t\ta chart.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(this.dirty){\n\t\t\t\treturn this.fullGeometry();\n\t\t\t}\n\n\t\t\t// calculate geometry\n\t\t\tvar dirty = arr.filter(this.stack, function(plot){\n\t\t\t\t\treturn plot.dirty ||\n\t\t\t\t\t\t(plot.hAxis && this.axes[plot.hAxis].dirty) ||\n\t\t\t\t\t\t(plot.vAxis && this.axes[plot.vAxis].dirty);\n\t\t\t\t}, this);\n\t\t\tcalculateAxes(dirty, this.plotArea);\n\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tfullGeometry: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the full geometry of the chart.  This includes passing\n\t\t\t//\t\tover all major elements of a chart (plots, axes, series, container)\n\t\t\t//\t\tin order to ensure proper rendering.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tthis._makeDirty();\n\n\t\t\t// clear old values\n\t\t\tarr.forEach(this.stack, clear);\n\n\t\t\t// rebuild new connections, and add defaults\n\n\t\t\t// set up a theme\n\t\t\tif(!this.theme){\n\t\t\t\tthis.setTheme(new SimpleTheme());\n\t\t\t}\n\n\t\t\t// assign series\n\t\t\tarr.forEach(this.series, function(run){\n\t\t\t\tif(!(run.plot in this.plots)){\n\t\t\t\t\t// TODO remove auto-assignment\n\t\t\t\t\tif(!dc.plot2d || !dc.plot2d.Default){\n\t\t\t\t\t\tthrow Error(\"Can't find plot: Default - didn't you forget to dojo\" + \".require() it?\");\n\t\t\t\t\t}\n\t\t\t\t\tvar plot = new dc.plot2d.Default(this, {});\n\t\t\t\t\tplot.name = run.plot;\n\t\t\t\t\tthis.plots[run.plot] = this.stack.length;\n\t\t\t\t\tthis.stack.push(plot);\n\t\t\t\t}\n\t\t\t\tthis.stack[this.plots[run.plot]].addSeries(run);\n\t\t\t}, this);\n\t\t\t// assign axes\n\t\t\tarr.forEach(this.stack, function(plot){\n\t\t\t\tif(plot.assignAxes){\n\t\t\t\t\tplot.assignAxes(this.axes);\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\t// calculate geometry\n\n\t\t\t// 1st pass\n\t\t\tvar dim = this.dim = this.surface.getDimensions();\n\t\t\tdim.width  = g.normalizedLength(dim.width);\n\t\t\tdim.height = g.normalizedLength(dim.height);\n\t\t\tfunc.forIn(this.axes, clear);\n\t\t\tcalculateAxes(this.stack, dim);\n\n\t\t\t// assumption: we don't have stacked axes yet\n\t\t\tvar offsets = this.offsets = {l: 0, r: 0, t: 0, b: 0};\n\t\t\t// chart mirroring starts\n\t\t\tvar self = this;\n\t\t\tfunc.forIn(this.axes, function(axis){\n\t\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\t\tself._resetLeftBottom(axis);\n\t\t\t\t}\n\t\t\t\tfunc.forIn(axis.getOffsets(), function(o, i){ offsets[i] = Math.max(o, offsets[i]); });\n\t\t\t});\n\t\t\t// chart mirroring ends\n\t\t\t// add title area\n\t\t\tif(this.title){\n\t\t\t\tthis.titleGap = (this.titleGap==0) ? 0 : this.titleGap || this.theme.chart.titleGap || 20;\n\t\t\t\tthis.titlePos = this.titlePos || this.theme.chart.titlePos || \"top\";\n\t\t\t\tthis.titleFont = this.titleFont || this.theme.chart.titleFont;\n\t\t\t\tthis.titleFontColor = this.titleFontColor || this.theme.chart.titleFontColor || \"black\";\n\t\t\t\tthis.titleAlign = this.titleAlign || this.theme && this.theme.chart && this.theme.chart.titleAlign || \"middle\";\n\t\t\t\tvar tsize = g.normalizedLength(g.splitFontString(this.titleFont).size);\n\t\t\t\toffsets[this.titlePos == \"top\" ? \"t\" : \"b\"] += (tsize + this.titleGap);\n\t\t\t}\n\t\t\t// add margins\n\t\t\tfunc.forIn(this.margins, function(o, i){ offsets[i] += o; });\n\n\t\t\t// 2nd pass with realistic dimensions\n\t\t\tthis.plotArea = {\n\t\t\t\twidth: dim.width - offsets.l - offsets.r,\n\t\t\t\theight: dim.height - offsets.t - offsets.b\n\t\t\t};\n\t\t\tfunc.forIn(this.axes, clear);\n\t\t\tcalculateAxes(this.stack, this.plotArea);\n\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\trender: function(){\n\t\t\t// summary:\n\t\t\t//\t\tRender the chart according to the current information defined.  This should\n\t\t\t//\t\tbe the last call made when defining/creating a chart, or if data within the\n\t\t\t//\t\tchart has been changed.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\n\t\t\t// do we have a delayed renderer pending? If yes we need to clear it\n\t\t\tif(this._delayedRenderHandle){\n\t\t\t\tclearTimeout(this._delayedRenderHandle);\n\t\t\t\tthis._delayedRenderHandle = null;\n\t\t\t}\n\t\t\t\n\t\t\tif(this.theme){\n\t\t\t\tthis.theme.clear();\n\t\t\t}\n\n\t\t\tif(this.dirty){\n\t\t\t\treturn this.fullRender();\n\t\t\t}\n\n\t\t\tthis.calculateGeometry();\n\n\t\t\t// go over the stack backwards\n\t\t\tfunc.forEachRev(this.stack, function(plot){ plot.render(this.dim, this.offsets); }, this);\n\n\t\t\t// go over axes\n\t\t\tfunc.forIn(this.axes, function(axis){ axis.render(this.dim, this.offsets); }, this);\n\n\t\t\tthis._makeClean();\n\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tfullRender: function(){\n\t\t\t// summary:\n\t\t\t//\t\tForce a full rendering of the chart, including full resets on the chart itself.\n\t\t\t//\t\tYou should not call this method directly unless absolutely necessary.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\n\t\t\t// calculate geometry\n\t\t\tthis.fullGeometry();\n\t\t\tvar offsets = this.offsets, dim = this.dim;\n\t\t\tvar w = Math.max(0, dim.width  - offsets.l - offsets.r),\n\t\t\t\th = Math.max(0, dim.height - offsets.t - offsets.b);\n\n\t\t\t// get required colors\n\t\t\t//var requiredColors = func.foldl(this.stack, \"z + plot.getRequiredColors()\", 0);\n\t\t\t//this.theme.defineColors({num: requiredColors, cache: false});\n\n\t\t\t// clear old shapes\n\t\t\tarr.forEach(this.series, purge);\n\t\t\tfunc.forIn(this.axes, purge);\n\t\t\tarr.forEach(this.stack,  purge);\n\t\t\tvar children = this.surface.children;\n\t\t\t// starting with 1.9 the registry is optional and thus dispose is\n\t\t\tif(shape.dispose){\n\t\t\t\tfor(var i = 0; i < children.length;++i){\n\t\t\t\t\tshape.dispose(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.chartTitle && this.chartTitle.tagName){\n\t\t\t\t// destroy title if it is a DOM node\n\t\t\t    domConstruct.destroy(this.chartTitle);\n\t\t\t}\n\t\t\tthis.surface.clear();\n\t\t\tthis.chartTitle = null;\n\n\t\t\tthis._renderChartBackground(dim, offsets);\n\t\t\tif(this._nativeClip){\n\t\t\t\tthis._renderPlotBackground(dim, offsets, w, h);\n\t\t\t}else{\n\t\t\t\t// VML\n\t\t\t\tthis._renderPlotBackground(dim, offsets, w, h);\n\t\t\t}\n\n\t\t\t// go over the stack backwards\n\t\t\tfunc.foldr(this.stack, function(z, plot){ return plot.render(dim, offsets), 0; }, 0);\n\n\t\t\tif(!this._nativeClip){\n\t\t\t\t// VML, matting-clipping\n\t\t\t\tthis._renderChartBackground(dim, offsets);\n\t\t\t}\n\n\t\t\t//create title: Whether to make chart title as a widget which extends dojox.charting.Element?\n\t\t\tif(this.title){\n\t\t\t\tthis._renderTitle(dim, offsets);\n\t\t\t}\n\n\t\t\t// go over axes\n\t\t\tfunc.forIn(this.axes, function(axis){ axis.render(dim, offsets); });\n\n\t\t\tthis._makeClean();\n\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\t_renderTitle: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tInternal function to render the chart title.\n\t\t\t// dim:\n\t\t\t//\t\tThe dimension object of the chart\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tvar forceHtmlLabels = (g.renderer == \"canvas\") && this.htmlLabels,\n\t\t\t\tlabelType = forceHtmlLabels || !has(\"ie\") && !has(\"opera\") && this.htmlLabels ? \"html\" : \"gfx\",\n\t\t\t\ttsize = g.normalizedLength(g.splitFontString(this.titleFont).size),\n\t\t\t\ttBox = g._base._getTextBox(this.title,{ font: this.titleFont });\n\t\t\t\t\n\t\t\tvar titleAlign = this.titleAlign;\n\t\t\tvar isRtl = has(\"dojo-bidi\") && this.isRightToLeft();\n\t\t\tvar posX = dim.width/2; // Default is middle.\n\t\t\tif(titleAlign === \"edge\"){\n\t\t\t\ttitleAlign = \"left\";\n\t\t\t\tif(isRtl){\n\t\t\t\t\tposX = dim.width - (offsets.r + tBox.w);\n\t\t\t\t}else {\n\t\t\t\t\tposX = offsets.l;\n\t\t\t\t}\n\t\t\t}else if(titleAlign != \"middle\"){\n\t\t\t\tif(isRtl){\n\t\t\t\t\t// We're in BIDI mode, reverse the alignment.\n\t\t\t\t\ttitleAlign = titleAlign === \"left\" ? \"right\" : \"left\";\n\t\t\t\t}\n\t\t\t\tif(titleAlign === \"left\"){\n\t\t\t\t\tposX = this.margins.l;\n\t\t\t\t}else if(titleAlign === \"right\"){\n\t\t\t\t\ttitleAlign = \"left\";\n\t\t\t\t\tposX = dim.width - (this.margins.l + tBox.w);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.chartTitle = common.createText[labelType](\n\t\t\t\tthis,\n\t\t\t\tthis.surface,\n\t\t\t\tposX,\n\t\t\t\tthis.titlePos==\"top\" ? tsize + this.margins.t : dim.height - this.margins.b,\n\t\t\t\ttitleAlign,\n\t\t\t\tthis.title,\n\t\t\t\tthis.titleFont,\n\t\t\t\tthis.titleFontColor\n\t\t\t);\n\t\t},\n\t\t_renderChartBackground: function(dim, offsets){\n\t\t\tvar t = this.theme, rect;\n\t\t\t// chart background\n\t\t\tvar fill   = this.fill   !== undefined ? this.fill   : (t.chart && t.chart.fill);\n\t\t\tvar stroke = this.stroke !== undefined ? this.stroke : (t.chart && t.chart.stroke);\n\n\t\t\t// TRT: support for \"inherit\" as a named value in a theme.\n\t\t\tif(fill == \"inherit\"){\n\t\t\t\t//\tfind the background color of the nearest ancestor node, and use that explicitly.\n\t\t\t\tvar node = this.node;\n\t\t\t\tfill = new Color(domStyle.get(node, \"backgroundColor\"));\n\t\t\t\twhile(fill.a==0 && node!=document.documentElement){\n\t\t\t\t\tfill = new Color(domStyle.get(node, \"backgroundColor\"));\n\t\t\t\t\tnode = node.parentNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(fill){\n\t\t\t\tif(this._nativeClip){\n\t\t\t\t\tfill = Element.prototype._shapeFill(Element.prototype._plotFill(fill, dim),\n\t\t\t\t\t\t{ x:0, y: 0, width: dim.width + 1, height: dim.height + 1 });\n\t\t\t\t\tthis.surface.createRect({ width: dim.width + 1, height: dim.height + 1 }).setFill(fill);\n\t\t\t\t}else{\n\t\t\t\t\t// VML\n\t\t\t\t\tfill = Element.prototype._plotFill(fill, dim, offsets);\n\t\t\t\t\tif(offsets.l){\t// left\n\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\twidth:  offsets.l,\n\t\t\t\t\t\t\theight: dim.height + 1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t}\n\t\t\t\t\tif(offsets.r){\t// right\n\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\tx: dim.width - offsets.r,\n\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\twidth:  offsets.r + 1,\n\t\t\t\t\t\t\theight: dim.height + 2\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t}\n\t\t\t\t\tif(offsets.t){\t// top\n\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\twidth:  dim.width + 1,\n\t\t\t\t\t\t\theight: offsets.t\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t}\n\t\t\t\t\tif(offsets.b){\t// bottom\n\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\ty: dim.height - offsets.b,\n\t\t\t\t\t\t\twidth:  dim.width + 1,\n\t\t\t\t\t\t\theight: offsets.b + 2\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.surface.createRect(rect).setFill(Element.prototype._shapeFill(fill, rect));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(stroke){\n\t\t\t\tthis.surface.createRect({\n\t\t\t\t\twidth:  dim.width - 1,\n\t\t\t\t\theight: dim.height - 1\n\t\t\t\t}).setStroke(stroke);\n\t\t\t}\n\t\t},\n\t\t_renderPlotBackground: function(dim, offsets, w, h){\n\t\t\tvar t = this.theme;\n\n\t\t\t// draw a plot background\n\t\t\tvar fill   = t.plotarea && t.plotarea.fill;\n\t\t\tvar stroke = t.plotarea && t.plotarea.stroke;\n\t\t\t// size might be neg if offsets are bigger that chart size this happens quite often at\n\t\t\t// initialization time if the chart widget is used in a BorderContainer\n\t\t\t// this will fail on IE/VML\n\t\t\tvar rect = {\n\t\t\t\tx: offsets.l - 1, y: offsets.t - 1,\n\t\t\t\twidth:  w + 2,\n\t\t\t\theight: h + 2\n\t\t\t};\n\t\t\tif(fill){\n\t\t\t\tfill = Element.prototype._shapeFill(Element.prototype._plotFill(fill, dim, offsets), rect);\n\t\t\t\tthis.surface.createRect(rect).setFill(fill);\n\t\t\t}\n\t\t\tif(stroke){\n\t\t\t\tthis.surface.createRect({\n\t\t\t\t\tx: offsets.l, y: offsets.t,\n\t\t\t\t\twidth:  w + 1,\n\t\t\t\t\theight: h + 1\n\t\t\t\t}).setStroke(stroke);\n\t\t\t}\n\t\t},\n\t\tdelayedRender: function(){\n\t\t\t// summary:\n\t\t\t//\t\tDelayed render, which is used to collect multiple updates\n\t\t\t//\t\twithin a delayInMs time window.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\n\t\t\tif(!this._delayedRenderHandle){\n\t\t\t\tthis._delayedRenderHandle = setTimeout(\n\t\t\t\t\tlang.hitch(this, function(){\n\t\t\t\t\t\tthis.render();\n\t\t\t\t\t}),\n\t\t\t\t\tthis.delayInMs\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\tconnectToPlot: function(name, object, method){\n\t\t\t// summary:\n\t\t\t//\t\tA convenience method to connect a function to a plot.\n\t\t\t// name: String\n\t\t\t//\t\tThe name of the plot as defined by addPlot.\n\t\t\t// object: Object\n\t\t\t//\t\tThe object to be connected.\n\t\t\t// method: Function\n\t\t\t//\t\tThe function to be executed.\n\t\t\t// returns: Array\n\t\t\t//\t\tA handle to the connection, as defined by dojo.connect (see dojo.connect).\n\t\t\treturn name in this.plots ? this.stack[this.plots[name]].connect(object, method) : null;\t//\tArray\n\t\t},\n\t\tfireEvent: function(seriesName, eventName, index){\n\t\t\t// summary:\n\t\t\t//\t\tFires a synthetic event for a series item.\n\t\t\t// seriesName: String\n\t\t\t//\t\tSeries name.\n\t\t\t// eventName: String\n\t\t\t//\t\tEvent name to simulate: onmouseover, onmouseout, onclick.\n\t\t\t// index: Number\n\t\t\t//\t\tValid data value index for the event.\n\t\t\t// returns: dojox/charting/Chart\n\t\t\t//\t\tA reference to the current chart for functional chaining.\n\t\t\tif(seriesName in this.runs){\n\t\t\t\tvar plotName = this.series[this.runs[seriesName]].plot;\n\t\t\t\tif(plotName in this.plots){\n\t\t\t\t\tvar plot = this.stack[this.plots[plotName]];\n\t\t\t\t\tif(plot){\n\t\t\t\t\t\tplot.fireEvent(seriesName, eventName, index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/Chart\n\t\t},\n\t\t_makeClean: function(){\n\t\t\t// reset dirty flags\n\t\t\tarr.forEach(this.axes,   makeClean);\n\t\t\tarr.forEach(this.stack,  makeClean);\n\t\t\tarr.forEach(this.series, makeClean);\n\t\t\tthis.dirty = false;\n\t\t},\n\t\t_makeDirty: function(){\n\t\t\t// reset dirty flags\n\t\t\tarr.forEach(this.axes,   makeDirty);\n\t\t\tarr.forEach(this.stack,  makeDirty);\n\t\t\tarr.forEach(this.series, makeDirty);\n\t\t\tthis.dirty = true;\n\t\t},\n\t\t_invalidateDependentPlots: function(plotName, /* Boolean */ verticalAxis){\n\t\t\tif(plotName in this.plots){\n\t\t\t\tvar plot = this.stack[this.plots[plotName]], axis,\n\t\t\t\t\taxisName = verticalAxis ? \"vAxis\" : \"hAxis\";\n\t\t\t\tif(plot[axisName]){\n\t\t\t\t\taxis = this.axes[plot[axisName]];\n\t\t\t\t\tif(axis && axis.dependOnData()){\n\t\t\t\t\t\taxis.dirty = true;\n\t\t\t\t\t\t// find all plots and mark them dirty\n\t\t\t\t\t\tarr.forEach(this.stack, function(p){\n\t\t\t\t\t\t\tif(p[axisName] && p[axisName] == plot[axisName]){\n\t\t\t\t\t\t\t\tp.dirty = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tplot.dirty = true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsetDir : function(dir){\n\t\t\treturn this; \n\t\t},\n\t\t_resetLeftBottom: function(axis){\n\t\t},\n\t\tformatTruncatedLabel: function(element, label, labelType){\t\t\t\n\t\t}\n\t});\n\n\tfunction hSection(stats){\n\t\treturn {min: stats.hmin, max: stats.hmax};\n\t}\n\n\tfunction vSection(stats){\n\t\treturn {min: stats.vmin, max: stats.vmax};\n\t}\n\n\tfunction hReplace(stats, h){\n\t\tstats.hmin = h.min;\n\t\tstats.hmax = h.max;\n\t}\n\n\tfunction vReplace(stats, v){\n\t\tstats.vmin = v.min;\n\t\tstats.vmax = v.max;\n\t}\n\n\tfunction combineStats(target, source){\n\t\tif(target && source){\n\t\t\ttarget.min = Math.min(target.min, source.min);\n\t\t\ttarget.max = Math.max(target.max, source.max);\n\t\t}\n\t\treturn target || source;\n\t}\n\n\tfunction calculateAxes(stack, plotArea){\n\t\tvar plots = {}, axes = {};\n\t\tarr.forEach(stack, function(plot){\n\t\t\tvar stats = plots[plot.name] = plot.getSeriesStats();\n\t\t\tif(plot.hAxis){\n\t\t\t\taxes[plot.hAxis] = combineStats(axes[plot.hAxis], hSection(stats));\n\t\t\t}\n\t\t\tif(plot.vAxis){\n\t\t\t\taxes[plot.vAxis] = combineStats(axes[plot.vAxis], vSection(stats));\n\t\t\t}\n\t\t});\n\t\tarr.forEach(stack, function(plot){\n\t\t\tvar stats = plots[plot.name];\n\t\t\tif(plot.hAxis){\n\t\t\t\thReplace(stats, axes[plot.hAxis]);\n\t\t\t}\n\t\t\tif(plot.vAxis){\n\t\t\t\tvReplace(stats, axes[plot.vAxis]);\n\t\t\t}\n\t\t\tplot.initializeScalers(plotArea, stats);\n\t\t});\n\t}\n\t\n\treturn has(\"dojo-bidi\")? declare(\"dojox.charting.Chart\", [Chart, BidiChart]) : Chart;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/Chart.js\n// module id = 191\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\",\"dojo/_base/declare\",\"dojo/_base/Color\", \"dojox/lang/utils\", \"dojox/gfx/gradutils\"],\n\tfunction(lang, arr, declare, Color, dlu, dgg){\n\t\n\tvar SimpleTheme = declare(\"dojox.charting.SimpleTheme\", null, {\n\t// summary:\n\t//\t\tA SimpleTheme or Theme is a pre-defined object, primarily JSON-based, that makes up the definitions to\n\t//\t\tstyle a chart.\n\t//\n\t// description:\n\t//\t\tWhile you can set up style definitions on a chart directly (usually through the various add methods\n\t//\t\ton a dojox.charting.Chart object), a Theme simplifies this manual setup by allowing you to\n\t//\t\tpre-define all of the various visual parameters of each element in a chart.\n\t//\n\t//\t\tMost of the properties of a Theme are straight-forward; if something is line-based (such as\n\t//\t\tan axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,\n\t//\t\tif an element is primarily block-based (such as the background of a chart), it will be primarily\n\t//\t\tfill-based.\n\t//\n\t//\t\tIn addition (for convenience), a Theme definition does not have to contain the entire JSON-based\n\t//\t\tstructure.  Each theme is built on top of a default theme (which serves as the basis for the theme\n\t//\t\t\"GreySkies\"), and is mixed into the default theme object.  This allows you to create a theme based,\n\t//\t\tsay, solely on colors for data series.\n\t//\n\t//\t\tDefining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples\n\t//\t\ton how to define your own.\n\t//\n\t//\t\tWhen you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter\n\t//\t\tthe theme itself after setting the theme value on a chart, and expect it to change your chart.  If you\n\t//\t\tare looking to make alterations to a theme for a chart, the suggestion would be to create your own\n\t//\t\ttheme, based on the one you want to use, that makes those alterations before it is applied to a chart.\n\t//\n\t//\t\tFinally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main\n\t//\t\thelper of which is the ~next~ method, in which a chart asks for the information for the next data series\n\t//\t\tto be rendered.\n\t//\n\t//\t\tA note on colors:\n\t//\t\tA theme palette is usually comprised of 5 different color definitions, and\n\t//\t\tno more.  If you have a need to render a chart with more than 5 data elements, you can simply \"push\"\n\t//\t\tnew color definitions into the theme's .color array.  Make sure that you do that with the actual\n\t//\t\ttheme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme\n\t//\t\ton a chart).\n\t//\n\t// example:\n\t//\t\tThe default theme (and structure) looks like so:\n\t//\t|\t// all objects are structs used directly in dojox.gfx\n\t//\t|\tchart:{\n\t//\t|\t\tmargins: {l: 10, t: 10, r: 10, b: 10},\n\t//\t|\t\tstroke: null,\n\t//\t|\t\tfill: \"white\",\n\t//\t|\t\tpageStyle: null // suggested page style as an object suitable for dojo.style()\n\t//\t|\t},\n\t//\t|\tplotarea:{\n\t//\t|\t\tstroke: null,\n\t//\t|\t\tfill: \"white\"\n\t//\t|\t},\n\t//\t|\taxis:{\n\t//\t|\t\tstroke:\t{ // the axis itself\n\t//\t|\t\t\tcolor: \"#333\",\n\t//\t|\t\t\twidth: 1\n\t//\t|\t\t},\n\t//\t|\t\ttick: {\t// used as a foundation for all ticks\n\t//\t|\t\t\tcolor:     \"#666\",\n\t//\t|\t\t\tposition:  \"center\",\n\t//\t|\t\t\tfont:      \"normal normal normal 7pt Tahoma\",\t// labels on axis\n\t//\t|\t\t\tfontColor: \"#333\"\t\t\t\t\t\t\t\t// color of labels\n\t//\t|\t\t},\n\t//\t|\t\tmajorTick:\t{ // major ticks on axis, and used for major gridlines\n\t//\t|\t\t\twidth:  1,\n\t//\t|\t\t\tlength: 6\n\t//\t|\t\t},\n\t//\t|\t\tminorTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t//\t|\t\t\twidth:  0.8,\n\t//\t|\t\t\tlength: 3\n\t//\t|\t\t},\n\t//\t|\t\tmicroTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t//\t|\t\t\twidth:  0.5,\n\t//\t|\t\t\tlength: 1\n\t//\t|\t\t},\n\t//\t|\t\ttitle: {\n\t//\t|\t\t\tgap:  15,\n\t//\t|\t\t\tfont: \"normal normal normal 11pt Tahoma\",\t// title font\n\t//\t|\t\t\tfontColor: \"#333\",\t\t\t\t\t\t\t// title font color\n\t//\t|\t\t\torientation: \"axis\"\t\t\t\t\t\t// \"axis\": facing the axis, \"away\": facing away\n\t//\t|\t\t}\n\t//\t|\t},\n\t//\t|\tseries: {\n\t//\t|\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// line\n\t//\t|\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t//\t|\t\t//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},\n\t//\t|\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t//\t|\t\t//filter:  dojox/gfx/filters.createFilter(),\n\t//\t|\t\tfilter: null,\t\t\t\t\t\t\t\t// no filter, to use a filter you must use gfx SVG render and require dojox/gfx/svgext\n\t//\t|\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill, if appropriate\n\t//\t|\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// if there's a label\n\t//\t|\t\tfontColor: \"#000\"\t\t\t\t\t\t\t// color of labels\n\t//\t|\t\tlabelWiring: {width: 1, color: \"#ccc\"},\t\t// connect marker and target data item(slice, column, bar...)\n\t//\t|\t},\n\t//\t|\tmarker: {\t// any markers on a series\n\t//\t|\t\tsymbol:  \"m-3,3 l3,-6 3,6 z\",\t\t\t\t// symbol\n\t//\t|\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// stroke\n\t//\t|\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t//\t|\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t//\t|\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill if needed\n\t//\t|\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// label\n\t//\t|\t\tfontColor: \"#000\"\n\t//\t|\t},\n\t//\t|\tgrid: {\t// grid, when not present axis tick strokes are used instead\n\t//\t|\t\tmajorLine: {\t// major grid line\n\t//\t|\t\t\tcolor:     \"#666\",\n\t//\t|\t\t\twidth:  1,\n\t//\t|\t\t\tlength: 6\n\t//\t|\t\t},\n\t//\t|\t\tminorLine: {\t// minor grid line\n\t//\t|\t\t\tcolor:     \"#666\",\n\t//\t|\t\t\twidth:  0.8,\n\t//\t|\t\t\tlength: 3\n\t//\t|\t\t},\n\t//\t|\t\tfill: \"grey\",  // every other stripe\n\t//\t|\t\talternateFill: \"grey\" // alternate stripe\n\t//\t|\t},\n\t//\t|\tindicator: {\n\t//\t|\t\tlineStroke:  {width: 1.5, color: \"#333\"},\t\t// line\n\t//\t|\t\tlineOutline: {width: 0.1, color: \"#ccc\"},\t\t// line outline\n\t//\t|\t\tlineShadow: null,\t\t\t\t\t\t\t\t// no line shadow\n\t//\t|\t\tlineFill: null,\t\t\t\t\t\t\t\t\t// fill between lines for dual indicators\n\t//\t|\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t\t// label background stroke\n\t//\t|\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t\t// label background outline\n\t//\t|\t\tshadow: null,\t\t\t\t\t\t\t\t\t// no label background shadow\n\t//\t|\t\tfill:  \"#ccc\",\t\t\t\t\t\t\t\t\t// label background fill\n\t//\t|\t\tradius: 3,\t\t\t\t\t\t\t\t\t\t// radius of the label background\n\t//\t|\t\tfont:    \"normal normal normal 10pt Tahoma\",\t// label font\n\t//\t|\t\tfontColor: \"#000\"\t\t\t\t\t\t\t\t// label color\n\t//\t|\t\tmarkerFill:    \"#ccc\",\t\t\t\t\t\t\t// marker fill\n\t//\t|\t\tmarkerSymbol:  \"m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0\",\t// marker symbol\n\t//\t|\t\tmarkerStroke:  {width: 1.5, color: \"#333\"},\t\t// marker stroke\n\t//\t|\t\tmarkerOutline: {width: 0.1, color: \"#ccc\"},\t\t// marker outline\n\t//\t|\t\tmarkerShadow: null,\t\t\t\t\t\t\t\t// no marker shadow\n\t//\t|\t}\n\t//\n\t// example:\n\t//\t\tDefining a new theme is pretty simple:\n\t//\t|\tvar Grasslands = new SimpleTheme({\n\t//\t|\t\tcolors: [ \"#70803a\", \"#dde574\", \"#788062\", \"#b1cc5d\", \"#eff2c2\" ]\n\t//\t|\t});\n\t//\t|\n\t//\t|\tmyChart.setTheme(Grasslands);\n\n\tshapeSpaces: {shape: 1, shapeX: 1, shapeY: 1},\n\n\tconstructor: function(kwArgs){\n\t\t// summary:\n\t\t//\t\tInitialize a theme using the keyword arguments.  Note that the arguments\n\t\t//\t\tlook like the example (above), and may include a few more parameters.\n\t\tkwArgs = kwArgs || {};\n\n\t\t// populate theme with defaults updating them if needed\n\t\tvar def = SimpleTheme.defaultTheme;\n\t\tarr.forEach([\"chart\", \"plotarea\", \"axis\", \"grid\", \"series\", \"marker\", \"indicator\"], function(name){\n\t\t\tthis[name] = lang.delegate(def[name], kwArgs[name]);\n\t\t}, this);\n\n\t\t// personalize theme\n\t\tif(kwArgs.seriesThemes && kwArgs.seriesThemes.length){\n\t\t\tthis.colors  = null;\n\t\t\tthis.seriesThemes = kwArgs.seriesThemes.slice(0);\n\t\t}else{\n\t\t\tthis.seriesThemes = null;\n\t\t\tthis.colors = (kwArgs.colors || SimpleTheme.defaultColors).slice(0);\n\t\t}\n\t\tthis.markerThemes = null;\n\t\tif(kwArgs.markerThemes && kwArgs.markerThemes.length){\n\t\t\tthis.markerThemes = kwArgs.markerThemes.slice(0);\n\t\t}\n\t\tthis.markers = kwArgs.markers ? lang.clone(kwArgs.markers) : lang.delegate(SimpleTheme.defaultMarkers);\n\n\t\t// set flags\n\t\tthis.noGradConv = kwArgs.noGradConv;\n\t\tthis.noRadialConv = kwArgs.noRadialConv;\n\t\tif(kwArgs.reverseFills){\n\t\t\tthis.reverseFills();\n\t\t}\n\n\t\t//\tprivate housekeeping\n\t\tthis._current = 0;\n\t\tthis._buildMarkerArray();\n\t},\n\n\tclone: function(){\n\t\t// summary:\n\t\t//\t\tClone the current theme.\n\t\t// returns: dojox.charting.SimpleTheme\n\t\t//\t\tThe cloned theme; any alterations made will not affect the original.\n\t\tvar theme = new this.constructor({\n\t\t\t// theme components\n\t\t\tchart: this.chart,\n\t\t\tplotarea: this.plotarea,\n\t\t\taxis: this.axis,\n\t\t\tgrid: this.grid,\n\t\t\tseries: this.series,\n\t\t\tmarker: this.marker,\n\t\t\t// individual arrays\n\t\t\tcolors: this.colors,\n\t\t\tmarkers: this.markers,\n\t\t\tindicator: this.indicator,\n\t\t\tseriesThemes: this.seriesThemes,\n\t\t\tmarkerThemes: this.markerThemes,\n\t\t\t// flags\n\t\t\tnoGradConv: this.noGradConv,\n\t\t\tnoRadialConv: this.noRadialConv\n\t\t});\n\t\t// copy custom methods\n\t\tarr.forEach(\n\t\t\t[\"clone\", \"clear\", \"next\", \"skip\", \"addMixin\", \"post\", \"getTick\"],\n\t\t\tfunction(name){\n\t\t\t\tif(this.hasOwnProperty(name)){\n\t\t\t\t\ttheme[name] = this[name];\n\t\t\t\t}\n\t\t\t},\n\t\t\tthis\n\t\t);\n\t\treturn theme;\t//\tdojox.charting.SimpleTheme\n\t},\n\n\tclear: function(){\n\t\t// summary:\n\t\t//\t\tClear and reset the internal pointer to start fresh.\n\t\tthis._current = 0;\n\t},\n\n\tnext: function(elementType, mixin, doPost){\n\t\t// summary:\n\t\t//\t\tGet the next color or series theme.\n\t\t// elementType: String?\n\t\t//\t\tAn optional element type (for use with series themes)\n\t\t// mixin: Object?\n\t\t//\t\tAn optional object to mix into the theme.\n\t\t// doPost: Boolean?\n\t\t//\t\tA flag to post-process the results.\n\t\t// returns: Object\n\t\t//\t\tAn object of the structure { series, marker, symbol }\n\t\tvar merge = dlu.merge, series, marker;\n\t\tif(this.colors){\n\t\t\tseries = lang.delegate(this.series);\n\t\t\tmarker = lang.delegate(this.marker);\n\t\t\tvar color = new Color(this.colors[this._current % this.colors.length]), old;\n\t\t\t// modify the stroke\n\t\t\tif(series.stroke && series.stroke.color){\n\t\t\t\tseries.stroke = lang.delegate(series.stroke);\n\t\t\t\told = new Color(series.stroke.color);\n\t\t\t\tseries.stroke.color = new Color(color);\n\t\t\t\tseries.stroke.color.a = old.a;\n\t\t\t}else{\n\t\t\t\tseries.stroke = {color: color};\n\t\t\t}\n\t\t\tif(marker.stroke && marker.stroke.color){\n\t\t\t\tmarker.stroke = lang.delegate(marker.stroke);\n\t\t\t\told = new Color(marker.stroke.color);\n\t\t\t\tmarker.stroke.color = new Color(color);\n\t\t\t\tmarker.stroke.color.a = old.a;\n\t\t\t}else{\n\t\t\t\tmarker.stroke = {color: color};\n\t\t\t}\n\t\t\t// modify the fill\n\t\t\tif(!series.fill || series.fill.type){\n\t\t\t\tseries.fill = color;\n\t\t\t}else{\n\t\t\t\told = new Color(series.fill);\n\t\t\t\tseries.fill = new Color(color);\n\t\t\t\tseries.fill.a = old.a;\n\t\t\t}\n\t\t\tif(!marker.fill || marker.fill.type){\n\t\t\t\tmarker.fill = color;\n\t\t\t}else{\n\t\t\t\told = new Color(marker.fill);\n\t\t\t\tmarker.fill = new Color(color);\n\t\t\t\tmarker.fill.a = old.a;\n\t\t\t}\n\t\t}else{\n\t\t\tseries = this.seriesThemes ?\n\t\t\t\tmerge(this.series, this.seriesThemes[this._current % this.seriesThemes.length]) :\n\t\t\t\tthis.series;\n\t\t\tmarker = this.markerThemes ?\n\t\t\t\tmerge(this.marker, this.markerThemes[this._current % this.markerThemes.length]) :\n\t\t\t\tseries;\n\t\t}\n\n\t\tvar symbol = marker && marker.symbol || this._markers[this._current % this._markers.length];\n\n\t\tvar theme = {series: series, marker: marker, symbol: symbol};\n\t\t\n\t\t// advance the counter\n\t\t++this._current;\n\n\t\tif(mixin){\n\t\t\ttheme = this.addMixin(theme, elementType, mixin);\n\t\t}\n\t\tif(doPost){\n\t\t\ttheme = this.post(theme, elementType);\n\t\t}\n\n\t\treturn theme;\t//\tObject\n\t},\n\n\tskip: function(){\n\t\t// summary:\n\t\t//\t\tSkip the next internal color.\n\t\t++this._current;\n\t},\n\n\taddMixin: function(theme, elementType, mixin, doPost){\n\t\t// summary:\n\t\t//\t\tAdd a mixin object to the passed theme and process.\n\t\t// theme: dojox/charting/SimpleTheme\n\t\t//\t\tThe theme to mixin to.\n\t\t// elementType: String\n\t\t//\t\tThe type of element in question. Can be \"line\", \"bar\" or \"circle\"\n\t\t// mixin: Object|Array\n\t\t//\t\tThe object or objects to mix into the theme.\n\t\t// doPost: Boolean\n\t\t//\t\tIf true, run the new theme through the post-processor.\n\t\t// returns: dojox/charting/SimpleTheme\n\t\t//\t\tThe new theme.\n\t\tif(lang.isArray(mixin)){\n\t\t\tarr.forEach(mixin, function(m){\n\t\t\t\ttheme = this.addMixin(theme, elementType, m);\n\t\t\t}, this);\n\t\t}else{\n\t\t\tvar t = {};\n\t\t\tif(\"color\" in mixin){\n\t\t\t\tif(elementType == \"line\" || elementType == \"area\"){\n\t\t\t\t\tlang.setObject(\"series.stroke.color\", mixin.color, t);\n\t\t\t\t\tlang.setObject(\"marker.stroke.color\", mixin.color, t);\n\t\t\t\t}else{\n\t\t\t\t\tlang.setObject(\"series.fill\", mixin.color, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr.forEach([\"stroke\", \"outline\", \"shadow\", \"fill\", \"filter\", \"font\", \"fontColor\", \"labelWiring\"], function(name){\n\t\t\t\tvar markerName = \"marker\" + name.charAt(0).toUpperCase() + name.substr(1),\n\t\t\t\t\tb = markerName in mixin;\n\t\t\t\tif(name in mixin){\n\t\t\t\t\tlang.setObject(\"series.\" + name, mixin[name], t);\n\t\t\t\t\tif(!b){\n\t\t\t\t\t\tlang.setObject(\"marker.\" + name, mixin[name], t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(b){\n\t\t\t\t\tlang.setObject(\"marker.\" + name, mixin[markerName], t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(\"marker\" in mixin){\n\t\t\t\tt.symbol = mixin.marker;\n\t\t\t\tt.symbol = mixin.marker;\n\t\t\t}\n\t\t\ttheme = dlu.merge(theme, t);\n\t\t}\n\t\tif(doPost){\n\t\t\ttheme = this.post(theme, elementType);\n\t\t}\n\t\treturn theme;\t//\tdojox/charting/SimpleTheme\n\t},\n\n\tpost: function(theme, elementType){\n\t\t// summary:\n\t\t//\t\tProcess any post-shape fills.\n\t\t// theme: dojox/charting/SimpleTheme\n\t\t//\t\tThe theme to post process with.\n\t\t// elementType: String\n\t\t//\t\tThe type of element being filled.  Can be \"bar\" or \"circle\".\n\t\t// returns: dojox/charting/SimpleTheme\n\t\t//\t\tThe post-processed theme.\n\t\tvar fill = theme.series.fill, t;\n\t\tif(!this.noGradConv && this.shapeSpaces[fill.space] && fill.type == \"linear\"){\n\t\t\tif(elementType == \"bar\"){\n\t\t\t\t// transpose start and end points\n\t\t\t\tt = {\n\t\t\t\t\tx1: fill.y1,\n\t\t\t\t\ty1: fill.x1,\n\t\t\t\t\tx2: fill.y2,\n\t\t\t\t\ty2: fill.x2\n\t\t\t\t};\n\t\t\t}else if(!this.noRadialConv && fill.space == \"shape\" && (elementType == \"slice\" || elementType == \"circle\")){\n\t\t\t\t// switch to radial\n\t\t\t\tt = {\n\t\t\t\t\ttype: \"radial\",\n\t\t\t\t\tcx: 0,\n\t\t\t\t\tcy: 0,\n\t\t\t\t\tr:  100\n\t\t\t\t};\n\t\t\t}\n\t\t\tif(t){\n\t\t\t\treturn dlu.merge(theme, {series: {fill: t}});\n\t\t\t}\n\t\t}\n\t\treturn theme;\t//\tdojox/charting/SimpleTheme\n\t},\n\n\tgetTick: function(name, mixin){\n\t\t// summary:\n\t\t//\t\tCalculates and merges tick parameters.\n\t\t// name: String\n\t\t//\t\tTick name, can be \"major\", \"minor\", or \"micro\".\n\t\t// mixin: Object?\n\t\t//\t\tOptional object to mix in to the tick.\n\t\tvar tick = this.axis.tick, tickName = name + \"Tick\",\n\t\t\tmerge = dlu.merge;\n\t\tif(tick){\n\t\t\tif(this.axis[tickName]){\n\t\t\t\ttick = merge(tick, this.axis[tickName]);\n\t\t\t}\n\t\t}else{\n\t\t\ttick = this.axis[tickName];\n\t\t}\n\t\tif(mixin){\n\t\t\tif(tick){\n\t\t\t\tif(mixin[tickName]){\n\t\t\t\t\ttick = merge(tick, mixin[tickName]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttick = mixin[tickName];\n\t\t\t}\n\t\t}\n\t\treturn tick;\t//\tObject\n\t},\n\n\tinspectObjects: function(f){\n\t\tarr.forEach([\"chart\", \"plotarea\", \"axis\", \"grid\", \"series\", \"marker\", \"indicator\"], function(name){\n\t\t\tf(this[name]);\n\t\t}, this);\n\t\tif(this.seriesThemes){\n\t\t\tarr.forEach(this.seriesThemes, f);\n\t\t}\n\t\tif(this.markerThemes){\n\t\t\tarr.forEach(this.markerThemes, f);\n\t\t}\n\t},\n\n\treverseFills: function(){\n\t\tthis.inspectObjects(function(o){\n\t\t\tif(o && o.fill){\n\t\t\t\to.fill = dgg.reverse(o.fill);\n\t\t\t}\n\t\t});\n\t},\n\n\taddMarker:function(/*String*/ name, /*String*/ segment){\n\t\t// summary:\n\t\t//\t\tAdd a custom marker to this theme.\n\t\t// example:\n\t\t//\t|\tmyTheme.addMarker(\"Ellipse\", foo);\n\t\tthis.markers[name] = segment;\n\t\tthis._buildMarkerArray();\n\t},\n\n\tsetMarkers:function(/*Object*/ obj){\n\t\t// summary:\n\t\t//\t\tSet all the markers of this theme at once.  obj should be a\n\t\t//\t\tdictionary of keys and path segments.\n\t\t//\n\t\t// example:\n\t\t//\t|\tmyTheme.setMarkers({ \"CIRCLE\": foo });\n\t\tthis.markers = obj;\n\t\tthis._buildMarkerArray();\n\t},\n\n\t_buildMarkerArray: function(){\n\t\tthis._markers = [];\n\t\tfor(var p in this.markers){\n\t\t\tthis._markers.push(this.markers[p]);\n\t\t}\n\t}\n});\n\nlang.mixin(SimpleTheme, {\n\tdefaultMarkers: {\n\t\tCIRCLE:   \"m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0\",\n\t\tSQUARE:   \"m-3,-3 l0,6 6,0 0,-6 z\",\n\t\tDIAMOND:  \"m0,-3 l3,3 -3,3 -3,-3 z\",\n\t\tCROSS:    \"m0,-3 l0,6 m-3,-3 l6,0\",\n\t\tX:        \"m-3,-3 l6,6 m0,-6 l-6,6\",\n\t\tTRIANGLE: \"m-3,3 l3,-6 3,6 z\",\n\t\tTRIANGLE_INVERTED: \"m-3,-3 l3,6 3,-6 z\"\n\t},\n\n\tdefaultColors:[\n\t\t// gray skies\n\t\t\"#54544c\", \"#858e94\", \"#6e767a\", \"#948585\", \"#474747\"\n\t],\n\n\tdefaultTheme: {\n\t\t// all objects are structs used directly in dojox.gfx\n\t\tchart:{\n\t\t\tstroke: null,\n\t\t\tfill: \"white\",\n\t\t\tpageStyle: null,\n\t\t\ttitleGap:\t\t20,\n\t\t\ttitlePos:\t\t\"top\",\n\t\t\ttitleFont:      \"normal normal bold 14pt Tahoma\",\t// chart title\n\t\t\ttitleFontColor: \"#333\",\n\t\t\ttitleAlign: \"middle\"\n\t\t},\n\t\tplotarea:{\n\t\t\tstroke: null,\n\t\t\tfill: \"white\"\n\t\t},\n\t\t// TODO: label rotation on axis\n\t\taxis:{\n\t\t\tstroke:\t{ // the axis itself\n\t\t\t\tcolor: \"#333\",\n\t\t\t\twidth: 1\n\t\t\t},\n\t\t\ttick: {\t// used as a foundation for all ticks\n\t\t\t\tcolor:     \"#666\",\n\t\t\t\tposition:  \"center\",\n\t\t\t\tfont:      \"normal normal normal 7pt Tahoma\",\t// labels on axis\n\t\t\t\tfontColor: \"#333\",\t\t\t\t\t\t\t\t// color of labels\n\t\t\t\tlabelGap:  4                                    // gap between a tick and its label in pixels\n\t\t\t},\n\t\t\tmajorTick:\t{ // major ticks on axis, and used for major gridlines\n\t\t\t\twidth:  1,\n\t\t\t\tlength: 6\n\t\t\t},\n\t\t\tminorTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t\t\t\twidth:  0.8,\n\t\t\t\tlength: 3\n\t\t\t},\n\t\t\tmicroTick:\t{ // minor ticks on axis, and used for minor gridlines\n\t\t\t\twidth:  0.5,\n\t\t\t\tlength: 1\n\t\t\t},\n\t\t\ttitle: {\n\t\t\t\tgap:  15,\n\t\t\t\tfont: \"normal normal normal 11pt Tahoma\",\t// title font\n\t\t\t\tfontColor: \"#333\",\t\t\t\t\t\t\t// title font color\n\t\t\t\torientation: \"axis\"\t\t\t\t\t\t// \"axis\": facing the axis, \"away\": facing away\n\t\t\t}\n\t\t},\n\t\tseries: {\n\t\t\t// used as a \"main\" theme for series, sThemes augment it\n\t\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// line\n\t\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t\t\t//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},\n\t\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill, if appropriate\n\t\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// if there's a label\n\t\t\tfontColor: \"#000\",\t\t\t\t\t\t\t// color of labels\n\t\t\tlabelWiring: {width: 1, color: \"#ccc\"}\t\t// connect marker and target data item(slice, column, bar...)\n\t\t},\n\t\tmarker: {\t// any markers on a series\n\t\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t// stroke\n\t\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t// outline\n\t\t\t//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},\n\t\t\tshadow: null,\t\t\t\t\t\t\t\t// no shadow\n\t\t\tfill:    \"#ccc\",\t\t\t\t\t\t\t// fill if needed\n\t\t\tfont:    \"normal normal normal 8pt Tahoma\",\t// label\n\t\t\tfontColor: \"#000\"\n\t\t},\n\t\tindicator: {\n\t\t\tlineStroke:  {width: 1.5, color: \"#333\"},\t\t\n\t\t\tlineOutline: {width: 0.1, color: \"#ccc\"},\t\t\n\t\t\tlineShadow: null,\n\t\t\tlineFill: null,\n\t\t\tstroke:  {width: 1.5, color: \"#333\"},\t\t\n\t\t\toutline: {width: 0.1, color: \"#ccc\"},\t\t\n\t\t\tshadow: null,\t\t\t\t\t\t\t\t\n\t\t\tfill : \"#ccc\",\n\t\t\tradius: 3,\n\t\t\tfont:    \"normal normal normal 10pt Tahoma\",\t\n\t\t\tfontColor: \"#000\",\t\t\t\t\t\t\t\n\t\t\tmarkerFill:    \"#ccc\",\t\t\t\t\t\t\t\n\t\t\tmarkerSymbol:  \"m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0\",\t\t\t\n\t\t\tmarkerStroke:  {width: 1.5, color: \"#333\"},\t\t\n\t\t\tmarkerOutline: {width: 0.1, color: \"#ccc\"},\t\t\n\t\t\tmarkerShadow: null\t\t\t\t\t\t\t\t\n\t\t}\n\t}\n});\n\nreturn SimpleTheme;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/SimpleTheme.js\n// module id = 192\n// module chunks = 4","// Various generic utilities to deal with a linear gradient\n\ndefine([\"./_base\", \"dojo/_base/lang\", \"./matrix\", \"dojo/_base/Color\"], \n  function(g, lang, m, Color){\n  \n\tvar gradutils = g.gradutils = {};\n\n\tfunction findColor(o, c){\n\t\tif(o <= 0){\n\t\t\treturn c[0].color;\n\t\t}\n\t\tvar len = c.length;\n\t\tif(o >= 1){\n\t\t\treturn c[len - 1].color;\n\t\t}\n\t\t//TODO: use binary search\n\t\tfor(var i = 0; i < len; ++i){\n\t\t\tvar stop = c[i];\n\t\t\tif(stop.offset >= o){\n\t\t\t\tif(i){\n\t\t\t\t\tvar prev = c[i - 1];\n\t\t\t\t\treturn Color.blendColors(new Color(prev.color), new Color(stop.color),\n\t\t\t\t\t\t(o - prev.offset) / (stop.offset - prev.offset));\n\t\t\t\t}\n\t\t\t\treturn stop.color;\n\t\t\t}\n\t\t}\n\t\treturn c[len - 1].color;\n\t}\n\n\tgradutils.getColor = function(fill, pt){\n\t\t// summary:\n\t\t//\t\tsample a color from a gradient using a point\n\t\t// fill: Object\n\t\t//\t\tfill object\n\t\t// pt: dojox/gfx.Point\n\t\t//\t\tpoint where to sample a color\n\t\tvar o;\n\t\tif(fill){\n\t\t\tswitch(fill.type){\n\t\t\t\tcase \"linear\":\n\t\t\t\t\tvar angle = Math.atan2(fill.y2 - fill.y1, fill.x2 - fill.x1),\n\t\t\t\t\t\trotation = m.rotate(-angle),\n\t\t\t\t\t\tprojection = m.project(fill.x2 - fill.x1, fill.y2 - fill.y1),\n\t\t\t\t\t\tp = m.multiplyPoint(projection, pt),\n\t\t\t\t\t\tpf1 = m.multiplyPoint(projection, fill.x1, fill.y1),\n\t\t\t\t\t\tpf2 = m.multiplyPoint(projection, fill.x2, fill.y2),\n\t\t\t\t\t\tscale = m.multiplyPoint(rotation, pf2.x - pf1.x, pf2.y - pf1.y).x;\n\t\t\t\t\to = m.multiplyPoint(rotation, p.x - pf1.x, p.y - pf1.y).x / scale;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"radial\":\n\t\t\t\t\tvar dx = pt.x - fill.cx, dy = pt.y - fill.cy;\n\t\t\t\t\to = Math.sqrt(dx * dx + dy * dy) / fill.r;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn findColor(o, fill.colors);\t// dojo/_base/Color\n\t\t}\n\t\t// simple color\n\t\treturn new Color(fill || [0, 0, 0, 0]);\t// dojo/_base/Color\n\t};\n\n\tgradutils.reverse = function(fill){\n\t\t// summary:\n\t\t//\t\treverses a gradient\n\t\t// fill: Object\n\t\t//\t\tfill object\n\t\tif(fill){\n\t\t\tswitch(fill.type){\n\t\t\t\tcase \"linear\":\n\t\t\t\tcase \"radial\":\n\t\t\t\t\tfill = lang.delegate(fill);\n\t\t\t\t\tif(fill.colors){\n\t\t\t\t\t\tvar c = fill.colors, l = c.length, i = 0, stop,\n\t\t\t\t\t\t\tn = fill.colors = new Array(c.length);\n\t\t\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\t\t\tstop = c[i];\n\t\t\t\t\t\t\tn[i] = {\n\t\t\t\t\t\t\t\toffset: 1 - stop.offset,\n\t\t\t\t\t\t\t\tcolor:  stop.color\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn.sort(function(a, b){ return a.offset - b.offset; });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn fill;\t// Object\n\t};\n\n\treturn gradutils;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/gradutils.js\n// module id = 193\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"./Element\"], \n\tfunction(lang, declare, Element){ \n\t/*=====\n\tvar __SeriesCtorArgs = {\n\t\t// summary:\n\t\t//\t\tAn optional arguments object that can be used in the Series constructor.\n\t\t// plot: String?\n\t\t//\t\tThe plot (by name) that this series belongs to.\n\t};\n\t=====*/\n\treturn declare(\"dojox.charting.Series\", Element, {\n\t\t// summary:\n\t\t//\t\tAn object representing a series of data for plotting on a chart.\n\t\tconstructor: function(chart, data, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a new data series object for use within charting.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart that this series belongs to.\n\t\t\t// data: Array|Object\n\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\t// kwArgs: __SeriesCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to set details for this series.\n\t\t\tlang.mixin(this, kwArgs);\n\t\t\tif(typeof this.plot != \"string\"){ this.plot = \"default\"; }\n\t\t\tthis.update(data);\n\t\t},\n\t\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear the calculated additional parameters set on this series.\n\t\t\tthis.dyn = {};\n\t\t},\n\t\t\n\t\tupdate: function(data){\n\t\t\t// summary:\n\t\t\t//\t\tSet data and make this object dirty, so it can be redrawn.\n\t\t\t// data: Array|Object\n\t\t\t//\t\tThe array of data points (either numbers or objects) that\n\t\t\t//\t\trepresents the data to be drawn. Or it can be an object. In\n\t\t\t//\t\tthe latter case, it should have a property \"data\" (an array),\n\t\t\t//\t\tdestroy(), and setSeriesObject().\n\t\t\tif(lang.isArray(data)){\n\t\t\t\tthis.data = data;\n\t\t\t}else{\n\t\t\t\tthis.source = data;\n\t\t\t\tthis.data = this.source.data;\n\t\t\t\tif(this.source.setSeriesObject){\n\t\t\t\t\tthis.source.setSeriesObject(this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t\tthis.clear();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/Series.js\n// module id = 194\n// module chunks = 4","define([\"dojox/main\", \"dojo/_base/declare\", \"dojo/_base/lang\", \"dojo/dom-style\", \"dojo/_base/array\", \"dojo/sniff\",\n\t\"dojo/dom\",\"dojo/dom-construct\",\n\t\"dojox/gfx\", \"dojox/gfx/_gfxBidiSupport\", \"../axis2d/common\", \"dojox/string/BidiEngine\",\n\t\"dojox/lang/functional\",\"dojo/dom-attr\",\"./_bidiutils\"],\n\tfunction(dojox, declare, lang, domStyle, arr, has, dom, domConstruct, g, gBidi, da, BidiEngine, df, domAttr,utils){\n\t// module:\n\t//\t\tdojox/charting/bidi/Chart\t\t\t\t\t\t\t\n\tvar bidiEngine = new BidiEngine();\n\tvar dc = lang.getObject(\"charting\", true, dojox);\n\tfunction validateTextDir(textDir){\n\t\treturn /^(ltr|rtl|auto)$/.test(textDir) ? textDir : null;\n\t};\n\t\n\treturn declare(null, {\n\t\t// textDir: String\n\t\t//\t\tBi-directional support,\tthe main variable which is responsible for the direction of the text.\n\t\t//\t\tThe text direction can be different than the GUI direction by using this parameter.\n\t\t//\t\tAllowed values:\n\t\t//\n\t\t//\t\t1. \"ltr\"\n\t\t//\t\t2. \"rtl\"\n\t\t//\t\t3. \"auto\" - contextual the direction of a text defined by first strong letter.\n\t\t//\n\t\t//\t\tBy default is as the page direction.\n\t\ttextDir:\"\",\n\t\t\n\t\t// dir: String\n\t\t//\t\tMirroring support,\tthe main variable which is responsible for the direction of the chart.\n\t\t//\n\t\t//\t\tAllowed values:\n\t\t//\t\t1. \"ltr\"\n\t\t//\t\t2. \"rtl\"\n\t\t//\n\t\t//\t\tBy default is ltr.\n\t\tdir: \"\",\n\t\tisMirrored: false,\n\t\t\n\t\tgetTextDir: function(text){\n\t\t\t// summary:\n\t\t\t//\t\tReturn direction of the text. \n\t\t\t// description:\n\t\t\t//\t\tIf textDir is ltr or rtl returns the value.\n\t\t\t//\t\tIf it's auto, calls to another function that responsible \n\t\t\t//\t\tfor checking the value, and defining the direction.\t\t\t\n\t\t\t// text:\n\t\t\t//\t\tUsed in case textDir is \"auto\", this case the direction is according to the first\n\t\t\t//\t\tstrong (directionally - which direction is strong defined) letter.\n\t\t\t// tags:\n\t\t\t//\t\tprotected.\n\t\t\tvar textDir = this.textDir == \"auto\" ? bidiEngine.checkContextual(text) : this.textDir;\n\t\t\t// providing default value\n\t\t\tif(!textDir){\n\t\t\t\ttextDir = domStyle.get(this.node, \"direction\");\n\t\t\t}\n\t\t\treturn textDir;\n\t\t},\n\n\t\tpostscript: function(node,args){\n\t\t\t// summary:\n\t\t\t//\t\tKicks off chart instantiation.\n\t\t\t// description:\n\t\t\t//\t\tUsed for setting the textDir of the chart. \n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\n\t\t\t// validate textDir\n\t\t\tvar textDir = args ? (args[\"textDir\"] ? validateTextDir(args[\"textDir\"]) : \"\") : \"\";\n\t\t\t// if textDir wasn't defined or was defined wrong, apply default value\n\t\t\ttextDir = textDir ? textDir : domStyle.get(this.node, \"direction\");\n\t\t\tthis.textDir = textDir;\n\n\t\t\tthis.surface.textDir = textDir;\n\t\t\t\n\t\t\t// two data structures, used for storing data for further enablement to change\n\t\t\t// textDir dynamically\n\t\t\tthis.htmlElementsRegistry = [];\n\t\t\tthis.truncatedLabelsRegistry = [];\n\t\t\t// chart mirroring starts\n\t\t\tvar chartDir = \"ltr\";\n\t\t\tif(domAttr.has(node, \"direction\")){\n\t\t\t\tchartDir = domAttr.get(node, \"direction\");\n\t\t\t}\n\t\t\tthis.setDir(args ? (args.dir ? args.dir: chartDir) : chartDir);\n\t\t\t// chart mirroring ends\n\t\t},\n\n\t\tsetTextDir: function(newTextDir, obj){\n\t\t\t// summary:\n\t\t\t//\t\tSetter for the textDir attribute.\n\t\t\t// description:\n\t\t\t//\t\tAllows dynamically set the textDir, goes over all the text-children and  \n\t\t\t//\t\tupdates their base text direction.\n\t\t\t// tags:\n\t\t\t//\t\tpublic\n\t\t\n\t\t\tif(newTextDir == this.textDir){\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif(validateTextDir(newTextDir) != null){\n\t\t\t\tthis.textDir = newTextDir;\n\t\t\t\t\n\t\t\t\t// set automatically all the gfx objects that were created by this surface\n\t\t\t\t// (groups, text objects)\n\t\t\t\tthis.surface.setTextDir(newTextDir);\n\t\t\t\n\t\t\t\t// truncated labels that were created with gfx creator need to recalculate dir\n\t\t\t\t// for case like: \"111111A\" (A stands for bidi character) and the truncation\n\t\t\t\t// is \"111...\" If the textDir is auto, the display should be: \"...111\" but in gfx\n\t\t\t\t// case we will get \"111...\". Because this.surface.setTextDir will calculate the dir of truncated\n\t\t\t\t// label, which value is \"111...\" but th real is \"111111A\".\n\t\t\t\t// each time we created a gfx truncated label we stored it in the truncatedLabelsRegistry, so update now \n\t\t\t\t// the registry.\n\t\t\t\tif(this.truncatedLabelsRegistry && newTextDir == \"auto\"){\n\t\t\t\t\tarr.forEach(this.truncatedLabelsRegistry, function(elem){\n\t\t\t\t\t\tvar tDir = this.getTextDir(elem[\"label\"]);\n\t\t\t\t\t\tif(elem[\"element\"].textDir != tDir){\n\t\t\t\t\t\t\telem[\"element\"].setShape({textDir: tDir});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// re-render axes with html labels. for recalculation of the labels\n\t\t\t\t// positions etc.\n\t\t\t\t// create array of keys for all the axis in chart \n\t\t\t\tvar axesKeyArr = df.keys(this.axes);\n\t\t\t\tif(axesKeyArr.length > 0){\n\t\t\t\t\t// iterate over the axes, and for each that have html labels render it.\n\t\t\t\t\tarr.forEach(axesKeyArr, function(key, index, arr){\n\t\t\t\t\t\t// get the axis \n\t\t\t\t\t\tvar axis = this.axes[key];\n\t\t\t\t\t\t// if the axis has html labels \n\t\t\t\t\t\tif(axis.htmlElements[0]){\n\t\t\t\t\t\t\taxis.dirty = true;\n\t\t\t\t\t\t\taxis.render(this.dim, this.offsets);\n\t\t\t\t\t\t}\n\t\t\t\t\t},this);\n\t\t\t\t\t\n\t\t\t\t\t// recreate title\n\t\t\t\t\tif(this.title){\n\t\t\t\t\t\tthis._renderTitle(this.dim, this.offsets);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t// case of pies, spiders etc.\n\t\t\t\t\tarr.forEach(this.htmlElementsRegistry, function(elem, index, arr){\n\t\t\t\t\t\tvar tDir = newTextDir == \"auto\" ? this.getTextDir(elem[4]) : newTextDir;\n\t\t\t\t\t\tif(elem[0].children[0] && elem[0].children[0].dir != tDir){\n\t\t\t\t\t\t\tdomConstruct.destroy(elem[0].children[0]);\n\t\t\t\t\t\t\telem[0].children[0] = da.createText[\"html\"]\n\t\t\t\t\t\t\t\t\t(this, this.surface, elem[1], elem[2], elem[3], elem[4], elem[5], elem[6]).children[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t},this);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\tsetDir : function(dir){\n\t\t\t// summary:\n\t\t\t//\t\tSetter for the dir attribute.\n\t\t\t// description:\n\t\t\t//\t\tAllows dynamically set the dri attribute, which will used to\n\t\t\t//\t\tupdates the chart rendering direction.\n\t\t\t//\tdir : the desired chart direction [rtl: for right to left ,ltr: for left to right]\n \n\t\t\tif(dir == \"rtl\" || dir == \"ltr\"){\n\t\t\t\tif(this.dir != dir){\n\t\t\t\t\tthis.isMirrored = true;\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t\tthis.dir = dir;\n\t\t\t}\t\t\t\n\t\t\treturn this; \n\t\t},\n\t\t\n\t\tisRightToLeft: function(){\n\t\t\t// summary:\n\t\t\t//\t\tcheck the direction of the chart.\n\t\t\t// description:\n\t\t\t//\t\tcheck the dir attribute to determine the rendering direction\n\t\t\t//\t\tof the chart.\n\t\t\treturn this.dir == \"rtl\";\n        },\n        \n\t\tapplyMirroring: function(plot, dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tapply the mirroring operation to the current chart plots.\n\t\t\t//\n\t\t\tutils.reverseMatrix(plot, dim, offsets, this.dir == \"rtl\");\n\t\t\t//force the direction of the node to be ltr to properly render the axes and the plots labels.\n\t\t\tdomStyle.set(this.node, \"direction\", \"ltr\");\n\t\t\treturn this;\n\t\t},\n\n\t\tformatTruncatedLabel: function(element, label, labelType){\n\t\t\tthis.truncateBidi(element, label, labelType);\n\t\t},\n\n\t\ttruncateBidi: function(elem, label, labelType){\n\t\t\t// summary:\n\t\t\t//\t\tEnables bidi support for truncated labels.\n\t\t\t// description:\n\t\t\t//\t\tCan be two types of labels: html or gfx.\n\t\t\t//\n\t\t\t//\t\t####gfx labels:\n\t\t\t//\n\t\t\t//\t\tNeed to be stored in registry to be used when the textDir will be set dynamically.\n\t\t\t//\t\tAdditional work on truncated labels is needed for case as 111111A (A stands for \"bidi\" character rtl directioned).\n\t\t\t//\t\tlet's say in this case the truncation is \"111...\" If the textDir is auto, the display should be: \"...111\" but in gfx\n\t\t\t//\t\tcase we will get \"111...\". Because this.surface.setTextDir will calculate the dir of truncated\n\t\t\t//\t\tlabel, which value is \"111...\" but th real is \"111111A\".\n\t\t\t//\t\teach time we created a gfx truncated label we store it in the truncatedLabelsRegistry.\n\t\t\t//\n\t\t\t//\t\t####html labels:\n\t\t\t//\n\t\t\t//\t\tno need for repository (stored in another place). Here we only need to update the current dir according to textDir.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\n\t\t\tif(labelType == \"gfx\"){\n\t\t\t\t// store truncated gfx labels in the data structure.\n\t\t\t\tthis.truncatedLabelsRegistry.push({element: elem, label: label});\n\t\t\t\tif(this.textDir == \"auto\"){\n\t\t\t\t\telem.setShape({textDir: this.getTextDir(label)});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(labelType == \"html\" && this.textDir == \"auto\"){\n\t\t\t\telem.children[0].dir = this.getTextDir(label);\n\t\t\t}\n\t\t},\n\t\t\n\t\trender: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tthis.isMirrored = false;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t_resetLeftBottom: function(axis){\n\t\t\tif(axis.vertical && this.isMirrored){\n\t\t\t\taxis.opt.leftBottom = !axis.opt.leftBottom;\n\t\t\t}\n\t\t}\t\t\n\t});\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/bidi/Chart.js\n// module id = 195\n// module chunks = 4","define([\"./_base\", \"dojo/_base/lang\",\"dojo/_base/sniff\", \"dojo/dom\", \"dojo/_base/html\", \"dojo/_base/array\",\n\t\t\"./utils\", \"./shape\", \"./path\", \"dojox/string/BidiEngine\"],\nfunction(g, lang, has, dom, html, arr, utils, shapeLib, pathLib, BidiEngine){\n\tlang.getObject(\"dojox.gfx._gfxBidiSupport\", true);\n\n\t/*=====\n\t// Prevent changes here from masking the definitions in _base.js from the doc parser\n\tvar origG = g;\n\tg = {};\n\t=====*/\n\n\tswitch (g.renderer){\n\t\tcase 'vml':\n\t\t\tg.isVml = true;\n\t\t\tbreak;\n\t\tcase 'svg':\n\t\t\tg.isSvg = true;\n\t\t\tif(g.svg.useSvgWeb){\n\t\t\t\tg.isSvgWeb = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'silverlight':\n\t\t\tg.isSilverlight = true;\n\t\t\tbreak;\n\t\tcase 'canvas':\n\t\tcase 'canvasWithEvents':\n\t\t\tg.isCanvas = true;\n\t\t\tbreak;\n\t}\n\n\tvar bidi_const = {\n\t\tLRM : '\\u200E',\n\t\tLRE : '\\u202A',\n\t\tPDF : '\\u202C',\n\t\tRLM : '\\u200f',\n\t\tRLE : '\\u202B'\n\t};\n\n\t/*===== g = origG; =====*/\n\n\t// the object that performs text transformations.\n\tvar bidiEngine = new BidiEngine();\n\n\tlang.extend(g.shape.Surface, {\n\t\t// textDir: String\n\t\t//\t\tWill be used as default for Text/TextPath/Group objects that created by this surface\n\t\t//\t\tand textDir wasn't directly specified for them, though the bidi support was loaded.\n\t\t//\t\tCan be set in two ways:\n\t\t//\n\t\t//\t\t1. When the surface is created and textDir value passed to it as fourth\n\t\t//\t\tparameter.\n\t\t//\t\t2. Using the setTextDir(String) function, when this function is used the value\n\t\t//\t\tof textDir propagates to all of it's children and the children of children (for Groups) etc.\n\t\ttextDir: \"\",\n\n\t\tsetTextDir: function(/*String*/newTextDir){\n\t\t\t// summary:\n\t\t\t//\t\tUsed for propagation and change of textDir.\n\t\t\t//\t\tnewTextDir will be forced as textDir for all of it's children (Group/Text/TextPath).\n\t\t\tsetTextDir(this, newTextDir);\n\t\t},\n\n\t\tgetTextDir: function(){\n\t\t\treturn this.textDir;\n\t\t}\n\t});\n\n\tlang.extend(g.Group, {                          \n\t\t// textDir: String\n\t\t//\t\tWill be used for inheritance, or as default for text objects\n\t\t//\t\tthat textDir wasn't directly specified for them but the bidi support was required.\n\t\ttextDir: \"\",\n\n\t\tsetTextDir: function(/*String*/newTextDir){\n\t\t\t// summary:\n\t\t\t//\t\tUsed for propagation and change of textDir.\n\t\t\t//\t\tnewTextDir will be forced as textDir for all of it's children (Group/Text/TextPath).\n\t\t\tsetTextDir(this, newTextDir);\n\t\t},\n\n\t\tgetTextDir: function(){\n\t\t\treturn this.textDir;\n\t\t}\t\n\t});\n\t\n\tlang.extend(g.Text, {  \n\t\t// summary:\n\t\t//\t\tOverrides some of dojox/gfx.Text properties, and adds some\n\t\t//\t\tfor bidi support.\n\t\t\n\t\t// textDir: String\n\t\t//\t\tUsed for displaying bidi scripts in right layout.\n\t\t//\t\tDefines the base direction of text that displayed, can have 3 values:\n\t\t//\n\t\t//\t\t1. \"ltr\" - base direction is left to right.\n\t\t//\t\t2. \"rtl\" - base direction is right to left.\n\t\t//\t\t3. \"auto\" - base direction is contextual (defined by first strong character).\n\t\ttextDir: \"\",\n\n\t\tformatText: function (/*String*/ text, /*String*/ textDir){\n\t\t\t// summary:\n\t\t\t//\t\tApplies the right transform on text, according to renderer.\n\t\t\t// text:\t\n\t\t\t//\t\tthe string for manipulation, by default return value.\n\t\t\t// textDir:\t\n\t\t\t//\t\tText direction.\n\t\t\t//\t\tCan be:\n\t\t\t//\n\t\t\t//\t\t1. \"ltr\" - for left to right layout.\n\t\t\t//\t\t2. \"rtl\" - for right to left layout\n\t\t\t//\t\t3. \"auto\" - for contextual layout: the first strong letter decides the direction.\n\t\t\t// description:\n\t\t\t//\t\tFinds the right transformation that should be applied on the text, according to renderer.\n\t\t\t//\t\tWas tested in:\n\t\t\t//\n\t\t\t//\t\tRenderers (browser for testing):\n\t\t\t//\n\t\t\t//\t\t- canvas (FF, Chrome, Safari),\n\t\t\t//\t\t- vml (IE),\n\t\t\t//\t\t- svg (FF, Chrome, Safari, Opera),\n\t\t\t//\t\t- silverlight (IE, Chrome, Safari, Opera),\n\t\t\t//\t\t- svgWeb(FF, Chrome, Safari, Opera, IE).\n\t\t\t//\n\t\t\t//\t\tBrowsers [browser version that was tested]:\n\t\t\t//\n\t\t\t//\t\t- IE [6,7,8], FF [3.6],\n\t\t\t//\t\t- Chrome (latest for March 2011),\n\t\t\t//\t\t- Safari [5.0.3],\n\t\t\t//\t\t- Opera [11.01].\n\n\t\t\tif(textDir && text && text.length > 1){\n\t\t\t\tvar sourceDir = \"ltr\", targetDir = textDir;\n\t\n\t\t\t\tif(targetDir == \"auto\"){\n\t\t\t\t\t//is auto by default\n\t\t\t\t\tif(g.isVml){\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t}\n\t\t\t\t\ttargetDir = bidiEngine.checkContextual(text);\n\t\t\t\t}\n\t\n\t\t\t\tif(g.isVml){\n\t\t\t\t\tsourceDir = bidiEngine.checkContextual(text);\n\t\t\t\t\tif(targetDir != sourceDir){\n\t\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\t\treturn !bidiEngine.hasBidiChar(text) ? bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\") : bidi_const.RLM + bidi_const.RLM + text;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn bidi_const.LRM + text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\n\t\t\t\tif(g.isSvgWeb){\n\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\treturn bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\");\n\t\t\t\t\t}\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\n\t\t\t\tif(g.isSilverlight){\n\t\t\t\t\treturn (targetDir == \"rtl\") ? bidiEngine.bidiTransform(text,\"IRNNN\",\"VLYNN\") : bidiEngine.bidiTransform(text,\"ILNNN\",\"VLYNN\");\n\t\t\t\t}\n\t\n\t\t\t\tif(g.isCanvas){\n\t\t\t\t\treturn (targetDir == \"rtl\") ? bidi_const.RLE + text + bidi_const.PDF : bidi_const.LRE + text + bidi_const.PDF;\n\t\t\t\t}\n\t\n\t\t\t\tif(g.isSvg){\n\t\t\t\t\tif(has(\"ff\") < 4){\n\t\t\t\t\t\treturn (targetDir == \"rtl\") ? bidiEngine.bidiTransform(text,\"IRYNN\",\"VLNNN\") : bidiEngine.bidiTransform(text,\"ILYNN\",\"VLNNN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn bidi_const.LRM + (targetDir == \"rtl\" ? bidi_const.RLE : bidi_const.LRE) + text + bidi_const.PDF;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\t\t\treturn text;\n\t\t},\t\n\n\t\tbidiPreprocess: function(newShape){     \n\t\t\treturn newShape;\n\t\t}\n\t});\n\n\tlang.extend(g.TextPath, {\n\t\t// textDir: String\n\t\t//\t\tUsed for displaying bidi scripts in right layout.\n\t\t//\t\tDefines the base direction of text that displayed, can have 3 values:\n\t\t//\n\t\t//\t\t1. \"ltr\" - base direction is left to right.\n\t\t//\t\t2. \"rtl\" - base direction is right to left.\n\t\t//\t\t3. \"auto\" - base direction is contextual (defined by first strong character).\n\t\ttextDir: \"\",\n\n\t\tformatText: function (/*String*/text, /*String*/textDir){\n\t\t\t// summary:\n\t\t\t//\t\tApplies the right transform on text, according to renderer.\n\t\t\t// text:\n\t\t\t//\t\tthe string for manipulation, by default return value.\n\t\t\t// textDir:\n\t\t\t//\t\ttext direction direction.\n\t\t\t//\t\tCan be:\n\t\t\t//\n\t\t\t//\t\t1. \"ltr\" - for left to right layout.\n\t\t\t//\t\t2. \"rtl\" - for right to left layout\n\t\t\t//\t\t3. \"auto\" - for contextual layout: the first strong letter decides the direction.\n\t\t\t// description:\n\t\t\t//\t\tFinds the right transformation that should be applied on the text, according to renderer.\n\t\t\t//\t\tWas tested in:\n\t\t\t//\n\t\t\t//\t\tRenderers:\n\t\t\t//\t\tcanvas (FF, Chrome, Safari), vml (IE), svg (FF, Chrome, Safari, Opera), silverlight (IE8), svgWeb(FF, Chrome, Safari, Opera, IE).\n\t\t\t//\n\t\t\t//\t\tBrowsers:\n\t\t\t//\t\tIE [6,7,8], FF [3.6], Chrome (latest for February 2011), Safari [5.0.3], Opera [11.01].\n\n\t\t\tif(textDir && text && text.length > 1){\n\t\t\t\tvar sourceDir = \"ltr\", targetDir = textDir;\n\n\t\t\t\tif(targetDir == \"auto\"){\n\t\t\t\t\t//is auto by default\n\t\t\t\t\tif(g.isVml){\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t}\n\t\t\t\t\ttargetDir = bidiEngine.checkContextual(text);\n\t\t\t\t}\n\n\t\t\t\tif(g.isVml){\n\t\t\t\t\tsourceDir = bidiEngine.checkContextual(text);\n\t\t\t\t\tif(targetDir != sourceDir){\n\t\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\t\treturn !bidiEngine.hasBidiChar(text) ? bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\") : bidi_const.RLM + bidi_const.RLM + text;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn bidi_const.LRM + text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t\tif(g.isSvgWeb){\n\t\t\t\t\tif(targetDir == \"rtl\"){\n\t\t\t\t\t\treturn bidiEngine.bidiTransform(text,\"IRNNN\",\"ILNNN\");\n\t\t\t\t\t}\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t\t//unlike the g.Text that is rendered in logical layout for Bidi scripts.\n\t\t\t\t//for g.TextPath in svg always visual -> bidi script is unreadable (except Opera and FF start from version 4)\n\t\t\t\tif(g.isSvg){\n\t\t\t\t\tif(has(\"opera\") || has(\"ff\") >= 4){\n\t\t\t\t\t\ttext = bidi_const.LRM + (targetDir == \"rtl\"? bidi_const.RLE : bidi_const.LRE) + text + bidi_const.PDF;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttext = (targetDir == \"rtl\") ? bidiEngine.bidiTransform(text,\"IRYNN\",\"VLNNN\") : bidiEngine.bidiTransform(text,\"ILYNN\",\"VLNNN\");\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\t\n\t\t\treturn text;\n\t\t},\n\t\tbidiPreprocess: function(newText){\n\t\t\tif(newText && (typeof newText == \"string\")){\n\t\t\t\tthis.origText = newText;\n\t\t\t\tnewText = this.formatText(newText,this.textDir);\n\t\t\t}\n\t\t\treturn newText;\n\t\t}\n\t});\t\n\t\t\n\tvar extendMethod = function(shape, method, before, after){\n\t\t// summary:\n\t\t//\t\tSome helper function. Used for extending methods of shape.\n\t\t// shape: Object\n\t\t//\t\tThe shape we overriding it's method.\n\t\t// method: String\n\t\t//\t\tThe method that is extended, the original method is called before or after\n\t\t//\t\tfunctions that passed to extendMethod.\n\t\t// before: function\n\t\t//\t\tIf defined this function will be executed before the original method.\n\t\t// after: function\n\t\t//\t\tIf defined this function will be executed after the original method.\n\t\tvar old = shape.prototype[method];\n\t\tshape.prototype[method] = \n\t\t\tfunction(){\n\t\t\t\tvar rBefore;\n\t\t\t\tif (before){\n\t\t\t\t\trBefore = before.apply(this, arguments);\n\t\t\t\t}\n\t\t\t\tvar r = old.call(this, rBefore);\n\t\t\t\tif (after){\n\t\t\t\t\tr = after.call(this, r, arguments);\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t};\n\t};\n\n\tvar bidiPreprocess = function(newText){\n\t\tif (newText){  \n\t\t\tif (newText.textDir){\n\t\t\t\tnewText.textDir = validateTextDir(newText.textDir);\n\t\t\t}\n\t\t\tif (newText.text && (newText.text instanceof Array)){\n\t\t\t\tnewText.text = newText.text.join(\",\");\n\t\t\t}\n\t\t}\n\t\tif(newText && (newText.text != undefined || newText.textDir) && (this.textDir != newText.textDir || newText.text != this.origText)){\n\t\t\t// store the original text. \n\t\t\tthis.origText = (newText.text != undefined) ? newText.text : this.origText;\n\t\t\tif(newText.textDir){\n\t\t\t\tthis.textDir = newText.textDir;\n\t\t\t}\n\t\t\tnewText.text = this.formatText(this.origText,this.textDir);\n\t\t}\n\t\treturn this.bidiPreprocess(newText);\n\n\t};\n\n\t// Instead of adding bidiPreprocess to all renders one by one\n\t// use the extendMethod, at first there's a need for bidi transformation \n\t// on text then call to original setShape.\n\textendMethod(g.Text,\"setShape\", bidiPreprocess, null);\n\textendMethod(g.TextPath,\"setText\", bidiPreprocess, null);\n\t\n\tvar restoreText = function(origObj){\n\t\tvar obj = lang.clone(origObj);\n\t\tif (obj && this.origText){\n\t\t\tobj.text = this.origText;\n\t\t}\n\t\treturn obj;\n\t};\n\n\t// Instead of adding restoreText to all renders one by one\n\t// use the extendMethod, at first get the shape by calling the original getShape,\n\t// than resrore original text (without the text transformations).\n\textendMethod(g.Text, \"getShape\", null, restoreText);\n\textendMethod(g.TextPath, \"getText\", null, restoreText);\n\n\tvar groupTextDir = function(group, args){\n\t\tvar textDir;\n\t\tif (args && args[0]){\n\t\t\ttextDir = validateTextDir(args[0]);\n\t\t}\n\t\tgroup.setTextDir(textDir ? textDir : this.textDir);\n\t\treturn group;\t// dojox/gfx.Group\n\t};\n\n\t// In creation of Group there's a need to update it's textDir,\n\t// so instead of doing it in renders one by one (vml vs others)\n\t// use the extendMethod, at first the original createGroup is applied, the\n\t// groupTextDir which is setts Group's textDir as it's father's or if was defined\n\t// by user by this value.\n\textendMethod(g.Surface, \"createGroup\", null, groupTextDir);\n\textendMethod(g.Group, \"createGroup\", null, groupTextDir);\n\n\tvar textDirPreprocess =  function(text){\n\t\t// inherit from surface / group  if textDir is defined there\n\t\tif(text){\n\t\t\tvar textDir = text.textDir ? validateTextDir(text.textDir) : this.textDir;\n\t\t\tif(textDir){\n\t\t\t\ttext.textDir = textDir;\n\t\t\t}\n\t\t}\n\t\treturn text;\n\t};\n\n\t// In creation there's a need to some preprocess,\n\t// so instead of doing it in renders one by one (vml vs others)\n\t// use the extendMethod, at first the textDirPreprocess function handles the input\n\t// then the original createXXXXXX is applied.\n\textendMethod(g.Surface,\"createText\", textDirPreprocess, null);\n\textendMethod(g.Surface,\"createTextPath\", textDirPreprocess, null);\n\textendMethod(g.Group,\"createText\", textDirPreprocess, null);\n\textendMethod(g.Group,\"createTextPath\", textDirPreprocess, null);\n\n\t/*=====\n\t// don't mask definition of original createSurface() function from doc parser\n\tg = {};\n\t=====*/\n\n\tg.createSurface = function(parentNode, width, height, textDir) {\n\t\tvar s = g[g.renderer].createSurface(parentNode, width, height);\n\t\tvar tDir = validateTextDir(textDir);\n\t\t\n\t\tif(g.isSvgWeb){\n\t\t\ts.textDir = tDir ? tDir : html.style(dom.byId(parentNode),\"direction\");\n\t\t\treturn s;\n\t\t}\n\t\t// if textDir was defined use it, else get default value.\n\t\t//s.textDir = tDir ? tDir : html.style(s.rawNode,\"direction\");\n\t\tif(g.isVml || g.isSvg || g.isCanvas){\n\t\t\ts.textDir = tDir ? tDir : html.style(s.rawNode,\"direction\");\n\t\t}\n\t\tif(g.isSilverlight){\n\t\t\t// allow this once rawNode will be able for the silverlight\n\t\t\t//s.textDir = tDir ? tDir : dojo.style(s.rawNode,\"direction\");\n\t\t\ts.textDir = tDir ? tDir : html.style(s._nodes[1],\"direction\");\n\t\t}\n\t\t\n\t\treturn s;\n\t};\n\t/*===== g = origG; =====*/\n\n\t// some helper functions\n\t\n\tfunction setTextDir(/*Object*/ obj, /*String*/ newTextDir){\n\t\tvar tDir = validateTextDir(newTextDir);\n\t\tif (tDir){\n\t\t\tg.utils.forEach(obj,function(e){\n\t\t\t\tif(e instanceof g.Surface || e instanceof g.Group){\n\t\t\t\t\te.textDir = tDir;\n\t\t\t\t}\t\t\n\t\t\t\tif(e instanceof g.Text){\n\t\t\t\t\te.setShape({textDir: tDir});\n\t\t\t\t}\n\t\t\t\tif(e instanceof g.TextPath){\n\t\t\t\t\te.setText({textDir: tDir})\n\t\t\t\t}\n\t\t\t}, obj);\n\t\t}\n\t\treturn obj;\n\t}\n\n\tfunction validateTextDir(textDir){\n\t\tvar validValues = [\"ltr\",\"rtl\",\"auto\"]; \n\t\tif (textDir){\n\t\t\ttextDir = textDir.toLowerCase();\n\t\t\tif (arr.indexOf(validValues, textDir) < 0){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn textDir;\n\t}\n\n\treturn g; // return gfx api augmented with bidi support\t\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/_gfxBidiSupport.js\n// module id = 196\n// module chunks = 4","define([\"./kernel\", \"../dom\", \"../dom-style\", \"../dom-attr\", \"../dom-prop\", \"../dom-class\", \"../dom-construct\", \"../dom-geometry\"], function(dojo, dom, style, attr, prop, cls, ctr, geom){\r\n\t// module:\r\n\t//\t\tdojo/dom\r\n\r\n\t/*=====\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tThis module is a stub for the core dojo DOM API.\r\n\t};\r\n\t=====*/\r\n\r\n\t// mix-in dom\r\n\tdojo.byId = dom.byId;\r\n\tdojo.isDescendant = dom.isDescendant;\r\n\tdojo.setSelectable = dom.setSelectable;\r\n\r\n\t// mix-in dom-attr\r\n\tdojo.getAttr = attr.get;\r\n\tdojo.setAttr = attr.set;\r\n\tdojo.hasAttr = attr.has;\r\n\tdojo.removeAttr = attr.remove;\r\n\tdojo.getNodeProp = attr.getNodeProp;\r\n\r\n\tdojo.attr = function(node, name, value){\r\n\t\t// summary:\r\n\t\t//\t\tGets or sets an attribute on an HTML element.\r\n\t\t// description:\r\n\t\t//\t\tHandles normalized getting and setting of attributes on DOM\r\n\t\t//\t\tNodes. If 2 arguments are passed, and a the second argument is a\r\n\t\t//\t\tstring, acts as a getter.\r\n\t\t//\r\n\t\t//\t\tIf a third argument is passed, or if the second argument is a\r\n\t\t//\t\tmap of attributes, acts as a setter.\r\n\t\t//\r\n\t\t//\t\tWhen passing functions as values, note that they will not be\r\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\r\n\t\t//\t\tbehavior will be removed and the new behavior will be added\r\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\r\n\t\t//\t\twill be normalized and that some caveats with regards to\r\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\r\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\r\n\t\t//\t\tpassed event object instead of returning a boolean value from\r\n\t\t//\t\tthe handler itself.\r\n\t\t// node: DOMNode|String\r\n\t\t//\t\tid or reference to the element to get or set the attribute on\r\n\t\t// name: String|Object\r\n\t\t//\t\tthe name of the attribute to get or set.\r\n\t\t// value: String?\r\n\t\t//\t\tThe value to set for the attribute\r\n\t\t// returns:\r\n\t\t//\t\twhen used as a getter, the value of the requested attribute\r\n\t\t//\t\tor null if that attribute does not have a specified or\r\n\t\t//\t\tdefault value;\r\n\t\t//\r\n\t\t//\t\twhen used as a setter, the DOM node\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\t// get the current value of the \"foo\" attribute on a node\r\n\t\t//\t|\tdojo.attr(dojo.byId(\"nodeId\"), \"foo\");\r\n\t\t//\t|\t// or we can just pass the id:\r\n\t\t//\t|\tdojo.attr(\"nodeId\", \"foo\");\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\t// use attr() to set the tab index\r\n\t\t//\t|\tdojo.attr(\"nodeId\", \"tabIndex\", 3);\r\n\t\t//\t|\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tSet multiple values at once, including event handlers:\r\n\t\t//\t|\tdojo.attr(\"formId\", {\r\n\t\t//\t|\t\t\"foo\": \"bar\",\r\n\t\t//\t|\t\t\"tabIndex\": -1,\r\n\t\t//\t|\t\t\"method\": \"POST\",\r\n\t\t//\t|\t\t\"onsubmit\": function(e){\r\n\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\r\n\t\t//\t|\t\t\t// of returning true or false will have no effect here\r\n\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\r\n\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\r\n\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\r\n\t\t//\t|\t\t\t// doesn't proceed.\r\n\t\t//\t|\t\t\tdojo.stopEvent(e);\r\n\t\t//\t|\r\n\t\t//\t|\t\t\t// submit the form with Ajax\r\n\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tStyle is s special case: Only set with an object hash of styles\r\n\t\t//\t|\tdojo.attr(\"someNode\",{\r\n\t\t//\t|\t\tid:\"bar\",\r\n\t\t//\t|\t\tstyle:{\r\n\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tAgain, only set style as an object hash of styles:\r\n\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\r\n\t\t//\t|\tdojo.attr(\"someNode\", \"style\", obj);\r\n\t\t//\t|\r\n\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\r\n\t\t//\t|\tdojo.style(\"someNode\", obj);\r\n\r\n\t\tif(arguments.length == 2){\r\n\t\t\treturn attr[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\r\n\t\t}\r\n\t\treturn attr.set(node, name, value);\r\n\t};\r\n\r\n\t// mix-in dom-class\r\n\tdojo.hasClass = cls.contains;\r\n\tdojo.addClass = cls.add;\r\n\tdojo.removeClass = cls.remove;\r\n\tdojo.toggleClass = cls.toggle;\r\n\tdojo.replaceClass = cls.replace;\r\n\r\n\t// mix-in dom-construct\r\n\tdojo._toDom = dojo.toDom = ctr.toDom;\r\n\tdojo.place = ctr.place;\r\n\tdojo.create = ctr.create;\r\n\tdojo.empty = function(node){ ctr.empty(node); };\r\n\tdojo._destroyElement = dojo.destroy = function(node){ ctr.destroy(node); };\r\n\r\n\t// mix-in dom-geometry\r\n\tdojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;\r\n\tdojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;\r\n\tdojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;\r\n\tdojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;\r\n\tdojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;\r\n\tdojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;\r\n\tdojo.setMarginBox = geom.setMarginBox;\r\n\tdojo._getContentBox = dojo.getContentBox = geom.getContentBox;\r\n\tdojo.setContentSize = geom.setContentSize;\r\n\tdojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;\r\n\tdojo._docScroll = dojo.docScroll = geom.docScroll;\r\n\tdojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;\r\n\tdojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;\r\n\tdojo.position = geom.position;\r\n\r\n\tdojo.marginBox = function marginBox(/*DomNode|String*/node, /*Object?*/box){\r\n\t\t// summary:\r\n\t\t//\t\tGetter/setter for the margin-box of node.\r\n\t\t// description:\r\n\t\t//\t\tGetter/setter for the margin-box of node.\r\n\t\t//\t\tReturns an object in the expected format of box (regardless\r\n\t\t//\t\tif box is passed). The object might look like:\r\n\t\t//\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\r\n\t\t//\t\tfor a node offset from its parent 50px to the left, 200px from\r\n\t\t//\t\tthe top with a margin width of 300px and a margin-height of\r\n\t\t//\t\t150px.\r\n\t\t// node:\r\n\t\t//\t\tid or reference to DOM Node to get/set box for\r\n\t\t// box:\r\n\t\t//\t\tIf passed, denotes that dojo.marginBox() should\r\n\t\t//\t\tupdate/set the margin box for node. Box is an object in the\r\n\t\t//\t\tabove format. All properties are optional if passed.\r\n\t\t// example:\r\n\t\t//\t\tRetrieve the margin box of a passed node\r\n\t\t//\t|\tvar box = dojo.marginBox(\"someNodeId\");\r\n\t\t//\t|\tconsole.dir(box);\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tSet a node's margin box to the size of another node\r\n\t\t//\t|\tvar box = dojo.marginBox(\"someNodeId\");\r\n\t\t//\t|\tdojo.marginBox(\"someOtherNode\", box);\r\n\t\treturn box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); // Object\r\n\t};\r\n\r\n\tdojo.contentBox = function contentBox(/*DomNode|String*/node, /*Object?*/box){\r\n\t\t// summary:\r\n\t\t//\t\tGetter/setter for the content-box of node.\r\n\t\t// description:\r\n\t\t//\t\tReturns an object in the expected format of box (regardless if box is passed).\r\n\t\t//\t\tThe object might look like:\r\n\t\t//\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\r\n\t\t//\t\tfor a node offset from its parent 50px to the left, 200px from\r\n\t\t//\t\tthe top with a content width of 300px and a content-height of\r\n\t\t//\t\t150px. Note that the content box may have a much larger border\r\n\t\t//\t\tor margin box, depending on the box model currently in use and\r\n\t\t//\t\tCSS values set/inherited for node.\r\n\t\t//\t\tWhile the getter will return top and left values, the\r\n\t\t//\t\tsetter only accepts setting the width and height.\r\n\t\t// node:\r\n\t\t//\t\tid or reference to DOM Node to get/set box for\r\n\t\t// box:\r\n\t\t//\t\tIf passed, denotes that dojo.contentBox() should\r\n\t\t//\t\tupdate/set the content box for node. Box is an object in the\r\n\t\t//\t\tabove format, but only w (width) and h (height) are supported.\r\n\t\t//\t\tAll properties are optional if passed.\r\n\t\treturn box ? geom.setContentSize(node, box) : geom.getContentBox(node); // Object\r\n\t};\r\n\r\n\tdojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated: Use position() for border-box x/y/w/h\r\n\t\t//\t\tor marginBox() for margin-box w/h/l/t.\r\n\t\t//\r\n\t\t//\t\tReturns an object that measures margin-box (w)idth/(h)eight\r\n\t\t//\t\tand absolute position x/y of the border-box. Also returned\r\n\t\t//\t\tis computed (l)eft and (t)op values in pixels from the\r\n\t\t//\t\tnode's offsetParent as returned from marginBox().\r\n\t\t//\t\tReturn value will be in the form:\r\n\t\t//|\t\t\t{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }\r\n\t\t//\t\tDoes not act as a setter. If includeScroll is passed, the x and\r\n\t\t//\t\ty params are affected as one would expect in dojo.position().\r\n\t\tdojo.deprecated(\"dojo.coords()\", \"Use dojo.position() or dojo.marginBox().\");\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);\r\n\t\tvar abs = geom.position(node, includeScroll);\r\n\t\tmb.x = abs.x;\r\n\t\tmb.y = abs.y;\r\n\t\treturn mb;\t// Object\r\n\t};\r\n\r\n\t// mix-in dom-prop\r\n\tdojo.getProp = prop.get;\r\n\tdojo.setProp = prop.set;\r\n\r\n\tdojo.prop = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){\r\n\t\t// summary:\r\n\t\t//\t\tGets or sets a property on an HTML element.\r\n\t\t// description:\r\n\t\t//\t\tHandles normalized getting and setting of properties on DOM\r\n\t\t//\t\tNodes. If 2 arguments are passed, and a the second argument is a\r\n\t\t//\t\tstring, acts as a getter.\r\n\t\t//\r\n\t\t//\t\tIf a third argument is passed, or if the second argument is a\r\n\t\t//\t\tmap of attributes, acts as a setter.\r\n\t\t//\r\n\t\t//\t\tWhen passing functions as values, note that they will not be\r\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\r\n\t\t//\t\tbehavior will be removed and the new behavior will be added\r\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\r\n\t\t//\t\twill be normalized and that some caveats with regards to\r\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\r\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\r\n\t\t//\t\tpassed event object instead of returning a boolean value from\r\n\t\t//\t\tthe handler itself.\r\n\t\t// node:\r\n\t\t//\t\tid or reference to the element to get or set the property on\r\n\t\t// name:\r\n\t\t//\t\tthe name of the property to get or set.\r\n\t\t// value:\r\n\t\t//\t\tThe value to set for the property\r\n\t\t// returns:\r\n\t\t//\t\twhen used as a getter, the value of the requested property\r\n\t\t//\t\tor null if that attribute does not have a specified or\r\n\t\t//\t\tdefault value;\r\n\t\t//\r\n\t\t//\t\twhen used as a setter, the DOM node\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\t// get the current value of the \"foo\" property on a node\r\n\t\t//\t|\tdojo.prop(dojo.byId(\"nodeId\"), \"foo\");\r\n\t\t//\t|\t// or we can just pass the id:\r\n\t\t//\t|\tdojo.prop(\"nodeId\", \"foo\");\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\t// use prop() to set the tab index\r\n\t\t//\t|\tdojo.prop(\"nodeId\", \"tabIndex\", 3);\r\n\t\t//\t|\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tSet multiple values at once, including event handlers:\r\n\t\t//\t|\tdojo.prop(\"formId\", {\r\n\t\t//\t|\t\t\"foo\": \"bar\",\r\n\t\t//\t|\t\t\"tabIndex\": -1,\r\n\t\t//\t|\t\t\"method\": \"POST\",\r\n\t\t//\t|\t\t\"onsubmit\": function(e){\r\n\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\r\n\t\t//\t|\t\t\t// of returning true or false will have no effect here\r\n\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\r\n\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\r\n\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\r\n\t\t//\t|\t\t\t// doesn't proceed.\r\n\t\t//\t|\t\t\tdojo.stopEvent(e);\r\n\t\t//\t|\r\n\t\t//\t|\t\t\t// submit the form with Ajax\r\n\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tStyle is s special case: Only set with an object hash of styles\r\n\t\t//\t|\tdojo.prop(\"someNode\",{\r\n\t\t//\t|\t\tid:\"bar\",\r\n\t\t//\t|\t\tstyle:{\r\n\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tAgain, only set style as an object hash of styles:\r\n\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\r\n\t\t//\t|\tdojo.prop(\"someNode\", \"style\", obj);\r\n\t\t//\t|\r\n\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\r\n\t\t//\t|\tdojo.style(\"someNode\", obj);\r\n\r\n\t\tif(arguments.length == 2){\r\n\t\t\treturn prop[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\r\n\t\t}\r\n\t\t// setter\r\n\t\treturn prop.set(node, name, value);\r\n\t};\r\n\r\n\t// mix-in dom-style\r\n\tdojo.getStyle = style.get;\r\n\tdojo.setStyle = style.set;\r\n\tdojo.getComputedStyle = style.getComputedStyle;\r\n\tdojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;\r\n\r\n\tdojo.style = function(node, name, value){\r\n\t\t// summary:\r\n\t\t//\t\tAccesses styles on a node. If 2 arguments are\r\n\t\t//\t\tpassed, acts as a getter. If 3 arguments are passed, acts\r\n\t\t//\t\tas a setter.\r\n\t\t// description:\r\n\t\t//\t\tGetting the style value uses the computed style for the node, so the value\r\n\t\t//\t\twill be a calculated value, not just the immediate node.style value.\r\n\t\t//\t\tAlso when getting values, use specific style names,\r\n\t\t//\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\r\n\t\t//\t\t\"border\" are not necessarily reflected as expected.\r\n\t\t//\t\tIf you want to get node dimensions, use `dojo.marginBox()`,\r\n\t\t//\t\t`dojo.contentBox()` or `dojo.position()`.\r\n\t\t// node: DOMNode|String\r\n\t\t//\t\tid or reference to node to get/set style for\r\n\t\t// name: String|Object?\r\n\t\t//\t\tthe style property to set in DOM-accessor format\r\n\t\t//\t\t(\"borderWidth\", not \"border-width\") or an object with key/value\r\n\t\t//\t\tpairs suitable for setting each property.\r\n\t\t// value: String?\r\n\t\t//\t\tIf passed, sets value on the node for style, handling\r\n\t\t//\t\tcross-browser concerns.  When setting a pixel value,\r\n\t\t//\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\r\n\t\t//\t\tOtherwise, in some cases, some browsers will not apply the style.\r\n\t\t// returns:\r\n\t\t//\t\twhen used as a getter, return the computed style of the node if passing in an ID or node,\r\n\t\t//\t\tor return the normalized, computed value for the property when passing in a node and a style property\r\n\t\t// example:\r\n\t\t//\t\tPassing only an ID or node returns the computed style object of\r\n\t\t//\t\tthe node:\r\n\t\t//\t|\tdojo.style(\"thinger\");\r\n\t\t// example:\r\n\t\t//\t\tPassing a node and a style property returns the current\r\n\t\t//\t\tnormalized, computed value for that property:\r\n\t\t//\t|\tdojo.style(\"thinger\", \"opacity\"); // 1 by default\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tPassing a node, a style property, and a value changes the\r\n\t\t//\t\tcurrent display of the node and returns the new computed value\r\n\t\t//\t|\tdojo.style(\"thinger\", \"opacity\", 0.5); // == 0.5\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\r\n\t\t//\t|\tdojo.style(\"thinger\", {\r\n\t\t//\t|\t\t\"opacity\": 0.5,\r\n\t\t//\t|\t\t\"border\": \"3px solid black\",\r\n\t\t//\t|\t\t\"height\": \"300px\"\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\r\n\t\t//\t\tfont-size becomes fontSize, and so on.\r\n\t\t//\t|\tdojo.style(\"thinger\",{\r\n\t\t//\t|\t\tfontSize:\"14pt\",\r\n\t\t//\t|\t\tletterSpacing:\"1.2em\"\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tdojo/NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\r\n\t\t//\t\tdojo.style() on every element of the list. See: `dojo/query` and `dojo/NodeList`\r\n\t\t//\t|\tdojo.query(\".someClassName\").style(\"visibility\",\"hidden\");\r\n\t\t//\t|\t// or\r\n\t\t//\t|\tdojo.query(\"#baz > div\").style({\r\n\t\t//\t|\t\topacity:0.75,\r\n\t\t//\t|\t\tfontSize:\"13pt\"\r\n\t\t//\t|\t});\r\n\r\n\t\tswitch(arguments.length){\r\n\t\t\tcase 1:\r\n\t\t\t\treturn style.get(node);\r\n\t\t\tcase 2:\r\n\t\t\t\treturn style[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\r\n\t\t}\r\n\t\t// setter\r\n\t\treturn style.set(node, name, value);\r\n\t};\r\n\r\n\treturn dojo;\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojo/_base/html.js\n// module id = 197\n// module chunks = 4","define([\"dojo/_base/kernel\",\"dojo/_base/lang\",\"./_base\", \"dojo/_base/html\",\"dojo/_base/array\", \"dojo/_base/window\", \"dojo/_base/json\", \n\t\"dojo/_base/Deferred\", \"dojo/_base/sniff\", \"require\",\"dojo/_base/config\"], \n  function(kernel, lang, g, html, arr, win, jsonLib, Deferred, has, require, config){\n\tvar gu = g.utils = {};\n\n\tlang.mixin(gu, {\n\t\tforEach: function(\n\t\t\t/*dojox/gfx/shape.Surface|dojox/gfx/shape.Shape*/ object,\n\t\t\t/*Function|String|Array*/ f, /*Object?*/ o\n\t\t){\n\t\t\t// summary:\n\t\t\t//\t\tTakes a shape or a surface and applies a function \"f\" to in the context of \"o\"\n\t\t\t//\t\t(or global, if missing). If \"shape\" was a surface or a group, it applies the same\n\t\t\t//\t\tfunction to all children recursively effectively visiting all shapes of the underlying scene graph.\n\t\t\t// object:\n\t\t\t//\t\tThe gfx container to iterate.\n\t\t\t// f:\n\t\t\t//\t\tThe function to apply.\n\t\t\t// o:\n\t\t\t//\t\tThe scope.\n\t\t\to = o || kernel.global;\n\t\t\tf.call(o, object);\n\t\t\tif(object instanceof g.Surface || object instanceof g.Group){\n\t\t\t\tarr.forEach(object.children, function(shape){\n\t\t\t\t\tgu.forEach(shape, f, o);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tserialize: function(object){\n\t\t\t// summary:\n\t\t\t//\t\tTakes a shape or a surface and returns an object, which describes underlying shapes.\n\t\t\t// object: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t//\t\tThe container to serialize.\n\n\t\t\tvar t = {}, v, isSurface = object instanceof g.Surface;\n\t\t\tif(isSurface || object instanceof g.Group){\n\t\t\t\tt.children = arr.map(object.children, gu.serialize);\n\t\t\t\tif(isSurface){\n\t\t\t\t\treturn t.children;\t// Array\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tt.shape = object.getShape();\n\t\t\t}\n\t\t\tif(object.getTransform){\n\t\t\t\tv = object.getTransform();\n\t\t\t\tif(v){ t.transform = v; }\n\t\t\t}\n\t\t\tif(object.getStroke){\n\t\t\t\tv = object.getStroke();\n\t\t\t\tif(v){ t.stroke = v; }\n\t\t\t}\n\t\t\tif(object.getFill){\n\t\t\t\tv = object.getFill();\n\t\t\t\tif(v){ t.fill = v; }\n\t\t\t}\n\t\t\tif(object.getFont){\n\t\t\t\tv = object.getFont();\n\t\t\t\tif(v){ t.font = v; }\n\t\t\t}\n\t\t\treturn t;\t// Object\n\t\t},\n\n\t\ttoJson: function(object, prettyPrint){\n\t\t\t// summary:\n\t\t\t//\t\tWorks just like serialize() but returns a JSON string. If prettyPrint is true, the string is pretty-printed to make it more human-readable.\n\t\t\t// object: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t//\t\tThe container to serialize.\n\t\t\t// prettyPrint: Boolean?\n\t\t\t//\t\tIndicates whether the output string should be formatted.\n\t\t\t// returns: String\n\t\t\t\n\t\t\treturn jsonLib.toJson(gu.serialize(object), prettyPrint);\t// String\n\t\t},\n\n\t\tdeserialize: function(parent, object){\n\t\t\t// summary:\n\t\t\t//\t\tTakes a surface or a shape and populates it with an object produced by serialize().\n\t\t\t// parent: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t//\t\tThe destination container for the deserialized shapes.\n\t\t\t// object: dojox/gfx/shape.Shape|Array\n\t\t\t//\t\tThe shapes to deserialize.\n\n\t\t\tif(object instanceof Array){\n\t\t\t\treturn arr.map(object, lang.hitch(null, gu.deserialize, parent));\t// Array\n\t\t\t}\n\t\t\tvar shape = (\"shape\" in object) ? parent.createShape(object.shape) : parent.createGroup();\n\t\t\tif(\"transform\" in object){\n\t\t\t\tshape.setTransform(object.transform);\n\t\t\t}\n\t\t\tif(\"stroke\" in object){\n\t\t\t\tshape.setStroke(object.stroke);\n\t\t\t}\n\t\t\tif(\"fill\" in object){\n\t\t\t\tshape.setFill(object.fill);\n\t\t\t}\n\t\t\tif(\"font\" in object){\n\t\t\t\tshape.setFont(object.font);\n\t\t\t}\n\t\t\tif(\"children\" in object){\n\t\t\t\tarr.forEach(object.children, lang.hitch(null, gu.deserialize, shape));\n\t\t\t}\n\t\t\treturn shape;\t// dojox/gfx/shape.Shape\n\t\t},\n\n\t\tfromJson: function(parent, json){\n\t\t\t// summary:\n\t\t\t//\t\tWorks just like deserialize() but takes a JSON representation of the object.\n\t\t\t// parent: dojox/gfx/shape.Surface|dojox/gfx/shape.Shape\n\t\t\t//\t\tThe destination container for the deserialized shapes.\n\t\t\t// json: String\n\t\t\t//\t\tThe shapes to deserialize.\n\n\t\t\treturn gu.deserialize(parent, jsonLib.fromJson(json));\t// Array|dojox/gfx/shape.Shape\n\t\t},\n\n\t\ttoSvg: function(/*dojox/gfx/shape.Surface*/surface){\n\t\t\t// summary:\n\t\t\t//\t\tFunction to serialize a GFX surface to SVG text.\n\t\t\t// description:\n\t\t\t//\t\tFunction to serialize a GFX surface to SVG text.  The value of this output\n\t\t\t//\t\tis that there are numerous serverside parser libraries that can render\n\t\t\t//\t\tSVG into images in various formats.  This provides a way that GFX objects\n\t\t\t//\t\tcan be captured in a known format and sent serverside for serialization\n\t\t\t//\t\tinto an image.\n\t\t\t// surface:\n\t\t\t//\t\tThe GFX surface to serialize.\n\t\t\t// returns:\n\t\t\t//\t\tDeferred object that will be called when SVG serialization is complete.\n\t\t\n\t\t\t//Since the init and even surface creation can be async, we need to\n\t\t\t//return a deferred that will be called when content has serialized.\n\t\t\tvar deferred = new Deferred();\n\t\t\n\t\t\tif(g.renderer === \"svg\"){\n\t\t\t\t//If we're already in SVG mode, this is easy and quick.\n\t\t\t\ttry{\n\t\t\t\t\tvar svg = gu._cleanSvg(gu._innerXML(surface.rawNode));\n\t\t\t\t\tdeferred.callback(svg);\n\t\t\t\t}catch(e){\n\t\t\t\t\tdeferred.errback(e);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//Okay, now we have to get creative with hidden iframes and the like to\n\t\t\t\t//serialize SVG.\n\t\t\t\tif (!gu._initSvgSerializerDeferred) {\n\t\t\t\t\tgu._initSvgSerializer();\n\t\t\t\t}\n\t\t\t\tvar jsonForm = gu.toJson(surface);\n\t\t\t\tvar serializer = function(){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar sDim = surface.getDimensions();\n\t\t\t\t\t\tvar width = sDim.width;\n\t\t\t\t\t\tvar\theight = sDim.height;\n\n\t\t\t\t\t\t//Create an attach point in the iframe for the contents.\n\t\t\t\t\t\tvar node = gu._gfxSvgProxy.document.createElement(\"div\");\n\t\t\t\t\t\tgu._gfxSvgProxy.document.body.appendChild(node);\n\t\t\t\t\t\t//Set the node scaling.\n\t\t\t\t\t\twin.withDoc(gu._gfxSvgProxy.document, function() {\n\t\t\t\t\t\t\thtml.style(node, \"width\", width);\n\t\t\t\t\t\t\thtml.style(node, \"height\", height);\n\t\t\t\t\t\t}, this);\n\n\t\t\t\t\t\t//Create temp surface to render object to and render.\n\t\t\t\t\t\tvar ts = gu._gfxSvgProxy[dojox._scopeName].gfx.createSurface(node, width, height);\n\n\t\t\t\t\t\t//It's apparently possible that a suface creation is async, so we need to use\n\t\t\t\t\t\t//the whenLoaded function.  Probably not needed for SVG, but making it common\n\t\t\t\t\t\tvar draw = function(surface) {\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\tgu._gfxSvgProxy[dojox._scopeName].gfx.utils.fromJson(surface, jsonForm);\n\n\t\t\t\t\t\t\t\t//Get contents and remove temp surface.\n\t\t\t\t\t\t\t\tvar svg = gu._cleanSvg(node.innerHTML);\n\t\t\t\t\t\t\t\tsurface.clear();\n\t\t\t\t\t\t\t\tsurface.destroy();\n\t\t\t\t\t\t\t\tgu._gfxSvgProxy.document.body.removeChild(node);\n\t\t\t\t\t\t\t\tdeferred.callback(svg);\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\tdeferred.errback(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tts.whenLoaded(null,draw);\n\t\t\t\t\t }catch (ex) {\n\t\t\t\t\t\tdeferred.errback(ex);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t//See if we can call it directly or pass it to the deferred to be\n\t\t\t\t//called on initialization.\n\t\t\t\tif(gu._initSvgSerializerDeferred.fired > 0){\n\t\t\t\t\tserializer();\n\t\t\t\t}else{\n\t\t\t\t\tgu._initSvgSerializerDeferred.addCallback(serializer);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn deferred; //dojo.Deferred that will be called when serialization finishes.\n\t\t},\n\n\t\t//iFrame document used for handling SVG serialization.\n\t\t_gfxSvgProxy: null,\n\n\t\t//Serializer loaded.\n\t\t_initSvgSerializerDeferred: null,\n\n\t\t_svgSerializerInitialized: function() {\n\t\t\t// summary:\n\t\t\t//\t\tInternal function to call when the serializer init completed.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tgu._initSvgSerializerDeferred.callback(true);\n\t\t},\n\n\t\t_initSvgSerializer: function(){\n\t\t\t// summary:\n\t\t\t//\t\tInternal function to initialize the hidden iframe where SVG rendering\n\t\t\t//\t\twill occur.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tif(!gu._initSvgSerializerDeferred){\n\t\t\t\tgu._initSvgSerializerDeferred = new Deferred();\n\t\t\t\tvar f = win.doc.createElement(\"iframe\");\n\t\t\t\thtml.style(f, {\n\t\t\t\t\tdisplay: \"none\",\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\twidth: \"1em\",\n\t\t\t\t\theight: \"1em\",\n\t\t\t\t\ttop: \"-10000px\"\n\t\t\t\t});\n\t\t\t\tvar intv;\n\t\t\t\tif(has(\"ie\")){\n\t\t\t\t\tf.onreadystatechange = function(){\n\t\t\t\t\t\tif(f.contentWindow.document.readyState == \"complete\"){\n\t\t\t\t\t\t\tf.onreadystatechange = function() {};\n\t\t\t\t\t\t\tintv = setInterval(function() {\n\t\t\t\t\t\t\t\tif(f.contentWindow[kernel.scopeMap[\"dojo\"][1]._scopeName] &&\n\t\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx &&\n\t\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils){\n\t\t\t\t\t\t\t\t\tclearInterval(intv);\n\t\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._gfxSvgProxy = f.contentWindow;\n\t\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._svgSerializerInitialized();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 50);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tf.onload = function(){\n\t\t\t\t\t\tf.onload = function() {};\n\t\t\t\t\t\tintv = setInterval(function() {\n\t\t\t\t\t\t\tif(f.contentWindow[kernel.scopeMap[\"dojo\"][1]._scopeName] &&\n\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx &&\n\t\t\t\t\t\t\t   f.contentWindow[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils){\n\t\t\t\t\t\t\t\tclearInterval(intv);\n\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._gfxSvgProxy = f.contentWindow;\n\t\t\t\t\t\t\t\tf.contentWindow.parent[kernel.scopeMap[\"dojox\"][1]._scopeName].gfx.utils._svgSerializerInitialized();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 50);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t//We have to load the GFX SVG proxy frame.  Default is to use the one packaged in dojox.\n\t\t\t\tvar uri = (config[\"dojoxGfxSvgProxyFrameUrl\"]||require.toUrl(\"dojox/gfx/resources/gfxSvgProxyFrame.html\"));\n\t\t\t\tf.setAttribute(\"src\", uri.toString());\n\t\t\t\twin.body().appendChild(f);\n\t\t\t}\n\t\t},\n\n\t\t_innerXML: function(/*Node*/node){\n\t\t\t// summary:\n\t\t\t//\t\tImplementation of MS's innerXML function, borrowed from dojox.xml.parser.\n\t\t\t// node:\n\t\t\t//\t\tThe node from which to generate the XML text representation.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tif(node.innerXML){\n\t\t\t\treturn node.innerXML;\t//String\n\t\t\t}else if(node.xml){\n\t\t\t\treturn node.xml;\t\t//String\n\t\t\t}else if(typeof XMLSerializer != \"undefined\"){\n\t\t\t\treturn (new XMLSerializer()).serializeToString(node);\t//String\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\t\t_cleanSvg: function(svg) {\n\t\t\t// summary:\n\t\t\t//\t\tInternal function that cleans up artifacts in extracted SVG content.\n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\tif(svg){\n\t\t\t\t//Make sure the namespace is set.\n\t\t\t\tif(svg.indexOf(\"xmlns=\\\"http://www.w3.org/2000/svg\\\"\") == -1){\n\t\t\t\t\tsvg = svg.substring(4, svg.length);\n\t\t\t\t\tsvg = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\" + svg;\n\t\t\t\t}\n\t\t\t\t//Same for xmlns:xlink (missing in Chrome and Safari)\n\t\t\t\tif(svg.indexOf(\"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\") == -1){\n\t\t\t\t\tsvg = svg.substring(4, svg.length);\n\t\t\t\t\tsvg = \"<svg xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\" + svg;\n\t\t\t\t}\n\t\t\t\t//and add namespace to href attribute if not done yet \n\t\t\t\t//(FF 5+ adds xlink:href but not the xmlns def)\n\t\t\t\tif(svg.indexOf(\"xlink:href\") === -1){\n\t\t\t\t\tsvg = svg.replace(/href\\s*=/g, \"xlink:href=\");\n\t\t\t\t}\n\t\t\t\t// in IE, <image are serialized as <img>\n\t\t\t\tsvg = svg.replace(/<img\\b([^>]*)>/gi,\"<image $1 />\");\n\t\t\t\t//Do some other cleanup, like stripping out the\n\t\t\t\t//dojoGfx attributes and quoting ids.\n\t\t\t\tsvg = svg.replace(/\\bdojoGfx\\w*\\s*=\\s*(['\"])\\w*\\1/g, \"\");\n\t\t\t\tsvg = svg.replace(/\\b__gfxObject__\\s*=\\s*(['\"])\\w*\\1/g, \"\");\n\t\t\t\tsvg = svg.replace(/[=]([^\"']+?)(\\s|>)/g,'=\"$1\"$2');\n\t\t\t\t\n\t\t\t\t// Undefined strokes (IE 8 seralization weirdness) should be removed to  \n\t\t\t\t// allow default.  'undefined' is not a valid value. \n\t\t\t\tsvg = svg.replace(/\\bstroke-opacity\\w*\\s*=\\s*(['\"])undefined\\1/g, \"\"); \t\t\t\t\n\t\t\t}\n\t\t\treturn svg;  //Cleaned SVG text.\n\t\t}\n\t});\n\n\treturn gu;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/gfx/utils.js\n// module id = 198\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/Stateful\"], \n  function(lang,declare,Stateful) {\n\tlang.getObject(\"string\", true, dojox);\n\n\tvar BidiEngine = declare(\"dojox.string.BidiEngine\", Stateful, {\n\t\t// summary:\n\t\t//\t\tThis class provides a bidi transformation engine, i.e.\n\t\t//\t\tfunctions for reordering and shaping bidi text.\n\t\t// description:\n\t\t//\t\tBidi stands for support for languages with a bidirectional script. \n\t\t//\n\t\t//\t\tUsually Unicode Bidi Algorithm used by OS platform (and web browsers) is capable of properly \n\t\t//\t\ttransforming Bidi text and as a result it is adequately displayed on the screen. \n\t\t//\t\tHowever, in some situations, Unicode Bidi Algorithm is not invoked or is not properly applied.  \n\t\t//\t\tThis may occur in situation in which software responsible for rendering the text is not leveraging \n\t\t//\t\tUnicode Bidi Algorithm implemented by OS (e.g. GFX renderers).\n\t\t//\n\t\t//\t\tBidi engine provided in this class implements Unicode Bidi Algorithm as specified at\n\t\t//\t\thttp://www.unicode.org/reports/tr9/.\n\t\t//\n\t\t//\t\tFor more information on basic Bidi concepts please read\n\t\t//\t\t\"Bidirectional script support - A primer\" available from\n\t\t//\t\thttp://www.ibm.com/developerworks/websphere/library/techarticles/bidi/bidigen.html.\n\t\t//\n\t\t//\t\tAs of February 2011, Bidi engine has following limitations:\n\t\t//\n\t\t//\t\t1. No support for following numeric shaping options:\n\t\t//\t\t\t- H - Hindi,\n\t\t//\t\t\t- C - Contextual, \n\t\t//\t\t\t- N - Nominal.\n\t\t//\t\t2. No support for following shaping options:\n\t\t//\t\t\t- I - Initial shaping,\n\t\t//\t\t\t- M - Middle shaping,\n\t\t//\t\t\t- F - Final shaping,\n\t\t//\t\t\t- B - Isolated shaping.\n\t\t//\t\t3. No support for LRE/RLE/LRO/RLO/PDF (they are handled like neutrals).\n\t\t//\t\t4. No support for Windows compatibility.\n\t\t//\t\t5. No support for  insert/remove marks.\n\t\t//\t\t6. No support for code pages. \n\t\t//\t\t\t\n\t\t\n\t\t// Input Bidi layout in which inputText is passed to the function.\n\t\tinputFormat: \"ILYNN\",\n\t\t\n\t\t// Output Bidi layout to which inputText should be transformed.\n\t\toutputFormat: \"VLNNN\",\n\n\t\t// Array, containing positions of each character from the source text in the resulting text. \n\t\tsourceToTarget: [],\n\t\t\n\t\t// Array, containing positions of each character from the resulting text in the source text. \n\t\ttargetToSource: [],\n\t\t\n\t\t// Array, containing bidi level of each character from the source text\n\t\tlevels: [],\n\n\t\tbidiTransform: function (/*String*/text, /*String*/formatIn, /*String*/formatOut) {\n\t\t\t// summary:\n\t\t\t//\t\tCentral public API for Bidi engine. Transforms the text according to formatIn, formatOut \n\t\t\t//\t\tparameters. If formatIn or formatOut parametrs are not valid throws an exception.\n\t\t\t// inputText:\n\t\t\t//\t\tInput text subject to application of Bidi transformation.\n\t\t\t// formatIn:\n\t\t\t//\t\tInput Bidi layout in which inputText is passed to the function.\n\t\t\t// formatOut:\n\t\t\t//\t\tOutput Bidi layout to which inputText should be transformed.\n\t\t\t// description:\n\t\t\t//\t\tBoth formatIn and formatOut parameters are 5 letters long strings. \n\t\t\t//\t\tFor example - \"ILYNN\". Each letter is associated with specific attribute of Bidi layout. \n\t\t\t//\t\tPossible and default values for each one of the letters are provided below:\n\t\t\t//\n\t\t\t//\t\tFirst letter:\n\t\t\t//\n\t\t\t//\t\t- Letter position/index:\n\t\t\t//\t\t\t1\n\t\t\t//\t\t- Letter meaning:\n\t\t\t//\t\t\tOrdering Schema.\n\t\t\t//\t\t- Possible values:\n\t\t\t//\t\t\t- I - Implicit (Logical).\n\t\t\t//\t\t\t- V - Visual.\n\t\t\t//\t\t- Default value:\n\t\t\t//\t\t\tI\n\t\t\t//\n\t\t\t//\t\tSecond letter:\n\t\t\t//\n\t\t\t//\t\t- Letter position/index:\n\t\t\t//\t\t\t2\n\t\t\t//\t\t- Letter meaning:\n\t\t\t//\t\t\tOrientation.\n\t\t\t//\t\t- Possible values:\n\t\t\t//\t\t\t- L - Left To Right.\n\t\t\t//\t\t\t- R - Right To Left.\n\t\t\t//\t\t\t- C - Contextual Left to Right.\n\t\t\t//\t\t\t- D - Contextual Right to Left.\n\t\t\t//\t\t- Default value:\n\t\t\t//\t\t\tL\t\t\n\t\t\t//\n\t\t\t//\t\tThird letter:\n\t\t\t//\n\t\t\t//\t\t- Letter position/index:\n\t\t\t//\t\t\t3\n\t\t\t//\t\t- Letter meaning:\n\t\t\t//\t\t\tSymmetric Swapping.\n\t\t\t//\t\t- Possible values:\n\t\t\t//\t\t\t- Y - Symmetric swapping is on.\n\t\t\t//\t\t\t- N - Symmetric swapping is off.\n\t\t\t//\t\t- Default value:\n\t\t\t//\t\t\tY\t\t\n\t\t\t//\n\t\t\t//\t\tFourth letter:\n\t\t\t//\n\t\t\t//\t\t- Letter position/index:\n\t\t\t//\t\t\t4\n\t\t\t//\t\t- Letter meaning:\n\t\t\t//\t\t\tShaping.\n\t\t\t//\t\t- Possible values:\n\t\t\t//\t\t\t- S - Text is shaped.\n\t\t\t//\t\t\t- N - Text is not shaped.\n\t\t\t//\t\t- Default value:\n\t\t\t//\t\t\tN\t\t\t\t\n\t\t\t//\n\t\t\t//\t\tFifth letter:\n\t\t\t//\n\t\t\t//\t\t- Letter position/index:\n\t\t\t//\t\t\t5\n\t\t\t//\t\t- Letter meaning:\n\t\t\t//\t\t\tNumeric Shaping.\n\t\t\t//\t\t- Possible values:\n\t\t\t//\t\t\t- N - Nominal.\n\t\t\t//\t\t- Default value:\n\t\t\t//\t\t\tN\t\t\t\t\n\t\t\t//\n\t\t\t//\t\tThe output of this function is original text (passed via first argument) transformed from \n\t\t\t//\t\tinput Bidi layout (second argument) to output Bidi layout (last argument). \n\t\t\t//\n\t\t\t//\t\tSample call:\n\t\t\t//\t|\tmytext = bidiTransform(\"HELLO WORLD\", \"ILYNN\", \"VLYNN\");\n\t\t\t//\t\tIn this case, \"HELLO WORLD\" text is transformed from Logical - LTR to Visual - LTR Bidi layout \n\t\t\t//\t\twith default values for symmetric swapping (Yes), shaping (Not shaped) and numeric shaping \n\t\t\t//\t\t(Nominal).\n\t\t\t// returns: String\n\t\t\t//\t\tOriginal text transformed from input Bidi layout (second argument)\n\t\t\t//\t\tto output Bidi layout (last argument).\n\t\t\t//\t\tThrows an exception if the bidi layout strings are not valid.\n\t\t\t// tags:\n\t\t\t//\t\tpublic\n\n\t\t\tthis.sourceToTarget = [];\n\t\t\tthis.targetToSource = [];\n\t\t\tif (!text) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tinitMaps(this.sourceToTarget, this.targetToSource, text.length);\n\t\t\tif (!this.checkParameters(formatIn, formatOut)) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\t\n\t\t\tformatIn = this.inputFormat;\n\t\t\tformatOut = this.outputFormat;\n\t\t\tvar result = text;\n\t\t\tvar bdx = BDX;\n\t\t\tvar orientIn = getOrientation(formatIn.charAt(1)),\n\t\t\t\torientOut = getOrientation(formatOut.charAt(1)),\n\t\t\t\tosIn = (formatIn.charAt(0) === \"I\") ? \"L\" : formatIn.charAt(0),\n\t\t\t\tosOut = (formatOut.charAt(0) === \"I\") ? \"L\" : formatOut.charAt(0),\n\t\t\t\tinFormat = osIn + orientIn,\n\t\t\t\toutFormat = osOut + orientOut,\n\t\t\t\tswap = formatIn.charAt(2) + formatOut.charAt(2);\n\t\n\t\t\tbdx.defInFormat = inFormat;\n\t\t\tbdx.defOutFormat = outFormat;\n\t\t\tbdx.defSwap = swap;\n\n\t\t\tvar stage1Text = doBidiReorder(text, inFormat, outFormat, swap, bdx),\n\t\t\t\tisRtl = false;\n\n\t\t\tif (formatOut.charAt(1) === \"R\") {\n\t\t\t\tisRtl = true;\n\t\t\t} else if (formatOut.charAt(1) === \"C\" || formatOut.charAt(1) === \"D\") {\n\t\t\t\tisRtl = this.checkContextual(stage1Text);\n\t\t\t}\n\t\t\t\n\t\t\tthis.sourceToTarget = stMap;\n\t\t\tthis.targetToSource = reverseMap(this.sourceToTarget);\n\t\t\ttsMap = this.targetToSource;\n\t\t\t\n\t\t\tif (formatIn.charAt(3) === formatOut.charAt(3)) {\n\t\t\t\tresult = stage1Text;\n\t\t\t} else if (formatOut.charAt(3) === \"S\") {\n\t\t\t\tresult = shape(isRtl, stage1Text, true);\n\t\t\t} else {  //formatOut.charAt(3) === \"N\"\n\t\t\t\tresult = deshape(stage1Text, isRtl, true);\n\t\t\t}\n\t\t\tthis.sourceToTarget = stMap;\n\t\t\tthis.targetToSource = tsMap;\n\t\t\tthis.levels = lvMap;\n\t\t\treturn result;\n\t\t},\n\n\t\t_inputFormatSetter: function (format) {\n\t\t\tif (!validFormat.test(format)) {\n\t\t\t\tthrow new Error(\"dojox/string/BidiEngine: the bidi layout string is wrong!\");\n\t\t\t}\n\t\t\tthis.inputFormat = format;\n\t\t},\n\n\t\t_outputFormatSetter: function (format) {\n\t\t\tif (!validFormat.test(format)) {\n\t\t\t\tthrow new Error(\"dojox/string/BidiEngine: the bidi layout string is wrong!\");\n\t\t\t}\n\t\t\tthis.outputFormat = format;\n\t\t},\n\n\t\tcheckParameters: function (/*String*/formatIn, /*String*/formatOut) {\n\t\t\t// summary:\n\t\t\t//\t\tChecks layout parameters.\n\t\t\t// formatIn:\n\t\t\t//\t\tInput Bidi layout in which inputText is passed to the function.\n\t\t\t// formatOut:\n\t\t\t//\t\tOutput Bidi layout to which inputText should be transformed.\t\t\t\n\t\t\t// description:\n\t\t\t//\t\tChecks, that layout parameters are different and contain allowed values.\n\t\t\t//\t\tAllowed values for format string are:\n\t\t\t//\t\t\t- 1st letter: I, V\n\t\t\t//\t\t\t- 2nd letter: L, R, C, D\n\t\t\t//\t\t\t- 3rd letter: Y, N\n\t\t\t//\t\t\t- 4th letter: S, N\n\t\t\t//\t\t\t- 5th letter: N\n\t\t\t// returns: /*Boolean*/\n\t\t\t//\t\ttrue - if layout parameters are valid.\n\t\t\t//\t\tfalse - otherwise. \n\t\t\t// tags:\n\t\t\t//\t\tprivate\n\t\t\t\n\t\t\tif (!formatIn) {\n\t\t\t\tformatIn = this.inputFormat;\n\t\t\t} else {\n\t\t\t\tthis.set(\"inputFormat\", formatIn);\n\t\t\t}\n\t\t\tif (!formatOut) {\n\t\t\t\tformatOut = this.outputFormat;\n\t\t\t} else {\n\t\t\t\tthis.set(\"outputFormat\", formatOut);\n\t\t\t}\n\t\t\tif (formatIn === formatOut) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tcheckContextual: function (/*String*/text) {\n\t\t\t// summary:\n\t\t\t//\t\tDetermine the base direction of a bidi text according\n\t\t\t//\t\tto its first strong directional character.\n\t\t\t// text: \n\t\t\t//\t\tThe text to check.\n\t\t\t// returns: /*String*/\n\t\t\t//\t\t\"ltr\" or \"rtl\" according to the first strong character.\n\t\t\t//\t\tIf there is no strong character, returns the value of the\n\t\t\t//\t\tdocument dir property.\n\t\t\t// tags:\n\t\t\t//\t\tpublic\t\t\n\t\t\tvar dir = firstStrongDir(text);\n\t\t\tif (dir !== \"ltr\" && dir !== \"rtl\") {\n\t\t\t\ttry {\n\t\t\t\t\tdir = document.dir.toLowerCase();\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t\tif (dir !== \"ltr\" && dir !== \"rtl\") {\n\t\t\t\t\tdir = \"ltr\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dir;\n\t\t},\n\n\t\thasBidiChar: function (/*String*/text) {\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if text contains RTL directed character.\n\t\t\t// text:\n\t\t\t//\t\tThe source string.\n\t\t\t// description:\n\t\t\t//\t\tSearches for RTL directed character. \n\t\t\t//\t\tReturns true if found, else returns false.\n\t\t\t// returns: /*Boolean*/\n\t\t\t//\t\ttrue - if text has a RTL directed character.\n\t\t\t//\t\tfalse - otherwise. \n\t\t\t// tags:\n\t\t\t//\t\tpublic\n\t\n\t\t    return bidiChars.test(text);\n\t\t}\n\t});\n\n\tfunction doBidiReorder(/*String*/text, /*String*/inFormat,\n\t\t\t\t/*String*/outFormat, /*String*/swap, /*Object*/bdx) {\n\t\t// summary:\n\t\t//\t\tReorder the source text according to the bidi attributes\n\t\t//\t\tof source and result.\n\t\t// text:\n\t\t//\t\tThe text to reorder.\n\t\t// inFormat:\n\t\t//\t\tOrdering scheme and base direction of the source text.\n\t\t//\t\tCan be \"LLTR\", \"LRTL\", \"LCLR\", \"LCRL\", \"VLTR\", \"VRTL\",\n\t\t//\t\t\"VCLR\", \"VCRL\".\n\t\t//\t\tThe first letter is \"L\" for logical ordering scheme,\n\t\t//\t\t\"V\" for visual ordering scheme.\n\t\t//\t\tThe other letters specify the base direction.\n\t\t//\t\t\"CLR\" means contextual direction defaulting to LTR if\n\t\t//\t\tthere is no strong letter.\n\t\t//\t\t\"CRL\" means contextual direction defaulting to RTL if\n\t\t//\t\tthere is no strong letter.\n\t\t//\t\tThe initial value is \"LLTR\", if none, the initial value is used.\n\t\t// outFormat:\n\t\t//\t\tRequired ordering scheme and base direction of the\n\t\t//\t\tresult. Has the same format as inFormat.\n\t\t//\t\tIf none, the initial value \"VLTR\" is used.\n\t\t// swap:\n\t\t//\t\tSymmetric swapping attributes of source and result.\n\t\t//\t\tThe allowed values can be \"YN\", \"NY\", \"YY\" and \"NN\".\n\t\t//\t\tThe first letter reflects the symmetric swapping attribute\n\t\t//\t\tof the source, the second letter that of the result.\n\t\t// bdx: Object\n\t\t//\t\tUsed for intermediate data storage\n\t\t// returns:\n\t\t//\t\tText reordered according to source and result attributes.\n\t\t\n\t\tvar params = prepareReorderingParameters(text, {inFormat: inFormat, outFormat: outFormat, swap: swap}, bdx);\n\t\tif (params.inFormat === params.outFormat) {\n\t\t\treturn text;\n\t\t}\n\t\tinFormat = params.inFormat;\n\t\toutFormat = params.outFormat;\n\t\tswap = params.swap;\n\t\tvar inOrdering = inFormat.substring(0, 1),\n\t\tinOrientation = inFormat.substring(1, 4),\n\t\toutOrdering = outFormat.substring(0, 1),\n\t\toutOrientation = outFormat.substring(1, 4);\n\t\tbdx.inFormat = inFormat;\n\t\tbdx.outFormat = outFormat;\n\t\tbdx.swap = swap;\n\t\tif ((inOrdering === \"L\") && (outFormat === \"VLTR\")) { //core cases\n\t\t\t//cases: LLTR->VLTR, LRTL->VLTR\n\t\t\tif (inOrientation === \"LTR\") {\n\t\t\t\tbdx.dir = LTR;\n\t\t\t\treturn doReorder(text, bdx);\n\t\t\t}\n\t\t\tif (inOrientation === \"RTL\") {\n\t\t\t\tbdx.dir = RTL;\n\t\t\t\treturn doReorder(text, bdx);\n\t\t\t}\n\t\t}\n\t\tif ((inOrdering === \"V\") && (outOrdering === \"V\")) {\n\t\t\t//inOrientation != outOrientation\n\t\t\t//cases: VRTL->VLTR, VLTR->VRTL\n\t\t\tbdx.dir = inOrientation === \"RTL\"? RTL : LTR;\n\t\t\treturn invertStr(text, bdx);\n\t\t}\n\t\tif ((inOrdering === \"L\") && (outFormat === \"VRTL\")) {\n\t\t\t//cases: LLTR->VRTL, LRTL->VRTL\n\t\t\tif (inOrientation === \"LTR\") {\n\t\t\t\tbdx.dir = LTR;\n\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t} else {\n\t\t\t\t//inOrientation == RTL\n\t\t\t\tbdx.dir = RTL;\n\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t}\n\t\t\treturn invertStr(text);\n\t\t}\n\t\tif ((inFormat === \"VLTR\") && (outFormat === \"LLTR\")) {\n\t\t\t//case: VLTR->LLTR\n\t\t\tbdx.dir = LTR;\n\t\t\treturn doReorder(text, bdx);\n\t\t}\n\t\tif ((inOrdering === \"V\") && (outOrdering === \"L\") && (inOrientation !== outOrientation)) {\n\t\t\t//cases: VLTR->LRTL, VRTL->LLTR\n\t\t\ttext = invertStr(text);\n\t\t\treturn (inOrientation === \"RTL\") ? doBidiReorder(text, \"LLTR\", \"VLTR\", swap, bdx) :\n\t\t\t\t\t\t\t\t\t\t\t\tdoBidiReorder(text, \"LRTL\", \"VRTL\", swap, bdx);\n\t\t}\n\t\tif ((inFormat === \"VRTL\") && (outFormat === \"LRTL\")) {\n\t\t\t//case VRTL->LRTL\n\t\t\treturn doBidiReorder(text, \"LRTL\", \"VRTL\", swap, bdx);\n\t\t}\n\t\tif ((inOrdering === \"L\") && (outOrdering === \"L\")) {\n\t\t\t//inOrientation != outOrientation\n\t\t\t//cases: LRTL->LLTR, LLTR->LRTL\n\t\t\tvar saveSwap = bdx.swap;\n\t\t\tbdx.swap = saveSwap.substr(0, 1) + \"N\";\n\t\t\tif (inOrientation === \"RTL\") {\n\t\t\t\t//LRTL->LLTR\n\t\t\t\tbdx.dir = RTL;\n\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\tbdx.swap = \"N\" + saveSwap.substr(1, 2);\n\t\t\t\tbdx.dir = LTR;\n\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t} else { //LLTR->LRTL\n\t\t\t\tbdx.dir = LTR;\n\t\t\t\ttext = doReorder(text, bdx);\n\t\t\t\tbdx.swap = \"N\" + saveSwap.substr(1, 2);\n\t\t\t\ttext = doBidiReorder(text, \"VLTR\", \"LRTL\", bdx.swap, bdx);\n\t\t\t}\n\t\t\treturn text;\n\t\t}\n\t}\n\t\n\tfunction prepareReorderingParameters(/*String*/text, /*Object*/params, /*Object*/bdx) {\n\t\t// summary:\n\t\t//\t\tPrepare reordering parameters\n\t\t// text:\n\t\t//\t\tThe text to reorder.\n\t\t// params:\n\t\t//      Object, containing reordering parameters: \n\t\t//         - inFormat: Ordering scheme and base direction of the source text.\n\t\t//         - outFormat: Required ordering scheme and base direction of the result.\n\t\t//         - swap: Symmetric swapping attributes of source and result.\n\t\t// bdx: Object\n\t\t//\t\tUsed for intermediate data storage\t\t\n\t\t// tags:\n\t\t//\t\tprivate\n\t\t\n\t\tif (params.inFormat === undefined) {\n\t\t\tparams.inFormat = bdx.defInFormat;\n\t\t}\n\t\tif (params.outFormat === undefined) {\n\t\t\tparams.outFormat = bdx.defOutFormat;\n\t\t}\n\t\tif (params.swap === undefined) {\n\t\t\tparams.swap = bdx.defSwap;\n\t\t}\n\t\tif (params.inFormat === params.outFormat) {\n\t\t\treturn params;\n\t\t}\n\t\tvar dir, inOrdering = params.inFormat.substring(0, 1),\n\t\tinOrientation = params.inFormat.substring(1, 4),\n\t\toutOrdering = params.outFormat.substring(0, 1),\n\t\toutOrientation = params.outFormat.substring(1, 4);\n\t\tif (inOrientation.charAt(0) === \"C\") {\n\t\t\tdir = firstStrongDir(text);\n\t\t\tif (dir === \"ltr\" || dir === \"rtl\") {\n\t\t\t\tinOrientation = dir.toUpperCase();\n\t\t\t} else {\n\t\t\t\tinOrientation = params.inFormat.charAt(2) === \"L\" ? \"LTR\" : \"RTL\";\n\t\t\t}\n\t\t\tparams.inFormat = inOrdering + inOrientation;\n\t\t}\n\t\tif (outOrientation.charAt(0) === \"C\") {\n\t\t\tdir = firstStrongDir(text);\n\t\t\tif (dir === \"rtl\") {\n\t\t\t\toutOrientation = \"RTL\";\n\t\t\t} else if (dir === \"ltr\") {\n\t\t\t\tdir = lastStrongDir(text);\n\t\t\t\toutOrientation = dir.toUpperCase();\n\t\t\t} else {\n\t\t\t\toutOrientation = params.outFormat.charAt(2) === \"L\" ? \"LTR\" : \"RTL\";\n\t\t\t}\n\t\t\tparams.outFormat = outOrdering + outOrientation;\n\t\t}\n\t\treturn params;\n\t}\n\n\tfunction shape(/*boolean*/rtl, /*String*/text, /*boolean*/compress) {\n\t\t// summary:\n\t\t//\t\tShape the source text.\n\t\t// rtl:\n\t\t//\t\tFlag indicating if the text is in RTL direction (logical\n\t\t//\t\tdirection for Arabic words).\n\t\t// text:\n\t\t//\t\tThe text to shape.\n\t\t// compress:\n\t\t//\t\tA flag indicates to insert extra space after the lam alef compression\n\t\t//\t\tto preserve the buffer size or not insert an extra space which will lead\n\t\t//\t\tto decrease the buffer size. This option can be:\n\t\t//\n\t\t//\t\t- true (default) to not insert extra space after compressing Lam+Alef into one character Lamalef\n\t\t//\t\t- false to insert an extra space after compressed Lamalef to preserve the buffer size\n\t\t// returns:\n\t\t//\t\ttext shaped.\n\t\t// tags:\n\t\t//\t\tprivate.\n\t\t\n\t\tif (text.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (rtl === undefined) {\n\t\t\trtl = true;\n\t\t}\n\t\tif (compress === undefined) {\n\t\t\tcompress = true;\n\t\t}\n\t\ttext = String(text);\n\t\t\n\t\tvar str06 = text.split(\"\"),\n\t\t\tIx = 0,\n\t\t\tstep = +1,\n\t\t\tnIEnd = str06.length;\n\t\tif (!rtl) {\n\t\t\tIx = str06.length - 1;\n\t\t\tstep = -1;\n\t\t\tnIEnd = 1;\n\t\t}\n\t\tvar compressArray = doShape(str06, Ix, step, nIEnd, compress);\n\t\tvar outBuf = \"\";\n\t\tfor (var idx = 0; idx < str06.length; idx++) {\n\t\t\tif (!(compress && indexOf(compressArray, compressArray.length, idx) > -1)) {\n\t\t\t\toutBuf += str06[idx];\n\t\t\t} else {\n\t\t\t\tupdateMap(tsMap, idx, !rtl, -1);\n\t\t\t\tstMap.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t\treturn outBuf;\n\t}\n\t\n\tfunction doShape(str06, Ix, step, nIEnd, compress) {\n\t\t// summary:\n\t\t//\t\tShape the source text.\n\t\t// str06:\n\t\t//\t\tArray containing source text\n\t\t// Ix:\n\t\t//\t\tIndex of the first handled element\n\t\t// step:\n\t\t//\t\tdirection of the process\n\t\t// nIEnd:\n\t\t//\t\tIndex of the last handled element\n\t\t// compress:\n\t\t//\t\tA flag indicates to insert extra space after the lam alef compression\n\t\t//\t\tto preserve the buffer size or not insert an extra space which will lead\n\t\t//\t\tto decrease the buffer size.\t\t\n\t\t// returns:\n\t\t//\t\tArray, contained shaped text.\n\t\t// tags:\n\t\t//\t\tprivate.\n\t\t\n\t\tvar previousCursive = 0, compressArray = [], compressArrayIndx = 0;\n\t\tfor (var index = Ix; index * step < nIEnd; index = index + step) {\n\t\t\tif (isArabicAlefbet(str06[index]) || isArabicDiacritics(str06[index])) {\n\t\t\t\t// Arabic letter Lam\n\t\t\t\tif (str06[index] === \"\\u0644\" && isNextAlef(str06, (index + step), step, nIEnd)) {\n\t\t\t\t\tstr06[index] = (previousCursive === 0) ?\n\t\t\t\t\t\t\tgetLamAlefFE(str06[index + step], LamAlefInialTableFE) :\n\t\t\t\t\t\t\tgetLamAlefFE(str06[index + step], LamAlefMedialTableFE);\n\t\t\t\t\tindex += step;\n\t\t\t\t\tsetAlefToSpace(str06, index, step, nIEnd);\n\t\t\t\t\tif (compress) {\n\t\t\t\t\t\tcompressArray[compressArrayIndx] = index;\n\t\t\t\t\t\tcompressArrayIndx++;\n\t\t\t\t\t}\n\t\t\t\t\tpreviousCursive = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar currentChr = str06[index];\n\t\t\t\tif (previousCursive === 1) {\n\t\t\t\t\t// if next is Arabic\n\t\t\t\t\t// Character is in medial form\n\t\t\t\t\t// else character is in final form\n\t\t\t\t\tstr06[index] = (isNextArabic(str06, (index + step), step, nIEnd)) ?\n\t\t\t\t\t\tgetMedialFormCharacterFE(str06[index]) : getFormCharacterFE(str06[index], FinalForm);\n\t\t\t\t} else {\n\t\t\t\t\tif (isNextArabic(str06, (index + step), step, nIEnd) === true) {\n\t\t\t\t\t\t//character is in Initial form\n\t\t\t\t\t\tstr06[index] = getFormCharacterFE(str06[index], InitialForm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr06[index] = getFormCharacterFE(str06[index], IsolatedForm);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//exam if the current character is cursive\n\t\t\t\tif (!isArabicDiacritics(currentChr)) {\n\t\t\t\t\tpreviousCursive = 1;\n\t\t\t\t}\n\t\t\t\tif (isStandAlonCharacter(currentChr) === true) {\n\t\t\t\t\tpreviousCursive = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpreviousCursive = 0;\n\t\t\t}\n\t\t}\n\t\treturn compressArray;\n\t}\n\t\n\tfunction firstStrongDir(/*String*/text) {\n\t\t// summary:\n\t\t//\t\tReturn the first strong character direction\n\t\t// text:\n\t\t//\t\tThe source string.\n\t\t// description:\n\t\t//\t\tSearches for first \"strong\" character. \n\t\t//\t\tReturns if strong character was found with the direction defined by this \n\t\t//\t\tcharacter, if no strong character was found returns an empty string.\n\t\t// returns: String\n\t\t//\t\t\"ltr\" - if the first strong character is Latin.\n\t\t//\t\t\"rtl\" - if the first strong character is RTL directed character.\n\t\t//\t\t\"\" - if the strong character wasn't found.\n\t\t// tags:\n\t\t//\t\tprivate\n\t\n\t\tvar fdc = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(text);\n\t\t// if found return the direction that defined by the character\n\t\treturn fdc ? (fdc[0] <= \"z\" ? \"ltr\" : \"rtl\") : \"\";\n\t}\n\t\n\tfunction lastStrongDir(text) {\n\t\t// summary:\n\t\t//\t\tReturn the last strong character direction\n\t\t// text:\n\t\t//\t\tThe source string.\n\t\t// description:\n\t\t//\t\tSearches for first (from the end) \"strong\" character. \n\t\t//\t\tReturns if strong character was found with the direction defined by this \n\t\t//\t\tcharacter, if no strong character was found returns an empty string.\n\t\t// tags:\n\t\t//\t\tprivate\t\t\n\t\tvar chars = text.split(\"\");\n\t\tchars.reverse();\n\t\treturn firstStrongDir(chars.join(\"\"));\n\t}\n\t\n\tfunction deshape(/*String*/text, /*boolean*/rtl, /*boolean*/consumeNextSpace) {\n\t\t// summary:\n\t\t//\t\tdeshape the source text.\n\t\t// text:\n\t\t//\t\tthe text to be deshape.\n\t\t// rtl:\n\t\t//\t\tflag indicating if the text is in RTL direction (logical\n\t\t//\t\tdirection for Arabic words).\n\t\t// consumeNextSpace:\n\t\t//\t\tflag indicating whether to consume the space next to the \n\t\t//\t\tthe lam alef if there is a space followed the Lamalef character to preserve the buffer size. \n\t\t//\t\tIn case there is no space next to the lam alef the buffer size will be increased due to the\n\t\t//\t\texpansion of the lam alef one character into lam+alef two characters\n\t\t// returns:\n\t\t//\t\ttext deshaped.\n\t\tif (text.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (consumeNextSpace === undefined) {\n\t\t\tconsumeNextSpace = true;\n\t\t}\n\t\tif (rtl === undefined) {\n\t\t\trtl = true;\n\t\t}\n\t\ttext = String(text);\n\t\n\t\tvar outBuf = \"\", strFE = [];\n\t\tstrFE = text.split(\"\");\n\t\tfor (var i = 0; i < text.length; i++) {\n\t\t\tvar increase = false;\n\t\t\tif (strFE[i] >= \"\\uFE70\" && strFE[i] < \"\\uFEFF\") {\n\t\t\t\tvar chNum = text.charCodeAt(i);\n\t\t\t\tif (strFE[i] >= \"\\uFEF5\" && strFE[i] <= \"\\uFEFC\") {\n\t\t\t\t\t//expand the LamAlef\n\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\t//Lam + Alef\n\t\t\t\t\t\tif (i > 0 && consumeNextSpace && strFE[i - 1] === \" \") {\n\t\t\t\t\t\t\toutBuf = outBuf.substring(0, outBuf.length - 1) + \"\\u0644\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutBuf += \"\\u0644\";\n\t\t\t\t\t\t\tincrease = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutBuf += AlefTable[(chNum - 65269) / 2];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutBuf += AlefTable[(chNum - 65269) / 2];\n\t\t\t\t\t\toutBuf += \"\\u0644\";\n\t\t\t\t\t\tif (i + 1 < text.length && consumeNextSpace && strFE[i + 1] === \" \") {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrease = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (increase) {\n\t\t\t\t\t\tupdateMap(tsMap, i, true, 1);\n\t\t\t\t\t\tstMap.splice(i, 0, stMap[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutBuf += FETo06Table[chNum - 65136];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutBuf += strFE[i];\n\t\t\t}\n\t\t}\n\t\treturn outBuf;\n\t}\n\t\n\tfunction doReorder(str, bdx) {\n\t\t// summary:\n\t\t//\t\tHelper to the doBidiReorder. Manages the UBA.\n\t\t// str:\n\t\t//\t\tthe string to reorder.\n\t\t// bdx: Object\n\t\t//\t\tUsed for intermediate data storage\t\t\n\t\t// returns:\n\t\t//\t\ttext reordered according to source and result attributes.\n\t\t// tags: \n\t\t//\t\tprivate\t\n\t\tvar chars = str.split(\"\"), levels = [];\n\t\n\t\tcomputeLevels(chars, levels, bdx);\n\t\tswapChars(chars, levels, bdx);\n\t\tinvertLevel(2, chars, levels, bdx);\n\t\tinvertLevel(1, chars, levels, bdx);\n\t\tlvMap = levels;\n\t\treturn chars.join(\"\");\n\t}\n\n\tfunction computeLevels(chars, levels, bdx) {\n\t\tvar len = chars.length,\n\t\t\timpTab = bdx.dir ? impTabRtl : impTabLtr,\n\t\t\tprevState = null, newClass = null, newLevel = null, newState = 0,\n\t\t\taction = null, cond = null, condPos = -1, i = null, ix = null,\n\t\t\ttypes = [],\n\t\t\tclasses = [];\n\t\tbdx.hiLevel = bdx.dir;\n\t\tbdx.lastArabic = false;\n\t\tbdx.hasUbatAl = false;\n\t\tbdx.hasUbatB = false;\n\t\tbdx.hasUbatS = false;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ttypes[i] = getCharacterType(chars[i]);\n\t\t}\n\t\tfor (ix = 0; ix < len; ix++) {\n\t\t\tprevState = newState;\n\t\t\tclasses[ix] = newClass = getCharClass(chars, types, classes, ix, bdx);\n\t\t\tnewState = impTab[prevState][newClass];\n\t\t\taction = newState & 0xF0;\n\t\t\tnewState &= 0x0F;\n\t\t\tlevels[ix] = newLevel = impTab[newState][ITIL];\n\t\t\tif (action > 0) {\n\t\t\t\tif (action === 0x10) {\t// set conditional run to level 1\n\t\t\t\t\tfor (i = condPos; i < ix; i++) {\n\t\t\t\t\t\tlevels[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcondPos = -1;\n\t\t\t\t} else {\t// 0x20 confirm the conditional run\n\t\t\t\t\tcondPos = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcond = impTab[newState][ITCOND];\n\t\t\tif (cond) {\n\t\t\t\tif (condPos === -1) {\n\t\t\t\t\tcondPos = ix;\n\t\t\t\t}\n\t\t\t} else {\t// unconditional level\n\t\t\t\tif (condPos > -1) {\n\t\t\t\t\tfor (i = condPos; i < ix; i++) {\n\t\t\t\t\t\tlevels[i] = newLevel;\n\t\t\t\t\t}\n\t\t\t\t\tcondPos = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (types[ix] === UBAT_B) {\n\t\t\t\tlevels[ix] = 0;\n\t\t\t}\n\t\t\tbdx.hiLevel |= newLevel;\n\t\t}\n\t\tif (bdx.hasUbatS) {\n\t\t\thandleUbatS(types, levels, len, bdx);\n\t\t}\n\t}\n\t\n\tfunction handleUbatS(types, levels, len, bdx) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (types[i] === UBAT_S) {\n\t\t\t\tlevels[i] = bdx.dir;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tif (types[j] === UBAT_WS) {\n\t\t\t\t\t\tlevels[j] = bdx.dir;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction swapChars(chars, levels, bdx) {\n\t\t// summary:\n\t\t//\t\tSwap characters with symmetrical mirroring as all kinds of parenthesis.\n\t\t//\t\t(When needed).\n\t\t// chars:\n\t\t//\t\tThe source string as Array of characters.\n\t\t// levels:\n\t\t//\t\tAn array (like hash) of flags for each character in the source string,\n\t\t//\t\tthat defines if swapping should be applied on the following character.\n\t\t// bdx: Object\n\t\t//\t\tUsed for intermediate data storage\n\t\t// tags:\n\t\t//\t\tprivate\t\n\t\n\t\tif (bdx.hiLevel === 0 || bdx.swap.substr(0, 1) === bdx.swap.substr(1, 2)) {\n\t\t\treturn;\n\t\t}\n\t\tfor (var i = 0; i < chars.length; i++) {\n\t\t\tif (levels[i] === 1) {\n\t\t\t\tchars[i] = getMirror(chars[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction getCharacterType(ch) {\n\t\t// summary:\n\t\t//\t\tReturn the type of the character.\n\t\t// ch:\n\t\t//\t\tThe character to be checked.\n\t\n\t\t// description:\n\t\t//\t\tCheck the type of the character according to MasterTable,\n\t\t//\t\ttype = LTR, RTL, neutral,Arabic-Indic digit etc.\n\t\t// tags:\n\t\t//\t\tprivate\t\t\t\n\t\tvar uc = ch.charCodeAt(0),\n\t\t\thi = MasterTable[uc >> 8];\n\t\treturn (hi < TBBASE) ? hi : UnicodeTable[hi - TBBASE][uc & 0xFF];\n\t}\n\t\n\tfunction invertStr(str, bdx) {\n\t\t// summary:\n\t\t//\t\tReturn the reversed string.\n\t\t// str:\n\t\t//\t\tThe string to be reversed.\n\t\t// description:\n\t\t//\t\tReverse the string str.\n\t\t// tags:\n\t\t//\t\tprivate\t\t\t\t\t\n\t\tvar chars = str.split(\"\");\n\t\tif (bdx) {\n\t\t\tvar levels = [];\n\t\t\tcomputeLevels(chars, levels, bdx);\n\t\t\tlvMap = levels;\n\t\t}\n\t\tchars.reverse();\n\t\tstMap.reverse();\n\t\treturn chars.join(\"\");\n\t}\n\t\n\tfunction indexOf(cArray, cLength, idx) {\n\t\tfor (var i = 0; i < cLength; i++) {\n\t\t\tif (cArray[i] === idx) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tfunction isArabicAlefbet(c) {\n\t\tfor (var i = 0; i < ArabicAlefBetIntervalsBegine.length; i++) {\n\t\t\tif (c >= ArabicAlefBetIntervalsBegine[i] && c <= ArabicAlefBetIntervalsEnd[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction isNextArabic(str06, index, step, nIEnd) {\n\t\twhile (((index) * step) < nIEnd && isArabicDiacritics(str06[index])) {\n\t\t\tindex += step;\n\t\t}\n\t\tif (((index) * step) < nIEnd && isArabicAlefbet(str06[index])) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction isNextAlef(str06, index, step, nIEnd) {\n\t\twhile (((index) * step) < nIEnd && isArabicDiacritics(str06[index])) {\n\t\t\tindex += step;\n\t\t}\n\t\tvar c = \" \";\n\t\tif (((index) * step) < nIEnd) {\n\t\t\tc = str06[index];\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < AlefTable.length; i++) {\n\t\t\tif (AlefTable[i] === c) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction invertLevel(lev, chars, levels, bdx) {\n\t\tif (bdx.hiLevel < lev) {\n\t\t\treturn;\n\t\t}\n\t\tif (lev === 1 && bdx.dir === RTL && !bdx.hasUbatB) {\n\t\t\tchars.reverse();\n\t\t\tstMap.reverse();\n\t\t\treturn;\n\t\t}\n\t\tvar len = chars.length, start = 0, end, lo, hi, tmp;\n\t\twhile (start < len) {\n\t\t\tif (levels[start] >= lev) {\n\t\t\t\tend = start + 1;\n\t\t\t\twhile (end < len && levels[end] >= lev) {\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tfor (lo = start, hi = end - 1 ; lo < hi; lo++, hi--) {\n\t\t\t\t\ttmp = chars[lo];\n\t\t\t\t\tchars[lo] = chars[hi];\n\t\t\t\t\tchars[hi] = tmp;\n\t\t\t\t\ttmp = stMap[lo];\n\t\t\t\t\tstMap[lo] = stMap[hi];\n\t\t\t\t\tstMap[hi] = tmp;\n\t\t\t\t}\n\t\t\t\tstart = end;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t}\n\t\n\tfunction getCharClass(chars, types, classes, ix, bdx) {\n\t\t// summary:\n\t\t//\t\tReturn the class if ix character in chars.\n\t\t// chars:\n\t\t//\t\tThe source string as Array of characters.\n\t\t// types:\n\t\t//\t\tArray of types, for each character in chars.\n\t\t// classes:\n\t\t//\t\tArray of classes that already been solved. \n\t\t// ix:\n\t\t//\t\tthe index of checked character.\n\t\t// bdx: Object\n\t\t//\t\tUsed for intermediate data storage\t\t\n\t\t// tags:\n\t\t//\t\tprivate\t\t\t\t\n\t\tvar cType = types[ix],\n\t\t\tresults = {\n\t\t\t\tUBAT_L : function () { bdx.lastArabic = false; return UBAT_L; },\n\t\t\t\tUBAT_R : function () { bdx.lastArabic = false; return UBAT_R; },\n\t\t\t\tUBAT_ON : function () { return UBAT_ON; },\n\t\t\t\tUBAT_AN : function () { return UBAT_AN; },\n\t\t\t\tUBAT_EN : function () { return bdx.lastArabic ? UBAT_AN : UBAT_EN; },\n\t\t\t\tUBAT_AL : function () { bdx.lastArabic = true; bdx.hasUbatAl = true; return UBAT_R; },\n\t\t\t\tUBAT_WS : function () { return UBAT_ON; },\n\t\t\t\tUBAT_CS : function () {\n\t\t\t\t\t\t\t\t\t\tvar wType, nType;\n\t\t\t\t\t\t\t\t\t\tif (ix < 1 || (ix + 1) >= types.length ||\n\t\t\t\t\t\t\t\t\t\t\t((wType = classes[ix - 1]) !== UBAT_EN && wType !== UBAT_AN) ||\n\t\t\t\t\t\t\t\t\t\t\t((nType = types[ix + 1]) !== UBAT_EN && nType !== UBAT_AN)) {\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (bdx.lastArabic) {\n\t\t\t\t\t\t\t\t\t\t\tnType = UBAT_AN;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn nType === wType ? nType : UBAT_ON;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\tUBAT_ES : function () {\n\t\t\t\t\t\t\t\t\t\tvar wType = ix > 0 ? classes[ix - 1] : UBAT_B;\n\t\t\t\t\t\t\t\t\t\tif (wType === UBAT_EN && (ix + 1) < types.length && types[ix + 1] === UBAT_EN) {\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_EN;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\tUBAT_ET : function () {\n\t\t\t\t\t\t\t\t\t\tif (ix > 0 && classes[ix - 1] === UBAT_EN) {\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_EN;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (bdx.lastArabic) {\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tvar i = ix + 1,\n\t\t\t\t\t\t\t\t\t\t\tlen = types.length;\n\t\t\t\t\t\t\t\t\t\twhile (i < len && types[i] === UBAT_ET) {\n\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (i < len && types[i] === UBAT_EN) {\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_EN;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\tUBAT_NSM : function () {\n\t\t\t\t\t\t\t\t\t\tif (bdx.inFormat === \"VLTR\") {\t// visual to implicit transformation\n\t\t\t\t\t\t\t\t\t\t\tvar len = types.length,\n\t\t\t\t\t\t\t\t\t\t\t\ti = ix + 1;\n\t\t\t\t\t\t\t\t\t\t\twhile (i < len && types[i] === UBAT_NSM) {\n\t\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (i < len) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar c = chars[ix],\n\t\t\t\t\t\t\t\t\t\t\t\t\trtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c === 0xFB1E,\n\t\t\t\t\t\t\t\t\t\t\t\t\twType = types[i];\n\t\t\t\t\t\t\t\t\t\t\t\tif (rtlCandidate && (wType === UBAT_R || wType === UBAT_AL)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn UBAT_R;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (ix < 1 || types[ix - 1] === UBAT_B) {\n\t\t\t\t\t\t\t\t\t\t\treturn UBAT_ON;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn classes[ix - 1];\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\tUBAT_B : function () { bdx.lastArabic = true; bdx.hasUbatB = true; return bdx.dir; },\n\t\t\t\tUBAT_S : function () { bdx.hasUbatS = true; return UBAT_ON; },\n\t\t\t\tUBAT_LRE : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\tUBAT_RLE : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\tUBAT_LRO : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\tUBAT_RLO : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\tUBAT_PDF : function () { bdx.lastArabic = false; return UBAT_ON; },\n\t\t\t\tUBAT_BN : function () { return UBAT_ON; }\n\t\t\t};\n\t\treturn results[TYPES_NAMES[cType]]();\n\t}\n\n\tfunction getMirror(c) {\n\t\t// summary:\n\t\t//\t\tCalculates the mirrored character of c\n\t\t// c:\n\t\t//\t\tThe character to be mirrored.\n\t\t// tags:\n\t\t//\t\tprivate\t\t\t\t\t\n\t\tvar mid, low = 0, high = SwapTable.length - 1;\n\t\n\t\twhile (low <= high) {\n\t\t\tmid = Math.floor((low + high) / 2);\n\t\t\tif (c < SwapTable[mid][0]) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (c > SwapTable[mid][0]) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\treturn SwapTable[mid][1];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tfunction isStandAlonCharacter(c) {\n\t\tfor (var i = 0; i < StandAlonForm.length; i++) {\n\t\t\tif (StandAlonForm[i] === c) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction getMedialFormCharacterFE(c) {\n\t\tfor (var i = 0; i < BaseForm.length; i++) {\n\t\t\tif (c === BaseForm[i]) {\n\t\t\t\treturn MedialForm[i];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tfunction getFormCharacterFE(/*char*/ c, /*char[]*/formArr) {\n\t\tfor (var i = 0; i < BaseForm.length; i++) {\n\t\t\tif (c === BaseForm[i]) {\n\t\t\t\treturn formArr[i];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tfunction isArabicDiacritics(c) {\n\t\treturn\t(c >= \"\\u064b\" && c <= \"\\u0655\") ? true : false;\n\t}\n\t\n\tfunction getOrientation(/*Char*/ oc) {\n\t\tif (oc === \"L\") {\n\t\t\treturn \"LTR\";\n\t\t}\n\t\tif (oc === \"R\") {\n\t\t\treturn \"RTL\";\n\t\t}\n\t\tif (oc === \"C\") {\n\t\t\treturn \"CLR\";\n\t\t}\n\t\tif (oc === \"D\") {\n\t\t\treturn \"CRL\";\n\t\t}\n\t}\n\t\n\tfunction setAlefToSpace(str06, index, step, nIEnd) {\n\t\twhile (((index) * step) < nIEnd && isArabicDiacritics(str06[index])) {\n\t\t\tindex += step;\n\t\t}\n\t\tif (((index) * step) < nIEnd) {\n\t\t\tstr06[index] = \" \";\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction getLamAlefFE(alef06, LamAlefForm) {\n\t\tfor (var i = 0; i < AlefTable.length; i++) {\n\t\t\tif (alef06 === AlefTable[i]) {\n\t\t\t\treturn LamAlefForm[i];\n\t\t\t}\n\t\t}\n\t\treturn alef06;\n\t}\n\n\tfunction initMaps(map1, map2, length) {\n\t\tstMap = [];\n\t\tlvMap = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tmap1[i] = i;\n\t\t\tmap2[i] = i;\n\t\t\tstMap[i] = i;\n\t\t}\n\t}\n\n\tfunction reverseMap(sourceMap) {\n\t\tvar map = new Array(sourceMap.length);\n\t\tfor (var i = 0; i < sourceMap.length; i++) {\n\t\t\tmap[sourceMap[i]] = i;\n\t\t}\n\t\treturn map;\n\t}\n\n\tfunction updateMap(map, value, isGreater, update) {\n\t\tfor (var i = 0; i < map.length; i++) {\n\t\t\tif (map[i] > value || (!isGreater && map[i] === value)) {\n\t\t\t\tmap[i] += update;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar stMap = [];\n\tvar tsMap = [];\n\tvar lvMap = [];\n\t\t\n\tvar\tBDX = {\n\t\t\tdir: 0,\n\t\t\tdefInFormat: \"LLTR\",\n\t\t\tdefoutFormat: \"VLTR\",\n\t\t\tdefSwap: \"YN\",\n\t\t\tinFormat: \"LLTR\",\n\t\t\toutFormat: \"VLTR\",\n\t\t\tswap: \"YN\",\n\t\t\thiLevel: 0,\n\t\t\tlastArabic: false,\n\t\t\thasUbatAl: false,\n\t\t\thasBlockSep: false,\n\t\t\thasSegSep: false\n\t\t};\n\t\n\tvar ITIL = 5;\n\t\n\tvar ITCOND = 6;\n\t\n\tvar LTR = 0;\n\t\n\tvar RTL = 1;\n\n\tvar validFormat = /^[(I|V)][(L|R|C|D)][(Y|N)][(S|N)][N]$/;\n\n\tvar bidiChars = /[\\u0591-\\u06ff\\ufb1d-\\ufefc]/;\n\n\t/****************************************************************************/\n\t/* Array in which directional characters are replaced by their symmetric.\t*/\n\t/****************************************************************************/\n\tvar SwapTable = [\n\t\t[ \"\\u0028\", \"\\u0029\" ],\t/* Round brackets\t\t\t\t\t*/\n\t\t[ \"\\u0029\", \"\\u0028\" ],\n\t\t[ \"\\u003C\", \"\\u003E\" ],\t/* Less than/greater than\t\t\t*/\n\t\t[ \"\\u003E\", \"\\u003C\" ],\n\t\t[ \"\\u005B\", \"\\u005D\" ],\t/* Square brackets\t\t\t\t\t*/\n\t\t[ \"\\u005D\", \"\\u005B\" ],\n\t\t[ \"\\u007B\", \"\\u007D\" ],\t/* Curly brackets\t\t\t\t\t*/\n\t\t[ \"\\u007D\", \"\\u007B\" ],\n\t\t[ \"\\u00AB\", \"\\u00BB\" ],\t/* Double angle quotation marks\t\t*/\n\t\t[ \"\\u00BB\", \"\\u00AB\" ],\n\t\t[ \"\\u2039\", \"\\u203A\" ],\t/* single angle quotation mark\t\t*/\n\t\t[ \"\\u203A\", \"\\u2039\" ],\n\t\t[ \"\\u207D\", \"\\u207E\" ],\t/* Superscript parentheses\t\t\t*/\n\t\t[ \"\\u207E\", \"\\u207D\" ],\n\t\t[ \"\\u208D\", \"\\u208E\" ],\t/* Subscript parentheses\t\t\t*/\n\t\t[ \"\\u208E\", \"\\u208D\" ],\n\t\t[ \"\\u2264\", \"\\u2265\" ],\t/* Less/greater than or equal\t\t*/\n\t\t[ \"\\u2265\", \"\\u2264\" ],\n\t\t[ \"\\u2329\", \"\\u232A\" ],\t/* Angle brackets\t\t\t\t\t*/\n\t\t[ \"\\u232A\", \"\\u2329\" ],\n\t\t[ \"\\uFE59\", \"\\uFE5A\" ],\t/* Small round brackets\t\t\t\t*/\n\t\t[ \"\\uFE5A\", \"\\uFE59\" ],\n\t\t[ \"\\uFE5B\", \"\\uFE5C\" ],\t/* Small curly brackets\t\t\t\t*/\n\t\t[ \"\\uFE5C\", \"\\uFE5B\" ],\n\t\t[ \"\\uFE5D\", \"\\uFE5E\" ],\t/* Small tortoise shell brackets\t*/\n\t\t[ \"\\uFE5E\", \"\\uFE5D\" ],\n\t\t[ \"\\uFE64\", \"\\uFE65\" ],\t/* Small less than/greater than\t\t*/\n\t\t[ \"\\uFE65\", \"\\uFE64\" ]\n\t];\n\tvar AlefTable = [\"\\u0622\", \"\\u0623\", \"\\u0625\", \"\\u0627\"];\n\t\n\tvar LamAlefInialTableFE = [\"\\ufef5\", \"\\ufef7\", \"\\ufef9\", \"\\ufefb\"];\n\t\n\tvar LamAlefMedialTableFE = [\"\\ufef6\", \"\\ufef8\", \"\\ufefa\", \"\\ufefc\"];\n\t/**\n\t * Arabic Characters in the base form\n\t */\n\tvar BaseForm = [\"\\u0627\", \"\\u0628\", \"\\u062A\", \"\\u062B\", \"\\u062C\", \"\\u062D\", \"\\u062E\", \"\\u062F\", \"\\u0630\", \"\\u0631\",\n                    \"\\u0632\", \"\\u0633\", \"\\u0634\", \"\\u0635\", \"\\u0636\", \"\\u0637\", \"\\u0638\", \"\\u0639\", \"\\u063A\", \"\\u0641\",\n                    \"\\u0642\", \"\\u0643\", \"\\u0644\", \"\\u0645\", \"\\u0646\", \"\\u0647\", \"\\u0648\", \"\\u064A\", \"\\u0625\", \"\\u0623\",\n                    \"\\u0622\", \"\\u0629\", \"\\u0649\", \"\\u0644\", \"\\u0645\", \"\\u0646\", \"\\u0647\", \"\\u0648\", \"\\u064A\", \"\\u0625\",\n                    \"\\u0623\", \"\\u0622\", \"\\u0629\", \"\\u0649\", \"\\u06CC\", \"\\u0626\", \"\\u0624\", \"\\u064B\", \"\\u064C\", \"\\u064D\",\n                    \"\\u064E\", \"\\u064F\", \"\\u0650\", \"\\u0651\", \"\\u0652\", \"\\u0621\"];\n\t\n\t/**\n\t * Arabic shaped characters in Isolated form\n\t */\n\tvar IsolatedForm = [\"\\uFE8D\", \"\\uFE8F\", \"\\uFE95\", \"\\uFE99\", \"\\uFE9D\", \"\\uFEA1\", \"\\uFEA5\", \"\\uFEA9\", \"\\uFEAB\",\n                        \"\\uFEAD\", \"\\uFEAF\", \"\\uFEB1\", \"\\uFEB5\", \"\\uFEB9\", \"\\uFEBD\", \"\\uFEC1\", \"\\uFEC5\", \"\\uFEC9\",\n                        \"\\uFECD\", \"\\uFED1\", \"\\uFED5\", \"\\uFED9\", \"\\uFEDD\", \"\\uFEE1\", \"\\uFEE5\", \"\\uFEE9\", \"\\uFEED\",\n                        \"\\uFEF1\", \"\\uFE87\", \"\\uFE83\", \"\\uFE81\", \"\\uFE93\", \"\\uFEEF\", \"\\uFBFC\", \"\\uFE89\", \"\\uFE85\",\n                        \"\\uFE70\", \"\\uFE72\", \"\\uFE74\", \"\\uFE76\", \"\\uFE78\", \"\\uFE7A\", \"\\uFE7C\", \"\\uFE7E\", \"\\uFE80\"];\n\t\n\t/**\n\t * Arabic shaped characters in Final form\n\t */\n\tvar FinalForm = [\"\\uFE8E\", \"\\uFE90\", \"\\uFE96\", \"\\uFE9A\", \"\\uFE9E\", \"\\uFEA2\", \"\\uFEA6\", \"\\uFEAA\", \"\\uFEAC\", \"\\uFEAE\",\n                     \"\\uFEB0\", \"\\uFEB2\", \"\\uFEB6\", \"\\uFEBA\", \"\\uFEBE\", \"\\uFEC2\", \"\\uFEC6\", \"\\uFECA\", \"\\uFECE\", \"\\uFED2\",\n                     \"\\uFED6\", \"\\uFEDA\", \"\\uFEDE\", \"\\uFEE2\", \"\\uFEE6\", \"\\uFEEA\", \"\\uFEEE\", \"\\uFEF2\", \"\\uFE88\", \"\\uFE84\",\n                     \"\\uFE82\", \"\\uFE94\", \"\\uFEF0\", \"\\uFBFD\", \"\\uFE8A\", \"\\uFE86\", \"\\uFE70\", \"\\uFE72\", \"\\uFE74\", \"\\uFE76\",\n                     \"\\uFE78\", \"\\uFE7A\", \"\\uFE7C\", \"\\uFE7E\", \"\\uFE80\"];\n\t\n\t/**\n\t * Arabic shaped characters in Media form\n\t */\n\tvar MedialForm = [\"\\uFE8E\", \"\\uFE92\", \"\\uFE98\", \"\\uFE9C\", \"\\uFEA0\", \"\\uFEA4\", \"\\uFEA8\", \"\\uFEAA\", \"\\uFEAC\",\n                      \"\\uFEAE\", \"\\uFEB0\", \"\\uFEB4\", \"\\uFEB8\", \"\\uFEBC\", \"\\uFEC0\", \"\\uFEC4\", \"\\uFEC8\", \"\\uFECC\",\n                      \"\\uFED0\", \"\\uFED4\", \"\\uFED8\", \"\\uFEDC\", \"\\uFEE0\", \"\\uFEE4\", \"\\uFEE8\", \"\\uFEEC\", \"\\uFEEE\",\n                      \"\\uFEF4\", \"\\uFE88\", \"\\uFE84\", \"\\uFE82\", \"\\uFE94\", \"\\uFEF0\", \"\\uFBFF\", \"\\uFE8C\", \"\\uFE86\",\n                      \"\\uFE71\", \"\\uFE72\", \"\\uFE74\", \"\\uFE77\", \"\\uFE79\", \"\\uFE7B\", \"\\uFE7D\", \"\\uFE7F\", \"\\uFE80\"];\n\t\n\t/**\n\t * Arabic shaped characters in Initial form\n\t */\n\tvar InitialForm = [\"\\uFE8D\", \"\\uFE91\", \"\\uFE97\", \"\\uFE9B\", \"\\uFE9F\", \"\\uFEA3\", \"\\uFEA7\", \"\\uFEA9\", \"\\uFEAB\",\n                       \"\\uFEAD\", \"\\uFEAF\", \"\\uFEB3\", \"\\uFEB7\", \"\\uFEBB\", \"\\uFEBF\", \"\\uFEC3\", \"\\uFEC7\", \"\\uFECB\",\n                       \"\\uFECF\", \"\\uFED3\", \"\\uFED7\", \"\\uFEDB\", \"\\uFEDF\", \"\\uFEE3\", \"\\uFEE7\", \"\\uFEEB\", \"\\uFEED\",\n                       \"\\uFEF3\", \"\\uFE87\", \"\\uFE83\", \"\\uFE81\", \"\\uFE93\", \"\\uFEEF\", \"\\uFBFE\", \"\\uFE8B\", \"\\uFE85\",\n                       \"\\uFE70\", \"\\uFE72\", \"\\uFE74\", \"\\uFE76\", \"\\uFE78\", \"\\uFE7A\", \"\\uFE7C\", \"\\uFE7E\", \"\\uFE80\"];\n\t\n\t/**\n\t * Arabic characters that couldn't join to the next character\n\t */\n\tvar StandAlonForm = [\"\\u0621\", \"\\u0627\", \"\\u062F\", \"\\u0630\", \"\\u0631\", \"\\u0632\", \"\\u0648\", \"\\u0622\", \"\\u0629\",\n                         \"\\u0626\", \"\\u0624\", \"\\u0625\", \"\\u0675\", \"\\u0623\"];\n\t\n\tvar FETo06Table = [\"\\u064B\", \"\\u064B\", \"\\u064C\", \"\\u061F\", \"\\u064D\", \"\\u061F\", \"\\u064E\", \"\\u064E\", \"\\u064F\",\n                       \"\\u064F\", \"\\u0650\", \"\\u0650\", \"\\u0651\", \"\\u0651\", \"\\u0652\", \"\\u0652\", \"\\u0621\", \"\\u0622\",\n                       \"\\u0622\", \"\\u0623\", \"\\u0623\", \"\\u0624\", \"\\u0624\", \"\\u0625\", \"\\u0625\", \"\\u0626\", \"\\u0626\",\n                       \"\\u0626\", \"\\u0626\", \"\\u0627\", \"\\u0627\", \"\\u0628\", \"\\u0628\", \"\\u0628\", \"\\u0628\", \"\\u0629\",\n                       \"\\u0629\", \"\\u062A\", \"\\u062A\", \"\\u062A\", \"\\u062A\", \"\\u062B\", \"\\u062B\", \"\\u062B\", \"\\u062B\",\n                       \"\\u062C\", \"\\u062C\", \"\\u062C\", \"\\u062c\", \"\\u062D\", \"\\u062D\", \"\\u062D\", \"\\u062D\", \"\\u062E\",\n                       \"\\u062E\", \"\\u062E\", \"\\u062E\", \"\\u062F\", \"\\u062F\", \"\\u0630\", \"\\u0630\", \"\\u0631\", \"\\u0631\",\n                       \"\\u0632\", \"\\u0632\", \"\\u0633\", \"\\u0633\", \"\\u0633\", \"\\u0633\", \"\\u0634\", \"\\u0634\", \"\\u0634\",\n                       \"\\u0634\", \"\\u0635\", \"\\u0635\", \"\\u0635\", \"\\u0635\", \"\\u0636\", \"\\u0636\", \"\\u0636\", \"\\u0636\",\n                       \"\\u0637\", \"\\u0637\", \"\\u0637\", \"\\u0637\", \"\\u0638\", \"\\u0638\", \"\\u0638\", \"\\u0638\", \"\\u0639\",\n                       \"\\u0639\", \"\\u0639\", \"\\u0639\", \"\\u063A\", \"\\u063A\", \"\\u063A\", \"\\u063A\", \"\\u0641\", \"\\u0641\",\n                       \"\\u0641\", \"\\u0641\", \"\\u0642\", \"\\u0642\", \"\\u0642\", \"\\u0642\", \"\\u0643\", \"\\u0643\", \"\\u0643\",\n                       \"\\u0643\", \"\\u0644\", \"\\u0644\", \"\\u0644\", \"\\u0644\", \"\\u0645\", \"\\u0645\", \"\\u0645\", \"\\u0645\",\n                       \"\\u0646\", \"\\u0646\", \"\\u0646\", \"\\u0646\", \"\\u0647\", \"\\u0647\", \"\\u0647\", \"\\u0647\", \"\\u0648\",\n                       \"\\u0648\", \"\\u0649\", \"\\u0649\", \"\\u064A\", \"\\u064A\", \"\\u064A\", \"\\u064A\", \"\\uFEF5\", \"\\uFEF6\",\n                       \"\\uFEF7\", \"\\uFEF8\", \"\\uFEF9\", \"\\uFEFA\", \"\\uFEFB\", \"\\uFEFC\", \"\\u061F\", \"\\u061F\", \"\\u061F\"];\n\n\tvar ArabicAlefBetIntervalsBegine = [\"\\u0621\", \"\\u0641\"];\n\t\n\tvar ArabicAlefBetIntervalsEnd = [\"\\u063A\", \"\\u064a\"];\n\t\n\tvar\timpTabLtr = [\n\t/*\t\tL,\t\tR,\t\tEN,\t\tAN,\t\tN,\t\tIL,\t\tCond */\n\t\t[\t0,\t\t3,\t\t0,\t\t1,\t\t0,\t\t0,\t\t0\t], /* 0 LTR text\t*/\n\t\t[\t0,\t\t3,\t\t0,\t\t1,\t\t2,\t\t2,\t\t0\t], /* 1 LTR+AN\t\t*/\n\t\t[\t0,\t\t3,\t\t0,\t\t0x11,\t2,\t\t0,\t\t1\t], /* 2 LTR+AN+N\t*/\n\t\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t1,\t\t0\t], /* 3 RTL text\t*/\n\t\t[\t0,\t\t3,\t\t0x15,\t0x15,\t4,\t\t0,\t\t1\t], /* 4 RTL cont\t*/\n\t\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t2,\t\t0\t]  /* 5 RTL+EN/AN\t*/\n\t];\n\tvar impTabRtl = [\n\t/*\t\tL,\t\tR,\t\tEN,\t\tAN,\t\tN,\t\tIL,\t\tCond */\n\t\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t1,\t\t0\t], /* 0 RTL text\t*/\n\t\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t2,\t\t0\t], /* 1 RTL+EN/AN\t*/\n\t\t[\t2,\t\t0,\t\t2,\t\t1,\t\t3,\t\t2,\t\t0\t], /* 2 LTR text\t*/\n\t\t[\t2,\t\t0,\t\t2,\t\t0x21,\t3,\t\t1,\t\t1\t]  /* 3 LTR+cont\t*/\n\t];\n\t\n\tvar UBAT_L\t= 0; /* left to right\t\t\t\t*/\n\tvar UBAT_R\t= 1; /* right to left\t\t\t\t*/\n\tvar UBAT_EN = 2; /* European digit\t\t\t\t*/\n\tvar UBAT_AN = 3; /* Arabic-Indic digit\t\t\t*/\n\tvar UBAT_ON = 4; /* neutral\t\t\t\t\t\t*/\n\tvar UBAT_B\t= 5; /* block separator\t\t\t\t*/\n\tvar UBAT_S\t= 6; /* segment separator\t\t\t*/\n\tvar UBAT_AL = 7; /* Arabic Letter\t\t\t\t*/\n\tvar UBAT_WS = 8; /* white space\t\t\t\t\t*/\n\tvar UBAT_CS = 9; /* common digit separator\t\t*/\n\tvar UBAT_ES = 10; /* European digit separator\t*/\n\tvar UBAT_ET = 11; /* European digit terminator\t*/\n\tvar UBAT_NSM = 12; /* Non Spacing Mark\t\t\t*/\n\tvar UBAT_LRE = 13; /* LRE\t\t\t\t\t\t*/\n\tvar UBAT_RLE = 14; /* RLE\t\t\t\t\t\t*/\n\tvar UBAT_PDF = 15; /* PDF\t\t\t\t\t\t*/\n\tvar UBAT_LRO = 16; /* LRO\t\t\t\t\t\t*/\n\tvar UBAT_RLO = 17; /* RLO\t\t\t\t\t\t*/\n\tvar UBAT_BN\t= 18; /* Boundary Neutral\t\t\t*/\n\n\tvar TYPES_NAMES = [ \"UBAT_L\", \"UBAT_R\", \"UBAT_EN\", \"UBAT_AN\", \"UBAT_ON\", \"UBAT_B\", \"UBAT_S\", \"UBAT_AL\", \"UBAT_WS\",\n\t\t\t\t\t\t\"UBAT_CS\", \"UBAT_ES\", \"UBAT_ET\", \"UBAT_NSM\", \"UBAT_LRE\", \"UBAT_RLE\", \"UBAT_PDF\", \"UBAT_LRO\",\n\t\t\t\t\t\t\"UBAT_RLO\", \"UBAT_BN\" ];\n\tvar TBBASE = 100;\n\t\n\tvar TB00 = TBBASE + 0;\n\tvar TB05 = TBBASE + 1;\n\tvar TB06 = TBBASE + 2;\n\tvar TB07 = TBBASE + 3;\n\tvar TB20 = TBBASE + 4;\n\tvar TBFB = TBBASE + 5;\n\tvar TBFE = TBBASE + 6;\n\tvar TBFF = TBBASE + 7;\n\t\n\tvar L\t= UBAT_L;\n\tvar R\t= UBAT_R;\n\tvar EN\t= UBAT_EN;\n\tvar AN\t= UBAT_AN;\n\tvar ON\t= UBAT_ON;\n\tvar B\t= UBAT_B;\n\tvar S\t= UBAT_S;\n\tvar AL\t= UBAT_AL;\n\tvar WS\t= UBAT_WS;\n\tvar CS\t= UBAT_CS;\n\tvar ES\t= UBAT_ES;\n\tvar ET\t= UBAT_ET;\n\tvar NSM\t= UBAT_NSM;\n\tvar LRE\t= UBAT_LRE;\n\tvar RLE\t= UBAT_RLE;\n\tvar PDF\t= UBAT_PDF;\n\tvar LRO\t= UBAT_LRO;\n\tvar RLO\t= UBAT_RLO;\n\tvar BN\t= UBAT_BN;\n\t\n\tvar MasterTable = [\n /*******************************************************************************************************/\n /*     0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F     */\n /*******************************************************************************************************/\n /*0-*/ TB00, L,    L,    L,    L,    TB05, TB06, TB07, R,    L,    L,    L,    L,    L,    L,    L,\n /*1-*/ L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,\n /*2-*/ TB20, ON,   ON,   ON,   L,    ON,   L,    ON,   L,    ON,   ON,   ON,   L,    L,    ON,   ON,\n /*3-*/ L,    L,    L,    L,    L,    ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*4-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    ON,\n /*5-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*6-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*7-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*8-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*9-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,\n /*A-*/ L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    ON,   ON,   ON,\n /*B-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*C-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*D-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    ON,   ON,   L,    L,    ON,   ON,   L,\n /*E-*/ L,    ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,\n /*F-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    L,    TBFB, AL,   AL,   TBFE, TBFF\n\t];\n\n\tvar UnicodeTable = [\n        [ /*\tTable 00: Unicode 00xx */\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  S,   B,   S,   WS,  B,   BN,  BN,\n    /*1-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  B,   B,   B,   S,\n    /*2-*/  WS,  ON,  ON,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ES,  CS,  ES,  CS,  CS,\n    /*3-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  CS,  ON,  ON,  ON,  ON,  ON,\n    /*4-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*5-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,\n    /*6-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  BN,\n    /*8-*/  BN,  BN,  BN,  BN,  BN,  B,   BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,\n    /*9-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,\n    /*A-*/  CS,  ON,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  L,   ON,  ON,  BN,  ON,  ON,\n    /*B-*/  ET,  ET,  EN,  EN,  ON,  L,   ON,  ON,  ON,  EN,  L,   ON,  ON,  ON,  ON,  ON,\n    /*C-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*D-*/  L,   L,   L,   L,   L,   L,   L,   ON,  L,   L,   L,   L,   L,   L,   L,   L,\n    /*E-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*F-*/  L,   L,   L,   L,   L,   L,   L,   ON,  L,   L,   L,   L,   L,   L,   L,   L\n\t\t],\n\t\t[ /*\tTable 01: Unicode 05xx */\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*1-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*2-*/  L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*3-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*4-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*5-*/  L,   L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   L,   L,   L,   L,\n    /*6-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*8-*/  L,   L,   L,   L,   L,   L,   L,   L,   ON,  L,   ON,  ON,  ON,  ON,  ON,  ON,\n    /*9-*/  ON,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*A-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*B-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, R,   NSM,\n    /*C-*/  R,   NSM, NSM, R,   NSM, NSM, R,   NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*D-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n    /*E-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   ON,  ON,  ON,  ON,  ON,\n    /*F-*/  R,   R,   R,   R,   R,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON\n\t\t],\n\t\t[ /*\tTable 02: Unicode 06xx */\n    /****************************************************************************************/\n\t/*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n\t/****************************************************************************************/\n    /*0-*/  AN,  AN,  AN,  AN,  ON,  ON,  ON,  ON,  AL,  ET,  ET,  AL,  CS,  AL,  ON,  ON,\n    /*1-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, AL,  ON,  ON,  AL,  AL,\n    /*2-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*3-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*4-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM,\n    /*5-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*6-*/  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  ET,  AN,  AN,  AL,  AL,  AL,\n    /*7-*/  NSM, AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*C-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*D-*/  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, AN,  ON,  NSM,\n    /*E-*/  NSM, NSM, NSM, NSM, NSM, AL,  AL,  NSM, NSM, ON,  NSM, NSM, NSM, NSM, AL,  AL,\n    /*F-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  AL,  AL,  AL,  AL,  AL,  AL\n\t\t],\n\t\t[\t/*\tTable\t03:\tUnicode\t07xx\t*/\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  ON,  AL,\n    /*1-*/  AL,  NSM, AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*2-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*3-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*4-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, ON,  ON,  AL,  AL,  AL,\n    /*5-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*6-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*7-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*B-*/  NSM, AL,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*C-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n    /*D-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n    /*E-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   NSM, NSM, NSM, NSM, NSM,\n    /*F-*/  NSM, NSM, NSM, NSM, R,   R,   ON,  ON,  ON,  ON,  R,   ON,  ON,  ON,  ON,  ON\n\t\t],\n\t\t[\t/*\tTable\t04:\tUnicode\t20xx\t*/\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  BN,  BN,  BN,  L,   R,\n    /*1-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*2-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  WS,  B,   LRE, RLE, PDF, LRO, RLO, CS,\n    /*3-*/  ET,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*4-*/  ON,  ON,  ON,  ON,  CS,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*5-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  WS,\n    /*6-*/  BN,  BN,  BN,  BN,  BN,  ON,  ON,  ON,  ON,  ON,  BN,  BN,  BN,  BN,  BN,  BN,\n    /*7-*/  EN,  L,   ON,  ON,  EN,  EN,  EN,  EN,  EN,  EN,  ES,  ES,  ON,  ON,  ON,  L,\n    /*8-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  ES,  ES,  ON,  ON,  ON,  ON,\n    /*9-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,\n    /*A-*/  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,\n    /*B-*/  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*C-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*D-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*E-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*F-*/  NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON\n\t\t],\n\t\t[\t/*\tTable\t05:\tUnicode\tFBxx\t*/\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*1-*/  ON,  ON,  ON,  L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  R,   NSM, R,\n    /*2-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   ES,  R,   R,   R,   R,   R,   R,\n    /*3-*/  R,   R,   R,   R,   R,   R,   R,   ON,  R,   R,   R,   R,   R,   ON,  R,   ON,\n    /*4-*/  R,   R,   ON,  R,   R,   ON,  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,\n    /*5-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*6-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*7-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*C-*/  AL,  AL,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*D-*/  ON,  ON,  ON,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*E-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*F-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL\n\t\t],\n\t\t[\t/*\tTable\t06:\tUnicode\tFExx\t*/\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,\n    /*1-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*2-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*3-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*4-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*5-*/  CS,  ON,  CS,  ON,  ON,  CS,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ET,\n    /*6-*/  ON,  ON,  ES,  ES,  ON,  ON,  ON,  ON,  ON,  ET,  ET,  ON,  ON,  ON,  ON,  ON,\n    /*7-*/  AL,  AL,  AL,  AL,  AL,  ON,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*C-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*D-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*E-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,\n    /*F-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  ON,  ON,  BN\n\t\t],\n\t\t[\t/*\tTable\t07:\tUnicode\tFFxx\t*/\n    /****************************************************************************************/\n    /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\t*/\n    /****************************************************************************************/\n    /*0-*/  ON,  ON,  ON,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ES,  CS,  ES,  CS,  CS,\n    /*1-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  CS,  ON,  ON,  ON,  ON,  ON,\n    /*2-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*3-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,\n    /*4-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*5-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,\n    /*6-*/  ON,  ON,  ON,  ON,  ON,  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*8-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*9-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*A-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,\n    /*B-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,\n    /*C-*/  ON,  ON,  L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   L,   L,   L,\n    /*D-*/  ON,  ON,  L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   ON,  ON,  ON,\n    /*E-*/  ET,  ET,  ON,  ON,  ON,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,\n    /*F-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON\n\t\t]\n\t];\n\n\treturn BidiEngine;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/string/BidiEngine.js\n// module id = 199\n// module chunks = 4","  define ({\n\t\treverseMatrix: function(plot, dim, offsets, rtl){\n\t\t\t//summary:\n\t\t\t//\treverse the underlying matrix of the plots to perform the mirroring behavior.\n\t\t\t//plot:\n\t\t\t//  the plot which has the matrix to be reversed.\n\t\t\t//dim:\n\t\t\t//  the dimension (width,height) of the chart.\n\t\t\t//offsets:\n\t\t\t//  the offsets of the chart\n\t\t\tvar shift = offsets.l - offsets.r;\n\t\t\tvar xx = rtl? -1 : 1;\n\t\t\tvar xy = 0;\n\t\t\tvar yx = 0;\n\t\t\tvar yy = 1;\n\t\t\tvar dx = rtl? dim.width + shift : 0;\n\t\t\tvar dy = 0;\n\t\t\tif(plot.matrix){\n\t\t\t\txx = xx * Math.abs(plot.matrix.xx);\n\t\t\t\tyy = plot.matrix.yy;\n\t\t\t\txy = plot.matrix.xy;\n\t\t\t\tyx = plot.matrix.yx;\n\t\t\t\tdy = plot.matrix.xy;\n\t\t\t}\n\t\t\tplot.setTransform({xx: xx, xy: xy, yx: yx, yy: yy, dx: dx, dy: dy});\n \t}\n });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/bidi/_bidiutils.js\n// module id = 200\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/kernel\", \"./lambda\"],\n\tfunction(lang, arr, kernel, df){\n\n// This module adds high-level functions and related constructs:\n//\t- \"fold\" family of functions\n\n// Notes:\n//\t- missing high-level functions are provided with the compatible API:\n//\t\tfoldl, foldl1, foldr, foldr1\n//\t- missing JS standard functions are provided with the compatible API:\n//\t\treduce, reduceRight\n//\t- the fold's counterpart: unfold\n\n// Defined methods:\n//\t- take any valid lambda argument as the functional argument\n//\t- operate on dense arrays\n//\t- take a string as the array argument\n//\t- take an iterator objects as the array argument (only foldl, foldl1, and reduce)\n\n\tvar empty = {};\n\n\tlang.mixin(df, {\n\t\t// classic reduce-class functions\n\t\tfoldl: function(/*Array|String|Object*/ a, /*Function*/ f, /*Object*/ z, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from left\n\t\t\t//\t\tto right using a seed value as a starting point; returns the final\n\t\t\t//\t\tvalue.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tfor(i = 0, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tfor(i = 0; a.hasNext(); z = f.call(o, z, a.next(), i++, a));\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tz = f.call(o, z, a[i], i, a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn z;\t// Object\n\t\t},\n\t\tfoldl1: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from left\n\t\t\t//\t\tto right; returns the final value.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar z, i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tz = a[0];\n\t\t\t\tfor(i = 1, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tif(a.hasNext()){\n\t\t\t\t\tz = a.next();\n\t\t\t\t\tfor(i = 1; a.hasNext(); z = f.call(o, z, a.next(), i++, a));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tvar first = true;\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tif(first){\n\t\t\t\t\t\t\tz = a[i];\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tz = f.call(o, z, a[i], i, a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn z;\t// Object\n\t\t},\n\t\tfoldr: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object*/ z, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from right\n\t\t\t//\t\tto left using a seed value as a starting point; returns the final\n\t\t\t//\t\tvalue.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i = a.length; i > 0; --i, z = f.call(o, z, a[i], i, a));\n\t\t\treturn z;\t// Object\n\t\t},\n\t\tfoldr1: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from right\n\t\t\t//\t\tto left; returns the final value.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar n = a.length, z = a[n - 1], i = n - 1;\n\t\t\tfor(; i > 0; --i, z = f.call(o, z, a[i], i, a));\n\t\t\treturn z;\t// Object\n\t\t},\n\t\t// JS 1.8 standard array functions, which can take a lambda as a parameter.\n\t\treduce: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ z){\n\t\t\t// summary:\n\t\t\t//\t\tapply a function simultaneously against two values of the array\n\t\t\t//\t\t(from left-to-right) as to reduce it to a single value.\n\t\t\treturn arguments.length < 3 ? df.foldl1(a, f) : df.foldl(a, f, z);\t// Object\n\t\t},\n\t\treduceRight: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ z){\n\t\t\t// summary:\n\t\t\t//\t\tapply a function simultaneously against two values of the array\n\t\t\t//\t\t(from right-to-left) as to reduce it to a single value.\n\t\t\treturn arguments.length < 3 ? df.foldr1(a, f) : df.foldr(a, f, z);\t// Object\n\t\t},\n\t\t// the fold's counterpart: unfold\n\t\tunfold: function(/*Function|String|Array*/ pr, /*Function|String|Array*/ f,\n\t\t\t\t\t\t/*Function|String|Array*/ g, /*Object*/ z, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds an array by unfolding a value\n\t\t\to = o || kernel.global; f = df.lambda(f); g = df.lambda(g); pr = df.lambda(pr);\n\t\t\tvar t = [];\n\t\t\tfor(; !pr.call(o, z); t.push(f.call(o, z)), z = g.call(o, z));\n\t\t\treturn t;\t// Array\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/lang/functional/fold.js\n// module id = 201\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/sniff\", \"dojo/_base/declare\",\n\t\"dojo/_base/connect\", \"dojo/dom-geometry\", \"./Invisible\",\n\t\"../scaler/linear\", \"./common\", \"dojox/gfx\", \"dojox/lang/utils\", \"dojox/lang/functional\",\n\t\"dojo/has!dojo-bidi?../bidi/axis2d/Default\"],\n\tfunction(lang, arr, has, declare, connect, domGeom, Invisible,\n\t\t\tlin, acommon, g, du, df, BidiDefault){\n\n\t/*=====\n\tvar __AxisCtorArgs = {\n\t\t// summary:\n\t\t//\t\tOptional arguments used in the definition of an axis.\n\t\t// vertical: Boolean?\n\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t// fixUpper: String?\n\t\t//\t\tAlign the greatest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t// fixLower: String?\n\t\t//\t\tAlign the smallest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t// natural: Boolean?\n\t\t//\t\tEnsure tick marks are made on \"natural\" numbers. Defaults to false.\n\t\t// leftBottom: Boolean?\n\t\t//\t\tDeprecated: use position instead. The position of a vertical axis; if true, will be placed against the left-bottom corner of the chart.  Defaults to true.\n\t\t// includeZero: Boolean?\n\t\t//\t\tInclude 0 on the axis rendering.  Default is false.\n\t\t// fixed: Boolean?\n\t\t//\t\tForce all axis labels to be fixed numbers.  Default is true.\n\t\t// majorLabels: Boolean?\n\t\t//\t\tFlag to draw labels at major ticks. Default is true.\n\t\t// minorTicks: Boolean?\n\t\t//\t\tFlag to draw minor ticks on an axis.  Default is true.\n\t\t// minorLabels: Boolean?\n\t\t//\t\tFlag to labels on minor ticks when there is enough space. Default is true.\n\t\t// microTicks: Boolean?\n\t\t//\t\tFlag to draw micro ticks on an axis. Default is false.\n\t\t// htmlLabels: Boolean?\n\t\t//\t\tFlag to use HTML (as opposed to the native vector graphics engine) to draw labels. Default is true.\n\t\t// min: Number?\n\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t// max: Number?\n\t\t//\t\tThe largest value on an axis. Default is 1.\n\t\t// from: Number?\n\t\t//\t\tForce the chart to render data visible from this value. Default is 0.\n\t\t// to: Number?\n\t\t//\t\tForce the chart to render data visible to this value. Default is 1.\n\t\t// majorTickStep: Number?\n\t\t//\t\tThe amount to skip before a major tick is drawn. When not set the major ticks step is computed from\n\t\t//\t\tthe data range.\n\t\t// minorTickStep: Number?\n\t\t//\t\tThe amount to skip before a minor tick is drawn. When not set the minor ticks step is computed from\n\t\t//\t\tthe data range.\n\t\t// microTickStep: Number?\n\t\t//\t\tThe amount to skip before a micro tick is drawn. When not set the micro ticks step is computed from\n\t\t// labels: Object[]?\n\t\t//\t\tAn array of labels for major ticks, with corresponding numeric values, ordered by value.\n\t\t// labelFunc: Function?\n\t\t//\t\tAn optional function to use to compute label text. It takes precedence over\n\t\t//\t\tthe default text when available. The function must be of the following form:\n\t\t//\t|\t\tfunction labelFunc(text, value, precision) {}\n\t\t//\t\t`text` is the already pre-formatted text. Pre-formatting is done using `dojo/number` is available, `Date.toFixed` otherwise.\n\t\t//\t\t`value`  is the raw axis value.\n\t\t//\t\t`precision` is the requested precision to be applied.\n\t\t// maxLabelSize: Number?\n\t\t//\t\tThe maximum size, in pixels, for a label.  To be used with the optional label function.\n\t\t// stroke: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke to be used for drawing an axis.\n\t\t// majorTick: Object?\n\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a major tick.\n\t\t// minorTick: Object?\n\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a minor tick.\n\t\t// microTick: Object?\n\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a micro tick.\n\t\t// tick: Object?\n\t\t//\t\tAn object containing a dojox.gfx.Stroke, and a length (number) for a tick.\n\t\t// font: String?\n\t\t//\t\tAn optional font definition (as used in the CSS font property) for labels.\n\t\t// fontColor: String|dojo.Color?\n\t\t//\t\tAn optional color to be used in drawing labels.\n\t\t// titleGap: Number?\n\t\t//\t\tAn optional grap between axis title and axis label\n\t\t// titleFont: String?\n\t\t//\t\tAn optional font definition for axis title\n\t\t// titleFontColor: String?\n\t\t//\t\tAn optional axis title color\n\t\t// titleOrientation: String?\n\t\t//\t\tAn optional orientation for axis title. \"axis\" means the title facing the axis, \"away\" means facing away.\n\t\t//\t\tIf no value is set \"axis\" is used.\n\t\t// enableCache: Boolean?\n\t\t//\t\tWhether the ticks and labels are cached from one rendering to another. This improves the rendering performance of\n\t\t//\t\tsuccessive rendering but penalize the first rendering. For labels it is only working with gfx labels\n\t\t//\t\tnot html ones.  Default false.\n\t\t// dropLabels: Boolean?\n\t\t//\t\tWhether the axis automatically drops labels at regular interval or not to avoid labels overlapping.\n\t\t//\t\tThis gives better results but require more computations.  You can disable it to save computation\n\t\t//\t\ttime when you know your labels won't overlap. Default is true.\n\t\t// labelSizeChange: Boolean?\n\t\t//\t\tIndicates to the axis whether the axis labels are changing their size on zoom. If false this allows to\n\t\t//\t\toptimize the axis by avoiding recomputing labels maximum size on zoom actions. Default is false.\n\t\t// position: String?\n\t\t//\t\tThe position of the axis. Values: \"leftOrBottom\", \"center\" or \"rightOrTop\". Default is \"leftOrBottom\".\n\t};\n\t=====*/\n\n\tvar centerAnchorLimit = 45;\t// in degrees\n\n\tvar Default = declare(has(\"dojo-bidi\")? \"dojox.charting.axis2d.NonBidiDefault\" : \"dojox.charting.axis2d.Default\", Invisible, {\n\t\t// summary:\n\t\t//\t\tThe default axis object used in dojox.charting.  See dojox.charting.Chart.addAxis for details.\n\n\t\t// defaultParams: Object\n\t\t//\t\tThe default parameters used to define any axis.\n\t\t// optionalParams: Object\n\t\t//\t\tAny optional parameters needed to define an axis.\n\n\t\t/*=====\n\t\t// TODO: the documentation tools need these to be pre-defined in order to pick them up\n\t\t//\tcorrectly, but the code here is partially predicated on whether or not the properties\n\t\t//\tactually exist.  For now, we will leave these undocumented but in the code for later. -- TRT\n\n\t\t// opt: Object\n\t\t//\t\tThe actual options used to define this axis, created at initialization.\n\t\t// scaler: Object\n\t\t//\t\tThe calculated helper object to tell charts how to draw an axis and any data.\n\t\t// ticks: Object\n\t\t//\t\tThe calculated tick object that helps a chart draw the scaling on an axis.\n\t\t// dirty: Boolean\n\t\t//\t\tThe state of the axis (whether it needs to be redrawn or not)\n\t\t// scale: Number\n\t\t//\t\tThe current scale of the axis.\n\t\t// offset: Number\n\t\t//\t\tThe current offset of the axis.\n\n\t\topt: null,\n\t\tscaler: null,\n\t\tticks: null,\n\t\tdirty: true,\n\t\tscale: 1,\n\t\toffset: 0,\n\t\t=====*/\n\t\tdefaultParams: {\n\t\t\tvertical:\tfalse,\t\t// true for vertical axis\n\t\t\tfixUpper:\t\"none\",\t// align the upper on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\tfixLower:\t\"none\",\t// align the lower on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\tnatural:\t false,\t\t// all tick marks should be made on natural numbers\n\t\t\tleftBottom:  true,\t\t// position of the axis, used with \"vertical\" - deprecated: use position instead\n\t\t\tincludeZero: false,\t\t// 0 should be included\n\t\t\tfixed:\t   true,\t\t// all labels are fixed numbers\n\t\t\tmajorLabels: true,\t\t// draw major labels\n\t\t\tminorTicks:  true,\t\t// draw minor ticks\n\t\t\tminorLabels: true,\t\t// draw minor labels\n\t\t\tmicroTicks:  false,\t\t// draw micro ticks\n\t\t\trotation:\t0,\t\t\t// label rotation angle in degrees\n\t\t\thtmlLabels:  true,\t\t// use HTML to draw labels\n\t\t\tenableCache: false,\t\t// whether we cache or not\n\t\t\tdropLabels: true,\t\t// whether we automatically drop overlapping labels or not\n\t\t\tlabelSizeChange: false, // whether the labels size change on zoom\n\t\t\tposition: \"leftOrBottom\" // position of the axis: \"leftOrBottom\" (default), \"center\" or \"rightOrTop\"\n\t\t},\n\t\toptionalParams: {\n\t\t\tmin:\t\t\t0,\t// minimal value on this axis\n\t\t\tmax:\t\t\t1,\t// maximal value on this axis\n\t\t\tfrom:\t\t\t0,\t// visible from this value\n\t\t\tto:\t\t\t\t1,\t// visible to this value\n\t\t\tmajorTickStep:\t4,\t// major tick step\n\t\t\tminorTickStep:\t2,\t// minor tick step\n\t\t\tmicroTickStep:\t1,\t// micro tick step\n\t\t\tlabels:\t\t\t[],\t// array of labels for major ticks\n\t\t\t// with corresponding numeric values\n\t\t\t// ordered by values\n\t\t\tlabelFunc:\t\tnull, // function to compute label values\n\t\t\tmaxLabelSize:\t0,\t// size in px. For use with labelFunc\n\t\t\tmaxLabelCharCount:\t0,\t// size in word count.\n\t\t\ttrailingSymbol:\tnull,\n\n\t\t\t// TODO: add support for minRange!\n\t\t\t// minRange:\t\t1,\t// smallest distance from min allowed on the axis\n\n\t\t\t// theme components\n\t\t\tstroke:\t\t\t{},\t// stroke for an axis\n\t\t\tmajorTick:\t\t{},\t// stroke + length for a tick\n\t\t\tminorTick:\t\t{},\t// stroke + length for a tick\n\t\t\tmicroTick:\t\t{},\t// stroke + length for a tick\n\t\t\ttick:\t\t   {},\t// stroke + length for a tick\n\t\t\tfont:\t\t\t\"\",\t// font for labels\n\t\t\tfontColor:\t\t\"\",\t// color for labels as a string\n\t\t\ttitle:\t\t\t\t \"\",\t// axis title\n\t\t\ttitleGap:\t\t\t 0,\t\t// gap between axis title and axis label\n\t\t\ttitleFont:\t\t\t \"\",\t\t// axis title font\n\t\t\ttitleFontColor:\t\t \"\",\t\t// axis title font color\n\t\t\ttitleOrientation:\t \"\"\t\t// \"axis\" means the title facing the axis, \"away\" means facing away\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for an axis.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart the axis belongs to.\n\t\t\t// kwArgs: __AxisCtorArgs?\n\t\t\t//\t\tAny optional keyword arguments to be used to define this axis.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tif(this.opt.enableCache){\n\t\t\t\tthis._textFreePool = [];\n\t\t\t\tthis._lineFreePool = [];\n\t\t\t\tthis._textUsePool = [];\n\t\t\t\tthis._lineUsePool = [];\n\t\t\t}\n\t\t\tthis._invalidMaxLabelSize = true;\n\t\t\t// replace deprecated leftBotton to position\n\t\t\tif(!(kwArgs && ('position' in kwArgs))){\n\t\t\t    this.opt.position = this.opt.leftBottom ? \"leftOrBottom\" : \"rightOrTop\";\n\t\t\t}\t\t\t\n\t\t\tthis.renderingOptions = { \"shape-rendering\": \"crispEdges\" };\n\t\t},\n\t\tsetWindow: function(scale, offset){\n\t\t\t// summary:\n\t\t\t//\t\tSet the drawing \"window\" for the axis.\n\t\t\t// scale: Number\n\t\t\t//\t\tThe new scale for the axis.\n\t\t\t// offset: Number\n\t\t\t//\t\tThe new offset for the axis.\n\t\t\t// returns: dojox/charting/axis2d/Default\n\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\tif(scale != this.scale){\n\t\t\t\t// if scale changed we need to recompute new max label size\n\t\t\t\tthis._invalidMaxLabelSize = true;\n\t\t\t}\n\t\t\treturn this.inherited(arguments);\n\t\t},\n\n\t\t_groupLabelWidth: function(labels, font, wcLimit){\n\t\t\tif(!labels.length){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(labels.length > 50){\n\t\t\t\t// let's avoid degenerated cases\n\t\t\t\tlabels.length = 50;\n\t\t\t}\n\t\t\tif(lang.isObject(labels[0])){\n\t\t\t\tlabels = df.map(labels, function(label){ return label.text; });\n\t\t\t}\n\t\t\tif(wcLimit){\n\t\t\t\tlabels = df.map(labels, function(label){\n\t\t\t\t\treturn lang.trim(label).length == 0 ? \"\" : label.substring(0, wcLimit) + this.trailingSymbol;\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\tvar s = labels.join(\"<br>\");\n\t\t\treturn g._base._getTextBox(s, {font: font}).w || 0;\n\t\t},\n\n\t\t_getMaxLabelSize: function(min, max, span, rotation, font, size){\n\t\t\tif(this._maxLabelSize == null && arguments.length == 6){\n\t\t\t\tvar o = this.opt;\n\t\t\t\t// everything might have changed, reset the minMinorStep value\n\t\t\t\tthis.scaler.minMinorStep = this._prevMinMinorStep = 0;\n\t\t\t\tvar ob = lang.clone(o);\n\t\t\t\tdelete ob.to;\n\t\t\t\tdelete ob.from;\n\t\t\t\t// build all the ticks from min, to max not from to to _but_ using the step\n\t\t\t\t// that would be used if we where just displaying from to to from.\n\t\t\t\tvar sb = lin.buildScaler(min, max, span, ob, o.to - o.from);\n\t\t\t\tsb.minMinorStep = 0;\n\t\t\t\tthis._majorStart = sb.major.start;\n\t\t\t\t// we build all the ticks not only the ones we need to draw in order to get\n\t\t\t\t// a correct drop rate computation that works for any offset of this scale\n\t\t\t\tvar tb = lin.buildTicks(sb, o);\n\t\t\t\t// if there is not tick at all tb is null\n\t\t\t\tif(size && tb){\n\t\t\t\t\tvar majLabelW = 0, minLabelW = 0; // non rotated versions\n\t\t\t\t\t// we first collect all labels when needed\n\t\t\t\t\tvar tickLabelFunc = function(tick){\n\t\t\t\t\t\tif(tick.label){\n\t\t\t\t\t\t\tthis.push(tick.label);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tvar labels = [];\n\t\t\t\t\tif(this.opt.majorLabels){\n\t\t\t\t\t\tarr.forEach(tb.major, tickLabelFunc, labels);\n\t\t\t\t\t\tmajLabelW = this._groupLabelWidth(labels, font, ob.maxLabelCharCount);\n\t\t\t\t\t\tif(ob.maxLabelSize){\n\t\t\t\t\t\t\tmajLabelW = Math.min(ob.maxLabelSize, majLabelW);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// do the minor labels computation only if dropLabels is set\n\t\t\t\t\tlabels = [];\n\t\t\t\t\tif(this.opt.dropLabels && this.opt.minorLabels){\n\t\t\t\t\t\tarr.forEach(tb.minor, tickLabelFunc, labels);\n\t\t\t\t\t\tminLabelW = this._groupLabelWidth(labels, font, ob.maxLabelCharCount);\n\t\t\t\t\t\tif(ob.maxLabelSize){\n\t\t\t\t\t\t\tminLabelW = Math.min(ob.maxLabelSize, minLabelW);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._maxLabelSize = {\n\t\t\t\t\t\tmajLabelW: majLabelW, minLabelW: minLabelW,\n\t\t\t\t\t\tmajLabelH: size, minLabelH: size\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tthis._maxLabelSize = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._maxLabelSize;\n\t\t},\n\n\t\tcalculate: function(min, max, span){\n\t\t\tthis.inherited(arguments);\n\t\t\t// when the scale has not changed there is no reason for minMinorStep to change\n\t\t\tthis.scaler.minMinorStep = this._prevMinMinorStep;\n\t\t\t// we want to recompute the dropping mechanism only when the scale or the size of the axis is changing\n\t\t\t// not when for example when we scroll (otherwise effect would be weird)\n\t\t\tif((this._invalidMaxLabelSize || span != this._oldSpan) && (min != Infinity && max != -Infinity)){\n\t\t\t\tthis._invalidMaxLabelSize = false;\n\t\t\t\tif(this.opt.labelSizeChange){\n\t\t\t\t\tthis._maxLabelSize = null;\n\t\t\t\t}\n\t\t\t\tthis._oldSpan = span;\n\t\t\t\tvar o = this.opt;\n\t\t\t\tvar ta = this.chart.theme.axis, rotation = o.rotation % 360,\n\t\t\t\t\tlabelGap = this.chart.theme.axis.tick.labelGap,\n\t\t\t\t\t// TODO: we use one font --- of major tick, we need to use major and minor fonts\n\t\t\t\t\tfont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),\n\t\t\t\t\tsize = font ? g.normalizedLength(g.splitFontString(font).size) : 0,\n\t\t\t\t\t// even if we don't drop label we need to compute max size for offsets\n\t\t\t\t\tlabelW = this._getMaxLabelSize(min, max, span, rotation, font, size);\n\t\t\t\tif(typeof labelGap != \"number\"){\n\t\t\t\t\tlabelGap = 4; // in pixels\n\t\t\t\t}\n\t\t\t\tif(labelW && o.dropLabels){\n\t\t\t\t\tvar cosr = Math.abs(Math.cos(rotation * Math.PI / 180)),\n\t\t\t\t\t\tsinr = Math.abs(Math.sin(rotation * Math.PI / 180));\n\t\t\t\t\tvar majLabelW, minLabelW;\n\t\t\t\t\tif(rotation < 0){\n\t\t\t\t\t\trotation += 360;\n\t\t\t\t\t}\n\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\t// trivial cases: horizontal labels\n\t\t\t\t\t\t\tif(this.vertical){\n\t\t\t\t\t\t\t\tmajLabelW = minLabelW = size;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmajLabelW = labelW.majLabelW;\n\t\t\t\t\t\t\t\tminLabelW = labelW.minLabelW;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\t// trivial cases: vertical\n\t\t\t\t\t\t\tif(this.vertical){\n\t\t\t\t\t\t\t\tmajLabelW = labelW.majLabelW;\n\t\t\t\t\t\t\t\tminLabelW = labelW.minLabelW;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmajLabelW = minLabelW = size;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// all major labels are parallel they can't collapse except if the two ticks are\n\t\t\t\t\t\t\t// closer than the height of the text * cos(90-rotation)\n\t\t\t\t\t\t\tmajLabelW  = this.vertical ? Math.min(labelW.majLabelW, size / cosr) : Math.min(labelW.majLabelW, size / sinr);\n\t\t\t\t\t\t\t// for minor labels we need to rotated them\n\t\t\t\t\t\t\tvar gap1 = Math.sqrt(labelW.minLabelW * labelW.minLabelW + size * size),\n\t\t\t\t\t\t\t\tgap2 = this.vertical ? size * cosr + labelW.minLabelW * sinr : labelW.minLabelW * cosr + size * sinr;\n\t\t\t\t\t\t\tminLabelW = Math.min(gap1, gap2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// we need to check both minor and major labels fit a minor step\n\t\t\t\t\tthis.scaler.minMinorStep = this._prevMinMinorStep =  Math.max(majLabelW, minLabelW) + labelGap;\n\t\t\t\t\tvar canMinorLabel = this.scaler.minMinorStep <= this.scaler.minor.tick * this.scaler.bounds.scale;\n\t\t\t\t\tif(!canMinorLabel){\n\t\t\t\t\t\t// we can't place minor labels, let's see if we can place major ones\n\t\t\t\t\t\t// in a major step and if not which skip interval we must follow\n\t\t\t\t\t\tthis._skipInterval = Math.floor((majLabelW + labelGap) / (this.scaler.major.tick * this.scaler.bounds.scale));\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// everything fit well\n\t\t\t\t\t\tthis._skipInterval = 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// drop label disabled\n\t\t\t\t\tthis._skipInterval = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// computes the tick subset we need for that scale/offset\n\t\t\tthis.ticks = lin.buildTicks(this.scaler, this.opt);\n\t\t\treturn this;\n\t\t},\n\n\t\tgetOffsets: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet the physical offset values for this axis (used in drawing data series). This method is not\n\t\t\t//\t\tsupposed to be called by the users but internally.\n\t\t\t// returns: Object\n\t\t\t//\t\tThe calculated offsets in the form of { l, r, t, b } (left, right, top, bottom).\n\t\t\tvar s = this.scaler, offsets = { l: 0, r: 0, t: 0, b: 0 };\n\t\t\tif(!s){\n\t\t\t\treturn offsets;\n\t\t\t}\n\t\t\tvar o = this.opt,\n\t\t\t\tta = this.chart.theme.axis,\n\t\t\t\tlabelGap = this.chart.theme.axis.tick.labelGap,\n\t\t\t\t// TODO: we use one font --- of major tick, we need to use major and minor fonts\n\t\t\t\ttaTitleFont = o.titleFont || (ta.title && ta.title.font),\n\t\t\t\ttaTitleGap = (o.titleGap==0) ? 0 : o.titleGap || (ta.title && ta.title.gap),\n\t\t\t\ttaMajorTick = this.chart.theme.getTick(\"major\", o),\n\t\t\t\ttaMinorTick = this.chart.theme.getTick(\"minor\", o),\n\t\t\t\ttsize = taTitleFont ? g.normalizedLength(g.splitFontString(taTitleFont).size) : 0,\n\t\t\t\trotation = o.rotation % 360, position = o.position, \n\t\t\t\tleftBottom = position !== \"rightOrTop\",\n\t\t\t\tcosr = Math.abs(Math.cos(rotation * Math.PI / 180)),\n\t\t\t\tsinr = Math.abs(Math.sin(rotation * Math.PI / 180));\n\t\t\tthis.trailingSymbol = (o.trailingSymbol === undefined || o.trailingSymbol === null) ?\n\t\t\t\tthis.trailingSymbol : o.trailingSymbol;\n\t\t\tif(typeof labelGap != \"number\"){\n\t\t\t\tlabelGap = 4; // in pixels\n\t\t\t}\n\t\t\tif(rotation < 0){\n\t\t\t\trotation += 360;\n\t\t\t}\n\t\t\tvar maxLabelSize = this._getMaxLabelSize(); // don't need parameters, calculate has been called before => we use cached value\n\t\t\tif(maxLabelSize){\n\t\t\t\tvar side;\n\t\t\t\tvar labelWidth = Math.ceil(Math.max(maxLabelSize.majLabelW, maxLabelSize.minLabelW)) + 1,\n\t\t\t\t\tsize = Math.ceil(Math.max(maxLabelSize.majLabelH, maxLabelSize.minLabelH)) + 1;\n\t\t\t\tif(this.vertical){\n\t\t\t\t\tside = leftBottom ? \"l\" : \"r\";\n\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\toffsets[side] = position === \"center\" ? 0 : labelWidth;\n\t\t\t\t\t\t\toffsets.t = offsets.b = size / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\toffsets[side] = size;\n\t\t\t\t\t\t\toffsets.t = offsets.b = labelWidth / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(rotation <= centerAnchorLimit || (180 < rotation && rotation <= (180 + centerAnchorLimit))){\n\t\t\t\t\t\t\t\toffsets[side] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"t\" : \"b\"] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"b\" : \"t\"] = size * cosr / 2;\n\t\t\t\t\t\t\t}else if(rotation > (360 - centerAnchorLimit) || (180 > rotation && rotation > (180 - centerAnchorLimit))){\n\t\t\t\t\t\t\t\toffsets[side] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"b\" : \"t\"] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"t\" : \"b\"] = size * cosr / 2;\n\t\t\t\t\t\t\t}else if(rotation < 90 || (180 < rotation && rotation < 270)){\n\t\t\t\t\t\t\t\toffsets[side] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"t\" : \"b\"] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\toffsets[side] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"b\" : \"t\"] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(position === \"center\"){\n\t\t\t\t\t    offsets[side] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\t\t\t\t\t\n\t\t\t\t\t    offsets[side] += labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) + (o.title ? (tsize + taTitleGap) : 0);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tside = leftBottom ? \"b\" : \"t\";\n\t\t\t\t\tswitch(rotation){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcase 180:\n\t\t\t\t\t\t\toffsets[side] = position === \"center\" ? 0 : size;\n\t\t\t\t\t\t\toffsets.l = offsets.r = labelWidth / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 90:\n\t\t\t\t\t\tcase 270:\n\t\t\t\t\t\t\toffsets[side] = labelWidth;\n\t\t\t\t\t\t\toffsets.l = offsets.r = size / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif((90 - centerAnchorLimit) <= rotation && rotation <= 90 || (270 - centerAnchorLimit) <= rotation && rotation <= 270){\n\t\t\t\t\t\t\t\toffsets[side] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"r\" : \"l\"] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"l\" : \"r\"] = size * sinr / 2;\n\t\t\t\t\t\t\t}else if(90 <= rotation && rotation <= (90 + centerAnchorLimit) || 270 <= rotation && rotation <= (270 + centerAnchorLimit)){\n\t\t\t\t\t\t\t\toffsets[side] = size * cosr / 2 + labelWidth * sinr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"l\" : \"r\"] = size * sinr / 2 + labelWidth * cosr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"r\" : \"l\"] = size * sinr / 2;\n\t\t\t\t\t\t\t}else if(rotation < centerAnchorLimit || (180 < rotation && rotation < (180 + centerAnchorLimit))){\n\t\t\t\t\t\t\t\toffsets[side] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"r\" : \"l\"] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\toffsets[side] = size * cosr + labelWidth * sinr;\n\t\t\t\t\t\t\t\toffsets[leftBottom ? \"l\" : \"r\"] = size * sinr + labelWidth * cosr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(position === \"center\"){\n\t\t\t\t\t    offsets[side] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\t\t\t\t\t\n\t\t\t\t\toffsets[side] += labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) + (o.title ? (tsize + taTitleGap) : 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn offsets;\t//\tObject\n\t\t},\n\t\tcleanGroup: function(creator){\n\t\t\tif(this.opt.enableCache && this.group){\n\t\t\t\tthis._lineFreePool = this._lineFreePool.concat(this._lineUsePool);\n\t\t\t\tthis._lineUsePool = [];\n\t\t\t\tthis._textFreePool = this._textFreePool.concat(this._textUsePool);\n\t\t\t\tthis._textUsePool = [];\n\t\t\t}\n\t\t\tthis.inherited(arguments);\n\t\t},\n\t\tcreateText: function(labelType, creator, x, y, align, textContent, font, fontColor, labelWidth){\n\t\t\tif(!this.opt.enableCache || labelType==\"html\"){\n\t\t\t\treturn acommon.createText[labelType](\n\t\t\t\t\t\tthis.chart,\n\t\t\t\t\t\tcreator,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\talign,\n\t\t\t\t\t\ttextContent,\n\t\t\t\t\t\tfont,\n\t\t\t\t\t\tfontColor,\n\t\t\t\t\t\tlabelWidth\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tvar text;\n\t\t\tif(this._textFreePool.length > 0){\n\t\t\t\ttext = this._textFreePool.pop();\n\t\t\t\ttext.setShape({x: x, y: y, text: textContent, align: align});\n\t\t\t\t// For now all items share the same font, no need to re-set it\n\t\t\t\t//.setFont(font).setFill(fontColor);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(text);\n\t\t\t}else{\n\t\t\t\ttext = acommon.createText[labelType](\n\t\t\t\t\t\tthis.chart,\n\t\t\t\t\t\tcreator,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\talign,\n\t\t\t\t\t\ttextContent,\n\t\t\t\t\t\tfont,\n\t\t\t\t\t\tfontColor\t\t\t\t\t\t\n\t\t\t\t\t);\t\t\t\n\t\t\t}\n\t\t\tthis._textUsePool.push(text);\n\t\t\treturn text;\n\t\t},\n\t\tcreateLine: function(creator, params){\n\t\t\tvar line;\n\t\t\tif(this.opt.enableCache && this._lineFreePool.length > 0){\n\t\t\t\tline = this._lineFreePool.pop();\n\t\t\t\tline.setShape(params);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(line);\n\t\t\t}else{\n\t\t\t\tline = creator.createLine(params);\n\t\t\t}\n\t\t\tif(this.opt.enableCache){\n\t\t\t\tthis._lineUsePool.push(line);\n\t\t\t}\n\t\t\treturn line;\n\t\t},\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRender/draw the axis.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height}.\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t// returns: dojox/charting/axis2d/Default\n\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\t\n\t\t\tvar isRtl = this._isRtl();\t// chart mirroring\n\t\t\tif(!this.dirty || !this.scaler){\n\t\t\t\treturn this;\t//\tdojox/charting/axis2d/Default\n\t\t\t}\n\t\t\t// prepare variable\n\t\t\tvar o = this.opt, ta = this.chart.theme.axis, position = o.position, \n\t\t\t       leftBottom = position !== \"rightOrTop\", rotation = o.rotation % 360,\n\t\t\t\tstart, stop, titlePos, titleRotation=0, titleOffset, axisVector, tickVector, anchorOffset, labelOffset, labelAlign,\n\t\t\t\tlabelGap = this.chart.theme.axis.tick.labelGap,\n\t\t\t\t// TODO: we use one font --- of major tick, we need to use major and minor fonts\n\t\t\t\ttaFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),\n\t\t\t\ttaTitleFont = o.titleFont || (ta.title && ta.title.font),\n\t\t\t\t// TODO: we use one font color --- we need to use different colors\n\t\t\t\ttaFontColor = o.fontColor || (ta.majorTick && ta.majorTick.fontColor) || (ta.tick && ta.tick.fontColor) || \"black\",\n\t\t\t\ttaTitleFontColor = o.titleFontColor || (ta.title && ta.title.fontColor) || \"black\",\n\t\t\t\ttaTitleGap = (o.titleGap==0) ? 0 : o.titleGap || (ta.title && ta.title.gap) || 15,\n\t\t\t\ttaTitleOrientation = o.titleOrientation || (ta.title && ta.title.orientation) || \"axis\",\n\t\t\t\ttaMajorTick = this.chart.theme.getTick(\"major\", o),\n\t\t\t\ttaMinorTick = this.chart.theme.getTick(\"minor\", o),\n\t\t\t\ttaMicroTick = this.chart.theme.getTick(\"micro\", o),\n\n\t\t\t\ttaStroke = \"stroke\" in o ? o.stroke : ta.stroke,\n\t\t\t\tsize = taFont ? g.normalizedLength(g.splitFontString(taFont).size) : 0,\n\t\t\t\tcosr = Math.abs(Math.cos(rotation * Math.PI / 180)),\n\t\t\t\tsinr = Math.abs(Math.sin(rotation * Math.PI / 180)),\n\t\t\t\ttsize = taTitleFont ? g.normalizedLength(g.splitFontString(taTitleFont).size) : 0;\n\t\t\tif(typeof labelGap != \"number\"){\n\t\t\t\tlabelGap = 4; // in pixels\n\t\t\t}\n\t\t\tif(rotation < 0){\n\t\t\t\trotation += 360;\n\t\t\t}\n\t\t\tvar cachedLabelW = this._getMaxLabelSize();\n\t\t\tcachedLabelW = cachedLabelW && cachedLabelW.majLabelW;\n\t\t\tif(this.vertical){\n\t\t\t\tstart = {y: dim.height - offsets.b};\n\t\t\t\tstop  = {y: offsets.t};\n\t\t\t\ttitlePos = {y: (dim.height - offsets.b + offsets.t)/2};\n\t\t\t\ttitleOffset = size * sinr + (cachedLabelW || 0) * cosr + labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) +\n\t\t\t\t\ttsize + taTitleGap;\n\t\t\t\taxisVector = {x: 0, y: -1};\n\t\t\t\tlabelOffset = {x: 0, y: 0};\n\t\t\t\ttickVector = {x: 1, y: 0};\n\t\t\t\tanchorOffset = {x: labelGap, y: 0};\n\t\t\t\tswitch(rotation){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 90:\n\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\tlabelOffset.x = -size;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 180:\n\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\tlabelOffset.y = -size * 0.4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 270:\n\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(rotation < centerAnchorLimit){\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t}else if(rotation < 90){\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t}else if(rotation < (180 - centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t}else if(rotation < (180 + centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.y = -size * 0.4;\n\t\t\t\t\t\t}else if(rotation < 270){\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.x = leftBottom ? 0 : size * 0.4;\n\t\t\t\t\t\t}else if(rotation < (360 - centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.x = leftBottom ? 0 : size * 0.4;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = size * 0.4;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftBottom){\n\t\t\t\t\tstart.x = stop.x = position === \"center\" ? dim.width/2 : offsets.l;\n\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"away\") ? 90 : 270;\n\t\t\t\t\ttitlePos.x = offsets.l - titleOffset + (titleRotation == 270 ? tsize : 0);\n\t\t\t\t\ttickVector.x = -1;\n\t\t\t\t\tanchorOffset.x = -anchorOffset.x;\n\t\t\t\t}else{\n\t\t\t\t\tstart.x = stop.x = dim.width - offsets.r;\n\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"axis\") ? 90 : 270;\n\t\t\t\t\ttitlePos.x = dim.width - offsets.r + titleOffset - (titleRotation == 270 ? 0 : tsize);\n\t\t\t\t\tswitch(labelAlign){\n\t\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\tlabelOffset.x += size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tstart = {x: offsets.l};\n\t\t\t\tstop  = {x: dim.width - offsets.r};\n\t\t\t\ttitlePos = {x: (dim.width - offsets.r + offsets.l)/2};\n\t\t\t\ttitleOffset = size * cosr + (cachedLabelW || 0) * sinr + labelGap + Math.max(taMajorTick.length > 0?taMajorTick.length:0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t taMinorTick.length > 0?taMinorTick.length:0) +\n\t\t\t\t\ttsize + taTitleGap;\n\t\t\t\taxisVector = {x: isRtl ? -1 : 1, y: 0}; \t// chart mirroring\n\t\t\t\tlabelOffset = {x: 0, y: 0};\n\t\t\t\ttickVector = {x: 0, y: 1};\n\t\t\t\tanchorOffset = {x: 0, y: labelGap};\n\t\t\t\tswitch(rotation){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\tlabelOffset.y = size;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 90:\n\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\tlabelOffset.x = -size * 0.4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 180:\n\t\t\t\t\t\tlabelAlign = \"middle\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 270:\n\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\tlabelOffset.x = size * 0.4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(rotation < (90 - centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? size : 0;\n\t\t\t\t\t\t}else if(rotation < (90 + centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.x = -size * 0.4;\n\t\t\t\t\t\t}else if(rotation < 180){\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? 0 : -size;\n\t\t\t\t\t\t}else if(rotation < (270 - centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? 0 : -size;\n\t\t\t\t\t\t}else if(rotation < (270 + centerAnchorLimit)){\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? size * 0.4 : 0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tlabelOffset.y = leftBottom ? size : 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftBottom){\n\t\t\t\t\tstart.y = stop.y = position === \"center\" ? dim.height/2 : dim.height - offsets.b;\n\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"axis\") ? 180 : 0;\n\t\t\t\t\ttitlePos.y = dim.height - offsets.b + titleOffset - (titleRotation ? tsize : 0);\n\t\t\t\t}else{\n\t\t\t\t\tstart.y = stop.y = offsets.t;\n\t\t\t\t\ttitleRotation = (taTitleOrientation && taTitleOrientation == \"away\") ? 180 : 0;\n\t\t\t\t\ttitlePos.y = offsets.t - titleOffset + (titleRotation ? 0 : tsize);\n\t\t\t\t\ttickVector.y = -1;\n\t\t\t\t\tanchorOffset.y = -anchorOffset.y;\n\t\t\t\t\tswitch(labelAlign){\n\t\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\t\tlabelAlign = \"end\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\tlabelAlign = \"start\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\t\tlabelOffset.y -= size;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// render shapes\n\n\t\t\tthis.cleanGroup();\n\n\t\t\tvar s = this.group,\n\t\t\t\tc = this.scaler,\n\t\t\t\tt = this.ticks,\n\t\t\t\tf = lin.getTransformerFromModel(this.scaler),\n\t\t\t\t// GFX Canvas now supports labels, so let's _not_ fallback to HTML anymore on canvas, just use\n\t\t\t\t// HTML labels if explicitly asked + no rotation + no IE + no Opera\n\t\t\t\tlabelType = (!o.title || !titleRotation) && !rotation && this.opt.htmlLabels && !has(\"ie\") && !has(\"opera\") ? \"html\" : \"gfx\",\n\t\t\t\tdx = tickVector.x * taMajorTick.length,\n\t\t\t\tdy = tickVector.y * taMajorTick.length,\n\t\t\t\tskip = this._skipInterval;\n\n\t\t\ts.createLine({\n\t\t\t\tx1: start.x,\n\t\t\t\ty1: start.y,\n\t\t\t\tx2: stop.x,\n\t\t\t\ty2: stop.y\n\t\t\t}).setStroke(taStroke);\n\n\t\t\t//create axis title\n\t\t\tif(o.title){\n\t\t\t\tvar axisTitle = acommon.createText[labelType](\n\t\t\t\t\tthis.chart,\n\t\t\t\t\ts,\n\t\t\t\t\ttitlePos.x,\n\t\t\t\t\ttitlePos.y,\n\t\t\t\t\t\"middle\",\n\t\t\t\t\to.title,\n\t\t\t\t\ttaTitleFont,\n\t\t\t\t\ttaTitleFontColor\n\t\t\t\t);\n\t\t\t\tif(labelType == \"html\"){\n\t\t\t\t\tthis.htmlElements.push(axisTitle);\n\t\t\t\t}else{\n\t\t\t\t\t//as soon as rotation is provided, labelType won't be \"html\"\n\t\t\t\t\t//rotate gfx labels\n\t\t\t\t\taxisTitle.setTransform(g.matrix.rotategAt(titleRotation, titlePos.x, titlePos.y));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// go out nicely instead of try/catch\n\t\t\tif(t == null){\n\t\t\t\tthis.dirty = false;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar rel = (t.major.length > 0)?(t.major[0].value - this._majorStart) / c.major.tick:0;\n\t\t\tvar canLabel = this.opt.majorLabels;\n\t\t\tarr.forEach(t.major, function(tick, i){\n\t\t\t\tvar offset = f(tick.value), elem,\n\t\t\t\t\tx = (isRtl ? stop.x : start.x) + axisVector.x * offset, // chart mirroring\n\t\t\t\t\ty = start.y + axisVector.y * offset;\n\t\t\t\ti += rel;\n\t\t\t\tthis.createLine(s, {\n\t\t\t\t\tx1: x, y1: y,\n\t\t\t\t\tx2: x + dx,\n\t\t\t\t\ty2: y + dy\n\t\t\t\t}).setStroke(taMajorTick);\n\t\t\t\tif(tick.label && (!skip || (i - (1 + skip)) % (1 + skip) == 0)){\n\t\t\t\t\tvar label = o.maxLabelCharCount ? this.getTextWithLimitCharCount(tick.label, taFont, o.maxLabelCharCount) : {\n\t\t\t\t\t\ttext: tick.label,\n\t\t\t\t\t\ttruncated: false\n\t\t\t\t\t};\n\t\t\t\t\tlabel = o.maxLabelSize ? this.getTextWithLimitLength(label.text, taFont, o.maxLabelSize, label.truncated) : label;\n\t\t\t\t\telem = this.createText(labelType,\n\t\t\t\t\t\ts,\n\t\t\t\t\t\tx + (taMajorTick.length > 0 ? dx : 0) + anchorOffset.x + (rotation ? 0 : labelOffset.x),\n\t\t\t\t\t\ty + (taMajorTick.length > 0 ? dy : 0) + anchorOffset.y + (rotation ? 0 : labelOffset.y),\n\t\t\t\t\t\tlabelAlign,\n\t\t\t\t\t\tlabel.text,\n\t\t\t\t\t\ttaFont,\n\t\t\t\t\t\ttaFontColor\n\t\t\t\t\t\t//cachedLabelW\n\t\t\t\t\t);\n\t\t\t\t\t// if bidi support was required, the textDir is \"auto\" and truncation\n\t\t\t\t\t// took place, we need to update the dir of the element for cases as:\n\t\t\t\t\t// Fool label: 111111W (W for bidi character)\n\t\t\t\t\t// truncated label: 11...\n\t\t\t\t\t// in this case for auto textDir the dir will be \"ltr\" which is wrong.\n\t\t\t\t\tif(label.truncated){\n\t\t\t\t\t\tthis.chart.formatTruncatedLabel(elem, tick.label, labelType);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.truncated && this.labelTooltip(elem, this.chart, tick.label, label.text, taFont, labelType);\n\t\t\t\t\tif(labelType == \"html\"){\n\t\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t\t}else if(rotation){\n\t\t\t\t\t\telem.setTransform([\n\t\t\t\t\t\t\t{dx: labelOffset.x, dy: labelOffset.y},\n\t\t\t\t\t\t\tg.matrix.rotategAt(\n\t\t\t\t\t\t\t\trotation,\n\t\t\t\t\t\t\t\tx + (taMajorTick.length > 0 ? dx : 0) + anchorOffset.x,\n\t\t\t\t\t\t\t\ty + (taMajorTick.length > 0 ? dy : 0) + anchorOffset.y\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tdx = tickVector.x * taMinorTick.length;\n\t\t\tdy = tickVector.y * taMinorTick.length;\n\t\t\tcanLabel = this.opt.minorLabels && c.minMinorStep <= c.minor.tick * c.bounds.scale;\n\t\t\tarr.forEach(t.minor, function(tick){\n\t\t\t\tvar offset = f(tick.value), elem,\n\t\t\t\t\tx = (isRtl ? stop.x : start.x)  + axisVector.x * offset,\n\t\t\t\t\ty = start.y + axisVector.y * offset; // chart mirroring\n\t\t\t\tthis.createLine(s, {\n\t\t\t\t\tx1: x, y1: y,\n\t\t\t\t\tx2: x + dx,\n\t\t\t\t\ty2: y + dy\n\t\t\t\t}).setStroke(taMinorTick);\n\t\t\t\tif(canLabel && tick.label){\n\t\t\t\t\tvar label = o.maxLabelCharCount ? this.getTextWithLimitCharCount(tick.label, taFont, o.maxLabelCharCount) : {\n\t\t\t\t\t\ttext: tick.label,\n\t\t\t\t\t\ttruncated: false\n\t\t\t\t\t};\n\t\t\t\t\tlabel = o.maxLabelSize ? this.getTextWithLimitLength(label.text, taFont, o.maxLabelSize, label.truncated) : label;\n\t\t\t\t\telem = this.createText(labelType,\n\t\t\t\t\t\ts,\n\t\t\t\t\t\tx + (taMinorTick.length > 0 ? dx : 0) + anchorOffset.x + (rotation ? 0 : labelOffset.x),\n\t\t\t\t\t\ty + (taMinorTick.length  > 0 ? dy : 0) + anchorOffset.y + (rotation ? 0 : labelOffset.y),\n\t\t\t\t\t\tlabelAlign,\n\t\t\t\t\t\tlabel.text,\n\t\t\t\t\t\ttaFont,\n\t\t\t\t\t\ttaFontColor\n\t\t\t\t\t\t//cachedLabelW\n\t\t\t\t\t);\n\t\t\t\t\t// if bidi support was required, the textDir is \"auto\" and truncation\n\t\t\t\t\t// took place, we need to update the dir of the element for cases as:\n\t\t\t\t\t// Fool label: 111111W (W for bidi character)\n\t\t\t\t\t// truncated label: 11...\n\t\t\t\t\t// in this case for auto textDir the dir will be \"ltr\" which is wrong.\n\t\t\t\t\tif(label.truncated){\n\t\t\t\t\t\tthis.chart.formatTruncatedLabel(elem, tick.label, labelType);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.truncated && this.labelTooltip(elem, this.chart, tick.label, label.text, taFont, labelType);\n\t\t\t\t\tif(labelType == \"html\"){\n\t\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t\t}else if(rotation){\n\t\t\t\t\t\telem.setTransform([\n\t\t\t\t\t\t\t{dx: labelOffset.x, dy: labelOffset.y},\n\t\t\t\t\t\t\tg.matrix.rotategAt(\n\t\t\t\t\t\t\t\trotation,\n\t\t\t\t\t\t\t\tx + (taMinorTick.length > 0 ? dx : 0) + anchorOffset.x,\n\t\t\t\t\t\t\t\ty + (taMinorTick.length > 0 ? dy : 0) + anchorOffset.y\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tdx = tickVector.x * taMicroTick.length;\n\t\t\tdy = tickVector.y * taMicroTick.length;\n\t\t\tarr.forEach(t.micro, function(tick){\n\t\t\t\tvar offset = f(tick.value),\n\t\t\t\t\tx = start.x + axisVector.x * offset,\n\t\t\t\t\ty = start.y + axisVector.y * offset;\n\t\t\t\t\tthis.createLine(s, {\n\t\t\t\t\t\tx1: x, y1: y,\n\t\t\t\t\t\tx2: x + dx,\n\t\t\t\t\t\ty2: y + dy\n\t\t\t\t\t}).setStroke(taMicroTick);\n\t\t\t}, this);\n\n\t\t\tthis.dirty = false;\n\t\t\treturn this;\t//\tdojox/charting/axis2d/Default\n\t\t},\n\t\tlabelTooltip: function(elem, chart, label, truncatedLabel, font, elemType){\n\t\t\tvar modules = [\"dijit/Tooltip\"];\n\t\t\tvar aroundRect = {type: \"rect\"}, position = [\"above\", \"below\"],\n\t\t\t\tfontWidth = g._base._getTextBox(truncatedLabel, {font: font}).w || 0,\n\t\t\t\tfontHeight = font ? g.normalizedLength(g.splitFontString(font).size) : 0;\n\t\t\tif(elemType == \"html\"){\n\t\t\t\tlang.mixin(aroundRect, domGeom.position(elem.firstChild, true));\n\t\t\t\taroundRect.width = Math.ceil(fontWidth);\n\t\t\t\taroundRect.height = Math.ceil(fontHeight);\n\t\t\t\tthis._events.push({\n\t\t\t\t\tshape:  dojo,\n\t\t\t\t\thandle: connect.connect(elem.firstChild, \"onmouseover\", this, function(e){\n\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\tTooltip.show(label, aroundRect, position);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tthis._events.push({\n\t\t\t\t\tshape:  dojo,\n\t\t\t\t\thandle: connect.connect(elem.firstChild, \"onmouseout\", this, function(e){\n\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\tTooltip.hide(aroundRect);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\tvar shp = elem.getShape(),\n\t\t\t\t\tlt = chart.getCoords();\n\t\t\t\taroundRect = lang.mixin(aroundRect, {\n\t\t\t\t\tx: shp.x - fontWidth / 2,\n\t\t\t\t\ty: shp.y\n\t\t\t\t});\n\t\t\t\taroundRect.x += lt.x;\n\t\t\t\taroundRect.y += lt.y;\n\t\t\t\taroundRect.x = Math.round(aroundRect.x);\n\t\t\t\taroundRect.y = Math.round(aroundRect.y);\n\t\t\t\taroundRect.width = Math.ceil(fontWidth);\n\t\t\t\taroundRect.height = Math.ceil(fontHeight);\n\t\t\t\tthis._events.push({\n\t\t\t\t\tshape:  elem,\n\t\t\t\t\thandle: elem.connect(\"onmouseenter\", this, function(e){\n\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\tTooltip.show(label, aroundRect, position);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tthis._events.push({\n\t\t\t\t\tshape:  elem,\n\t\t\t\t\thandle: elem.connect(\"onmouseleave\", this, function(e){\n\t\t\t\t\t\trequire(modules, function(Tooltip){\n\t\t\t\t\t\t\tTooltip.hide(aroundRect);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t_isRtl: function(){\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn has(\"dojo-bidi\")? declare(\"dojox.charting.axis2d.Default\", [Default, BidiDefault]) : Default;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/axis2d/Default.js\n// module id = 202\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"./Base\", \"../scaler/linear\",\n\t\"dojox/lang/utils\"],\n\tfunction(lang, declare, Base, lin, du){\n\n/*=====\n\tvar __InvisibleAxisCtorArgs = {\n\t\t// summary:\n\t\t//\t\tOptional arguments used in the definition of an invisible axis.\n\t\t// vertical: Boolean?\n\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t// fixUpper: String?\n\t\t//\t\tAlign the greatest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t// fixLower: String?\n\t\t//\t\tAlign the smallest value on the axis with the specified tick level. Options are \"major\", \"minor\", \"micro\", or \"none\".  Defaults to \"none\".\n\t\t// natural: Boolean?\n\t\t//\t\tEnsure tick marks are made on \"natural\" numbers. Defaults to false.\n\t\t// leftBottom: Boolean?\n\t\t//\t\tThe position of a vertical axis; if true, will be placed against the left-bottom corner of the chart.  Defaults to true.\n\t\t// includeZero: Boolean?\n\t\t//\t\tInclude 0 on the axis rendering.  Default is false.\n\t\t// fixed: Boolean?\n\t\t//\t\tForce all axis labels to be fixed numbers.  Default is true.\n\t\t// min: Number?\n\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t// max: Number?\n\t\t//\t\tThe largest value on an axis. Default is 1.\n\t\t// from: Number?\n\t\t//\t\tForce the chart to render data visible from this value. Default is 0.\n\t\t// to: Number?\n\t\t//\t\tForce the chart to render data visible to this value. Default is 1.\n\t\t// majorTickStep: Number?\n\t\t//\t\tThe amount to skip before a major tick is drawn. When not set the major ticks step is computed from\n\t\t//\t\tthe data range.\n\t\t// minorTickStep: Number?\n\t\t//\t\tThe amount to skip before a minor tick is drawn. When not set the minor ticks step is computed from\n\t\t//\t\tthe data range.\n\t\t// microTickStep: Number?\n\t\t//\t\tThe amount to skip before a micro tick is drawn. When not set the micro ticks step is computed from\n\t};\n=====*/\n\n\treturn declare(\"dojox.charting.axis2d.Invisible\", Base, {\n\t\t// summary:\n\t\t//\t\tA axis object used in dojox.charting.  You can use that axis if you want the axis to be invisible.\n\t\t//\t\tSee dojox.charting.Chart.addAxis for details.\n\t\t//\n\t\t// defaultParams: Object\n\t\t//\t\tThe default parameters used to define any axis.\n\t\t// optionalParams: Object\n\t\t//\t\tAny optional parameters needed to define an axis.\n\n\t\t/*\n\t\t// TODO: the documentation tools need these to be pre-defined in order to pick them up\n\t\t//\tcorrectly, but the code here is partially predicated on whether or not the properties\n\t\t//\tactually exist.  For now, we will leave these undocumented but in the code for later. -- TRT\n\n\t\t// opt: Object\n\t\t//\t\tThe actual options used to define this axis, created at initialization.\n\t\t// scaler: Object\n\t\t//\t\tThe calculated helper object to tell charts how to draw an axis and any data.\n\t\t// ticks: Object\n\t\t//\t\tThe calculated tick object that helps a chart draw the scaling on an axis.\n\t\t// dirty: Boolean\n\t\t//\t\tThe state of the axis (whether it needs to be redrawn or not)\n\t\t// scale: Number\n\t\t//\t\tThe current scale of the axis.\n\t\t// offset: Number\n\t\t//\t\tThe current offset of the axis.\n\n\t\topt: null,\n\t\tscaler: null,\n\t\tticks: null,\n\t\tdirty: true,\n\t\tscale: 1,\n\t\toffset: 0,\n\t\t*/\n\t\tdefaultParams: {\n\t\t\tvertical:    false,\t\t// true for vertical axis\n\t\t\tfixUpper:    \"none\",\t// align the upper on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\tfixLower:    \"none\",\t// align the lower on ticks: \"major\", \"minor\", \"micro\", \"none\"\n\t\t\tnatural:     false,\t\t// all tick marks should be made on natural numbers\n\t\t\tleftBottom:  true,\t\t// position of the axis, used with \"vertical\"\n\t\t\tincludeZero: false,\t\t// 0 should be included\n\t\t\tfixed:       true\t\t// all labels are fixed numbers\n\t\t},\n\t\toptionalParams: {\n\t\t\tmin:\t\t\t0,\t// minimal value on this axis\n\t\t\tmax:\t\t\t1,\t// maximal value on this axis\n\t\t\tfrom:\t\t\t0,\t// visible from this value\n\t\t\tto:\t\t\t\t1,\t// visible to this value\n\t\t\tmajorTickStep:\t4,\t// major tick step\n\t\t\tminorTickStep:\t2,\t// minor tick step\n\t\t\tmicroTickStep:\t1\t// micro tick step\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for an invisible axis.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart the axis belongs to.\n\t\t\t// kwArgs: __InvisibleAxisCtorArgs?\n\t\t\t//\t\tAny optional keyword arguments to be used to define this axis.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n            du.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t},\n\t\tdependOnData: function(){\n\t\t\t// summary:\n\t\t\t//\t\tFind out whether or not the axis options depend on the data in the axis.\n\t\t\treturn !(\"min\" in this.opt) || !(\"max\" in this.opt);\t//\tBoolean\n\t\t},\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear out all calculated properties on this axis;\n\t\t\t// returns: dojox/charting/axis2d/Invisible\n\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\tdelete this.scaler;\n\t\t\tdelete this.ticks;\n\t\t\tthis.dirty = true;\n\t\t\treturn this;\t//\tdojox/charting/axis2d/Invisible\n\t\t},\n\t\tinitialized: function(){\n\t\t\t// summary:\n\t\t\t//\t\tFinds out if this axis has been initialized or not.\n\t\t\t// returns: Boolean\n\t\t\t//\t\tWhether a scaler has been calculated and if the axis is not dirty.\n\t\t\treturn \"scaler\" in this && !(this.dirty && this.dependOnData());\n\t\t},\n\t\tsetWindow: function(scale, offset){\n\t\t\t// summary:\n\t\t\t//\t\tSet the drawing \"window\" for the axis.\n\t\t\t// scale: Number\n\t\t\t//\t\tThe new scale for the axis.\n\t\t\t// offset: Number\n\t\t\t//\t\tThe new offset for the axis.\n\t\t\t// returns: dojox/charting/axis2d/Invisible\n\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\tthis.scale  = scale;\n\t\t\tthis.offset = offset;\n\t\t\treturn this.clear();\t//\tdojox/charting/axis2d/Invisible\n\t\t},\n\t\tgetWindowScale: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet the current windowing scale of the axis.\n\t\t\treturn \"scale\" in this ? this.scale : 1;\t//\tNumber\n\t\t},\n\t\tgetWindowOffset: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet the current windowing offset for the axis.\n\t\t\treturn \"offset\" in this ? this.offset : 0;\t//\tNumber\n\t\t},\n\t\tcalculate: function(min, max, span, scalerType){\n\t\t\t// summary:\n\t\t\t//\t\tPerform all calculations needed to render this axis.\n\t\t\t// min: Number\n\t\t\t//\t\tThe smallest value represented on this axis.\n\t\t\t// max: Number\n\t\t\t//\t\tThe largest value represented on this axis.\n\t\t\t// span: Number\n\t\t\t//\t\tThe span in pixels over which axis calculations are made.\n\t\t\t// scalerType: Object\n\t\t\t//\t\tAn optional scaler type object.\n\t\t\t// returns: dojox/charting/axis2d/Invisible\n\t\t\t//\t\tThe reference to the axis for functional chaining.\n\t\t\tif(this.initialized()){\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tvar o = this.opt;\n\t\t\t// we used to have a 4th function parameter to reach labels but\n\t\t\t// nobody was calling it with 4 parameters.\n\t\t\tthis.labels = o.labels;\n\t\t\tthis.scaler = (scalerType || lin).buildScaler(min, max, span, o);\n\t\t\t// store the absolute major tick start, this will be useful when dropping a label every n labels\n\t\t\t// TODO: if o.lower then it does not work\n\t\t\tvar tsb = this.scaler.bounds;\n\t\t\tif(\"scale\" in this){\n\t\t\t\t// calculate new range\n\t\t\t\to.from = tsb.lower + this.offset;\n\t\t\t\to.to   = (tsb.upper - tsb.lower) / this.scale + o.from;\n\t\t\t\t// make sure that bounds are correct\n\t\t\t\tif( !isFinite(o.from) ||\n\t\t\t\t\tisNaN(o.from) ||\n\t\t\t\t\t!isFinite(o.to) ||\n\t\t\t\t\tisNaN(o.to) ||\n\t\t\t\t\to.to - o.from >= tsb.upper - tsb.lower\n\t\t\t\t){\n\t\t\t\t\t// any error --- remove from/to bounds\n\t\t\t\t\tdelete o.from;\n\t\t\t\t\tdelete o.to;\n\t\t\t\t\tdelete this.scale;\n\t\t\t\t\tdelete this.offset;\n\t\t\t\t}else{\n\t\t\t\t\t// shift the window, if we are out of bounds\n\t\t\t\t\tif(o.from < tsb.lower){\n\t\t\t\t\t\to.to += tsb.lower - o.from;\n\t\t\t\t\t\to.from = tsb.lower;\n\t\t\t\t\t}else if(o.to > tsb.upper){\n\t\t\t\t\t\to.from += tsb.upper - o.to;\n\t\t\t\t\t\to.to = tsb.upper;\n\t\t\t\t\t}\n\t\t\t\t\t// update the offset\n\t\t\t\t\tthis.offset = o.from - tsb.lower;\n\t\t\t\t}\n\t\t\t\t// re-calculate the scaler\n\t\t\t\tthis.scaler = (scalerType || lin).buildScaler(min, max, span, o);\n\t\t\t\ttsb = this.scaler.bounds;\n\t\t\t\t// cleanup\n\t\t\t\tif(this.scale == 1 && this.offset == 0){\n\t\t\t\t\tdelete this.scale;\n\t\t\t\t\tdelete this.offset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/axis2d/Invisible\n\t\t},\n\t\tgetScaler: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet the pre-calculated scaler object.\n\t\t\treturn this.scaler;\t//\tObject\n\t\t},\n\t\tgetTicks: function(){\n\t\t\t// summary:\n\t\t\t//\t\tGet the pre-calculated ticks object.\n\t\t\treturn this.ticks;\t//\tObject\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/axis2d/Invisible.js\n// module id = 203\n// module chunks = 4","define([\"dojo/_base/declare\", \"../Element\"],\n\tfunction(declare, Element){\n\t/*=====\n\tvar __BaseAxisCtorArgs = {\n\t\t// summary:\n\t\t//\t\tOptional arguments used in the definition of an invisible axis.\n\t\t// vertical: Boolean?\n\t\t//\t\tA flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).\n\t\t// min: Number?\n\t\t//\t\tThe smallest value on an axis. Default is 0.\n\t\t// max: Number?\n\t\t//\t\tThe largest value on an axis. Default is 1.\n\t};\n\t=====*/\n\treturn declare(\"dojox.charting.axis2d.Base\", Element, {\n\t\t// summary:\n\t\t//\t\tThe base class for any axis.  This is more of an interface/API\n\t\t//\t\tdefinition than anything else; see dojox.charting.axis2d.Default\n\t\t//\t\tfor more details.\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tReturn a new base axis.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this axis belongs to.\n\t\t\t// kwArgs: __BaseAxisCtorArgs?\n\t\t\t//\t\tAn optional arguments object to define the axis parameters.\n\t\t\tthis.vertical = kwArgs && kwArgs.vertical;\n\t\t\tthis.opt = {};\n\t\t\tthis.opt.min = kwArgs && kwArgs.min;\n\t\t\tthis.opt.max = kwArgs && kwArgs.max;\n\t\t},\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tStub function for clearing the axis.\n\t\t\t// returns: dojox/charting/axis2d/Base\n\t\t\t//\t\tA reference to the axis for functional chaining.\n\t\t\treturn this;\t//\tdojox/charting/axis2d/Base\n\t\t},\n\t\tinitialized: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturn a flag as to whether or not this axis has been initialized.\n\t\t\t// returns: Boolean\n\t\t\t//\t\tIf the axis is initialized or not.\n\t\t\treturn false;\t//\tBoolean\n\t\t},\n\t\tcalculate: function(min, max, span){\n\t\t\t// summary:\n\t\t\t//\t\tStub function to run the calculations needed for drawing this axis.\n\t\t\t// returns: dojox/charting/axis2d/Base\n\t\t\t//\t\tA reference to the axis for functional chaining.\n\t\t\treturn this;\t//\tdojox/charting/axis2d/Base\n\t\t},\n\t\tgetScaler: function(){\n\t\t\t// summary:\n\t\t\t//\t\tA stub function to return the scaler object created during calculate.\n\t\t\t// returns: Object\n\t\t\t//\t\tThe scaler object (see dojox.charting.scaler.linear for more information)\n\t\t\treturn null;\t//\tObject\n\t\t},\n\t\tgetTicks: function(){\n\t\t\t// summary:\n\t\t\t//\t\tA stub function to return the object that helps define how ticks are rendered.\n\t\t\t// returns: Object\n\t\t\t//\t\tThe ticks object.\n\t\t\treturn null;\t//\tObject\n\t\t},\n\t\tgetOffsets: function(){\n\t\t\t// summary:\n\t\t\t//\t\tA stub function to return any offsets needed for axis and series rendering.\n\t\t\t// returns: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\treturn {l: 0, r: 0, t: 0, b: 0};\t//\tObject\n\t\t},\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tStub function to render this axis.\n\t\t\t// returns: dojox/charting/axis2d/Base\n\t\t\t//\t\tA reference to the axis for functional chaining.\n\t\t\tthis.dirty = false;\n\t\t\treturn this;\t//\tdojox/charting/axis2d/Base\n\t\t},\n\t\tisNullValue: function(value){\n\t\t\t// summary:\n\t\t\t//\t\tA stub function to determine a data value\n\t\t\t//\t\tthat should be ignored.\n\t\t\t// value: Number|Null|Object\n\t\t\t//\t\tA data value to be inspected.\n\t\t\t// returns: Boolean\n\t\t\t//\t\tIf the value makes sense for this axis or not.\n\t\t\treturn false;\n\t\t},\n\t\tnaturalBaseline: 0\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/axis2d/Base.js\n// module id = 204\n// module chunks = 4","define([\"dojo/_base/lang\", \"./common\"], \n\tfunction(lang, common){\n\tvar linear = lang.getObject(\"dojox.charting.scaler.linear\", true);\n\t\n\tvar deltaLimit = 3,\t// pixels\n\t\tgetLabel = common.getNumericLabel;\n\n\t\tfunction findString(/*String*/ val, /*Array*/ text){\n\t\t\tval = val.toLowerCase();\n\t\t\tfor(var i = text.length - 1; i >= 0; --i){\n\t\t\t\tif(val === text[i]){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\tvar calcTicks = function(min, max, kwArgs, majorTick, minorTick, microTick, span){\n\t\tkwArgs = lang.delegate(kwArgs);\n\t\tif(!majorTick){\n\t\t\tif(kwArgs.fixUpper == \"major\"){ kwArgs.fixUpper = \"minor\"; }\n\t\t\tif(kwArgs.fixLower == \"major\"){ kwArgs.fixLower = \"minor\"; }\n\t\t}\n\t\tif(!minorTick){\n\t\t\tif(kwArgs.fixUpper == \"minor\"){ kwArgs.fixUpper = \"micro\"; }\n\t\t\tif(kwArgs.fixLower == \"minor\"){ kwArgs.fixLower = \"micro\"; }\n\t\t}\n\t\tif(!microTick){\n\t\t\tif(kwArgs.fixUpper == \"micro\"){ kwArgs.fixUpper = \"none\"; }\n\t\t\tif(kwArgs.fixLower == \"micro\"){ kwArgs.fixLower = \"none\"; }\n\t\t}\n\t\tvar lowerBound = findString(kwArgs.fixLower, [\"major\"]) ?\n\t\t\t\tMath.floor(kwArgs.min / majorTick) * majorTick :\n\t\t\t\t\tfindString(kwArgs.fixLower, [\"minor\"]) ?\n\t\t\t\t\t\tMath.floor(kwArgs.min / minorTick) * minorTick :\n\t\t\t\t\t\t\tfindString(kwArgs.fixLower, [\"micro\"]) ?\n\t\t\t\t\t\t\t\tMath.floor(kwArgs.min / microTick) * microTick : kwArgs.min,\n\t\t\tupperBound = findString(kwArgs.fixUpper, [\"major\"]) ?\n\t\t\t\tMath.ceil(kwArgs.max / majorTick) * majorTick :\n\t\t\t\t\tfindString(kwArgs.fixUpper, [\"minor\"]) ?\n\t\t\t\t\t\tMath.ceil(kwArgs.max / minorTick) * minorTick :\n\t\t\t\t\t\t\tfindString(kwArgs.fixUpper, [\"micro\"]) ?\n\t\t\t\t\t\t\t\tMath.ceil(kwArgs.max / microTick) * microTick : kwArgs.max;\n\t\t\t\t\t\t\t\t\n\t\tif(kwArgs.useMin){ min = lowerBound; }\n\t\tif(kwArgs.useMax){ max = upperBound; }\n\t\t\n\t\tvar majorStart = (!majorTick || kwArgs.useMin && findString(kwArgs.fixLower, [\"major\"])) ?\n\t\t\t\tmin : Math.ceil(min / majorTick) * majorTick,\n\t\t\tminorStart = (!minorTick || kwArgs.useMin && findString(kwArgs.fixLower, [\"major\", \"minor\"])) ?\n\t\t\t\tmin : Math.ceil(min / minorTick) * minorTick,\n\t\t\tmicroStart = (! microTick || kwArgs.useMin && findString(kwArgs.fixLower, [\"major\", \"minor\", \"micro\"])) ?\n\t\t\t\tmin : Math.ceil(min / microTick) * microTick,\n\t\t\tmajorCount = !majorTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, [\"major\"]) ?\n\t\t\t\tMath.round((max - majorStart) / majorTick) :\n\t\t\t\tMath.floor((max - majorStart) / majorTick)) + 1,\n\t\t\tminorCount = !minorTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, [\"major\", \"minor\"]) ?\n\t\t\t\tMath.round((max - minorStart) / minorTick) :\n\t\t\t\tMath.floor((max - minorStart) / minorTick)) + 1,\n\t\t\tmicroCount = !microTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, [\"major\", \"minor\", \"micro\"]) ?\n\t\t\t\tMath.round((max - microStart) / microTick) :\n\t\t\t\tMath.floor((max - microStart) / microTick)) + 1,\n\t\t\tminorPerMajor  = minorTick ? Math.round(majorTick / minorTick) : 0,\n\t\t\tmicroPerMinor  = microTick ? Math.round(minorTick / microTick) : 0,\n\t\t\tmajorPrecision = majorTick ? Math.floor(Math.log(majorTick) / Math.LN10) : 0,\n\t\t\tminorPrecision = minorTick ? Math.floor(Math.log(minorTick) / Math.LN10) : 0,\n\t\t\tscale = span / (max - min);\n\t\tif(!isFinite(scale)){ scale = 1; }\n\t\t\n\t\treturn {\n\t\t\tbounds: {\n\t\t\t\tlower:\tlowerBound,\n\t\t\t\tupper:\tupperBound,\n\t\t\t\tfrom:\tmin,\n\t\t\t\tto:\t\tmax,\n\t\t\t\tscale:\tscale,\n\t\t\t\tspan:\tspan\n\t\t\t},\n\t\t\tmajor: {\n\t\t\t\ttick:\tmajorTick,\n\t\t\t\tstart:\tmajorStart,\n\t\t\t\tcount:\tmajorCount,\n\t\t\t\tprec:\tmajorPrecision\n\t\t\t},\n\t\t\tminor: {\n\t\t\t\ttick:\tminorTick,\n\t\t\t\tstart:\tminorStart,\n\t\t\t\tcount:\tminorCount,\n\t\t\t\tprec:\tminorPrecision\n\t\t\t},\n\t\t\tmicro: {\n\t\t\t\ttick:\tmicroTick,\n\t\t\t\tstart:\tmicroStart,\n\t\t\t\tcount:\tmicroCount,\n\t\t\t\tprec:\t0\n\t\t\t},\n\t\t\tminorPerMajor:\tminorPerMajor,\n\t\t\tmicroPerMinor:\tmicroPerMinor,\n\t\t\tscaler:\t\t\tlinear\n\t\t};\n\t};\n\t\n\treturn lang.mixin(linear, {\n\t\tbuildScaler: function(/*Number*/ min, /*Number*/ max, /*Number*/ span, /*Object*/ kwArgs, /*Number?*/ delta, /*Number?*/ minorDelta){\n\t\t\tvar h = {fixUpper: \"none\", fixLower: \"none\", natural: false};\n\t\t\tif(kwArgs){\n\t\t\t\tif(\"fixUpper\" in kwArgs){ h.fixUpper = String(kwArgs.fixUpper); }\n\t\t\t\tif(\"fixLower\" in kwArgs){ h.fixLower = String(kwArgs.fixLower); }\n\t\t\t\tif(\"natural\"  in kwArgs){ h.natural  = Boolean(kwArgs.natural); }\n\t\t\t}\n\t\t\tminorDelta = !minorDelta || minorDelta < deltaLimit ? deltaLimit : minorDelta;\n\t\t\t\n\t\t\t// update bounds\n\t\t\tif(\"min\" in kwArgs){ min = kwArgs.min; }\n\t\t\tif(\"max\" in kwArgs){ max = kwArgs.max; }\n\t\t\tif(kwArgs.includeZero){\n\t\t\t\tif(min > 0){ min = 0; }\n\t\t\t\tif(max < 0){ max = 0; }\n\t\t\t}\n\t\t\th.min = min;\n\t\t\th.useMin = true;\n\t\t\th.max = max;\n\t\t\th.useMax = true;\n\t\t\t\n\t\t\tif(\"from\" in kwArgs){\n\t\t\t\tmin = kwArgs.from;\n\t\t\t\th.useMin = false;\n\t\t\t}\n\t\t\tif(\"to\" in kwArgs){\n\t\t\t\tmax = kwArgs.to;\n\t\t\t\th.useMax = false;\n\t\t\t}\n\t\t\t\n\t\t\t// check for erroneous condition\n\t\t\tif(max <= min){\n\t\t\t\treturn calcTicks(min, max, h, 0, 0, 0, span);\t// Object\n\t\t\t}\n\t\t\tif(!delta){\n\t\t\t\tdelta = max - min;\n\t\t\t}\n\t\t\tvar mag = Math.floor(Math.log(delta) / Math.LN10),\n\t\t\t\tmajor = kwArgs && (\"majorTickStep\" in kwArgs) ? kwArgs.majorTickStep : Math.pow(10, mag),\n\t\t\t\tminor = 0, micro = 0, ticks;\n\t\t\t\t\n\t\t\t// calculate minor ticks\n\t\t\tif(kwArgs && (\"minorTickStep\" in kwArgs)){\n\t\t\t\tminor = kwArgs.minorTickStep;\n\t\t\t}else{\n\t\t\t\tdo{\n\t\t\t\t\tminor = major / 10;\n\t\t\t\t\tif(!h.natural || minor > 0.9){\n\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, 0, span);\n\t\t\t\t\t\tif(ticks.bounds.scale * ticks.minor.tick > minorDelta){ break; }\n\t\t\t\t\t}\n\t\t\t\t\tminor = major / 5;\n\t\t\t\t\tif(!h.natural || minor > 0.9){\n\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, 0, span);\n\t\t\t\t\t\tif(ticks.bounds.scale * ticks.minor.tick > minorDelta){ break; }\n\t\t\t\t\t}\n\t\t\t\t\tminor = major / 2;\n\t\t\t\t\tif(!h.natural || minor > 0.9){\n\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, 0, span);\n\t\t\t\t\t\tif(ticks.bounds.scale * ticks.minor.tick > minorDelta){ break; }\n\t\t\t\t\t}\n\t\t\t\t\treturn calcTicks(min, max, h, major, 0, 0, span);\t// Object\n\t\t\t\t}while(false);\n\t\t\t}\n\t\n\t\t\t// calculate micro ticks\n\t\t\tif(kwArgs && (\"microTickStep\" in kwArgs)){\n\t\t\t\tmicro = kwArgs.microTickStep;\n\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t}else{\n\t\t\t\tdo{\n\t\t\t\t\tmicro = minor / 10;\n\t\t\t\t\tif(!h.natural || micro > 0.9){\n\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t\t\tif(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }\n\t\t\t\t\t}\n\t\t\t\t\tmicro = minor / 5;\n\t\t\t\t\tif(!h.natural || micro > 0.9){\n\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t\t\tif(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }\n\t\t\t\t\t}\n\t\t\t\t\tmicro = minor / 2;\n\t\t\t\t\tif(!h.natural || micro > 0.9){\n\t\t\t\t\t\tticks = calcTicks(min, max, h, major, minor, micro, span);\n\t\t\t\t\t\tif(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }\n\t\t\t\t\t}\n\t\t\t\t\tmicro = 0;\n\t\t\t\t}while(false);\n\t\t\t}\n\t\n\t\t\treturn micro ? ticks : calcTicks(min, max, h, major, minor, 0, span);\t// Object\n\t\t},\n\t\tbuildTicks: function(/*Object*/ scaler, /*Object*/ kwArgs){\n\t\t\tvar step, next, tick,\n\t\t\t\tnextMajor = scaler.major.start,\n\t\t\t\tnextMinor = scaler.minor.start,\n\t\t\t\tnextMicro = scaler.micro.start;\n\t\t\tif(kwArgs.microTicks && scaler.micro.tick){\n\t\t\t\tstep = scaler.micro.tick, next = nextMicro;\n\t\t\t}else if(kwArgs.minorTicks && scaler.minor.tick){\n\t\t\t\tstep = scaler.minor.tick, next = nextMinor;\n\t\t\t}else if(scaler.major.tick){\n\t\t\t\tstep = scaler.major.tick, next = nextMajor;\n\t\t\t}else{\n\t\t\t\t// no ticks\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// make sure that we have finite bounds\n\t\t\tvar revScale = 1 / scaler.bounds.scale;\n\t\t\tif(scaler.bounds.to <= scaler.bounds.from || isNaN(revScale) || !isFinite(revScale) ||\n\t\t\t\t\tstep <= 0 || isNaN(step) || !isFinite(step)){\n\t\t\t\t// no ticks\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// loop over all ticks\n\t\t\tvar majorTicks = [], minorTicks = [], microTicks = [];\n\t\t\twhile(next <= scaler.bounds.to + revScale){\n\t\t\t\tif(Math.abs(nextMajor - next) < step / 2){\n\t\t\t\t\t// major tick\n\t\t\t\t\ttick = {value: nextMajor};\n\t\t\t\t\tif(kwArgs.majorLabels){\n\t\t\t\t\t\ttick.label = getLabel(nextMajor, scaler.major.prec, kwArgs);\n\t\t\t\t\t}\n\t\t\t\t\tmajorTicks.push(tick);\n\t\t\t\t\tnextMajor += scaler.major.tick;\n\t\t\t\t\tnextMinor += scaler.minor.tick;\n\t\t\t\t\tnextMicro += scaler.micro.tick;\n\t\t\t\t}else if(Math.abs(nextMinor - next) < step / 2){\n\t\t\t\t\t// minor tick\n\t\t\t\t\tif(kwArgs.minorTicks){\n\t\t\t\t\t\ttick = {value: nextMinor};\n\t\t\t\t\t\tif(kwArgs.minorLabels && (scaler.minMinorStep <= scaler.minor.tick * scaler.bounds.scale)){\n\t\t\t\t\t\t\ttick.label = getLabel(nextMinor, scaler.minor.prec, kwArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminorTicks.push(tick);\n\t\t\t\t\t}\n\t\t\t\t\tnextMinor += scaler.minor.tick;\n\t\t\t\t\tnextMicro += scaler.micro.tick;\n\t\t\t\t}else{\n\t\t\t\t\t// micro tick\n\t\t\t\t\tif(kwArgs.microTicks){\n\t\t\t\t\t\tmicroTicks.push({value: nextMicro});\n\t\t\t\t\t}\n\t\t\t\t\tnextMicro += scaler.micro.tick;\n\t\t\t\t}\n\t\t\t\tnext += step;\n\t\t\t}\n\t\t\treturn {major: majorTicks, minor: minorTicks, micro: microTicks};\t// Object\n\t\t},\n\t\tgetTransformerFromModel: function(/*Object*/ scaler){\n\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\treturn function(x){ return (x - offset) * scale; };\t// Function\n\t\t},\n\t\tgetTransformerFromPlot: function(/*Object*/ scaler){\n\t\t\tvar offset = scaler.bounds.from, scale = scaler.bounds.scale;\n\t\t\treturn function(x){ return x / scale + offset; };\t// Function\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/scaler/linear.js\n// module id = 205\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/dom-style\"],\n\tfunction(declare, domStyle){\n\t// module:\n\t//\t\tdojox/charting/bidi/axis2d/Default\t\t\t\n\treturn declare(null, {\n\t\tlabelTooltip: function(elem, chart, label, truncatedLabel, font, elemType){\n\t\t\t// additional preprocessing of the labels, needed for rtl base text direction in LTR\n\t\t\t// GUI, or for ltr base text direction for RTL GUI.\n\n\t\t\tvar isChartDirectionRtl = (domStyle.get(chart.node,\"direction\") == \"rtl\");\n\t\t\tvar isBaseTextDirRtl = (chart.getTextDir(label) == \"rtl\");\n\n\t\t\tif(isBaseTextDirRtl && !isChartDirectionRtl){\n\t\t\t\tlabel = \"<span dir='rtl'>\" + label +\"</span>\";\n\t\t\t}\n\t\t\tif(!isBaseTextDirRtl && isChartDirectionRtl){\n\t\t\t\tlabel = \"<span dir='ltr'>\" + label +\"</span>\";\n\t\t\t}\n\t\t\tthis.inherited(arguments);\n\t\t},\n\t\t\n\t\t_isRtl: function(){\n\t\t\treturn this.chart.isRightToLeft();\n\t\t}\n\t});\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/bidi/axis2d/Default.js\n// module id = 206\n// module chunks = 4","define([\"dojo/_base/declare\", \"./Default\"], function(declare, Default){\n\n\treturn declare(\"dojox.charting.plot2d.Lines\", Default, {\n\t\t// summary:\n\t\t//\t\tA convenience constructor to create a typical line chart.\n\t\tconstructor: function(){\n\t\t\t// summary:\n\t\t\t//\t\tPreset our default plot to be line-based.\n\t\t\tthis.opt.lines = true;\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Lines.js\n// module id = 207\n// module chunks = 4","define([\"dojo/_base/declare\", \"./Default\"], \n  function(declare, Default){\n\n\treturn declare(\"dojox.charting.plot2d.Areas\", Default, {\n\t\t// summary:\n\t\t//\t\tRepresents an area chart.  See dojox/charting/plot2d/Default for details.\n\t\tconstructor: function(){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for an Area chart.\n\t\t\tthis.opt.lines = true;\n\t\t\tthis.opt.areas = true;\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Areas.js\n// module id = 208\n// module chunks = 4","define([\"dojo/_base/declare\", \"./Default\"], function(declare, Default){\n\n\treturn declare(\"dojox.charting.plot2d.Markers\", Default, {\n\t\t// summary:\n\t\t//\t\tA convenience plot to draw a line chart with markers.\n\t\tconstructor: function(){\n\t\t\t// summary:\n\t\t\t//\t\tSet up the plot for lines and markers.\n\t\t\tthis.opt.markers = true;\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Markers.js\n// module id = 209\n// module chunks = 4","define([\"dojo/_base/declare\", \"./Default\"], function(declare, Default){\n\n\treturn declare(\"dojox.charting.plot2d.MarkersOnly\", Default, {\n\t\t// summary:\n\t\t//\t\tA convenience object to draw only markers (like a scatter but not quite).\n\t\tconstructor: function(){\n\t\t\t// summary:\n\t\t\t//\t\tSet up our default plot to only have markers and no lines.\n\t\t\tthis.opt.lines   = false;\n\t\t\tthis.opt.markers = true;\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/MarkersOnly.js\n// module id = 210\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/declare\", \"dojo/has\", \"./CartesianBase\", \"./_PlotEvents\", \"./common\",\n\t\"dojox/lang/functional\", \"dojox/lang/functional/reversed\", \"dojox/lang/utils\", \"dojox/gfx/fx\", \"dojox/gfx/gradutils\"],\n\tfunction(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx, gradutils){\n\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\n\treturn declare(\"dojox.charting.plot2d.Scatter\", [CartesianBase, _PlotEvents], {\n\t\t// summary:\n\t\t//\t\tA plot object representing a typical scatter chart.\n\t\tdefaultParams: {\n\t\t\tshadows: null,\t// draw shadows\n\t\t\tanimate: null\t// animate chart to place\n\t\t},\n\t\toptionalParams: {\n\t\t\t// theme component\n\t\t\tmarkerStroke:\t\t{},\n\t\t\tmarkerOutline:\t\t{},\n\t\t\tmarkerShadow:\t\t{},\n\t\t\tmarkerFill:\t\t\t{},\n\t\t\tmarkerFont:\t\t\t\"\",\n\t\t\tmarkerFontColor:\t\"\",\n\t\t\tstyleFunc:\t\t\tnull\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate the scatter plot.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define this plot's parameters.\n\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.animate = this.opt.animate;\n\t\t},\n\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t// returns: dojox/charting/plot2d/Scatter\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tvar s;\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\ts = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\t\t\tvar t = this.chart.theme, events = this.events();\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tif(!run.data.length){\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t\tt.skip();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar theme = t.next(\"marker\", [this.opt, run]), lpoly,\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler);\n\t\t\t\tif(run.hidden){\n\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\trun.dyn.markerFill = theme.marker.fill;\n\t\t\t\t\trun.dyn.markerStroke = theme.marker.stroke;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = run.group;\n\t\t\t\tif(typeof run.data[0] == \"number\"){\n\t\t\t\t\tlpoly = arr.map(run.data, function(v, i){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: ht(i + 1) + offsets.l,\n\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v)\n\t\t\t\t\t\t};\n\t\t\t\t\t}, this);\n\t\t\t\t}else{\n\t\t\t\t\tlpoly = arr.map(run.data, function(v, i){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\n\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y)\n\t\t\t\t\t\t};\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\n\t\t\t\tvar shadowMarkers  = new Array(lpoly.length),\n\t\t\t\t\tfrontMarkers   = new Array(lpoly.length),\n\t\t\t\t\toutlineMarkers = new Array(lpoly.length);\n\n\t\t\t\tarr.forEach(lpoly, function(c, i){\n\t\t\t\t\tvar value = run.data[i], finalTheme;\n\t\t\t\t\tif(this.opt.styleFunc || typeof value != \"number\"){\n\t\t\t\t\t\tvar tMixin = typeof value != \"number\" ? [value] : [];\n\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinalTheme = t.addMixin(theme, \"marker\", tMixin, true);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinalTheme = t.post(theme, \"marker\");\n\t\t\t\t\t}\n\t\t\t\t\tvar path = \"M\" + c.x + \" \" + c.y + \" \" + finalTheme.symbol;\n\t\t\t\t\tif(finalTheme.marker.shadow){\n\t\t\t\t\t\tshadowMarkers[i] = s.createPath(\"M\" + (c.x + finalTheme.marker.shadow.dx) + \" \" +\n\t\t\t\t\t\t\t(c.y + finalTheme.marker.shadow.dy) + \" \" + finalTheme.symbol).\n\t\t\t\t\t\t\tsetStroke(finalTheme.marker.shadow).setFill(finalTheme.marker.shadow.color);\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateScatter(shadowMarkers[i], dim.height - offsets.b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(finalTheme.marker.outline){\n\t\t\t\t\t\tvar outline = dc.makeStroke(finalTheme.marker.outline);\n\t\t\t\t\t\toutline.width = 2 * outline.width + (finalTheme.marker.stroke && finalTheme.marker.stroke.width || 0);\n\t\t\t\t\t\toutlineMarkers[i] = s.createPath(path).setStroke(outline);\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateScatter(outlineMarkers[i], dim.height - offsets.b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar stroke = dc.makeStroke(finalTheme.marker.stroke),\n\t\t\t\t\t\tfill = this._plotFill(finalTheme.marker.fill, dim, offsets);\n\t\t\t\t\tif(fill && (fill.type === \"linear\" || fill.type == \"radial\")){\n\t\t\t\t\t\tvar color = gradutils.getColor(fill, {x: c.x, y: c.y});\n\t\t\t\t\t\tif(stroke){\n\t\t\t\t\t\t\tstroke.color = color;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfrontMarkers[i] = s.createPath(path).setStroke(stroke).setFill(color);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfrontMarkers[i] = s.createPath(path).setStroke(stroke).setFill(fill);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.labels){\n\t\t\t\t\t\tvar markerBox = frontMarkers[i].getBoundingBox();\n\t\t\t\t\t\tthis.createLabel(s, value, markerBox, finalTheme);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\tthis._animateScatter(frontMarkers[i], dim.height - offsets.b);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t\tif(frontMarkers.length){\n\t\t\t\t\trun.dyn.marker = theme.symbol;\n\t\t\t\t\trun.dyn.markerStroke = frontMarkers[frontMarkers.length - 1].getStroke();\n\t\t\t\t\trun.dyn.markerFill   = frontMarkers[frontMarkers.length - 1].getFill();\n\t\t\t\t}\n\n\t\t\t\tif(events){\n\t\t\t\t\tvar eventSeries = new Array(frontMarkers.length);\n\t\t\t\t\tarr.forEach(frontMarkers, function(s, i){\n\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\telement: \"marker\",\n\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\tshape:   s,\n\t\t\t\t\t\t\toutline: outlineMarkers && outlineMarkers[i] || null,\n\t\t\t\t\t\t\tshadow:  shadowMarkers && shadowMarkers[i] || null,\n\t\t\t\t\t\t\tcx:      lpoly[i].x,\n\t\t\t\t\t\t\tcy:      lpoly[i].y\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif(typeof run.data[0] == \"number\"){\n\t\t\t\t\t\t\to.x = i + 1;\n\t\t\t\t\t\t\to.y = run.data[i];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\to.x = run.data[i].x;\n\t\t\t\t\t\t\to.y = run.data[i].y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t}, this);\n\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t}else{\n\t\t\t\t\tdelete this._eventSeries[run.name];\n\t\t\t\t}\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Scatter\n\t\t},\n\t\t_animateScatter: function(shape, offset){\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: [0, offset], end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: [0, 0], end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Scatter.js\n// module id = 211\n// module chunks = 4","define([\"dojo/_base/declare\", \"./Stacked\"], function(declare, Stacked){\n\n\treturn declare(\"dojox.charting.plot2d.StackedLines\", Stacked, {\n\t\t// summary:\n\t\t//\t\tA convenience object to create a stacked line chart.\n\t\tconstructor: function(){\n\t\t\t// summary:\n\t\t\t//\t\tForce our Stacked base to be lines only.\n\t\t\tthis.opt.lines = true;\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/StackedLines.js\n// module id = 212\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/declare\", \"dojo/has\", \"./CartesianBase\", \"./_PlotEvents\", \"./common\",\n\t\t\"dojox/lang/functional\", \"dojox/lang/functional/reversed\", \"dojox/lang/utils\", \"dojox/gfx/fx\"],\n\tfunction(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\n\tvar alwaysFalse = function(){ return false; };\n\n\treturn declare(\"dojox.charting.plot2d.Columns\", [CartesianBase, _PlotEvents], {\n\t\t// summary:\n\t\t//\t\tThe plot object representing a column chart (vertical bars).\n\t\tdefaultParams: {\n\t\t\tgap:\t0,\t\t// gap between columns in pixels\n\t\t\tanimate: null,  // animate bars into place\n\t\t\tenableCache: false\n\t\t},\n\t\toptionalParams: {\n\t\t\tminBarSize:\t1,\t// minimal column width in pixels\n\t\t\tmaxBarSize:\t1,\t// maximal column width in pixels\n\t\t\t// theme component\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfilter:     {},\n\t\t\tstyleFunc:  null,\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\"\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for a columns chart.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.animate = this.opt.animate;\n\t\t\tthis.renderingOptions = { \"shape-rendering\": \"crispEdges\" };\n\t\t},\n\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = dc.collectSimpleStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\tstats.hmin -= 0.5;\n\t\t\tstats.hmax += 0.5;\n\t\t\treturn stats; // Object\n\t\t},\n\n\t\tcreateRect: function(run, creator, params){\n\t\t\tvar rect;\n\t\t\tif(this.opt.enableCache && run._rectFreePool.length > 0){\n\t\t\t\trect = run._rectFreePool.pop();\n\t\t\t\trect.setShape(params);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(rect);\n\t\t\t}else{\n\t\t\t\trect = creator.createRect(params);\n\t\t\t}\n\t\t\tif(this.opt.enableCache){\n\t\t\t\trun._rectUsePool.push(rect);\n\t\t\t}\n\t\t\treturn rect;\n\t\t},\n\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t// returns: dojox/charting/plot2d/Columns\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tvar s;\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\ts = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\t\t\tvar t = this.chart.theme,\n\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\tbaseline = Math.max(this._vScaler.bounds.lower,\n\t\t\t\t\tthis._vAxis ? this._vAxis.naturalBaseline : 0),\n\t\t\t\tbaselineHeight = vt(baseline),\n\t\t\t\tevents = this.events(),\n\t\t\t\tbar = this.getBarProperties();\n\n\t\t\tvar z = this.series.length;\n\t\t\tarr.forEach(this.series, function(serie){if(serie.hidden){z--;}});\n\n\t\t\t// Collect and calculate  all values\n\t\t\tvar extractedValues = this.extractValues(this._hScaler);\n\t\t\textractedValues = this.rearrangeValues(extractedValues, vt, baselineHeight);\n\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\trun._rectFreePool = (run._rectFreePool?run._rectFreePool:[]).concat(run._rectUsePool?run._rectUsePool:[]);\n\t\t\t\t\trun._rectUsePool = [];\n\t\t\t\t}\n\t\t\t\tvar theme = t.next(\"column\", [this.opt, run]),\n\t\t\t\t\teventSeries = new Array(run.data.length);\n\n\t\t\t\tif(run.hidden){\n\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tz--;\n\n\t\t\t\ts = run.group;\n\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t});\n\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t// data point to save time\n\t\t\t\tvar min = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0;\n\t\t\t\tvar max = indexed?Math.min(run.data.length, Math.ceil(this._hScaler.bounds.to)):run.data.length;\n\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\tif(!this.isNullValue(value)){\n\t\t\t\t\t\tvar val = this.getValue(value, j, i, indexed),\n\t\t\t\t\t\t\tvv = vt(val.y),\n\t\t\t\t\t\t\th = extractedValues[i][j],\n\t\t\t\t\t\t\tfinalTheme,\n\t\t\t\t\t\t\tsshape;\n\n\t\t\t\t\t\tif(this.opt.styleFunc || typeof value != \"number\"){\n\t\t\t\t\t\t\tvar tMixin = typeof value != \"number\" ? [value] : [];\n\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinalTheme = t.addMixin(theme, \"column\", tMixin, true);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinalTheme = t.post(theme, \"column\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bar.width >= 1){\n\t\t\t\t\t\t\tvar rect = {\n\t\t\t\t\t\t\t\tx: offsets.l + ht(val.x + 0.5) + bar.gap + bar.thickness * z,\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - baselineHeight - Math.max(h, 0),\n\t\t\t\t\t\t\t\twidth: bar.width,\n\t\t\t\t\t\t\t\theight: Math.abs(h)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif(finalTheme.series.shadow){\n\t\t\t\t\t\t\t\tvar srect = lang.clone(rect);\n\t\t\t\t\t\t\t\tsrect.x += finalTheme.series.shadow.dx;\n\t\t\t\t\t\t\t\tsrect.y += finalTheme.series.shadow.dy;\n\t\t\t\t\t\t\t\tsshape = this.createRect(run, s, srect).setFill(finalTheme.series.shadow.color).setStroke(finalTheme.series.shadow);\n\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\tthis._animateColumn(sshape, dim.height - offsets.b + baselineHeight, h);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar specialFill = this._plotFill(finalTheme.series.fill, dim, offsets);\n\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, rect);\n\t\t\t\t\t\t\tvar shape = this.createRect(run, s, rect).setFill(specialFill).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\tthis.overrideShape(shape, {index: j, value: val});\n\t\t\t\t\t\t\tif(shape.setFilter && finalTheme.series.filter){\n\t\t\t\t\t\t\t\tshape.setFilter(finalTheme.series.filter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trun.dyn.fill   = shape.getFill();\n\t\t\t\t\t\t\trun.dyn.stroke = shape.getStroke();\n\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\telement: \"column\",\n\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\t\t\tshadow:  sshape,\n\t\t\t\t\t\t\t\t\tcx:      val.x + 0.5,\n\t\t\t\t\t\t\t\t\tcy:      val.y,\n\t\t\t\t\t\t\t\t\tx:\t     indexed?j:run.data[j].x,\n\t\t\t\t\t\t\t\t\ty:\t \t indexed?run.data[j]:run.data[j].y\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if val.py is here, this means we are stacking and we need to subtract previous\n\t\t\t\t\t\t\t// value to get the high in which we will lay out the label\n\t\t\t\t\t\t\tif(!isNaN(val.py) && val.py > baseline){\n\t\t\t\t\t\t\t\trect.height = h - vt(val.py);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.createLabel(s, value, rect, finalTheme);\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateColumn(shape, dim.height - offsets.b - baselineHeight, h);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Columns\n\t\t},\n\t\tgetValue: function(value, j, seriesIndex, indexed){\n\t\t\tvar y,x;\n\t\t\tif(indexed){\n\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\ty = value;\n\t\t\t\t}else{\n\t\t\t\t\ty = value.y;\n\t\t\t\t}\n\t\t\t\tx = j;\n\t\t\t}else{\n\t\t\t\ty = value.y;\n\t\t\t\tx = value.x - 1;\n\t\t\t}\n\t\t\treturn { x: x, y: y };\n\t\t},\n\t\textractValues: function(scaler){\n\t\t\tvar extracted = [];\n\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t// data point to save time\n\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t}),\n\t\t\t\t\tmin = indexed ? Math.max(0, Math.floor(scaler.bounds.from - 1)) : 0,\n\t\t\t\t\tmax = indexed ? Math.min(run.data.length, Math.ceil(scaler.bounds.to)) : run.data.length,\n\t\t\t\t\textractedSet = extracted[i] = [];\n\t\t\t\textractedSet.min = min;\n\t\t\t\textractedSet.max = max;\n\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 :\n\t\t\t\t\t\t(typeof value == \"number\" ? value : value.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn extracted;\n\t\t},\n\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t// transform to pixels\n\t\t\tfor(var i = 0, n = values.length; i < n; ++i){\n\t\t\t\tvar extractedSet = values[i];\n\t\t\t\tif(extractedSet){\n\t\t\t\t\tfor(var j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\tvar value = extractedSet[j];\n\t\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 : transform(value) - baseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values;\n\t\t},\n\n\t\tisNullValue: function(value){\n\t\t\tif(value === null || typeof value == \"undefined\"){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar h = this._hAxis ? this._hAxis.isNullValue : alwaysFalse,\n\t\t\t\tv = this._vAxis ? this._vAxis.isNullValue : alwaysFalse;\n\t\t\tif(typeof value == \"number\"){\n\t\t\t\treturn v(0.5) || h(value);\n\t\t\t}\n\t\t\treturn v(isNaN(value.x) ? 0.5 : value.x + 0.5) || value.y === null || h(value.y);\n\t\t},\n\t\tgetBarProperties: function(){\n\t\t\tvar f = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt);\n\t\t\treturn {gap: f.gap, width: f.size, thickness: 0};\n\t\t},\n\t\t_animateColumn: function(shape, voffset, vsize){\n\t\t\tif(vsize===0){\n\t\t\t\tvsize = 1;\n\t\t\t}\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: [0, voffset - (voffset/vsize)], end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: [1, 1/vsize], end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Columns.js\n// module id = 213\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"./Columns\", \"./commonStacked\"], \n\tfunction(declare, lang, Columns, commonStacked){\n\n\treturn declare(\"dojox.charting.plot2d.StackedColumns\", Columns, {\n\t\t// summary:\n\t\t//\t\tThe plot object representing a stacked column chart (vertical bars).\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = commonStacked.collectStats(this.series, lang.hitch(this, \"isNullValue\"));\n\t\t\tstats.hmin -= 0.5;\n\t\t\tstats.hmax += 0.5;\n\t\t\treturn stats; // Object\n\t\t},\n\n\t\trearrangeValues: function(values, transform, baseline){\n\t\t\treturn commonStacked.rearrangeValues.call(this, values, transform, baseline);\n \t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/StackedColumns.js\n// module id = 214\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/_base/array\", \"./Columns\", \"./common\"], \n\tfunction(declare, array, Columns, dc){\n\n\treturn declare(\"dojox.charting.plot2d.ClusteredColumns\", Columns, {\n\t\t// summary:\n\t\t//\t\tA plot representing grouped or clustered columns (vertical bars)\n\t\tgetBarProperties: function(){\n\t\t\tvar length = this.series.length;\n\t\t\tarray.forEach(this.series, function(serie){if(serie.hidden){length--;}});\n\t\t\tvar f = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt, length);\n\t\t\treturn {gap: f.gap, width: f.size, thickness: f.size, clusterSize: length};\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/ClusteredColumns.js\n// module id = 215\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/declare\", \"dojo/has\", \"./CartesianBase\", \"./_PlotEvents\", \"./common\",\n\t\"dojox/gfx/fx\", \"dojox/lang/utils\", \"dojox/lang/functional\", \"dojox/lang/functional/reversed\"], \n\tfunction(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, fx, du, df, dfr){\n\t\t\n\t/*=====\n\tdeclare(\"dojox.charting.plot2d.__BarCtorArgs\", dojox.charting.plot2d.__DefaultCtorArgs, {\n\t\t// summary:\n\t\t//\t\tAdditional keyword arguments for bar charts.\n\t\n\t\t// minBarSize: Number?\n\t\t//\t\tThe minimum size for a bar in pixels.  Default is 1.\n\t\tminBarSize: 1,\n\t\n\t\t// maxBarSize: Number?\n\t\t//\t\tThe maximum size for a bar in pixels.  Default is 1.\n\t\tmaxBarSize: 1,\n\n\t\t// stroke: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke to use for any series on the plot.\n\t\tstroke:\t\t{},\n\n\t\t// outline: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke used to outline any series on the plot.\n\t\toutline:\t{},\n\n\t\t// shadow: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\n\t\tshadow:\t\t{},\n\n\t\t// fill: dojox.gfx.Fill?\n\t\t//\t\tAny fill to be used for elements on the plot.\n\t\tfill:\t\t{},\n\n\t\t// filter: dojox.gfx.Filter?\n\t \t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\n\t \t//\t\tbe required for this to work.\n\t \tfilter:\t\t{},\n\n\t\t// styleFunc: Function?\n\t\t//\t\tA function that returns a styling object for the a given data item.\n\t\tstyleFunc:\tnull,\n\n\t\t// font: String?\n\t\t//\t\tA font definition to be used for labels and other text-based elements on the plot.\n\t\tfont:\t\t\"\",\n\n\t\t// fontColor: String|dojo.Color?\n\t\t//\t\tThe color to be used for any text-based elements on the plot.\n\t\tfontColor:\t\"\",\n\t\t\n\t\t// enableCache: Boolean?\n\t\t//\t\tWhether the bars rect are cached from one rendering to another. This improves the rendering performance of\n\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\n\t\tenableCache: false\n\t});\n\t=====*/\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\t\n\tvar alwaysFalse = function(){ return false; }\n\n\treturn declare(\"dojox.charting.plot2d.Bars\", [CartesianBase, _PlotEvents], {\n\t\t// summary:\n\t\t//\t\tThe plot object representing a bar chart (horizontal bars).\n\t\tdefaultParams: {\n\t\t\tgap:\t0,\t\t// gap between columns in pixels\n\t\t\tanimate: null,   // animate bars into place\n\t\t\tenableCache: false\n\t\t},\n\t\toptionalParams: {\n\t\t\tminBarSize:\t1,\t// minimal bar width in pixels\n\t\t\tmaxBarSize:\t1,\t// maximal bar width in pixels\n\t\t\t// theme component\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfilter:\t    {},\n\t\t\tstyleFunc:  null,\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\"\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for a bar chart.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.animate = this.opt.animate;\n\t\t\tthis.renderingOptions = { \"shape-rendering\": \"crispEdges\" };\n\t\t},\n\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = dc.collectSimpleStats(this.series, lang.hitch(this, \"isNullValue\")), t;\n\t\t\tstats.hmin -= 0.5;\n\t\t\tstats.hmax += 0.5;\n\t\t\tt = stats.hmin, stats.hmin = stats.vmin, stats.vmin = t;\n\t\t\tt = stats.hmax, stats.hmax = stats.vmax, stats.vmax = t;\n\t\t\treturn stats; // Object\n\t\t},\n\t\t\n\t\tcreateRect: function(run, creator, params){\n\t\t\tvar rect;\n\t\t\tif(this.opt.enableCache && run._rectFreePool.length > 0){\n\t\t\t\trect = run._rectFreePool.pop();\n\t\t\t\trect.setShape(params);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(rect);\n\t\t\t}else{\n\t\t\t\trect = creator.createRect(params);\n\t\t\t}\n\t\t\tif(this.opt.enableCache){\n\t\t\t\trun._rectUsePool.push(rect);\n\t\t\t}\n\t\t\treturn rect;\n\t\t},\n\n\t\tcreateLabel: function(group, value, bbox, theme){\n\t\t\tif(this.opt.labels && this.opt.labelStyle == \"outside\"){\n\t\t\t\tvar y = bbox.y + bbox.height / 2;\n\t\t\t\tvar x = bbox.x + bbox.width + this.opt.labelOffset;\n\t\t\t\tthis.renderLabel(group, x, y, this._getLabel(isNaN(value.y)?value:value.y), theme, \"start\");\n          \t}else{\n\t\t\t\tthis.inherited(arguments);\n\t\t\t}\n\t\t},\n\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t// returns: dojox/charting/plot2d/Bars\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets); // dojox/charting/plot2d/Bars\n\t\t\t}\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tthis.resetEvents();\n\t\t\tvar s;\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\ts = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\t\t\tvar t = this.chart.theme,\n\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\tbaseline = Math.max(this._hScaler.bounds.lower,\n\t\t\t\t\tthis._hAxis ? this._hAxis.naturalBaseline : 0),\t\t\t\t\n\t\t\t\tbaselineWidth = ht(baseline),\n\t\t\t\tevents = this.events();\n\t\t\tvar bar = this.getBarProperties();\n\n\t\t\tvar actualLength = this.series.length;\n\t\t\tarr.forEach(this.series, function(serie){if(serie.hidden){actualLength--;}});\n\t\t\tvar z = actualLength;\n\t\t\t\n\t\t\t// Collect and calculate all values\n\t\t\tvar extractedValues = this.extractValues(this._vScaler);\n\t\t\textractedValues = this.rearrangeValues(extractedValues, ht, baselineWidth);\n\t\t\t\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tif(this.opt.enableCache){\n\t\t\t\t\trun._rectFreePool = (run._rectFreePool?run._rectFreePool:[]).concat(run._rectUsePool?run._rectUsePool:[]);\n\t\t\t\t\trun._rectUsePool = [];\n\t\t\t\t}\n\t\t\t\tvar theme = t.next(\"bar\", [this.opt, run]);\n\t\t\t\tif(run.hidden){\n\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\trun.dyn.stroke = theme.series.stroke;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tz--;\n\n\t\t\t\tvar\teventSeries = new Array(run.data.length);\n\t\t\t\ts = run.group;\t\n\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t});\n\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t// data point to save time\n\t\t\t\tvar min = indexed?Math.max(0, Math.floor(this._vScaler.bounds.from - 1)):0;\n\t\t\t\tvar max = indexed?Math.min(run.data.length, Math.ceil(this._vScaler.bounds.to)):run.data.length;\n\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\tif(!this.isNullValue(value)){\n\t\t\t\t\t\tvar val = this.getValue(value, j, i, indexed),\n\t\t\t\t\t\t\tw = extractedValues[i][j], finalTheme, sshape;\n\t\t\t\t\t\tif(this.opt.styleFunc || typeof value != \"number\"){\n\t\t\t\t\t\t\tvar tMixin = typeof value != \"number\" ? [value] : [];\n\t\t\t\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinalTheme = t.addMixin(theme, \"bar\", tMixin, true);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinalTheme = t.post(theme, \"bar\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(w && bar.height >= 1){\n\t\t\t\t\t\t\tvar rect = {\n\t\t\t\t\t\t\t\tx: offsets.l + baselineWidth + Math.min(w, 0),\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(val.x + 1.5) + bar.gap + bar.thickness * (actualLength - z - 1),\n\t\t\t\t\t\t\t\twidth: Math.abs(w),\n\t\t\t\t\t\t\t\theight: bar.height\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif(finalTheme.series.shadow){\n\t\t\t\t\t\t\t\tvar srect = lang.clone(rect);\n\t\t\t\t\t\t\t\tsrect.x += finalTheme.series.shadow.dx;\n\t\t\t\t\t\t\t\tsrect.y += finalTheme.series.shadow.dy;\n\t\t\t\t\t\t\t\tsshape = this.createRect(run, s, srect).setFill(finalTheme.series.shadow.color).setStroke(finalTheme.series.shadow);\n\t\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\t\tthis._animateBar(sshape, offsets.l + baselineWidth, -w);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar specialFill = this._plotFill(finalTheme.series.fill, dim, offsets);\n\t\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, rect);\n\t\t\t\t\t\t\tvar shape = this.createRect(run, s, rect).setFill(specialFill).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\tif(shape.setFilter && finalTheme.series.filter){\n\t\t\t\t\t\t\t\tshape.setFilter(finalTheme.series.filter);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trun.dyn.fill   = shape.getFill();\n\t\t\t\t\t\t\trun.dyn.stroke = shape.getStroke();\n\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\telement: \"bar\",\n\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\t\t\tshadow:\t sshape,\n\t\t\t\t\t\t\t\t\tcx:      val.y,\n\t\t\t\t\t\t\t\t\tcy:      val.x + 1.5,\n\t\t\t\t\t\t\t\t\tx:\t     indexed?j:run.data[j].x,\n\t\t\t\t\t\t\t\t\ty:\t \t indexed?run.data[j]:run.data[j].y\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!isNaN(val.py) && val.py > baseline){\n\t\t\t\t\t\t\t\trect.x += ht(val.py);\n\t\t\t\t\t\t\t\trect.width -= ht(val.py);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.createLabel(s, value, rect, finalTheme);\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateBar(shape, offsets.l + baselineWidth, -Math.abs(w));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Bars\n\t\t},\n\t\tgetValue: function(value, j, seriesIndex, indexed){\n\t\t\tvar y, x;\n\t\t\tif(indexed){\n\t\t\t\tif(typeof value == \"number\"){\n\t\t\t\t\ty = value;\n\t\t\t\t}else{\n\t\t\t\t\ty = value.y;\n\t\t\t\t}\n\t\t\t\tx = j;\n\t\t\t}else{\n\t\t\t\ty = value.y;\n\t\t\t\tx = value.x -1;\n\t\t\t}\n\t\t\treturn {y:y, x:x};\n\t\t},\n\t\textractValues: function(scaler){\n\t\t\tvar extracted = [];\n\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// on indexed charts we can easily just interate from the first visible to the last visible\n\t\t\t\t// data point to save time\n\t\t\t\tvar indexed = arr.some(run.data, function(item){\n\t\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\n\t\t\t\t\t}),\n\t\t\t\t\tmin = indexed ? Math.max(0, Math.floor(scaler.bounds.from - 1)) : 0,\n\t\t\t\t\tmax = indexed ? Math.min(run.data.length, Math.ceil(scaler.bounds.to)) : run.data.length,\n\t\t\t\t\textractedSet = extracted[i] = [];\n\t\t\t\textractedSet.min = min;\n\t\t\t\textractedSet.max = max;\n\t\t\t\tfor(var j = min; j < max; ++j){\n\t\t\t\t\tvar value = run.data[j];\n\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 :\n\t\t\t\t\t\t(typeof value == \"number\" ? value : value.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn extracted;\n\t\t},\n\t\trearrangeValues: function(values, transform, baseline){\n\t\t\t// transform to pixels\n\t\t\tfor(var i = 0, n = values.length; i < n; ++i){\n\t\t\t\tvar extractedSet = values[i];\n\t\t\t\tif(extractedSet){\n\t\t\t\t\tfor(var j = extractedSet.min, k = extractedSet.max; j < k; ++j){\n\t\t\t\t\t\tvar value = extractedSet[j];\n\t\t\t\t\t\textractedSet[j] = this.isNullValue(value) ? 0 : transform(value) - baseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values;\n\t\t},\n\t\tisNullValue: function(value){\n\t\t\tif(value === null || typeof value == \"undefined\"){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar h = this._hAxis ? this._hAxis.isNullValue : alwaysFalse,\n\t\t\t\tv = this._vAxis ? this._vAxis.isNullValue : alwaysFalse;\n\t\t\tif(typeof value == \"number\"){\n\t\t\t\treturn v(0.5) || h(value);\n\t\t\t}\n\t\t\treturn v(isNaN(value.x) ? 0.5 : value.x + 0.5) || value.y === null || h(value.y);\n\t\t},\t\t\n\t\tgetBarProperties: function(){\n\t\t\tvar f = dc.calculateBarSize(this._vScaler.bounds.scale, this.opt);\n\t\t\treturn {gap: f.gap, height: f.size, thickness: 0};\n\t\t},\n\t\t_animateBar: function(shape, hoffset, hsize){\n\t\t\tif(hsize==0){\n\t\t\t\thsize = 1;\n\t\t\t}\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: [hoffset - (hoffset/hsize), 0], end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: [1/hsize, 1], end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Bars.js\n// module id = 216\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"./Bars\", \"./commonStacked\"], \n\tfunction(declare, lang, Bars, commonStacked){\n\n\treturn declare(\"dojox.charting.plot2d.StackedBars\", Bars, {\n\t\t// summary:\n\t\t//\t\tThe plot object representing a stacked bar chart (horizontal bars).\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = commonStacked.collectStats(this.series, lang.hitch(this, \"isNullValue\")), t;\n\t\t\tstats.hmin -= 0.5;\n\t\t\tstats.hmax += 0.5;\n\t\t\tt = stats.hmin, stats.hmin = stats.vmin, stats.vmin = t;\n\t\t\tt = stats.hmax, stats.hmax = stats.vmax, stats.vmax = t;\n\t\t\treturn stats; // Object\n\t\t},\n\t\trearrangeValues: function(values, transform, baseline){\n\t\t\treturn commonStacked.rearrangeValues.call(this, values, transform, baseline);\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/StackedBars.js\n// module id = 217\n// module chunks = 4","define([\"dojo/_base/declare\", \"dojo/_base/array\", \"./Bars\", \"./common\"], \n\tfunction(declare, array, Bars, dc){\n\n\treturn declare(\"dojox.charting.plot2d.ClusteredBars\", Bars, {\n\t\t// summary:\n\t\t//\t\tA plot representing grouped or clustered bars (horizontal bars)\n\t\tgetBarProperties: function(){\n\t\t\tvar length = this.series.length;\n\t\t\tarray.forEach(this.series, function(serie){if(serie.hidden){length--;}});\n\t\t\tvar f = dc.calculateBarSize(this._vScaler.bounds.scale, this.opt, length);\n\t\t\treturn {gap: f.gap, height: f.size, thickness: f.size};\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/ClusteredBars.js\n// module id = 218\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/sniff\",\n\t\t\"./CartesianBase\", \"./common\", \"dojox/lang/utils\", \"dojox/gfx/fx\"],\n\tfunction(lang, declare, arr, has, CartesianBase, dc, du, fx){\n\n\tvar sortTicks = function(a,b){return a.value - b.value};\n\n\t/*=====\n\tdeclare(\"dojox.charting.plot2d.__GridCtorArgs\", dojox.charting.plot2d.__CartesianCtorArgs, {\n\t\t// summary:\n\t\t//\t\tA special keyword arguments object that is specific to a grid \"plot\".\n\n\t\t// majorHLine: dojox.gfx.Stroke?\n\t\t//\t\tAn optional dojox.gfx.Stroke for a major horizontal line. By default major lines use major tick stroke.\n\t\tmajorHLine:undefined,\n\n\t\t// minorHLine: dojox.gfx.Stroke?\n\t\t//\t\tAn optional dojox.gfx.Stroke for a minor horizontal line. By default minor lines use minor tick stroke.\n\t\tminorHLine:undefined,\n\n\t\t// majorVLine: dojox.gfx.Stroke?\n\t\t//\t\tAn optional dojox.gfx.Stroke for a major vertical line. By default major lines use major tick stroke.\n\t\tmajorVLine:undefined,\n\n\t\t// minorVLine: dojox.gfx.Stroke?\n\t\t//\t\tAn optional dojox.gfx.Stroke for a minor vertical line. By default major lines use major tick stroke.\n\t\tminorVLine:undefined,\n\n\t\t// hFill: dojox.gfx.Fill?\n\t\t//\t\tAn optional dojox.gfx.Fill used to fill every other horizontal stripe created by grid lines.\n\t\thFill: undefined,\n\n\t\t// hAlternateFill: dojox.gfx.Fill?\n\t\t//\t\tAn optional dojox.gfx.Fill used to fill alternating horizontal stripe created by grid lines not filled by `hFill`.\n\t\thAlternateFill: undefined,\n\n\t\t// vFill: dojox.gfx.Fill?\n\t\t//\t\tAn optional dojox.gfx.Fill used to fill every other vertical stripe created by grid lines.\n\t\tvFill: undefined,\n\n\t\t// vAlternateFill: dojox.gfx.Fill?\n\t\t//\t\tAn optional dojox.gfx.Fill used to fill alternating vertical stripe created by grid lines not filled by `vFill`.\n\t\tvAlternateFill: undefined,\n\n\t\t// hMajorLines: Boolean?\n\t\t//\t\tWhether to show lines at the major ticks along the horizontal axis. Default is true.\n\t\thMajorLines: true,\n\n\t\t// hMinorLines: Boolean?\n\t\t//\t\tWhether to show lines at the minor ticks along the horizontal axis. Default is false.\n\t\thMinorLines: false,\n\n\t\t// vMajorLines: Boolean?\n\t\t//\t\tWhether to show lines at the major ticks along the vertical axis. Default is true.\n\t\tvMajorLines: true,\n\n\t\t// vMinorLines: Boolean?\n\t\t//\t\tWhether to show lines at the major ticks along the vertical axis. Default is false.\n\t\tvMinorLines: false,\n\n\t\t// hStripes: Boolean?\n\t\t//\t\tWhether to show horizontal stripes. Default is false.\n\t\thStripes: false,\n\n\t\t// vStripes: Boolean?\n\t\t//\t\tWhether to show vertical stripes. Default is false.\n\t\tvStripes: false,\n\n\t\t// enableCache: Boolean?\n\t\t//\t\tWhether the grid lines are cached from one rendering to another. This improves the rendering performance of\n\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\n\t\tenableCache: false,\n\n\t\t// renderOnAxis: Boolean?\n\t\t//\t\tWhether or not the grid is rendered when drawn at horizontal or vertical axis position. Default is true.\n\t\trenderOnAxis: true\n\t});\n\t=====*/\n\n\treturn declare(\"dojox.charting.plot2d.Grid\", CartesianBase, {\n\t\t// summary:\n\t\t//\t\tA \"faux\" plot that can be placed behind other plots to represent\n\t\t//\t\ta grid against which other plots can be easily measured.\n\t\tdefaultParams: {\n\t\t\thMajorLines: true,\t// draw horizontal major lines\n\t\t\thMinorLines: false,\t// draw horizontal minor lines\n\t\t\tvMajorLines: true,\t// draw vertical major lines\n\t\t\tvMinorLines: false,\t// draw vertical minor lines\n\t\t\thStripes: false,\t// draw vertical stripes\n\t\t\tvStripes: false,\t// draw vertical stripes\n\t\t\tanimate: null,   // animate bars into place\n\t\t\tenableCache: false,\n\t\t\trenderOnAxis: true\n\t\t},\n\n\t\toptionalParams: {\n\t\t\tmajorHLine: {},\n\t\t\tminorHLine: {},\n\t\t\tmajorVLine: {},\n\t\t\tminorVLine: {},\n\t\t\thFill: {},\n\t\t\tvFill: {},\n\t\t\thAlternateFill: {},\n\t\t\tvAlternateFill: {}\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate the faux Grid plot.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__GridCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define the parameters of the underlying grid.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.animate = this.opt.animate;\n\t\t\tif(this.opt.enableCache){\n\t\t\t\tthis._lineFreePool = [];\n\t\t\t\tthis._lineUsePool = [];\n\t\t\t\tthis._rectFreePool = [];\n\t\t\t\tthis._rectUsePool = [];\n\t\t\t}\n\t\t},\n\t\taddSeries: function(run){\n\t\t\t// summary:\n\t\t\t//\t\tIgnored but included as a dummy method.\n\t\t\t// returns: dojox/charting/plot2d/Grid\n\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Grid\n\t\t},\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns default stats (irrelevant for this type of plot).\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\treturn lang.delegate(dc.defaultStats); // Object\n\t\t},\n\t\tcleanGroup: function(){\n\t\t\tthis.inherited(arguments);\n\t\t\tif(this.opt.enableCache){\n\t\t\t\tthis._lineFreePool = this._lineFreePool.concat(this._lineUsePool);\n\t\t\t\tthis._lineUsePool = [];\n\t\t\t\tthis._rectFreePool = this._rectFreePool.concat(this._rectUsePool);\n\t\t\t\tthis._rectUsePool = [];\n\t\t\t}\n\t\t},\n\t\tcreateLine: function(creator, params){\n\t\t\tvar line;\n\t\t\tif(this.opt.enableCache && this._lineFreePool.length > 0){\n\t\t\t\tline = this._lineFreePool.pop();\n\t\t\t\tline.setShape(params);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(line);\n\t\t\t}else{\n\t\t\t\tline = creator.createLine(params);\n\t\t\t}\n\t\t\tif(this.opt.enableCache){\n\t\t\t\tthis._lineUsePool.push(line);\n\t\t\t}\n\t\t\treturn line;\n\t\t},\n\t\tcreateRect: function(creator, params){\n\t\t\tvar rect;\n\t\t\tif(this.opt.enableCache && this._rectFreePool.length > 0){\n\t\t\t\trect = this._rectFreePool.pop();\n\t\t\t\trect.setShape(params);\n\t\t\t\t// was cleared, add it back\n\t\t\t\tcreator.add(rect);\n\t\t\t}else{\n\t\t\t\trect = creator.createRect(params);\n\t\t\t}\n\t\t\tif(this.opt.enableCache){\n\t\t\t\tthis._rectUsePool.push(rect);\n\t\t\t}\n\t\t\treturn rect;\n\t\t},\n\t\t\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRender the plot on the chart.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t// returns: dojox/charting/plot2d/Grid\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this.zoom){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tif(!this.dirty){ return this; }\n\t\t\tthis.cleanGroup();\n\t\t\tvar s = this.getGroup(), ta = this.chart.theme, lineStroke, ticks;\n\t\t\tif((has(\"ios\") && has(\"ios\") < 6) || has(\"android\") || (has(\"safari\") && !has(\"ios\"))){\n\t\t\t\t// clipping seems buggy in some mobile Webkit browser and Safari desktop\n\t\t\t\t// it does not clip correctly if only lines are present => create a invisible rectangle...\n\t\t\t\tvar w = Math.max(0, dim.width  - offsets.l - offsets.r),\n\t\t\t\t\th = Math.max(0, dim.height - offsets.t - offsets.b);\n\t\t\t\ts.createRect({ x: offsets.l, y: offsets.t, width: w, height: h});\n\t\t\t}\n\t\t\tif(this._vAxis){\n\t\t\t\t// draw horizontal stripes and lines\n\t\t\t\tticks = this._vAxis.getTicks();\n\t\t\t\tvar vScaler = this._vAxis.getScaler();\n\t\t\t\tif(ticks != null && vScaler != null){\n\t\t\t\t\tvar vt = vScaler.scaler.getTransformerFromModel(vScaler);\n\t\t\t\t\tif(this.opt.hStripes){\n\t\t\t\t\t\tthis._renderHRect(ticks, ta.grid, dim, offsets, vScaler, vt);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.hMinorLines){\n\t\t\t\t\t\tlineStroke = this.opt.minorHLine || (ta.grid && ta.grid.minorLine) || ta.axis.minorTick;\n\t\t\t\t\t\tthis._renderHLines(ticks.minor, lineStroke, dim, offsets, vScaler, vt);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.opt.hMajorLines){\n\t\t\t\t\t\tlineStroke = this.opt.majorHLine || (ta.grid && ta.grid.majorLine) || ta.axis.majorTick;\n\t\t\t\t\t\tthis._renderHLines(ticks.major, lineStroke, dim, offsets, vScaler, vt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(this._hAxis){\n\t\t\t\t// draw vertical stripes and lines\n\t\t\t\tticks = this._hAxis.getTicks();\n\t\t\t\tvar hScaler = this._hAxis.getScaler();\n\t\t\t\tif(ticks != null && hScaler != null){\n\t\t\t\t\tvar ht = hScaler.scaler.getTransformerFromModel(hScaler);\n\t\t\t\t\tif(this.opt.vStripes){\n\t\t\t\t\t\tthis._renderVRect(ticks, ta.grid, dim, offsets, hScaler, ht);\n\t\t\t\t\t}\n\t\t\t\t\tif(ticks && this.opt.vMinorLines){\n\t\t\t\t\t\tlineStroke = this.opt.minorVLine || (ta.grid && ta.grid.minorLine) || ta.axis.minorTick;\n\t\t\t\t\t\tthis._renderVLines(ticks.minor, lineStroke, dim, offsets, hScaler, ht);\n\t\t\t\t\t}\n\t\t\t\t\tif(ticks && this.opt.vMajorLines){\n\t\t\t\t\t\tlineStroke = this.opt.majorVLine || (ta.grid && ta.grid.majorLine) || ta.axis.majorTick;\n\t\t\t\t\t\tthis._renderVLines(ticks.major, lineStroke, dim, offsets, hScaler, ht);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Grid\n\t\t},\n\t\t_renderHLines: function(ticks, lineStroke, dim, offsets, vScaler, vt){\n\t\t\tvar s = this.getGroup();\n\t\t\tarr.forEach(ticks, function(tick){\n\t\t\t\tif(!this.opt.renderOnAxis && tick.value == (this._vAxis.opt.leftBottom?vScaler.bounds.from:vScaler.bounds.to)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar y = dim.height - offsets.b - vt(tick.value);\n\t\t\t\tvar hLine = this.createLine(s, {\n\t\t\t\t\tx1: offsets.l,\n\t\t\t\t\ty1: y,\n\t\t\t\t\tx2: dim.width - offsets.r,\n\t\t\t\t\ty2: y\n\t\t\t\t}).setStroke(lineStroke);\n\t\t\t\tif(this.animate){\n\t\t\t\t\tthis._animateGrid(hLine, \"h\", offsets.l, offsets.r + offsets.l - dim.width);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t},\n\t\t_renderVLines: function(ticks, lineStroke, dim, offsets, hScaler, ht){\n\t\t\tvar s = this.getGroup();\n\t\t\tarr.forEach(ticks, function(tick){\n\t\t\t\tif(!this.opt.renderOnAxis && tick.value == (this._hAxis.opt.leftBottom?hScaler.bounds.from:hScaler.bounds.to)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar x = offsets.l + ht(tick.value);\n\t\t\t\tvar vLine = this.createLine(s, {\n\t\t\t\t\tx1: x,\n\t\t\t\t\ty1: offsets.t,\n\t\t\t\t\tx2: x,\n\t\t\t\t\ty2: dim.height - offsets.b\n\t\t\t\t}).setStroke(lineStroke);\n\t\t\t\tif(this.animate){\n\t\t\t\t\tthis._animateGrid(vLine, \"v\", dim.height - offsets.b, dim.height - offsets.b - offsets.t);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t},\n\t\t_renderHRect: function(ticks, theme, dim, offsets, vScaler, vt){\n\t\t\tvar fill, tick, y, y2, hStripe;\n\t\t\tvar allTicks = ticks.major.concat(ticks.minor);\n\t\t\tallTicks.sort(sortTicks);\n\t\t\tif(allTicks[0].value > vScaler.bounds.from){\n\t\t\t\tallTicks.splice(0, 0, {value: vScaler.bounds.from});\n\t\t\t}\n\t\t\tif(allTicks[allTicks.length - 1].value < vScaler.bounds.to){\n\t\t\t\tallTicks.push({value: vScaler.bounds.to});\n\t\t\t}\n\t\t\tvar s = this.getGroup();\n\t\t\tfor(var j = 0; j < allTicks.length - 1; j++){\n\t\t\t\ttick = allTicks[j];\n\t\t\t\ty = dim.height - offsets.b - vt(tick.value);\n\t\t\t\ty2 = dim.height - offsets.b - vt(allTicks[j+1].value);\n\n\t\t\t\tfill = (j%2 == 0)?(this.opt.hAlternateFill ||(theme && theme.alternateFill)):\n\t\t\t\t\t(this.opt.hFill || (theme && theme.fill));\n\t\t\t\tif(fill){\n\t\t\t\t\thStripe = this.createRect(s, {\n\t\t\t\t\t\tx: offsets.l,\n\t\t\t\t\t\ty: y,\n\t\t\t\t\t\twidth: dim.width - offsets.r,\n\t\t\t\t\t\theight: y - y2\n\t\t\t\t\t}).setFill(fill);\n\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\tthis._animateGrid(hStripe, \"h\", offsets.l, offsets.r + offsets.l - dim.width);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_renderVRect: function(ticks, theme, dim, offsets, hScaler, ht){\n\t\t\tvar fill, tick, x, x2, vStripe;\n\t\t\tvar allTicks = ticks.major.concat(ticks.minor);\n\t\t\tallTicks.sort(sortTicks);\n\t\t\tif(allTicks[0].value > hScaler.bounds.from){\n\t\t\t\tallTicks.splice(0, 0, {value: hScaler.bounds.from});\n\t\t\t}\n\t\t\tif(allTicks[allTicks.length - 1].value < hScaler.bounds.to){\n\t\t\t\tallTicks.push({value: hScaler.bounds.to});\n\t\t\t}\n\t\t\tvar s = this.getGroup();\n\t\t\tfor(var j = 0; j < allTicks.length - 1; j++){\n\t\t\t\ttick = allTicks[j];\n\t\t\t\tx = offsets.l + ht(tick.value);\n\t\t\t\tx2 = offsets.l + ht(allTicks[j+1].value);\n\n\t\t\t\tfill = (j%2 == 0)?(this.opt.vAlternateFill ||(theme && theme.alternateFill)):\n\t\t\t\t\t(this.opt.vFill || (theme && theme.fill));\n\t\t\t\tif(fill){\n\t\t\t\t\tvStripe = this.createRect(s, {\n\t\t\t\t\t\tx: x,\n\t\t\t\t\t\ty: offsets.t,\n\t\t\t\t\t\twidth: x2 - x,\n\t\t\t\t\t\theight: dim.width - offsets.r\n\t\t\t\t\t}).setFill(fill);\n\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\tthis._animateGrid(vStripe, \"v\", dim.height - offsets.b, dim.height - offsets.b - offsets.t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_animateGrid: function(shape, type, offset, size){\n\t\t\tvar transStart = type == \"h\" ? [offset, 0] : [0, offset];\n\t\t\tvar scaleStart = type == \"h\" ? [1/size, 1] : [1, 1/size];\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: transStart, end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: scaleStart, end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Grid.js\n// module id = 219\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\" ,\"dojo/_base/declare\", \n\t\t\"./Base\", \"./_PlotEvents\", \"./common\",\n\t\t\"dojox/gfx\", \"dojox/gfx/matrix\", \"dojox/lang/functional\", \"dojox/lang/utils\",\"dojo/has\"],\n\tfunction(lang, arr, declare, Base, PlotEvents, dc, g, m, df, du, has){\n\n\t/*=====\n\tdeclare(\"dojox.charting.plot2d.__PieCtorArgs\", dojox.charting.plot2d.__DefaultCtorArgs, {\n\t\t// summary:\n\t\t//\t\tSpecialized keyword arguments object for use in defining parameters on a Pie chart.\n\t\n\t\t// labels: Boolean?\n\t\t//\t\tWhether or not to draw labels for each pie slice.  Default is true.\n\t\tlabels:\t\t\ttrue,\n\t\n\t\t// ticks: Boolean?\n\t\t//\t\tWhether or not to draw ticks to labels within each slice. Default is false.\n\t\tticks:\t\t\tfalse,\n\t\n\t\t// fixed: Boolean?\n\t\t//\t\tWhether a fixed precision must be applied to data values for display. Default is true.\n\t\tfixed:\t\t\ttrue,\n\t\n\t\t// precision: Number?\n\t\t//\t\tThe precision at which to round data values for display. Default is 0.\n\t\tprecision:\t\t1,\n\t\n\t\t// labelOffset: Number?\n\t\t//\t\tThe amount in pixels by which to offset labels.  Default is 20.\n\t\tlabelOffset:\t20,\n\t\n\t\t// labelStyle: String?\n\t\t//\t\tOptions as to where to draw labels.  Values include \"default\", and \"columns\".\tDefault is \"default\".\n\t\tlabelStyle:\t\t\"default\",\t// default/columns\n\t\t\n\t\t// omitLabels: Boolean?\n\t\t//\t\tWhether labels of slices small to the point of not being visible are omitted.\tDefault false.\n\t\tomitLabels: false,\n\t\t\n\t\t// htmlLabels: Boolean?\n\t\t//\t\tWhether or not to use HTML to render slice labels. Default is true.\n\t\thtmlLabels:\t\ttrue,\n\t\n\t\t// radGrad: String?\n\t\t//\t\tThe type of radial gradient to use in rendering.  Default is \"native\".\n\t\tradGrad:        \"native\",\n\t\n\t\t// fanSize: Number?\n\t\t//\t\tThe amount for a radial gradient.  Default is 5.\n\t\tfanSize:\t\t5,\n\t\n\t\t// startAngle: Number?\n\t\t//\t\tWhere to being rendering gradients in slices, in degrees.  Default is 0.\n\t\tstartAngle:     0,\n\t\n\t\t// radius: Number?\n\t\t//\t\tThe size of the radial gradient.  Default is 0.\n\t\tradius:\t\t0,\n\n\t\t// shadow: dojox.gfx.Stroke?\n\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\n\t\tshadow:\t\t{},\n\n\t\t// fill: dojox.gfx.Fill?\n\t\t//\t\tAny fill to be used for elements on the plot.\n\t\tfill:\t\t{},\n\n\t\t// filter: dojox.gfx.Filter?\n\t\t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\n\t\t//\t\tbe required for this to work.\n\t\tfilter:\t\t{},\n\n\t\t// styleFunc: Function?\n\t\t//\t\tA function that returns a styling object for the a given data item.\n\t\tstyleFunc:\tnull\n\t});\n\t=====*/\n\n\tvar FUDGE_FACTOR = 0.2; // use to overlap fans\n\n\treturn declare(\"dojox.charting.plot2d.Pie\", [Base, PlotEvents], {\n\t\t// summary:\n\t\t//\t\tThe plot that represents a typical pie chart.\n\t\tdefaultParams: {\n\t\t\tlabels:\t\t\ttrue,\n\t\t\tticks:\t\t\tfalse,\n\t\t\tfixed:\t\t\ttrue,\n\t\t\tprecision:\t\t1,\n\t\t\tlabelOffset:\t20,\n\t\t\tlabelStyle:\t\t\"default\",\t// default/columns\n\t\t\thtmlLabels:\t\ttrue,\t\t// use HTML to draw labels\n\t\t\tradGrad:        \"native\",\t// or \"linear\", or \"fan\"\n\t\t\tfanSize:\t\t5,\t\t\t// maximum fan size in degrees\n\t\t\tstartAngle:     0\t\t\t// start angle for slices in degrees\n\t\t},\n\t\toptionalParams: {\n\t\t\tradius:\t\t0,\n\t\t\tomitLabels: false,\n\t\t\t// theme components\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfilter:     {},\n\t\t\tstyleFunc:\tnull,\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\",\n\t\t\tlabelWiring: {}\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a pie plot.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.axes = [];\n\t\t\tthis.run = null;\n\t\t\tthis.dyn = [];\n\t\t\tthis.runFilter = []; \n\t\t},\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.inherited(arguments);\n\t\t\tthis.dyn = [];\n\t\t\tthis.run = null;\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t},\n\t\tsetAxis: function(axis){\n\t\t\t// summary:\n\t\t\t//\t\tDummy method, since axes are irrelevant with a Pie chart.\n\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t},\n\t\taddSeries: function(run){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a series of data to this plot.\n\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t//\t\tThe reference to this plot for functional chaining.\n\t\t\tthis.run = run;\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t},\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns default stats (irrelevant for this type of plot).\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\treturn lang.delegate(dc.defaultStats); // Object\n\t\t},\n\t\tgetRequiredColors: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturn the number of colors needed to draw this plot.\n\t\t\treturn this.run ? this.run.data.length : 0;\n\t\t},\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRender the plot on the chart.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t// returns: dojox/charting/plot2d/Pie\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(!this.dirty){ return this; }\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = false;\n\t\t\tthis._eventSeries = {};\n\t\t\tthis.cleanGroup();\n\t\t\tvar s = this.group, t = this.chart.theme;\n\n\t\t\tif(!this.run || !this.run.data.length){\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// calculate the geometry\n\t\t\tvar rx = (dim.width  - offsets.l - offsets.r) / 2,\n\t\t\t\try = (dim.height - offsets.t - offsets.b) / 2,\n\t\t\t\tr  = Math.min(rx, ry),\n\t\t\t\tlabelFont = \"font\" in this.opt ? this.opt.font : t.series.font,\n\t\t\t\tsize,\n\t\t\t\tstartAngle = m._degToRad(this.opt.startAngle),\n\t\t\t\tstart = startAngle, filteredRun, slices, labels, shift, labelR,\n\t\t\t\tevents = this.events();\n\n\t\t\tvar run = arr.map(this.run.data, function(item, i){\n\t\t\t\tif(typeof item != \"number\" && item.hidden){ \n\t\t\t\t\tthis.runFilter.push(i); \n\t\t\t\t\titem.hidden = false; \n\t\t\t\t} \n\t\t\t\tif(arr.some(this.runFilter, function(filter){return filter == i;})){ \n\t\t\t\t\tif(typeof item == \"number\"){ \n\t\t\t\t\t\treturn 0; \n\t\t\t\t\t}else{ \n\t\t\t\t\t\treturn {y: 0, text: item.text}; \n\t\t\t\t\t} \n\t\t\t\t}else{ \n\t\t\t\t\treturn item; \n\t\t\t\t} \n\t\t\t}, this);\n\n\t\t\tthis.dyn = [];\n\n\t\t\tif(\"radius\" in this.opt){\n\t\t\t\tr = this.opt.radius;\n\t\t\t\tlabelR = r - this.opt.labelOffset;\n\t\t\t}\n\t\t\tvar\tcircle = {\n\t\t\t\tcx: offsets.l + rx,\n\t\t\t\tcy: offsets.t + ry,\n\t\t\t\tr:  r\n\t\t\t};\n\n\t\t\t// draw shadow\n\t\t\tif(this.opt.shadow || t.shadow){\n\t\t\t\tvar shadow = this.opt.shadow || t.shadow;\n\t\t\t\tvar scircle = lang.clone(circle);\n\t\t\t\tscircle.cx += shadow.dx;\n\t\t\t\tscircle.cy += shadow.dy;\n\t\t\t\ts.createCircle(scircle).setFill(shadow.color).setStroke(shadow);\n\t\t\t}\n\t\t\tif(s.setFilter && (this.opt.filter || t.filter)){\n\t\t\t\ts.createCircle(circle).setFill(t.series.stroke).setFilter(this.opt.filter || t.filter);\n\t\t\t}\n\n\t\t\tif(typeof run[0] == \"number\"){\n\t\t\t\tfilteredRun = df.map(run, \"x ? Math.max(x, 0) : 0\");\n\t\t\t\tif(df.every(filteredRun, \"<= 0\")){\n\t\t\t\t\ts.createCircle(circle).setStroke(t.series.stroke);\n\t\t\t\t\tthis.dyn = arr.map(filteredRun, function(){\n\t\t\t\t\t\treturn {  };\n\t\t\t\t\t});\n\t\t\t\t\treturn this;\n\t\t\t\t}else{\n\t\t\t\t\tslices = df.map(filteredRun, \"/this\", df.foldl(filteredRun, \"+\", 0));\n\t\t\t\t \tif(this.opt.labels){\n\t\t\t\t \t\tlabels = arr.map(slices, function(x){\n\t\t\t\t\t\t\treturn x > 0 ? this._getLabel(x * 100) + \"%\" : \"\";\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfilteredRun = df.map(run, \"x ? Math.max(x.y, 0) : 0\");\n\t\t\t\tif(df.every(filteredRun, \"<= 0\")){\n\t\t\t\t\ts.createCircle(circle).setStroke(t.series.stroke);\n\t\t\t\t\tthis.dyn = arr.map(filteredRun, function(){\n\t\t\t\t\t\treturn {  };\n\t\t\t\t\t});\n\t\t\t\t\treturn this;\n\t\t\t\t}else{\n\t\t\t\t\tslices = df.map(filteredRun, \"/this\", df.foldl(filteredRun, \"+\", 0));\n\t\t\t\t\tif(this.opt.labels){\n\t\t\t\t\t\tlabels = arr.map(slices, function(x, i){\n\t\t\t\t\t\t\tif(x < 0){ return \"\"; }\n\t\t\t\t\t\t\tvar v = run[i];\n\t\t\t\t\t\t\treturn \"text\" in v ? v.text : this._getLabel(x * 100) + \"%\";\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar themes = df.map(run, function(v, i){\n\t\t\t\tvar tMixin = [this.opt, this.run];\n\t\t\t\tif(v !== null && typeof v != \"number\"){\n\t\t\t\t\ttMixin.push(v);\n\t\t\t\t}\n\t\t\t\tif(this.opt.styleFunc){\n\t\t\t\t\ttMixin.push(this.opt.styleFunc(v));\n\t\t\t\t}\n\t\t\t\treturn t.next(\"slice\", tMixin, true);\n\t\t\t}, this);\n\n\t\t\tif(this.opt.labels){\n\t\t\t\tsize = labelFont ? g.normalizedLength(g.splitFontString(labelFont).size) : 0;\n\t\t\t\tshift = df.foldl1(df.map(labels, function(label, i){\n\t\t\t\t\tvar font = themes[i].series.font;\n\t\t\t\t\treturn g._base._getTextBox(label, {font: font}).w;\n\t\t\t\t}, this), \"Math.max(a, b)\") / 2;\n\t\t\t\tif(this.opt.labelOffset < 0){\n\t\t\t\t\tr = Math.min(rx - 2 * shift, ry - size) + this.opt.labelOffset;\n\t\t\t\t}\n\t\t\t\tlabelR = r - this.opt.labelOffset;\n\t\t\t}\n\n\t\t\t// draw slices\n\t\t\tvar eventSeries = new Array(slices.length);\n\t\t\tarr.some(slices, function(slice, i){\n\t\t\t\tif(slice < 0){\n\t\t\t\t\t// degenerated slice\n\t\t\t\t\treturn false;\t// continue\n\t\t\t\t}\n\t\t\t\tvar v = run[i], theme = themes[i], specialFill, o;\n\t\t\t\tif(slice == 0){\n\t\t\t\t\tthis.dyn.push({fill: theme.series.fill, stroke: theme.series.stroke});\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(slice >= 1){\n\t\t\t\t\t// whole pie\n\t\t\t\t\tspecialFill = this._plotFill(theme.series.fill, dim, offsets);\n\t\t\t\t\tspecialFill = this._shapeFill(specialFill,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx: circle.cx - circle.r, y: circle.cy - circle.r,\n\t\t\t\t\t\t\twidth: 2 * circle.r, height: 2 * circle.r\n\t\t\t\t\t\t});\n\t\t\t\t\tspecialFill = this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, circle.r);\n\t\t\t\t\tvar shape = s.createCircle(circle).setFill(specialFill).setStroke(theme.series.stroke);\n\t\t\t\t\tthis.dyn.push({fill: specialFill, stroke: theme.series.stroke});\n\n\t\t\t\t\tif(events){\n\t\t\t\t\t\to = {\n\t\t\t\t\t\t\telement: \"slice\",\n\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\trun:     this.run,\n\t\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\t\tx:       i,\n\t\t\t\t\t\t\ty:       typeof v == \"number\" ? v : v.y,\n\t\t\t\t\t\t\tcx:      circle.cx,\n\t\t\t\t\t\t\tcy:      circle.cy,\n\t\t\t\t\t\t\tcr:      r\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\t// we continue because we want to collect null data points for legend\n\t\t\t\t}\n\t\t\t\t// calculate the geometry of the slice\n\t\t\t\tvar end = start + slice * 2 * Math.PI;\n\t\t\t\tif(i + 1 == slices.length){\n\t\t\t\t\tend = startAngle + 2 * Math.PI;\n\t\t\t\t}\n\t\t\t\tvar\tstep = end - start,\n\t\t\t\t\tx1 = circle.cx + r * Math.cos(start),\n\t\t\t\t\ty1 = circle.cy + r * Math.sin(start),\n\t\t\t\t\tx2 = circle.cx + r * Math.cos(end),\n\t\t\t\t\ty2 = circle.cy + r * Math.sin(end);\n\t\t\t\t// draw the slice\n\t\t\t\tvar fanSize = m._degToRad(this.opt.fanSize);\n\t\t\t\tif(theme.series.fill && theme.series.fill.type === \"radial\" && this.opt.radGrad === \"fan\" && step > fanSize){\n\t\t\t\t\tvar group = s.createGroup(), nfans = Math.ceil(step / fanSize), delta = step / nfans;\n\t\t\t\t\tspecialFill = this._shapeFill(theme.series.fill,\n\t\t\t\t\t\t{x: circle.cx - circle.r, y: circle.cy - circle.r, width: 2 * circle.r, height: 2 * circle.r});\n\t\t\t\t\tfor(var j = 0; j < nfans; ++j){\n\t\t\t\t\t\tvar fansx = j == 0 ? x1 : circle.cx + r * Math.cos(start + (j - FUDGE_FACTOR) * delta),\n\t\t\t\t\t\t\tfansy = j == 0 ? y1 : circle.cy + r * Math.sin(start + (j - FUDGE_FACTOR) * delta),\n\t\t\t\t\t\t\tfanex = j == nfans - 1 ? x2 : circle.cx + r * Math.cos(start + (j + 1 + FUDGE_FACTOR) * delta),\n\t\t\t\t\t\t\tfaney = j == nfans - 1 ? y2 : circle.cy + r * Math.sin(start + (j + 1 + FUDGE_FACTOR) * delta);\n\t\t\t\t\t\tgroup.createPath().\n\t\t\t\t\t\t\t\tmoveTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\t\tlineTo(fansx, fansy).\n\t\t\t\t\t\t\t\tarcTo(r, r, 0, delta > Math.PI, true, fanex, faney).\n\t\t\t\t\t\t\t\tlineTo(circle.cx, circle.cy).\n\t\t\t\t\t\t\t\tclosePath().\n\t\t\t\t\t\t\t\tsetFill(this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, r, start + (j + 0.5) * delta, start + (j + 0.5) * delta));\n\t\t\t\t\t}\n\t\t\t\t\tgroup.createPath().\n\t\t\t\t\t\tmoveTo(circle.cx, circle.cy).\n\t\t\t\t\t\tlineTo(x1, y1).\n\t\t\t\t\t\tarcTo(r, r, 0, step > Math.PI, true, x2, y2).\n\t\t\t\t\t\tlineTo(circle.cx, circle.cy).\n\t\t\t\t\t\tclosePath().\n\t\t\t\t\t\tsetStroke(theme.series.stroke);\n\t\t\t\t\tshape = group;\n\t\t\t\t}else{\n\t\t\t\t\tshape = s.createPath().\n\t\t\t\t\t\tmoveTo(circle.cx, circle.cy).\n\t\t\t\t\t\tlineTo(x1, y1).\n\t\t\t\t\t\tarcTo(r, r, 0, step > Math.PI, true, x2, y2).\n\t\t\t\t\t\tlineTo(circle.cx, circle.cy).\n\t\t\t\t\t\tclosePath().\n\t\t\t\t\t\tsetStroke(theme.series.stroke);\n\t\t\t\t\tspecialFill = theme.series.fill;\n\t\t\t\t\tif(specialFill && specialFill.type === \"radial\"){\n\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, {x: circle.cx - circle.r, y: circle.cy - circle.r, width: 2 * circle.r, height: 2 * circle.r});\n\t\t\t\t\t\tif(this.opt.radGrad === \"linear\"){\n\t\t\t\t\t\t\tspecialFill = this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, r, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(specialFill && specialFill.type === \"linear\"){\n\t\t\t\t\t\tspecialFill = this._plotFill(specialFill, dim, offsets);\n\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, shape.getBoundingBox());\n\t\t\t\t\t}\n\t\t\t\t\tshape.setFill(specialFill);\n\t\t\t\t}\n\t\t\t\tthis.dyn.push({fill: specialFill, stroke: theme.series.stroke});\n\n\t\t\t\tif(events){\n\t\t\t\t\to = {\n\t\t\t\t\t\telement: \"slice\",\n\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\trun:     this.run,\n\t\t\t\t\t\tshape:   shape,\n\t\t\t\t\t\tx:       i,\n\t\t\t\t\t\ty:       typeof v == \"number\" ? v : v.y,\n\t\t\t\t\t\tcx:      circle.cx,\n\t\t\t\t\t\tcy:      circle.cy,\n\t\t\t\t\t\tcr:      r\n\t\t\t\t\t};\n\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t}\n\n\t\t\t\tstart = end;\n\n\t\t\t\treturn false;\t// continue\n\t\t\t}, this);\n\t\t\t// draw labels\n\t\t\tif(this.opt.labels){\n\t\t\t\tvar isRtl = has(\"dojo-bidi\") && this.chart.isRightToLeft(); \n\t\t\t\tif(this.opt.labelStyle == \"default\"){ // inside or outside based on labelOffset\n\t\t\t\t\tstart = startAngle;\n\t\t\t\t\tarr.some(slices, function(slice, i){\n\t\t\t\t\t\tif(slice <= 0){\n\t\t\t\t\t\t\t// degenerated slice\n\t\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar theme = themes[i];\n\t\t\t\t\t\tif(slice >= 1){\n\t\t\t\t\t\t\t// whole pie\n\t\t\t\t\t\t\tthis.renderLabel(s, circle.cx, circle.cy + size / 2, labels[i], theme, this.opt.labelOffset > 0);\n\t\t\t\t\t\t\treturn true;\t// stop iteration\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// calculate the geometry of the slice\n\t\t\t\t\t\tvar end = start + slice * 2 * Math.PI;\n\t\t\t\t\t\tif(i + 1 == slices.length){\n\t\t\t\t\t\t\tend = startAngle + 2 * Math.PI;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.opt.omitLabels && end-start < 0.001){\n\t\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar\tlabelAngle = (start + end) / 2,\n\t\t\t\t\t\t\tx = circle.cx + labelR * Math.cos(labelAngle),\n\t\t\t\t\t\t\ty = circle.cy + labelR * Math.sin(labelAngle) + size / 2;\n\t\t\t\t\t\t// draw the label\n\t\t\t\t\t\tthis.renderLabel(s, isRtl ? dim.width - x : x, y, labels[i], theme, this.opt.labelOffset > 0);\n\t\t\t\t\t\tstart = end;\n\t\t\t\t\t\treturn false;\t// continue\n\t\t\t\t\t}, this);\n\t\t\t\t}else if(this.opt.labelStyle == \"columns\"){\n\t\t\t\t\tstart = startAngle;\n\t\t\t\t\tvar omitLabels = this.opt.omitLabels;\n\t\t\t\t\t//calculate label angles\n\t\t\t\t\tvar labeledSlices = [];\n\t\t\t\t\tarr.forEach(slices, function(slice, i){\n\t\t\t\t\t\tvar end = start + slice * 2 * Math.PI;\n\t\t\t\t\t\tif(i + 1 == slices.length){\n\t\t\t\t\t\t\tend = startAngle + 2 * Math.PI;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar labelAngle = (start + end) / 2;\n\t\t\t\t\t\tlabeledSlices.push({\n\t\t\t\t\t\t\tangle: labelAngle,\n\t\t\t\t\t\t\tleft: Math.cos(labelAngle) < 0,\n\t\t\t\t\t\t\ttheme: themes[i],\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tomit: omitLabels?end - start < 0.001:false\n\t\t\t\t\t\t});\n\t\t\t\t\t\tstart = end;\n\t\t\t\t\t});\n\t\t\t\t\t//calculate label radius to each slice\n\t\t\t\t\tvar labelHeight = g._base._getTextBox(\"a\",{ font: labelFont }).h;\n\t\t\t\t\tthis._getProperLabelRadius(labeledSlices, labelHeight, circle.r * 1.1);\n\t\t\t\t\t//draw label and wiring\n\t\t\t\t\tarr.forEach(labeledSlices, function(slice, i){\n\t\t\t\t\t\tif(!slice.omit){\n\t\t\t\t\t\t\tvar leftColumn = circle.cx - circle.r * 2,\n\t\t\t\t\t\t\t\trightColumn = circle.cx + circle.r * 2,\n\t\t\t\t\t\t\t\tlabelWidth = g._base._getTextBox(labels[i], {font: slice.theme.series.font}).w,\n\t\t\t\t\t\t\t\tx = circle.cx + slice.labelR * Math.cos(slice.angle),\n\t\t\t\t\t\t\t\ty = circle.cy + slice.labelR * Math.sin(slice.angle),\n\t\t\t\t\t\t\t\tjointX = (slice.left) ? (leftColumn + labelWidth) : (rightColumn - labelWidth),\n\t\t\t\t\t\t\t\tlabelX = (slice.left) ? leftColumn : jointX;\n\t\t\t\t\t\t\tvar wiring = s.createPath().moveTo(circle.cx + circle.r * Math.cos(slice.angle), circle.cy + circle.r * Math.sin(slice.angle));\n\t\t\t\t\t\t\tif(Math.abs(slice.labelR * Math.cos(slice.angle)) < circle.r * 2 - labelWidth){\n\t\t\t\t\t\t\t\twiring.lineTo(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twiring.lineTo(jointX, y).setStroke(slice.theme.series.labelWiring);\n\t\t\t\t\t\t\tthis.renderLabel(s, isRtl ? dim.width - labelWidth - labelX : labelX, y, labels[i], slice.theme, false, \"left\");\n\t\t\t\t\t\t}\n\t\t\t\t\t},this);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// post-process events to restore the original indexing\n\t\t\tvar esi = 0;\n\t\t\tthis._eventSeries[this.run.name] = df.map(run, function(v){\n\t\t\t\treturn v <= 0 ? null : eventSeries[esi++];\n\t\t\t});\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Pie\n\t\t},\n\t\t_getProperLabelRadius: function(slices, labelHeight, minRidius){\n\t\t\tvar leftCenterSlice, rightCenterSlice,\n\t\t\t\tleftMinSIN = 1, rightMinSIN = 1;\n\t\t\tif(slices.length == 1){\n\t\t\t\tslices[0].labelR = minRidius;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(var i = 0; i < slices.length; i++){\n\t\t\t\tvar tempSIN = Math.abs(Math.sin(slices[i].angle));\n\t\t\t\tif(slices[i].left){\n\t\t\t\t\tif(leftMinSIN >= tempSIN){\n\t\t\t\t\t\tleftMinSIN = tempSIN;\n\t\t\t\t\t\tleftCenterSlice = slices[i];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(rightMinSIN >= tempSIN){\n\t\t\t\t\t\trightMinSIN = tempSIN;\n\t\t\t\t\t\trightCenterSlice = slices[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tleftCenterSlice.labelR = rightCenterSlice.labelR = minRidius;\n\t\t\tthis._calculateLabelR(leftCenterSlice, slices, labelHeight);\n\t\t\tthis._calculateLabelR(rightCenterSlice, slices, labelHeight);\n\t\t},\n\t\t_calculateLabelR: function(firstSlice, slices, labelHeight){\n\t\t\tvar i = firstSlice.index,length = slices.length,\n\t\t\t\tcurrentLabelR = firstSlice.labelR, nextLabelR;\n\t\t\twhile(!(slices[i%length].left ^ slices[(i+1)%length].left)){\n\t\t\t\tif(!slices[(i + 1) % length].omit){\n\t\t\t\t\tnextLabelR = (Math.sin(slices[i % length].angle) * currentLabelR + ((slices[i % length].left) ? (-labelHeight) : labelHeight)) /\n\t\t\t\t\tMath.sin(slices[(i + 1) % length].angle);\n\t\t\t\t\tcurrentLabelR = (nextLabelR < firstSlice.labelR) ? firstSlice.labelR : nextLabelR;\n\t\t\t\t\tslices[(i + 1) % length].labelR = currentLabelR;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti = firstSlice.index;\n\t\t\tvar j = (i == 0)?length-1 : i - 1;\n\t\t\twhile(!(slices[i].left ^ slices[j].left)){\n\t\t\t\tif(!slices[j].omit){\n\t\t\t\t\tnextLabelR = (Math.sin(slices[i].angle) * currentLabelR + ((slices[i].left) ? labelHeight : (-labelHeight))) /\n\t\t\t\t\tMath.sin(slices[j].angle);\n\t\t\t\t\tcurrentLabelR = (nextLabelR < firstSlice.labelR) ? firstSlice.labelR : nextLabelR;\n\t\t\t\t\tslices[j].labelR = currentLabelR;\n\t\t\t\t}\n\t\t\t\ti--;j--;\n\t\t\t\ti = (i < 0)?i+slices.length:i;\n\t\t\t\tj = (j < 0)?j+slices.length:j;\n\t\t\t}\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Pie.js\n// module id = 220\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/has\", \n\t\t\"./CartesianBase\", \"./_PlotEvents\", \"./common\", \"dojox/lang/functional\", \"dojox/lang/functional/reversed\",\n\t\t\"dojox/lang/utils\", \"dojox/gfx/fx\"], \n\tfunction(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\n\treturn declare(\"dojox.charting.plot2d.Bubble\", [CartesianBase, _PlotEvents], {\n\t\t// summary:\n\t\t//\t\tA plot representing bubbles.  Note that data for Bubbles requires 3 parameters,\n\t\t//\t\tin the form of:  { x, y, size }, where size determines the size of the bubble.\n\t\tdefaultParams: {\n\t\t\tanimate: null   // animate bars into place\n\t\t},\n\t\toptionalParams: {\n\t\t\t// theme component\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfilter:     {},\n\t\t\tstyleFunc:\tnull,\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\",\n\t\t\tlabelFunc: null\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a plot of bubbles.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t//\t\tOptional keyword arguments object to help define plot parameters.\n\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tif(!this.opt.labelFunc){\n\t\t\t\tthis.opt.labelFunc = function(value, fixed, precision){\n\t\t\t\t\treturn this._getLabel(value.size, fixed, precision);\n\t\t\t\t};\n\t\t\t}\n\t\t\tthis.animate = this.opt.animate;\n\t\t},\n\n\t\t//\toverride the render so that we are plotting only circles.\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t// returns: dojox/charting/plot2d/Bubble\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tvar s;\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\ts = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\n\t\t\tvar t = this.chart.theme,\n\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\tevents = this.events();\n\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tif(!run.data.length){\n\t\t\t\t\trun.dirty = false;\n\t\t\t\t\tt.skip();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(typeof run.data[0] == \"number\"){\n\t\t\t\t\tconsole.warn(\"dojox.charting.plot2d.Bubble: the data in the following series cannot be rendered as a bubble chart; \", run);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar theme = t.next(\"circle\", [this.opt, run]),\n\t\t\t\t\tpoints = arr.map(run.data, function(v){\n\t\t\t\t\t\treturn v ? {\n\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\n\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y),\n\t\t\t\t\t\t\tradius: this._vScaler.bounds.scale * (v.size / 2)\n\t\t\t\t\t\t} : null;\n\t\t\t\t\t}, this);\n\n\t\t\t\tif(run.hidden){\n\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\trun.dyn.stroke =  theme.series.stroke;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = run.group;\n                \n\t\t\t\tvar frontCircles = null, outlineCircles = null, shadowCircles = null, styleFunc = this.opt.styleFunc;\n\n\t\t\t\tvar getFinalTheme = function(item){\n\t\t\t\t\tif(styleFunc){\n\t\t\t\t\t\treturn t.addMixin(theme, \"circle\", [item, styleFunc(item)], true);\n\t\t\t\t\t}\n\t\t\t\t\treturn t.addMixin(theme, \"circle\", item, true);\n\t\t\t\t};\n\n\t\t\t\t// make shadows if needed\n\t\t\t\tif(theme.series.shadow){\n\t\t\t\t\tshadowCircles = arr.map(points, function(item, i){\n\t\t\t\t\t\tif(!this.isNullValue(item)){\n\t\t\t\t\t\t\tvar finalTheme = getFinalTheme(run.data[i]),\n\t\t\t\t\t\t\t\tshadow = finalTheme.series.shadow;\n\t\t\t\t\t\t\tvar shape = s.createCircle({\n\t\t\t\t\t\t\t\tcx: item.x + shadow.dx, cy: item.y + shadow.dy, r: item.radius\n\t\t\t\t\t\t\t}).setStroke(shadow).setFill(shadow.color);\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateBubble(shape, dim.height - offsets.b, item.radius);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}, this);\n\t\t\t\t\tif(shadowCircles.length){\n\t\t\t\t\t\trun.dyn.shadow = shadowCircles[shadowCircles.length - 1].getStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make outlines if needed\n\t\t\t\tif(theme.series.outline){\n\t\t\t\t\toutlineCircles = arr.map(points, function(item, i){\n\t\t\t\t\t\tif(!this.isNullValue(item)){\n\t\t\t\t\t\t\tvar finalTheme = getFinalTheme(run.data[i]),\n\t\t\t\t\t\t\t\toutline = dc.makeStroke(finalTheme.series.outline);\n\t\t\t\t\t\t\toutline.width = 2 * outline.width + (theme.series.stroke && theme.series.stroke.width || 0);\n\t\t\t\t\t\t\tvar shape = s.createCircle({\n\t\t\t\t\t\t\t\tcx: item.x, cy: item.y, r: item.radius\n\t\t\t\t\t\t\t}).setStroke(outline);\n\t\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\t\tthis._animateBubble(shape, dim.height - offsets.b, item.radius);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}, this);\n\t\t\t\t\tif(outlineCircles.length){\n\t\t\t\t\t\trun.dyn.outline = outlineCircles[outlineCircles.length - 1].getStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//\trun through the data and add the circles.\n\t\t\t\tfrontCircles = arr.map(points, function(item, i){\n\t\t\t\t\tif(!this.isNullValue(item)){\n\t\t\t\t\t\tvar finalTheme = getFinalTheme(run.data[i]),\n\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\tx: item.x - item.radius,\n\t\t\t\t\t\t\t\ty: item.y - item.radius,\n\t\t\t\t\t\t\t\twidth:  2 * item.radius,\n\t\t\t\t\t\t\t\theight: 2 * item.radius\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tvar specialFill = this._plotFill(finalTheme.series.fill, dim, offsets);\n\t\t\t\t\t\tspecialFill = this._shapeFill(specialFill, rect);\n\t\t\t\t\t\tvar shape = s.createCircle({\n\t\t\t\t\t\t\tcx: item.x, cy: item.y, r: item.radius\n\t\t\t\t\t\t}).setFill(specialFill).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\tif(shape.setFilter && finalTheme.series.filter){\n\t\t\t\t\t\t\tshape.setFilter(finalTheme.series.filter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateBubble(shape, dim.height - offsets.b, item.radius);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.createLabel(s, run.data[i], rect, finalTheme);\n\t\t\t\t\t\treturn shape;\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}, this);\n\t\t\t\tif(frontCircles.length){\n\t\t\t\t\trun.dyn.fill   = frontCircles[frontCircles.length - 1].getFill();\n\t\t\t\t\trun.dyn.stroke = frontCircles[frontCircles.length - 1].getStroke();\n\t\t\t\t}\n\n\t\t\t\tif(events){\n\t\t\t\t\tvar eventSeries = new Array(frontCircles.length);\n\t\t\t\t\tarr.forEach(frontCircles, function(s, i){\n\t\t\t\t\t\tif(s !== null){\n\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\telement: \"circle\",\n\t\t\t\t\t\t\t\tindex:   i,\n\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\tshape:   s,\n\t\t\t\t\t\t\t\toutline: outlineCircles && outlineCircles[i] || null,\n\t\t\t\t\t\t\t\tshadow:  shadowCircles && shadowCircles[i] || null,\n\t\t\t\t\t\t\t\tx:       run.data[i].x,\n\t\t\t\t\t\t\t\ty:       run.data[i].y,\n\t\t\t\t\t\t\t\tr:       run.data[i].size / 2,\n\t\t\t\t\t\t\t\tcx:      points[i].x,\n\t\t\t\t\t\t\t\tcy:      points[i].y,\n\t\t\t\t\t\t\t\tcr:      points[i].radius\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\teventSeries[i] = o;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\t}else{\n\t\t\t\t\tdelete this._eventSeries[run.name];\n\t\t\t\t}\n\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Bubble\n\t\t},\n\t\t_animateBubble: function(shape, offset, size){\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: [0, offset], end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: [0, 1/size], end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Bubble.js\n// module id = 221\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/has\", \"./CartesianBase\", \"./_PlotEvents\", \"./common\",\n\t\t\"dojox/lang/functional\", \"dojox/lang/functional/reversed\", \"dojox/lang/utils\", \"dojox/gfx/fx\"], \n\tfunction(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\n\t//\tCandlesticks are based on the Bars plot type; we expect the following passed\n\t//\tas values in a series:\n\t//\t{ x?, open, close, high, low, mid? }\n\t//\tif x is not provided, the array index is used.\n\t//\tfailing to provide the OHLC values will throw an error.\n\treturn declare(\"dojox.charting.plot2d.Candlesticks\", [CartesianBase, _PlotEvents], {\n\t\t// summary:\n\t\t//\t\tA plot that represents typical candlesticks (financial reporting, primarily).\n\t\t//\t\tUnlike most charts, the Candlestick expects data points to be represented by\n\t\t//\t\tan object of the form { x?, open, close, high, low, mid? }, where both\n\t\t//\t\tx and mid are optional parameters.  If x is not provided, the index of the\n\t\t//\t\tdata array is used.\n\t\tdefaultParams: {\n\t\t\tgap:\t2,\t\t// gap between columns in pixels\n\t\t\tanimate: null   // animate bars into place\n\t\t},\n\t\toptionalParams: {\n\t\t\tminBarSize:\t1,\t// minimal candle width in pixels\n\t\t\tmaxBarSize:\t1,\t// maximal candle width in pixels\n\t\t\t// theme component\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\"\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for a candlestick chart.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.animate = this.opt.animate;\n\t\t},\n\n\t\tcollectStats: function(series){\n\t\t\t// summary:\n\t\t\t//\t\tCollect all statistics for drawing this chart.  Since the common\n\t\t\t//\t\tfunctionality only assumes x and y, Candlesticks must create it's own\n\t\t\t//\t\tstats (since data has no y value, but open/close/high/low instead).\n\t\t\t// series: dojox.charting.Series[]\n\t\t\t//\t\tThe data series array to be drawn on this plot.\n\t\t\t// returns: Object\n\t\t\t//\t\tReturns an object in the form of { hmin, hmax, vmin, vmax }.\n\n\t\t\t//\twe have to roll our own, since we need to use all four passed\n\t\t\t//\tvalues to figure out our stats, and common only assumes x and y.\n\t\t\tvar stats = lang.delegate(dc.defaultStats);\n\t\t\tfor(var i=0; i<series.length; i++){\n\t\t\t\tvar run = series[i];\n\t\t\t\tif(!run.data.length){ continue; }\n\t\t\t\tvar old_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\tif(!(\"ymin\" in run) || !(\"ymax\" in run)){\n\t\t\t\t\tarr.forEach(run.data, function(val, idx){\n\t\t\t\t\t\tif(!this.isNullValue(val)){\n\t\t\t\t\t\t\tvar x = val.x || idx + 1;\n\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t}\n\t\t\treturn stats;\t//\tObject\n\t\t},\n\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = this.collectStats(this.series);\n\t\t\tstats.hmin -= 0.5;\n\t\t\tstats.hmax += 0.5;\n\t\t\treturn stats; // Object\n\t\t},\n\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t// returns: dojox/charting/plot2d/Candlesticks\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tvar s;\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\ts = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\t\t\tvar t = this.chart.theme, f, gap, width,\n\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\tevents = this.events();\n\t\t\tf = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt);\n\t\t\tgap = f.gap;\n\t\t\twidth = f.size;\n\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tvar theme = t.next(\"candlestick\", [this.opt, run]),\n\t\t\t\t\teventSeries = new Array(run.data.length);\n\n\t\t\t\tif(run.hidden){\n\t\t\t\t\trun.dyn.fill = theme.series.fill;\n\t\t\t\t\trun.dyn.stroke =  theme.series.stroke;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = run.group;\n                \n\t\t\t\tfor(var j = 0; j < run.data.length; ++j){\n\t\t\t\t\tvar v = run.data[j];\n\t\t\t\t\tif(!this.isNullValue(v)){\n\t\t\t\t\t\tvar finalTheme = t.addMixin(theme, \"candlestick\", v, true);\n\n\t\t\t\t\t\t//\tcalculate the points we need for OHLC\n\t\t\t\t\t\tvar x = ht(v.x || (j+0.5)) + offsets.l + gap,\n\t\t\t\t\t\t\ty = dim.height - offsets.b,\n\t\t\t\t\t\t\topen = vt(v.open),\n\t\t\t\t\t\t\tclose = vt(v.close),\n\t\t\t\t\t\t\thigh = vt(v.high),\n\t\t\t\t\t\t\tlow = vt(v.low);\n\t\t\t\t\t\tif(\"mid\" in v){\n\t\t\t\t\t\t\tvar mid = vt(v.mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(low > high){\n\t\t\t\t\t\t\tvar tmp = high;\n\t\t\t\t\t\t\thigh = low;\n\t\t\t\t\t\t\tlow = tmp;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(width >= 1){\n\t\t\t\t\t\t\t//\tdraw the line and rect, set up as a group and pass that to the events.\n\t\t\t\t\t\t\tvar doFill = open > close;\n\t\t\t\t\t\t\tvar line = { x1: width/2, x2: width/2, y1: y - high, y2: y - low },\n\t\t\t\t\t\t\t\trect = {\n\t\t\t\t\t\t\t\t\tx: 0, y: y-Math.max(open, close),\n\t\t\t\t\t\t\t\t\twidth: width, height: Math.max(doFill ? open-close : close-open, 1)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tvar shape = s.createGroup();\n\t\t\t\t\t\t\tshape.setTransform({dx: x, dy: 0 });\n\t\t\t\t\t\t\tvar inner = shape.createGroup();\n\t\t\t\t\t\t\tinner.createLine(line).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\tinner.createRect(rect).setStroke(finalTheme.series.stroke).\n\t\t\t\t\t\t\t\tsetFill(doFill ? finalTheme.series.fill : \"white\");\n\t\t\t\t\t\t\tif(\"mid\" in v){\n\t\t\t\t\t\t\t\t//\tadd the mid line.\n\t\t\t\t\t\t\t\tinner.createLine({\n\t\t\t\t\t\t\t\t\t\tx1: (finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1), x2: width - (finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1),\n\t\t\t\t\t\t\t\t\ty1: y - mid, y2: y - mid\n\t\t\t\t\t\t\t\t}).setStroke(doFill ? \"white\" : finalTheme.series.stroke);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// TODO: double check this.\n\t\t\t\t\t\t\trun.dyn.fill   = finalTheme.series.fill;\n\t\t\t\t\t\t\trun.dyn.stroke = finalTheme.series.stroke;\n\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\telement: \"candlestick\",\n\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\tshape:   inner,\n\t\t\t\t\t\t\t\t\tx:       x,\n\t\t\t\t\t\t\t\t\ty:       y-Math.max(open, close),\n\t\t\t\t\t\t\t\t\tcx:\t\t width/2,\n\t\t\t\t\t\t\t\t\tcy:\t\t (y-Math.max(open, close)) + (Math.max(doFill ? open-close : close-open, 1)/2),\n\t\t\t\t\t\t\t\t\twidth:\t width,\n\t\t\t\t\t\t\t\t\theight:  Math.max(doFill ? open-close : close-open, 1),\n\t\t\t\t\t\t\t\t\tdata:\t v\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateCandlesticks(shape, y - low, high - low);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Candlesticks\n\t\t},\n\n\t\ttooltipFunc: function(o){\n\t\t\treturn '<table cellpadding=\"1\" cellspacing=\"0\" border=\"0\" style=\"font-size:0.9em;\">'\n\t\t\t\t\t\t+ '<tr><td>Open:</td><td align=\"right\"><strong>' + o.data.open + '</strong></td></tr>'\n\t\t\t\t\t\t+ '<tr><td>High:</td><td align=\"right\"><strong>' + o.data.high + '</strong></td></tr>'\n\t\t\t\t\t\t+ '<tr><td>Low:</td><td align=\"right\"><strong>' + o.data.low + '</strong></td></tr>'\n\t\t\t\t\t\t+ '<tr><td>Close:</td><td align=\"right\"><strong>' + o.data.close + '</strong></td></tr>'\n\t\t\t\t\t\t+ (o.data.mid !== undefined ? '<tr><td>Mid:</td><td align=\"right\"><strong>' + o.data.mid + '</strong></td></tr>' : '')\n\t\t\t\t\t\t+ '</table>';\n\t\t},\n\n\t\t_animateCandlesticks: function(shape, voffset, vsize){\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: [0, voffset - (voffset/vsize)], end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: [1, 1/vsize], end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Candlesticks.js\n// module id = 222\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/declare\", \"dojo/has\", \"./CartesianBase\", \"./_PlotEvents\", \"./common\",\n\t\"dojox/lang/functional\", \"dojox/lang/functional/reversed\", \"dojox/lang/utils\", \"dojox/gfx/fx\"],\n\tfunction(lang, arr, declare, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\n\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\n\n\t//\tCandlesticks are based on the Bars plot type; we expect the following passed\n\t//\tas values in a series:\n\t//\t{ x?, open, close, high, low }\n\t//\tif x is not provided, the array index is used.\n\t//\tfailing to provide the OHLC values will throw an error.\n\treturn declare(\"dojox.charting.plot2d.OHLC\", [CartesianBase, _PlotEvents], {\n\t\t// summary:\n\t\t//\t\tA plot that represents typical open/high/low/close (financial reporting, primarily).\n\t\t//\t\tUnlike most charts, the Candlestick expects data points to be represented by\n\t\t//\t\tan object of the form { x?, open, close, high, low, mid? }, where both\n\t\t//\t\tx and mid are optional parameters.  If x is not provided, the index of the\n\t\t//\t\tdata array is used.\n\t\tdefaultParams: {\n\t\t\tgap:\t2,\t\t// gap between columns in pixels\n\t\t\tanimate: null\t// animate chart to place\n\t\t},\n\t\toptionalParams: {\n\t\t\tminBarSize: 1,\t// minimal bar size in pixels\n\t\t\tmaxBarSize: 1,\t// maximal bar size in pixels\n\t\t\t// theme component\n\t\t\tstroke:\t\t{},\n\t\t\toutline:\t{},\n\t\t\tshadow:\t\t{},\n\t\t\tfill:\t\t{},\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\"\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tThe constructor for a candlestick chart.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__BarCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define the plot.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.animate = this.opt.animate;\n\t\t},\n\n\t\tcollectStats: function(series){\n\t\t\t// summary:\n\t\t\t//\t\tCollect all statistics for drawing this chart.  Since the common\n\t\t\t//\t\tfunctionality only assumes x and y, OHLC must create it's own\n\t\t\t//\t\tstats (since data has no y value, but open/close/high/low instead).\n\t\t\t// series: dojox/charting/Series[]\n\t\t\t//\t\tThe data series array to be drawn on this plot.\n\t\t\t// returns: Object\n\t\t\t//\t\tReturns an object in the form of { hmin, hmax, vmin, vmax }.\n\n\t\t\t//\twe have to roll our own, since we need to use all four passed\n\t\t\t//\tvalues to figure out our stats, and common only assumes x and y.\n\t\t\tvar stats = lang.delegate(dc.defaultStats);\n\t\t\tfor(var i=0; i<series.length; i++){\n\t\t\t\tvar run = series[i];\n\t\t\t\tif(!run.data.length){ continue; }\n\t\t\t\tvar old_vmin = stats.vmin, old_vmax = stats.vmax;\n\t\t\t\tif(!(\"ymin\" in run) || !(\"ymax\" in run)){\n\t\t\t\t\tarr.forEach(run.data, function(val, idx){\n\t\t\t\t\t\tif(!this.isNullValue(val)){\n\t\t\t\t\t\t\tvar x = val.x || idx + 1;\n\t\t\t\t\t\t\tstats.hmin = Math.min(stats.hmin, x);\n\t\t\t\t\t\t\tstats.hmax = Math.max(stats.hmax, x);\n\t\t\t\t\t\t\tstats.vmin = Math.min(stats.vmin, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t\tstats.vmax = Math.max(stats.vmax, val.open, val.close, val.high, val.low);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\tif(\"ymin\" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }\n\t\t\t\tif(\"ymax\" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }\n\t\t\t}\n\t\t\treturn stats; // Object\n\t\t},\n\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\tvar stats = this.collectStats(this.series);\n\t\t\tstats.hmin -= 0.5;\n\t\t\tstats.hmax += 0.5;\n\t\t\treturn stats; // Object\n\t\t},\n\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRun the calculations for any axes for this plot.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object in the form of { width, height }\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b}.\n\t\t\t// returns: dojox/charting/plot2d/OHLC\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(this.zoom && !this.isDataDirty()){\n\t\t\t\treturn this.performZoom(dim, offsets);\n\t\t\t}\n\t\t\tthis.resetEvents();\n\t\t\tthis.dirty = this.isDirty();\n\t\t\tif(this.dirty){\n\t\t\t\tarr.forEach(this.series, purgeGroup);\n\t\t\t\tthis._eventSeries = {};\n\t\t\t\tthis.cleanGroup();\n\t\t\t\tvar s = this.getGroup();\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\n\t\t\t}\n\t\t\tvar t = this.chart.theme, f, gap, width,\n\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\n\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\n\t\t\t\tevents = this.events();\n\t\t\tf = dc.calculateBarSize(this._hScaler.bounds.scale, this.opt);\n\t\t\tgap = f.gap;\n\t\t\twidth = f.size;\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tvar run = this.series[i];\n\t\t\t\tif(!this.dirty && !run.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tthis._reconnectEvents(run.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trun.cleanGroup();\n\t\t\t\tvar theme = t.next(\"candlestick\", [this.opt, run]), s = run.group,\n\t\t\t\t\teventSeries = new Array(run.data.length);\n\t\t\t\tfor(var j = 0; j < run.data.length; ++j){\n\t\t\t\t\tvar v = run.data[j];\n\t\t\t\t\tif(!this.isNullValue(v)){\n\t\t\t\t\t\tvar finalTheme = t.addMixin(theme, \"candlestick\", v, true);\n\n\t\t\t\t\t\t//\tcalculate the points we need for OHLC\n\t\t\t\t\t\tvar x = ht(v.x || (j+0.5)) + offsets.l + gap,\n\t\t\t\t\t\t\ty = dim.height - offsets.b,\n\t\t\t\t\t\t\topen = vt(v.open),\n\t\t\t\t\t\t\tclose = vt(v.close),\n\t\t\t\t\t\t\thigh = vt(v.high),\n\t\t\t\t\t\t\tlow = vt(v.low);\n\t\t\t\t\t\tif(low > high){\n\t\t\t\t\t\t\tvar tmp = high;\n\t\t\t\t\t\t\thigh = low;\n\t\t\t\t\t\t\tlow = tmp;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(width >= 1){\n\t\t\t\t\t\t\tvar hl = {x1: width/2, x2: width/2, y1: y - high, y2: y - low},\n\t\t\t\t\t\t\t\top = {x1: 0, x2: ((width/2) + ((finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1)/2)), y1: y-open, y2: y-open},\n\t\t\t\t\t\t\t\tcl = {x1: ((width/2) - ((finalTheme.series.stroke ? finalTheme.series.stroke.width || 1 : 1)/2)), x2: width, y1: y-close, y2: y-close};\n\t\t\t\t\t\t\tvar shape = s.createGroup();\n\t\t\t\t\t\t\tshape.setTransform({dx: x, dy: 0});\n\t\t\t\t\t\t\tvar inner = shape.createGroup();\n\t\t\t\t\t\t\tinner.createLine(hl).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\tinner.createLine(op).setStroke(finalTheme.series.stroke);\n\t\t\t\t\t\t\tinner.createLine(cl).setStroke(finalTheme.series.stroke);\n\n\t\t\t\t\t\t\t// TODO: double check this.\n\t\t\t\t\t\t\trun.dyn.stroke = finalTheme.series.stroke;\n\t\t\t\t\t\t\tif(events){\n\t\t\t\t\t\t\t\tvar o = {\n\t\t\t\t\t\t\t\t\telement: \"candlestick\",\n\t\t\t\t\t\t\t\t\tindex:   j,\n\t\t\t\t\t\t\t\t\trun:     run,\n\t\t\t\t\t\t\t\t\tshape:\t inner,\n\t\t\t\t\t\t\t\t\tx:       x,\n\t\t\t\t\t\t\t\t\ty:       y-Math.max(open, close),\n\t\t\t\t\t\t\t\t\tcx:\t\t width/2,\n\t\t\t\t\t\t\t\t\tcy:\t\t (y-Math.max(open, close)) + (Math.max(open > close ? open-close : close-open, 1)/2),\n\t\t\t\t\t\t\t\t\twidth:\t width,\n\t\t\t\t\t\t\t\t\theight:  Math.max(open > close ? open-close : close-open, 1),\n\t\t\t\t\t\t\t\t\tdata:\t v\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\n\t\t\t\t\t\t\t\teventSeries[j] = o;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.animate){\n\t\t\t\t\t\t\tthis._animateOHLC(shape, y - low, high - low);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._eventSeries[run.name] = eventSeries;\n\t\t\t\trun.dirty = false;\n\t\t\t}\n\t\t\tthis.dirty = false;\n\t\t\t// chart mirroring starts\n\t\t\tif(has(\"dojo-bidi\")){\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\n\t\t\t}\n\t\t\t// chart mirroring ends\n\t\t\treturn this;\t//\tdojox/charting/plot2d/OHLC\n\t\t},\n\t\t_animateOHLC: function(shape, voffset, vsize){\n\t\t\tfx.animateTransform(lang.delegate({\n\t\t\t\tshape: shape,\n\t\t\t\tduration: 1200,\n\t\t\t\ttransform: [\n\t\t\t\t\t{name: \"translate\", start: [0, voffset - (voffset/vsize)], end: [0, 0]},\n\t\t\t\t\t{name: \"scale\", start: [1, 1/vsize], end: [1, 1]},\n\t\t\t\t\t{name: \"original\"}\n\t\t\t\t]\n\t\t\t}, this.animate)).play();\n\t\t}\n\t});\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/OHLC.js\n// module id = 223\n// module chunks = 4","define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/connect\", \"dojo/_base/array\",\n\t\"dojo/dom-geometry\", \"dojo/_base/fx\", \"dojo/fx\", \"dojo/sniff\",\n\t\"./Base\", \"./_PlotEvents\", \"./common\", \"../axis2d/common\",\n\t\"dojox/gfx\", \"dojox/gfx/matrix\", \"dojox/gfx/fx\", \"dojox/lang/functional\",\n\t\"dojox/lang/utils\", \"dojo/fx/easing\"],\n\tfunction(lang, declare, hub, arr, domGeom, baseFx, coreFx, has,\n\t\t\tBase, PlotEvents, dc, da, g, m, gfxfx, df, du, easing){\n\n\tvar FUDGE_FACTOR = 0.2; // use to overlap fans\n\n\tvar Spider = declare(\"dojox.charting.plot2d.Spider\", [Base, PlotEvents], {\n\t\t// summary:\n\t\t//\t\tThe plot that represents a typical Spider chart.\n\t\tdefaultParams: {\n\t\t\tlabels:\t\t\ttrue,\n\t\t\tticks:\t\t\tfalse,\n\t\t\tfixed:\t\t\ttrue,\n\t\t\tprecision:\t\t1,\n\t\t\tlabelOffset:\t-10,\n\t\t\tlabelStyle:\t\t\"default\",\t// default/rows/auto\n\t\t\thtmlLabels:\t\ttrue,\t\t// use HTML to draw labels\n\t\t\tstartAngle:\t\t-90,\t\t// start angle for slices in degrees\n\t\t\tdivisions:\t\t 3,\t\t\t// radius tick count\n\t\t\taxisColor:\t\t \"\",\t\t// spider axis color\n\t\t\taxisWidth:\t\t 0,\t\t\t// spider axis stroke width\n\t\t\tspiderColor:\t \"\",\t\t// spider web color\n\t\t\tspiderWidth:\t 0,\t\t\t// spider web stroke width\n\t\t\tseriesWidth:\t 0,\t\t\t// plot border with\n\t\t\tseriesFillAlpha: 0.2,\t\t// plot fill alpha\n\t\t\tspiderOrigin:\t 0.16,\n\t\t\tmarkerSize:\t\t 3,\t\t\t// radius of plot vertex (px)\n\t\t\tspiderType:\t\t \"polygon\", //\"circle\"\n\t\t\tanimationType:\t easing.backOut,\n\t\t\tanimate: null,\n\t\t\taxisTickFont:\t\t\"\",\n\t\t\taxisTickFontColor:\t\"\",\n\t\t\taxisFont:\t\t\t\"\",\n\t\t\taxisFontColor:\t\t\"\"\n\t\t},\n\t\toptionalParams: {\n\t\t\tradius:\t\t0,\n\t\t\tfont:\t\t\"\",\n\t\t\tfontColor:\t\"\"\n\t\t},\n\n\t\tconstructor: function(chart, kwArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a Spider plot.\n\t\t\t// chart: dojox/charting/Chart\n\t\t\t//\t\tThe chart this plot belongs to.\n\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\n\t\t\t//\t\tAn optional keyword arguments object to help define this plot's parameters.\n\t\t\tthis.opt = lang.clone(this.defaultParams);\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\n\t\t\tthis.dyn = [];\n\t\t\tthis.datas = {};\n\t\t\tthis.labelKey = [];\n\t\t\tthis.oldSeriePoints = {};\n\t\t\tthis.animate = this.opt.animate === null ? {} : this.opt.animate;\n\t\t\tthis.animations = {};\n\t\t},\n\t\tclear: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear out all of the information tied to this plot.\n\t\t\t// returns: dojox/charting/plot2d/Spider\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.inherited(arguments);\n\t\t\tthis.dyn = [];\n\t\t\tthis.axes = [];\n\t\t\tthis.datas = {};\n\t\t\tthis.labelKey = [];\n\t\t\tthis.oldSeriePoints = {};\n\t\t\tthis.animations = {};\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Spider\n\t\t},\n\t\tsetAxis: function(axis){\n\t\t\t// summary:\n\t\t\t//\t\tOptionally set axis min and max property.\n\t\t\t// returns: dojox/charting/plot2d/Spider\n\t\t\t//\t\tThe reference to this plot for functional chaining.\n\n\t\t\t// override the computed min/max with provided values if any\n\t\t\tif(axis){\n\t\t\t\tif(axis.opt.min != undefined){\n\t\t\t\t\tthis.datas[axis.name].min = axis.opt.min;\n\t\t\t\t}\n\t\t\t\tif(axis.opt.max != undefined){\n\t\t\t\t\tthis.datas[axis.name].max = axis.opt.max;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Spider\n\t\t},\n\t\taddSeries: function(run){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a data series to this plot.\n\t\t\t// run: dojox.charting.Series\n\t\t\t//\t\tThe series to be added.\n\t\t\t// returns: dojox/charting/plot2d/Base\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tthis.series.push(run);\n\t\t\tvar key;\n\t\t\tfor(key in run.data){\n\t\t\t\tvar val = run.data[key],\n\t\t\t\t\tdata = this.datas[key];\n\t\t\t\tif(data){\n\t\t\t\t\tdata.vlist.push(val);\n\t\t\t\t\tdata.min = Math.min(data.min, val);\n\t\t\t\t\tdata.max = Math.max(data.max, val);\n\t\t\t\t}else{\n\t\t\t\t\tvar axisKey = \"__\"+key;\n\t\t\t\t\tthis.axes.push(axisKey);\n\t\t\t\t\tthis[axisKey] = key;\n\t\t\t\t\tthis.datas[key] = {min: val, max: val, vlist: [val]};\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.labelKey.length <= 0){\n\t\t\t\tfor(key in run.data){\n\t\t\t\t\tthis.labelKey.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox.charting.plot2d.Base\n\t\t},\n\t\tgetSeriesStats: function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\n\t\t\t// returns: Object\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\n\t\t\treturn dc.collectSimpleStats(this.series, function(v){ return v === null; }); // Object\n\t\t},\n\t\trender: function(dim, offsets){\n\t\t\t// summary:\n\t\t\t//\t\tRender the plot on the chart.\n\t\t\t// dim: Object\n\t\t\t//\t\tAn object of the form { width, height }.\n\t\t\t// offsets: Object\n\t\t\t//\t\tAn object of the form { l, r, t, b }.\n\t\t\t// returns: dojox/charting/plot2d/Spider\n\t\t\t//\t\tA reference to this plot for functional chaining.\n\t\t\tif(!this.dirty){ return this; }\n\t\t\tthis.dirty = false;\n\t\t\tthis.cleanGroup();\n\t\t\tvar s = this.group, t = this.chart.theme;\n\t\t\tthis.resetEvents();\n\n\t\t\tif(!this.series || !this.series.length){\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// calculate the geometry\n\t\t\tvar o = this.opt, ta = t.axis,\n\t\t\t\trx = (dim.width\t - offsets.l - offsets.r) / 2,\n\t\t\t\try = (dim.height - offsets.t - offsets.b) / 2,\n\t\t\t\tr  = Math.min(rx, ry),\n\t\t\t\taxisTickFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font) || \"normal normal normal 7pt Tahoma\",\n\t\t\t\taxisFont = o.axisFont || (ta.tick && ta.tick.titleFont) || \"normal normal normal 11pt Tahoma\",\n\t\t\t\taxisTickFontColor = o.axisTickFontColor || (ta.majorTick && ta.majorTick.fontColor) || (ta.tick && ta.tick.fontColor) || \"silver\",\n\t\t\t\taxisFontColor = o.axisFontColor || (ta.tick && ta.tick.titleFontColor) || \"black\",\n\t\t\t\taxisColor = o.axisColor || (ta.tick && ta.tick.axisColor) || \"silver\",\n\t\t\t\tspiderColor = o.spiderColor || (ta.tick && ta.tick.spiderColor) || \"silver\",\n\t\t\t\taxisWidth = o.axisWidth || (ta.stroke && ta.stroke.width) || 2,\n\t\t\t\tspiderWidth = o.spiderWidth || (ta.stroke && ta.stroke.width) || 2,\n\t\t\t\tseriesWidth = o.seriesWidth || (ta.stroke && ta.stroke.width) || 2,\n\t\t\t\tasize = g.normalizedLength(g.splitFontString(axisFont).size),\n\t\t\t\tstartAngle = m._degToRad(o.startAngle),\n\t\t\t\tstart = startAngle, labels, shift, labelR,\n\t\t\t\touterPoints, innerPoints, divisionPoints, divisionRadius, labelPoints,\n\t\t\t\tro = o.spiderOrigin, dv = o.divisions >= 3 ? o.divisions : 3, ms = o.markerSize,\n\t\t\t\tspt = o.spiderType, at = o.animationType, lboffset = o.labelOffset < -10 ? o.labelOffset : -10,\n\t\t\t\taxisExtra = 0.2,\n\t\t\t\ti, j, point, len, fontWidth, render, serieEntry, run, data, min, max, distance;\n\t\t\t\n\t\t\tif(o.labels){\n\t\t\t\tlabels = arr.map(this.series, function(s){\n\t\t\t\t\treturn s.name;\n\t\t\t\t}, this);\n\t\t\t\tshift = df.foldl1(df.map(labels, function(label){\n\t\t\t\t\tvar font = t.series.font;\n\t\t\t\t\treturn g._base._getTextBox(label, {\n\t\t\t\t\t\tfont: font\n\t\t\t\t\t}).w;\n\t\t\t\t}, this), \"Math.max(a, b)\") / 2;\n\t\t\t\tr = Math.min(rx - 2 * shift, ry - asize) + lboffset;\n\t\t\t\tlabelR = r - lboffset;\n\t\t\t}\n\t\t\tif(\"radius\" in o){\n\t\t\t\tr = o.radius;\n\t\t\t\tlabelR = r - lboffset;\n\t\t\t}\n\t\t\tr /= (1+axisExtra);\n\t\t\tvar circle = {\n\t\t\t\tcx: offsets.l + rx,\n\t\t\t\tcy: offsets.t + ry,\n\t\t\t\tr: r\n\t\t\t};\n\n\t\t\tfor(var i = 0; i < this.series.length; i++){\n\t\t\t\tserieEntry = this.series[i];\n\t\t\t\tif(!this.dirty && !serieEntry.dirty){\n\t\t\t\t\tt.skip();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tserieEntry.cleanGroup();\n\t\t\t\trun = serieEntry.data;\n\t\t\t\tif(run !== null){\n\t\t\t\t\tlen = this._getObjectLength(run);\n\t\t\t\t\t//construct connect points\n\t\t\t\t\tif(!outerPoints || outerPoints.length <= 0){\n\t\t\t\t\t\touterPoints = [], innerPoints = [], labelPoints = [];\n\t\t\t\t\t\tthis._buildPoints(outerPoints, len, circle, r, start, true, dim);\n\t\t\t\t\t\tthis._buildPoints(innerPoints, len, circle, r*ro, start, true, dim);\n\t\t\t\t\t\tthis._buildPoints(labelPoints, len, circle, labelR, start, false, dim);\n\t\t\t\t\t\tif(dv > 2){\n\t\t\t\t\t\t\tdivisionPoints = [], divisionRadius = [];\n\t\t\t\t\t\t\tfor (j = 0; j < dv - 2; j++){\n\t\t\t\t\t\t\t\tdivisionPoints[j] = [];\n\t\t\t\t\t\t\t\tthis._buildPoints(divisionPoints[j], len, circle, r*(ro + (1-ro)*(j+1)/(dv-1)), start, true, dim);\n\t\t\t\t\t\t\t\tdivisionRadius[j] = r*(ro + (1-ro)*(j+1)/(dv-1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//draw Spider\n\t\t\t//axis\n\t\t\tvar axisGroup = s.createGroup(), axisStroke = {color: axisColor, width: axisWidth},\n\t\t\t\tspiderStroke = {color: spiderColor, width: spiderWidth};\n\t\t\tfor (j = outerPoints.length - 1; j >= 0; --j){\n\t\t\t\tpoint = outerPoints[j];\n\t\t\t\tvar st = {\n\t\t\t\t\t\tx: point.x + (point.x - circle.cx) * axisExtra,\n\t\t\t\t\t\ty: point.y + (point.y - circle.cy) * axisExtra\n\t\t\t\t\t},\n\t\t\t\t\tnd = {\n\t\t\t\t\t\tx: point.x + (point.x - circle.cx) * axisExtra / 2,\n\t\t\t\t\t\ty: point.y + (point.y - circle.cy) * axisExtra / 2\n\t\t\t\t\t};\n\t\t\t\taxisGroup.createLine({\n\t\t\t\t\tx1: circle.cx,\n\t\t\t\t\ty1: circle.cy,\n\t\t\t\t\tx2: st.x,\n\t\t\t\t\ty2: st.y\n\t\t\t\t}).setStroke(axisStroke);\n\t\t\t\t//arrow\n\t\t\t\tthis._drawArrow(axisGroup, st, nd, axisStroke);\n\t\t\t}\n\t\t\t\n\t\t\t// draw the label\n\t\t\tvar labelGroup = s.createGroup();\n\t\t\tfor (j = labelPoints.length - 1; j >= 0; --j){\n\t\t\t\tpoint = labelPoints[j];\n\t\t\t\tfontWidth = g._base._getTextBox(this.labelKey[j], {font: axisFont}).w || 0;\n\t\t\t\trender = this.opt.htmlLabels && g.renderer != \"vml\" ? \"html\" : \"gfx\";\n\t\t\t\tvar elem = da.createText[render](this.chart, labelGroup, (!domGeom.isBodyLtr() && render == \"html\") ? (point.x + fontWidth - dim.width) : point.x, point.y,\n\t\t\t\t\t\t\t\"middle\", this.labelKey[j], axisFont, axisFontColor);\n\t\t\t\tif(this.opt.htmlLabels){\n\t\t\t\t\tthis.htmlElements.push(elem);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spider web: polygon or circle\n\t\t\tvar spiderGroup = s.createGroup();\n\t\t\tif(spt == \"polygon\"){\n\t\t\t\tspiderGroup.createPolyline(outerPoints).setStroke(spiderStroke);\n\t\t\t\tspiderGroup.createPolyline(innerPoints).setStroke(spiderStroke);\n\t\t\t\tif(divisionPoints.length > 0){\n\t\t\t\t\tfor (j = divisionPoints.length - 1; j >= 0; --j){\n\t\t\t\t\t\tspiderGroup.createPolyline(divisionPoints[j]).setStroke(spiderStroke);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{//circle\n\t\t\t\tspiderGroup.createCircle({cx: circle.cx, cy: circle.cy, r: r}).setStroke(spiderStroke);\n\t\t\t\tspiderGroup.createCircle({cx: circle.cx, cy: circle.cy, r: r*ro}).setStroke(spiderStroke);\n\t\t\t\tif(divisionRadius.length > 0){\n\t\t\t\t\tfor (j = divisionRadius.length - 1; j >= 0; --j){\n\t\t\t\t\t\tspiderGroup.createCircle({cx: circle.cx, cy: circle.cy, r: divisionRadius[j]}).setStroke(spiderStroke);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//text\n\t\t\tlen = this._getObjectLength(this.datas);\n\t\t\tvar textGroup = s.createGroup(), k = 0;\n\t\t\tfor(var key in this.datas){\n\t\t\t\tdata = this.datas[key];\n\t\t\t\tmin = data.min;\n\t\t\t\tmax = data.max;\n\t\t\t\tdistance = max - min;\n\t\t\t\t\tend = start + 2 * Math.PI * k / len;\n\t\t\t\tfor (i = 0; i < dv; i++){\n\t\t\t\t\tvar text = min + distance*i/(dv-1);\n\t\t\t\t\tpoint = this._getCoordinate(circle, r*(ro + (1-ro)*i/(dv-1)), end, dim);\n\t\t\t\t\ttext = this._getLabel(text);\n\t\t\t\t\tfontWidth = g._base._getTextBox(text, {font: axisTickFont}).w || 0;\n\t\t\t\t\t\trender = this.opt.htmlLabels && g.renderer != \"vml\" ? \"html\" : \"gfx\";\n\t\t\t\t\tif(this.opt.htmlLabels){\n\t\t\t\t\t\tthis.htmlElements.push(da.createText[render]\n\t\t\t\t\t\t\t(this.chart, textGroup, (!domGeom.isBodyLtr() && render == \"html\") ? (point.x + fontWidth - dim.width) : point.x, point.y,\n\t\t\t\t\t\t\t\t\"start\", text, axisTickFont, axisTickFontColor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\t\n\t\t\t//draw series (animation)\n\t\t\tthis.chart.seriesShapes = {};\n\t\t\tfor (i = this.series.length - 1; i >= 0; i--){\n\t\t\t\tserieEntry = this.series[i];\n\t\t\t\trun = serieEntry.data;\n\t\t\t\tif(run !== null){\n\t\t\t\t\tvar theme = t.next(\"spider\", [o, serieEntry]),\n\t\t\t\t\t\tf = g.normalizeColor(theme.series.fill), \n\t\t\t\t\t\tsk = {color: theme.series.fill, width: seriesWidth};\n\t\t\t\t\tf.a = o.seriesFillAlpha;\n\t\t\t\t\tserieEntry.dyn = {fill: f, stroke: sk};\n\t\t\t\t\tif(serieEntry.hidden){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//series polygon\n\t\t\t\t\tvar seriePoints = [], tipData = [];\n\t\t\t\t\tk = 0;\n\t\t\t\t\tfor(key in run){\n\t\t\t\t\t\tdata = this.datas[key];\n\t\t\t\t\t\tmin = data.min;\n\t\t\t\t\t\tmax = data.max;\n\t\t\t\t\t\tdistance = max - min;\n\t\t\t\t\t\tvar entry = run[key], end = start + 2 * Math.PI * k / len;\n\t\t\t\t\t\t\tpoint = this._getCoordinate(circle, r*(ro + (1-ro)*(entry-min)/distance), end, dim);\n\t\t\t\t\t\tseriePoints.push(point);\n\t\t\t\t\t\ttipData.push({sname: serieEntry.name, key: key, data: entry});\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tseriePoints[seriePoints.length] = seriePoints[0];\n\t\t\t\t\ttipData[tipData.length] = tipData[0];\n\t\t\t\t\tvar polygonBoundRect = this._getBoundary(seriePoints),\n\t\t\t\t\t\tts = serieEntry.group;\n\t\t\t         \n\t\t\t\t\t\n\t\t\t\t\tvar osps = this.oldSeriePoints[serieEntry.name];\n\t\t\t\t\tvar cs = this._createSeriesEntry(ts, (osps || innerPoints), seriePoints, f, sk, r, ro, ms, at);\n\t\t\t\t\tthis.chart.seriesShapes[serieEntry.name] = cs;\n\t\t\t\t\tthis.oldSeriePoints[serieEntry.name] = seriePoints;\n\t\t\t\t\t\n\t\t\t\t\tvar po = {\n\t\t\t\t\t\telement: \"spider_poly\",\n\t\t\t\t\t\tindex:\t i,\n\t\t\t\t\t\tid:\t\t \"spider_poly_\"+serieEntry.name,\n\t\t\t\t\t\trun:\t serieEntry,\n\t\t\t\t\t\tplot:\t this,\n\t\t\t\t\t\tshape:\t cs.poly,\n\t\t\t\t\t\tparent:\t ts,\n\t\t\t\t\t\tbrect:\t polygonBoundRect,\n\t\t\t\t\t\tcx:\t\t circle.cx,\n\t\t\t\t\t\tcy:\t\t circle.cy,\n\t\t\t\t\t\tcr:\t\t r,\n\t\t\t\t\t\tf:\t\t f,\n\t\t\t\t\t\ts:\t\t s\n\t\t\t\t\t};\n\t\t\t\t\tthis._connectEvents(po);\n\t\t\t\t\t\n\t\t\t\t\tvar so = {\n\t\t\t\t\t\telement: \"spider_plot\",\n\t\t\t\t\t\tindex:\t i,\n\t\t\t\t\t\tid:\t\t \"spider_plot_\"+serieEntry.name,\n\t\t\t\t\t\trun:\t serieEntry,\n\t\t\t\t\t\tplot:\t this,\n\t\t\t\t\t\tshape:\t serieEntry.group\n\t\t\t\t\t};\n\t\t\t\t\tthis._connectEvents(so);\n\t\t\t\t\t\n\t\t\t\t\tarr.forEach(cs.circles, function(c, i){\n\t\t\t\t\t\tvar co = {\n\t\t\t\t\t\t\t\telement: \"spider_circle\",\n\t\t\t\t\t\t\t\tindex:\t i,\n\t\t\t\t\t\t\t\tid:\t\t \"spider_circle_\"+serieEntry.name+i,\n\t\t\t\t\t\t\t\trun:\t serieEntry,\n\t\t\t\t\t\t\t\tplot:\t this,\n\t\t\t\t\t\t\t\tshape:\t c,\n\t\t\t\t\t\t\t\tparent:\t ts,\n\t\t\t\t\t\t\t\ttdata:\t tipData[i],\n\t\t\t\t\t\t\t\tcx:\t\t seriePoints[i].x,\n\t\t\t\t\t\t\t\tcy:\t\t seriePoints[i].y,\n\t\t\t\t\t\t\t\tf:\t\t f,\n\t\t\t\t\t\t\t\ts:\t\t s\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._connectEvents(co);\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Spider\n\t\t},\n\t\t_createSeriesEntry: function(ts, osps, sps, f, sk, r, ro, ms, at){\n\t\t\t//polygon\n\t\t\tvar initpoints = this.animate?osps:sps;\n\t\t\tvar spoly = ts.createPolyline(initpoints).setFill(f).setStroke(sk), scircle = [];\n\t\t\tfor (var j = 0; j < initpoints.length; j++){\n\t\t\t\tvar point = initpoints[j], cr = ms;\n\t\t\t\tvar circle = ts.createCircle({cx: point.x, cy: point.y, r: cr}).setFill(f).setStroke(sk);\n\t\t\t\tscircle.push(circle);\n\t\t\t}\n\t\t\tif(this.animate) {\n\t\t\t\tvar anims = arr.map(sps, function (np, j) {\n\t\t\t\t\t// create animation\n\t\t\t\t\tvar sp = osps[j],\n\t\t\t\t\t\tanim = new baseFx.Animation(lang.delegate({\n\t\t\t\t\t\t\tduration: 1000,\n\t\t\t\t\t\t\teasing: at,\n\t\t\t\t\t\t\tcurve: [sp.y, np.y]\n\t\t\t\t\t\t}, this.animate));\n\t\t\t\t\tvar spl = spoly, sc = scircle[j];\n\t\t\t\t\thub.connect(anim, \"onAnimate\", function (y) {\n\t\t\t\t\t\t//apply poly\n\t\t\t\t\t\tvar pshape = spl.getShape();\n\t\t\t\t\t\tpshape.points[j].y = y;\n\t\t\t\t\t\tspl.setShape(pshape);\n\t\t\t\t\t\t//apply circle\n\t\t\t\t\t\tvar cshape = sc.getShape();\n\t\t\t\t\t\tcshape.cy = y;\n\t\t\t\t\t\tsc.setShape(cshape);\n\t\t\t\t\t});\n\t\t\t\t\treturn anim;\n\t\t\t\t}, this);\n\n\t\t\t\tvar anims1 = arr.map(sps, function (np, j) {\n\t\t\t\t\t// create animation\n\t\t\t\t\tvar sp = osps[j],\n\t\t\t\t\t\tanim = new baseFx.Animation(lang.delegate({\n\t\t\t\t\t\t\tduration: 1000,\n\t\t\t\t\t\t\teasing: at,\n\t\t\t\t\t\t\tcurve: [sp.x, np.x]\n\t\t\t\t\t\t}, this.animate));\n\t\t\t\t\tvar spl = spoly, sc = scircle[j];\n\t\t\t\t\thub.connect(anim, \"onAnimate\", function (x) {\n\t\t\t\t\t\t//apply poly\n\t\t\t\t\t\tvar pshape = spl.getShape();\n\t\t\t\t\t\tpshape.points[j].x = x;\n\t\t\t\t\t\tspl.setShape(pshape);\n\t\t\t\t\t\t//apply circle\n\t\t\t\t\t\tvar cshape = sc.getShape();\n\t\t\t\t\t\tcshape.cx = x;\n\t\t\t\t\t\tsc.setShape(cshape);\n\t\t\t\t\t});\n\t\t\t\t\treturn anim;\n\t\t\t\t}, this);\n\t\t\t\tvar masterAnimation = coreFx.combine(anims.concat(anims1)); //dojo.fx.chain(anims);\n\t\t\t\tmasterAnimation.play();\n\t\t\t}\n\t\t\treturn {group :ts, poly: spoly, circles: scircle};\n\t\t},\n\t\tplotEvent: function(o){\n\t\t\t// summary:\n\t\t\t//\t\tStub function for use by specific plots.\n\t\t\t// o: Object\n\t\t\t//\t\tAn object intended to represent event parameters.\n\t\t\tif(o.element == \"spider_plot\"){\n\t\t\t\t//dojo gfx function \"moveToFront\" not work in IE\n\t\t\t\tif(o.type == \"onmouseover\" && !has(\"ie\")){\n\t\t\t\t\to.shape.moveToFront();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\ttooltipFunc: function(o){\n\t\t\tif(o.element == \"spider_circle\"){\n\t\t\t\treturn o.tdata.sname + \"<br/>\" + o.tdata.key + \"<br/>\" + o.tdata.data;\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\t_getBoundary: function(points){\n\t\t\tvar xmax = points[0].x,\n\t\t\t\txmin = points[0].x,\n\t\t\t\tymax = points[0].y,\n\t\t\t\tymin = points[0].y;\n\t\t\tfor(var i = 0; i < points.length; i++){\n\t\t\t\tvar point = points[i];\n\t\t\t\txmax = Math.max(point.x, xmax);\n\t\t\t\tymax = Math.max(point.y, ymax);\n\t\t\t\txmin = Math.min(point.x, xmin);\n\t\t\t\tymin = Math.min(point.y, ymin);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tx: xmin,\n\t\t\t\ty: ymin,\n\t\t\t\twidth: xmax - xmin,\n\t\t\t\theight: ymax - ymin\n\t\t\t};\n\t\t},\n\t\t\n\t\t_drawArrow: function(s, start, end, stroke){\n\t\t\tvar len = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)),\n\t\t\t\tsin = (end.y - start.y)/len, cos = (end.x - start.x)/len,\n\t\t\t\tpoint2 = {x: end.x + (len/3)*(-sin), y: end.y + (len/3)*cos},\n\t\t\t\tpoint3 = {x: end.x + (len/3)*sin, y: end.y + (len/3)*(-cos)};\n\t\t\ts.createPolyline([start, point2, point3]).setFill(stroke.color).setStroke(stroke);\n\t\t},\n\t\t\n\t\t_buildPoints: function(points, count, circle, radius, angle, recursive, dim){\n\t\t\tfor(var i = 0; i < count; i++){\n\t\t\t\tvar end = angle + 2 * Math.PI * i / count;\n\t\t\t\tpoints.push(this._getCoordinate(circle, radius, end, dim));\n\t\t\t}\n\t\t\tif(recursive){\n\t\t\t\tpoints.push(this._getCoordinate(circle, radius, angle + 2 * Math.PI, dim));\n\t\t\t}\n\t\t},\n\t\t\n\t\t_getCoordinate: function(circle, radius, angle, dim){\n\t\t\tvar x = circle.cx + radius * Math.cos(angle);\n\t\t\tif(has(\"dojo-bidi\") && this.chart.isRightToLeft() && dim){\n\t\t\t\tx = dim.width - x;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: circle.cy + radius * Math.sin(angle)\n\t\t\t}\n\t\t},\n\t\t\n\t\t_getObjectLength: function(obj){\n\t\t\tvar count = 0;\n\t\t\tif(lang.isObject(obj)){\n\t\t\t\tfor(var key in obj){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\t// utilities\n\t\t_getLabel: function(number){\n\t\t\treturn dc.getLabel(number, this.opt.fixed, this.opt.precision);\n\t\t}\n\t});\n\n\treturn Spider; // dojox/plot2d/Spider\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/plot2d/Spider.js\n// module id = 224\n// module chunks = 4","define([\r\n\t\"./_base/lang\",\r\n\t\"./Evented\",\r\n\t\"./_base/kernel\",\r\n\t\"./_base/array\",\r\n\t\"./aspect\",\r\n\t\"./_base/fx\",\r\n\t\"./dom\",\r\n\t\"./dom-style\",\r\n\t\"./dom-geometry\",\r\n\t\"./ready\",\r\n\t\"require\" // for context sensitive loading of Toggler\r\n], function(lang, Evented, dojo, arrayUtil, aspect, baseFx, dom, domStyle, geom, ready, require){\r\n\r\n\t// module:\r\n\t//\t\tdojo/fx\r\n\t\r\n\t// For back-compat, remove in 2.0.\r\n\tif(!dojo.isAsync){\r\n\t\tready(0, function(){\r\n\t\t\tvar requires = [\"./fx/Toggler\"];\r\n\t\t\trequire(requires);\t// use indirection so modules not rolled into a build\r\n\t\t});\r\n\t}\r\n\r\n\tvar coreFx = dojo.fx = {\r\n\t\t// summary:\r\n\t\t//\t\tEffects library on top of Base animations\r\n\t};\r\n\r\n\tvar _baseObj = {\r\n\t\t\t_fire: function(evt, args){\r\n\t\t\t\tif(this[evt]){\r\n\t\t\t\t\tthis[evt].apply(this, args||[]);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\tvar _chain = function(animations){\r\n\t\tthis._index = -1;\r\n\t\tthis._animations = animations||[];\r\n\t\tthis._current = this._onAnimateCtx = this._onEndCtx = null;\r\n\r\n\t\tthis.duration = 0;\r\n\t\tarrayUtil.forEach(this._animations, function(a){\r\n\t\t\tthis.duration += a.duration;\r\n\t\t\tif(a.delay){ this.duration += a.delay; }\r\n\t\t}, this);\r\n\t};\r\n\t_chain.prototype = new Evented();\r\n\tlang.extend(_chain, {\r\n\t\t_onAnimate: function(){\r\n\t\t\tthis._fire(\"onAnimate\", arguments);\r\n\t\t},\r\n\t\t_onEnd: function(){\r\n\t\t\tthis._onAnimateCtx.remove();\r\n\t\t\tthis._onEndCtx.remove();\r\n\t\t\tthis._onAnimateCtx = this._onEndCtx = null;\r\n\t\t\tif(this._index + 1 == this._animations.length){\r\n\t\t\t\tthis._fire(\"onEnd\");\r\n\t\t\t}else{\r\n\t\t\t\t// switch animations\r\n\t\t\t\tthis._current = this._animations[++this._index];\r\n\t\t\t\tthis._onAnimateCtx = aspect.after(this._current, \"onAnimate\", lang.hitch(this, \"_onAnimate\"), true);\r\n\t\t\t\tthis._onEndCtx = aspect.after(this._current, \"onEnd\", lang.hitch(this, \"_onEnd\"), true);\r\n\t\t\t\tthis._current.play(0, true);\r\n\t\t\t}\r\n\t\t},\r\n\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\r\n\t\t\tif(!this._current){ this._current = this._animations[this._index = 0]; }\r\n\t\t\tif(!gotoStart && this._current.status() == \"playing\"){ return this; }\r\n\t\t\tvar beforeBegin = aspect.after(this._current, \"beforeBegin\", lang.hitch(this, function(){\r\n\t\t\t\t\tthis._fire(\"beforeBegin\");\r\n\t\t\t\t}), true),\r\n\t\t\t\tonBegin = aspect.after(this._current, \"onBegin\", lang.hitch(this, function(arg){\r\n\t\t\t\t\tthis._fire(\"onBegin\", arguments);\r\n\t\t\t\t}), true),\r\n\t\t\t\tonPlay = aspect.after(this._current, \"onPlay\", lang.hitch(this, function(arg){\r\n\t\t\t\t\tthis._fire(\"onPlay\", arguments);\r\n\t\t\t\t\tbeforeBegin.remove();\r\n\t\t\t\t\tonBegin.remove();\r\n\t\t\t\t\tonPlay.remove();\r\n\t\t\t\t}));\r\n\t\t\tif(this._onAnimateCtx){\r\n\t\t\t\tthis._onAnimateCtx.remove();\r\n\t\t\t}\r\n\t\t\tthis._onAnimateCtx = aspect.after(this._current, \"onAnimate\", lang.hitch(this, \"_onAnimate\"), true);\r\n\t\t\tif(this._onEndCtx){\r\n\t\t\t\tthis._onEndCtx.remove();\r\n\t\t\t}\r\n\t\t\tthis._onEndCtx = aspect.after(this._current, \"onEnd\", lang.hitch(this, \"_onEnd\"), true);\r\n\t\t\tthis._current.play.apply(this._current, arguments);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tpause: function(){\r\n\t\t\tif(this._current){\r\n\t\t\t\tvar e = aspect.after(this._current, \"onPause\", lang.hitch(this, function(arg){\r\n\t\t\t\t\t\tthis._fire(\"onPause\", arguments);\r\n\t\t\t\t\t\te.remove();\r\n\t\t\t\t\t}), true);\r\n\t\t\t\tthis._current.pause();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tgotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){\r\n\t\t\tthis.pause();\r\n\t\t\tvar offset = this.duration * percent;\r\n\t\t\tthis._current = null;\r\n\r\n\t\t\tarrayUtil.some(this._animations, function(a, index){\r\n\t\t\t\tif(offset <= a.duration){\r\n\t\t\t\t\tthis._current = a;\r\n\t\t\t\t\tthis._index = index;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\toffset -= a.duration;\r\n\t\t\t\treturn false;\r\n\t\t\t}, this);\r\n\t\t\tif(this._current){\r\n\t\t\t\tthis._current.gotoPercent(offset / this._current.duration);\r\n\t\t\t}\r\n\t\t\tif (andPlay) { this.play(); }\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tstop: function(/*boolean?*/ gotoEnd){\r\n\t\t\tif(this._current){\r\n\t\t\t\tif(gotoEnd){\r\n\t\t\t\t\tfor(; this._index + 1 < this._animations.length; ++this._index){\r\n\t\t\t\t\t\tthis._animations[this._index].stop(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._current = this._animations[this._index];\r\n\t\t\t\t}\r\n\t\t\t\tvar e = aspect.after(this._current, \"onStop\", lang.hitch(this, function(arg){\r\n\t\t\t\t\t\tthis._fire(\"onStop\", arguments);\r\n\t\t\t\t\t\te.remove();\r\n\t\t\t\t\t}), true);\r\n\t\t\t\tthis._current.stop();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tstatus: function(){\r\n\t\t\treturn this._current ? this._current.status() : \"stopped\";\r\n\t\t},\r\n\t\tdestroy: function(){\r\n\t\t\tthis.stop();\r\n\t\t\tif(this._onAnimateCtx){ this._onAnimateCtx.remove(); }\r\n\t\t\tif(this._onEndCtx){ this._onEndCtx.remove(); }\r\n\t\t}\r\n\t});\r\n\tlang.extend(_chain, _baseObj);\r\n\r\n\tcoreFx.chain = function(/*dojo/_base/fx.Animation[]*/ animations){\r\n\t\t// summary:\r\n\t\t//\t\tChain a list of `dojo/_base/fx.Animation`s to run in sequence\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tReturn a `dojo/_base/fx.Animation` which will play all passed\r\n\t\t//\t\t`dojo/_base/fx.Animation` instances in sequence, firing its own\r\n\t\t//\t\tsynthesized events simulating a single animation. (eg:\r\n\t\t//\t\tonEnd of this animation means the end of the chain,\r\n\t\t//\t\tnot the individual animations within)\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tOnce `node` is faded out, fade in `otherNode`\r\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t//\t|\t\tfx.chain([\r\n\t\t//\t|\t\t\tfx.fadeIn({ node:node }),\r\n\t\t//\t|\t\t\tfx.fadeOut({ node:otherNode })\r\n\t\t//\t|\t\t]).play();\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\treturn new _chain(animations); // dojo/_base/fx.Animation\r\n\t};\r\n\r\n\tvar _combine = function(animations){\r\n\t\tthis._animations = animations||[];\r\n\t\tthis._connects = [];\r\n\t\tthis._finished = 0;\r\n\r\n\t\tthis.duration = 0;\r\n\t\tarrayUtil.forEach(animations, function(a){\r\n\t\t\tvar duration = a.duration;\r\n\t\t\tif(a.delay){ duration += a.delay; }\r\n\t\t\tif(this.duration < duration){ this.duration = duration; }\r\n\t\t\tthis._connects.push(aspect.after(a, \"onEnd\", lang.hitch(this, \"_onEnd\"), true));\r\n\t\t}, this);\r\n\r\n\t\tthis._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});\r\n\t\tvar self = this;\r\n\t\tarrayUtil.forEach([\"beforeBegin\", \"onBegin\", \"onPlay\", \"onAnimate\", \"onPause\", \"onStop\", \"onEnd\"],\r\n\t\t\tfunction(evt){\r\n\t\t\t\tself._connects.push(aspect.after(self._pseudoAnimation, evt,\r\n\t\t\t\t\tfunction(){ self._fire(evt, arguments); },\r\n\t\t\t\ttrue));\r\n\t\t\t}\r\n\t\t);\r\n\t};\r\n\tlang.extend(_combine, {\r\n\t\t_doAction: function(action, args){\r\n\t\t\tarrayUtil.forEach(this._animations, function(a){\r\n\t\t\t\ta[action].apply(a, args);\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t_onEnd: function(){\r\n\t\t\tif(++this._finished > this._animations.length){\r\n\t\t\t\tthis._fire(\"onEnd\");\r\n\t\t\t}\r\n\t\t},\r\n\t\t_call: function(action, args){\r\n\t\t\tvar t = this._pseudoAnimation;\r\n\t\t\tt[action].apply(t, args);\r\n\t\t},\r\n\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\r\n\t\t\tthis._finished = 0;\r\n\t\t\tthis._doAction(\"play\", arguments);\r\n\t\t\tthis._call(\"play\", arguments);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tpause: function(){\r\n\t\t\tthis._doAction(\"pause\", arguments);\r\n\t\t\tthis._call(\"pause\", arguments);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tgotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){\r\n\t\t\tvar ms = this.duration * percent;\r\n\t\t\tarrayUtil.forEach(this._animations, function(a){\r\n\t\t\t\ta.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);\r\n\t\t\t});\r\n\t\t\tthis._call(\"gotoPercent\", arguments);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tstop: function(/*boolean?*/ gotoEnd){\r\n\t\t\tthis._doAction(\"stop\", arguments);\r\n\t\t\tthis._call(\"stop\", arguments);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tstatus: function(){\r\n\t\t\treturn this._pseudoAnimation.status();\r\n\t\t},\r\n\t\tdestroy: function(){\r\n\t\t\tthis.stop();\r\n\t\t\tarrayUtil.forEach(this._connects, function(handle){\r\n\t\t\t\thandle.remove();\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\tlang.extend(_combine, _baseObj);\r\n\r\n\tcoreFx.combine = function(/*dojo/_base/fx.Animation[]*/ animations){\r\n\t\t// summary:\r\n\t\t//\t\tCombine a list of `dojo/_base/fx.Animation`s to run in parallel\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tCombine an array of `dojo/_base/fx.Animation`s to run in parallel,\r\n\t\t//\t\tproviding a new `dojo/_base/fx.Animation` instance encompasing each\r\n\t\t//\t\tanimation, firing standard animation events.\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tFade out `node` while fading in `otherNode` simultaneously\r\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t//\t|\t\tfx.combine([\r\n\t\t//\t|\t\t\tfx.fadeIn({ node:node }),\r\n\t\t//\t|\t\t\tfx.fadeOut({ node:otherNode })\r\n\t\t//\t|\t\t]).play();\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tWhen the longest animation ends, execute a function:\r\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t//\t|\t\tvar anim = fx.combine([\r\n\t\t//\t|\t\t\tfx.fadeIn({ node: n, duration:700 }),\r\n\t\t//\t|\t\t\tfx.fadeOut({ node: otherNode, duration: 300 })\r\n\t\t//\t|\t\t]);\r\n\t\t//\t|\t\taspect.after(anim, \"onEnd\", function(){\r\n\t\t//\t|\t\t\t// overall animation is done.\r\n\t\t//\t|\t\t}, true);\r\n\t\t//\t|\t\tanim.play(); // play the animation\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\treturn new _combine(animations); // dojo/_base/fx.Animation\r\n\t};\r\n\r\n\tcoreFx.wipeIn = function(/*Object*/ args){\r\n\t\t// summary:\r\n\t\t//\t\tExpand a node to it's natural height.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tReturns an animation that will expand the\r\n\t\t//\t\tnode defined in 'args' object from it's current height to\r\n\t\t//\t\tit's natural height (with no scrollbar).\r\n\t\t//\t\tNode must have no margin/border/padding.\r\n\t\t//\r\n\t\t// args: Object\r\n\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\r\n\t\t//\t\t(such as easing: node: duration: and so on)\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t//\t|\t\tfx.wipeIn({\r\n\t\t//\t|\t\t\tnode:\"someId\"\r\n\t\t//\t|\t\t}).play()\r\n\t\t//\t|\t});\r\n\r\n\t\tvar node = args.node = dom.byId(args.node), s = node.style, o;\r\n\r\n\t\tvar anim = baseFx.animateProperty(lang.mixin({\r\n\t\t\tproperties: {\r\n\t\t\t\theight: {\r\n\t\t\t\t\t// wrapped in functions so we wait till the last second to query (in case value has changed)\r\n\t\t\t\t\tstart: function(){\r\n\t\t\t\t\t\t// start at current [computed] height, but use 1px rather than 0\r\n\t\t\t\t\t\t// because 0 causes IE to display the whole panel\r\n\t\t\t\t\t\to = s.overflow;\r\n\t\t\t\t\t\ts.overflow = \"hidden\";\r\n\t\t\t\t\t\tif(s.visibility == \"hidden\" || s.display == \"none\"){\r\n\t\t\t\t\t\t\ts.height = \"1px\";\r\n\t\t\t\t\t\t\ts.display = \"\";\r\n\t\t\t\t\t\t\ts.visibility = \"\";\r\n\t\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tvar height = domStyle.get(node, \"height\");\r\n\t\t\t\t\t\t\treturn Math.max(height, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tend: function(){\r\n\t\t\t\t\t\treturn node.scrollHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, args));\r\n\r\n\t\tvar fini = function(){\r\n\t\t\ts.height = \"auto\";\r\n\t\t\ts.overflow = o;\r\n\t\t};\r\n\t\taspect.after(anim, \"onStop\", fini, true);\r\n\t\taspect.after(anim, \"onEnd\", fini, true);\r\n\r\n\t\treturn anim; // dojo/_base/fx.Animation\r\n\t};\r\n\r\n\tcoreFx.wipeOut = function(/*Object*/ args){\r\n\t\t// summary:\r\n\t\t//\t\tShrink a node to nothing and hide it.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tReturns an animation that will shrink node defined in \"args\"\r\n\t\t//\t\tfrom it's current height to 1px, and then hide it.\r\n\t\t//\r\n\t\t// args: Object\r\n\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\r\n\t\t//\t\t(such as easing: node: duration: and so on)\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\r\n\t\t//\t|\t\tfx.wipeOut({ node:\"someId\" }).play()\r\n\t\t//\t|\t});\r\n\r\n\t\tvar node = args.node = dom.byId(args.node), s = node.style, o;\r\n\r\n\t\tvar anim = baseFx.animateProperty(lang.mixin({\r\n\t\t\tproperties: {\r\n\t\t\t\theight: {\r\n\t\t\t\t\tend: 1 // 0 causes IE to display the whole panel\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, args));\r\n\r\n\t\taspect.after(anim, \"beforeBegin\", function(){\r\n\t\t\to = s.overflow;\r\n\t\t\ts.overflow = \"hidden\";\r\n\t\t\ts.display = \"\";\r\n\t\t}, true);\r\n\t\tvar fini = function(){\r\n\t\t\ts.overflow = o;\r\n\t\t\ts.height = \"auto\";\r\n\t\t\ts.display = \"none\";\r\n\t\t};\r\n\t\taspect.after(anim, \"onStop\", fini, true);\r\n\t\taspect.after(anim, \"onEnd\", fini, true);\r\n\r\n\t\treturn anim; // dojo/_base/fx.Animation\r\n\t};\r\n\r\n\tcoreFx.slideTo = function(/*Object*/ args){\r\n\t\t// summary:\r\n\t\t//\t\tSlide a node to a new top/left position\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tReturns an animation that will slide \"node\"\r\n\t\t//\t\tdefined in args Object from its current position to\r\n\t\t//\t\tthe position defined by (args.left, args.top).\r\n\t\t//\r\n\t\t// args: Object\r\n\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\r\n\t\t//\t\t(such as easing: node: duration: and so on). Special args members\r\n\t\t//\t\tare `top` and `left`, which indicate the new position to slide to.\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\t.slideTo({ node: node, left:\"40\", top:\"50\", units:\"px\" }).play()\r\n\r\n\t\tvar node = args.node = dom.byId(args.node),\r\n\t\t\ttop = null, left = null;\r\n\r\n\t\tvar init = (function(n){\r\n\t\t\treturn function(){\r\n\t\t\t\tvar cs = domStyle.getComputedStyle(n);\r\n\t\t\t\tvar pos = cs.position;\r\n\t\t\t\ttop = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);\r\n\t\t\t\tleft = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);\r\n\t\t\t\tif(pos != 'absolute' && pos != 'relative'){\r\n\t\t\t\t\tvar ret = geom.position(n, true);\r\n\t\t\t\t\ttop = ret.y;\r\n\t\t\t\t\tleft = ret.x;\r\n\t\t\t\t\tn.style.position=\"absolute\";\r\n\t\t\t\t\tn.style.top=top+\"px\";\r\n\t\t\t\t\tn.style.left=left+\"px\";\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t})(node);\r\n\t\tinit();\r\n\r\n\t\tvar anim = baseFx.animateProperty(lang.mixin({\r\n\t\t\tproperties: {\r\n\t\t\t\ttop: args.top || 0,\r\n\t\t\t\tleft: args.left || 0\r\n\t\t\t}\r\n\t\t}, args));\r\n\t\taspect.after(anim, \"beforeBegin\", init, true);\r\n\r\n\t\treturn anim; // dojo/_base/fx.Animation\r\n\t};\r\n\r\n\treturn coreFx;\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojo/fx.js\n// module id = 225\n// module chunks = 4","define([\"../_base/lang\"], function(lang){\r\n\r\n// module:\r\n//\t\tdojo/fx/easing\r\n\r\nvar easingFuncs = {\r\n\t// summary:\r\n\t//\t\tCollection of easing functions to use beyond the default\r\n\t//\t\t`dojo._defaultEasing` function.\r\n\t// description:\r\n\t//\t\tEasing functions are used to manipulate the iteration through\r\n\t//\t\tan `dojo.Animation`s _Line. _Line being the properties of an Animation,\r\n\t//\t\tand the easing function progresses through that Line determining\r\n\t//\t\thow quickly (or slowly) it should go. Or more accurately: modify\r\n\t//\t\tthe value of the _Line based on the percentage of animation completed.\r\n\t//\r\n\t//\t\tAll functions follow a simple naming convention of \"ease type\" + \"when\".\r\n\t//\t\tIf the name of the function ends in Out, the easing described appears\r\n\t//\t\ttowards the end of the animation. \"In\" means during the beginning,\r\n\t//\t\tand InOut means both ranges of the Animation will applied, both\r\n\t//\t\tbeginning and end.\r\n\t//\r\n\t//\t\tOne does not call the easing function directly, it must be passed to\r\n\t//\t\tthe `easing` property of an animation.\r\n\t// example:\r\n\t//\t|\tdojo.require(\"dojo.fx.easing\");\r\n\t//\t|\tvar anim = dojo.fadeOut({\r\n\t//\t|\t\tnode: 'node',\r\n\t//\t|\t\tduration: 2000,\r\n\t//\t|\t\t//\tnote there is no ()\r\n\t//\t|\t\teasing: dojo.fx.easing.quadIn\r\n\t//\t|\t}).play();\r\n\t//\r\n\r\n\tlinear: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tA linear easing function\r\n\t\treturn n;\r\n\t},\r\n\r\n\tquadIn: function(/* Decimal? */n){\r\n\t\treturn Math.pow(n, 2);\r\n\t},\r\n\r\n\tquadOut: function(/* Decimal? */n){\r\n\t\treturn n * (n - 2) * -1;\r\n\t},\r\n\r\n\tquadInOut: function(/* Decimal? */n){\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return Math.pow(n, 2) / 2; }\r\n\t\treturn -1 * ((--n) * (n - 2) - 1) / 2;\r\n\t},\r\n\r\n\tcubicIn: function(/* Decimal? */n){\r\n\t\treturn Math.pow(n, 3);\r\n\t},\r\n\r\n\tcubicOut: function(/* Decimal? */n){\r\n\t\treturn Math.pow(n - 1, 3) + 1;\r\n\t},\r\n\r\n\tcubicInOut: function(/* Decimal? */n){\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return Math.pow(n, 3) / 2; }\r\n\t\tn -= 2;\r\n\t\treturn (Math.pow(n, 3) + 2) / 2;\r\n\t},\r\n\r\n\tquartIn: function(/* Decimal? */n){\r\n\t\treturn Math.pow(n, 4);\r\n\t},\r\n\r\n\tquartOut: function(/* Decimal? */n){\r\n\t\treturn -1 * (Math.pow(n - 1, 4) - 1);\r\n\t},\r\n\r\n\tquartInOut: function(/* Decimal? */n){\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return Math.pow(n, 4) / 2; }\r\n\t\tn -= 2;\r\n\t\treturn -1 / 2 * (Math.pow(n, 4) - 2);\r\n\t},\r\n\r\n\tquintIn: function(/* Decimal? */n){\r\n\t\treturn Math.pow(n, 5);\r\n\t},\r\n\r\n\tquintOut: function(/* Decimal? */n){\r\n\t\treturn Math.pow(n - 1, 5) + 1;\r\n\t},\r\n\r\n\tquintInOut: function(/* Decimal? */n){\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return Math.pow(n, 5) / 2; }\r\n\t\tn -= 2;\r\n\t\treturn (Math.pow(n, 5) + 2) / 2;\r\n\t},\r\n\r\n\tsineIn: function(/* Decimal? */n){\r\n\t\treturn -1 * Math.cos(n * (Math.PI / 2)) + 1;\r\n\t},\r\n\r\n\tsineOut: function(/* Decimal? */n){\r\n\t\treturn Math.sin(n * (Math.PI / 2));\r\n\t},\r\n\r\n\tsineInOut: function(/* Decimal? */n){\r\n\t\treturn -1 * (Math.cos(Math.PI * n) - 1) / 2;\r\n\t},\r\n\r\n\texpoIn: function(/* Decimal? */n){\r\n\t\treturn (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));\r\n\t},\r\n\r\n\texpoOut: function(/* Decimal? */n){\r\n\t\treturn (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);\r\n\t},\r\n\r\n\texpoInOut: function(/* Decimal? */n){\r\n\t\tif(n == 0){ return 0; }\r\n\t\tif(n == 1){ return 1; }\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }\r\n\t\t--n;\r\n\t\treturn (-1 * Math.pow(2, -10 * n) + 2) / 2;\r\n\t},\r\n\r\n\tcircIn: function(/* Decimal? */n){\r\n\t\treturn -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);\r\n\t},\r\n\r\n\tcircOut: function(/* Decimal? */n){\r\n\t\tn = n - 1;\r\n\t\treturn Math.sqrt(1 - Math.pow(n, 2));\r\n\t},\r\n\r\n\tcircInOut: function(/* Decimal? */n){\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }\r\n\t\tn -= 2;\r\n\t\treturn 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);\r\n\t},\r\n\r\n\tbackIn: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that starts away from the target,\r\n\t\t//\t\tand quickly accelerates towards the end value.\r\n\t\t//\r\n\t\t//\t\tUse caution when the easing will cause values to become\r\n\t\t//\t\tnegative as some properties cannot be set to negative values.\r\n\t\tvar s = 1.70158;\r\n\t\treturn Math.pow(n, 2) * ((s + 1) * n - s);\r\n\t},\r\n\r\n\tbackOut: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that pops past the range briefly, and slowly comes back.\r\n\t\t// description:\r\n\t\t//\t\tAn easing function that pops past the range briefly, and slowly comes back.\r\n\t\t//\r\n\t\t//\t\tUse caution when the easing will cause values to become negative as some\r\n\t\t//\t\tproperties cannot be set to negative values.\r\n\r\n\t\tn = n - 1;\r\n\t\tvar s = 1.70158;\r\n\t\treturn Math.pow(n, 2) * ((s + 1) * n + s) + 1;\r\n\t},\r\n\r\n\tbackInOut: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function combining the effects of `backIn` and `backOut`\r\n\t\t// description:\r\n\t\t//\t\tAn easing function combining the effects of `backIn` and `backOut`.\r\n\t\t//\t\tUse caution when the easing will cause values to become negative\r\n\t\t//\t\tas some properties cannot be set to negative values.\r\n\t\tvar s = 1.70158 * 1.525;\r\n\t\tn = n * 2;\r\n\t\tif(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }\r\n\t\tn-=2;\r\n\t\treturn (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;\r\n\t},\r\n\r\n\telasticIn: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function the elastically snaps from the start value\r\n\t\t// description:\r\n\t\t//\t\tAn easing function the elastically snaps from the start value\r\n\t\t//\r\n\t\t//\t\tUse caution when the elasticity will cause values to become negative\r\n\t\t//\t\tas some properties cannot be set to negative values.\r\n\t\tif(n == 0 || n == 1){ return n; }\r\n\t\tvar p = .3;\r\n\t\tvar s = p / 4;\r\n\t\tn = n - 1;\r\n\t\treturn -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);\r\n\t},\r\n\r\n\telasticOut: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that elasticly snaps around the target value,\r\n\t\t//\t\tnear the end of the Animation\r\n\t\t// description:\r\n\t\t//\t\tAn easing function that elasticly snaps around the target value,\r\n\t\t//\t\tnear the end of the Animation\r\n\t\t//\r\n\t\t//\t\tUse caution when the elasticity will cause values to become\r\n\t\t//\t\tnegative as some properties cannot be set to negative values.\r\n\t\tif(n==0 || n == 1){ return n; }\r\n\t\tvar p = .3;\r\n\t\tvar s = p / 4;\r\n\t\treturn Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;\r\n\t},\r\n\r\n\telasticInOut: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that elasticly snaps around the value, near\r\n\t\t//\t\tthe beginning and end of the Animation.\r\n\t\t// description:\r\n\t\t//\t\tAn easing function that elasticly snaps around the value, near\r\n\t\t//\t\tthe beginning and end of the Animation.\r\n\t\t//\r\n\t\t//\t\tUse caution when the elasticity will cause values to become\r\n\t\t//\t\tnegative as some properties cannot be set to negative values.\r\n\t\tif(n == 0) return 0;\r\n\t\tn = n * 2;\r\n\t\tif(n == 2) return 1;\r\n\t\tvar p = .3 * 1.5;\r\n\t\tvar s = p / 4;\r\n\t\tif(n < 1){\r\n\t\t\tn -= 1;\r\n\t\t\treturn -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));\r\n\t\t}\r\n\t\tn -= 1;\r\n\t\treturn .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;\r\n\t},\r\n\r\n\tbounceIn: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that 'bounces' near the beginning of an Animation\r\n\t\treturn (1 - easingFuncs.bounceOut(1 - n)); // Decimal\r\n\t},\r\n\r\n\tbounceOut: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that 'bounces' near the end of an Animation\r\n\t\tvar s = 7.5625;\r\n\t\tvar p = 2.75;\r\n\t\tvar l;\r\n\t\tif(n < (1 / p)){\r\n\t\t\tl = s * Math.pow(n, 2);\r\n\t\t}else if(n < (2 / p)){\r\n\t\t\tn -= (1.5 / p);\r\n\t\t\tl = s * Math.pow(n, 2) + .75;\r\n\t\t}else if(n < (2.5 / p)){\r\n\t\t\tn -= (2.25 / p);\r\n\t\t\tl = s * Math.pow(n, 2) + .9375;\r\n\t\t}else{\r\n\t\t\tn -= (2.625 / p);\r\n\t\t\tl = s * Math.pow(n, 2) + .984375;\r\n\t\t}\r\n\t\treturn l;\r\n\t},\r\n\r\n\tbounceInOut: function(/* Decimal? */n){\r\n\t\t// summary:\r\n\t\t//\t\tAn easing function that 'bounces' at the beginning and end of the Animation\r\n\t\tif(n < 0.5){ return easingFuncs.bounceIn(n * 2) / 2; }\r\n\t\treturn (easingFuncs.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal\r\n\t}\r\n};\r\n\r\nlang.setObject(\"dojo.fx.easing\", easingFuncs);\r\n\r\nreturn easingFuncs;\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojo/fx/easing.js\n// module id = 226\n// module chunks = 4","define([\"../SimpleTheme\", \"./common\"], function(SimpleTheme, themes){\n\tthemes.Wetland = new SimpleTheme({\n\t\tcolors: [\n\t\t\t\"#bfbc64\",\n\t\t\t\"#737130\",\n\t\t\t\"#73373b\",\n\t\t\t\"#7dafca\",\n\t\t\t\"#8d3c42\"\n\t\t]\n\t});\n\treturn themes.Wetland;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/themes/Wetland.js\n// module id = 227\n// module chunks = 4","define([\"dojo/_base/lang\"], function(lang){\n\treturn lang.getObject(\"dojox.charting.themes\", true);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../dojox/charting/themes/common.js\n// module id = 228\n// module chunks = 4"],"sourceRoot":""}